(function() {
  "use strict";
  function _mergeNamespaces(n, m) {
    for (var i = 0; i < m.length; i++) {
      const e = m[i];
      if (typeof e !== "string" && !Array.isArray(e)) {
        for (const k3 in e) {
          if (k3 !== "default" && !(k3 in n)) {
            const d = Object.getOwnPropertyDescriptor(e, k3);
            if (d) {
              Object.defineProperty(n, k3, d.get ? d : {
                enumerable: true,
                get: () => e[k3]
              });
            }
          }
        }
      }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const EPSILON_FLOAT32$1 = 1e-7;
  const EPSILON_FLOAT16$1 = 1e-4;
  class DataStorage {
    constructor(backend2, dataMover) {
      this.backend = backend2;
      this.dataMover = dataMover;
      this.data = /* @__PURE__ */ new WeakMap();
      this.dataIdsCount = 0;
    }
    get(dataId) {
      if (!this.data.has(dataId)) {
        this.dataMover.moveData(this.backend, dataId);
      }
      return this.data.get(dataId);
    }
    set(dataId, value) {
      this.dataIdsCount++;
      this.data.set(dataId, value);
    }
    has(dataId) {
      return this.data.has(dataId);
    }
    delete(dataId) {
      this.dataIdsCount--;
      return this.data.delete(dataId);
    }
    numDataIds() {
      return this.dataIdsCount;
    }
  }
  class KernelBackend {
    refCount(dataId) {
      return notYetImplemented("refCount");
    }
    incRef(dataId) {
      return notYetImplemented("incRef");
    }
    timerAvailable() {
      return true;
    }
    time(f) {
      return notYetImplemented("time");
    }
    read(dataId) {
      return notYetImplemented("read");
    }
    readSync(dataId) {
      return notYetImplemented("readSync");
    }
    readToGPU(dataId, options) {
      return notYetImplemented("readToGPU");
    }
    numDataIds() {
      return notYetImplemented("numDataIds");
    }
    disposeData(dataId, force) {
      return notYetImplemented("disposeData");
    }
    write(values, shape, dtype) {
      return notYetImplemented("write");
    }
    move(dataId, values, shape, dtype, refCount) {
      return notYetImplemented("move");
    }
    createTensorFromGPUData(values, shape, dtype) {
      return notYetImplemented("createTensorFromGPUData");
    }
    memory() {
      return notYetImplemented("memory");
    }
    /** Returns the highest precision for floats in bits (e.g. 16 or 32) */
    floatPrecision() {
      return notYetImplemented("floatPrecision");
    }
    /** Returns the smallest representable number.  */
    epsilon() {
      return this.floatPrecision() === 32 ? EPSILON_FLOAT32$1 : EPSILON_FLOAT16$1;
    }
    dispose() {
      return notYetImplemented("dispose");
    }
  }
  function notYetImplemented(kernelName) {
    throw new Error(`'${kernelName}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function shuffle(array) {
    let counter = array.length;
    let index2 = 0;
    while (counter > 0) {
      index2 = Math.random() * counter | 0;
      counter--;
      swap(array, counter, index2);
    }
  }
  function shuffleCombo(array, array2) {
    if (array.length !== array2.length) {
      throw new Error(`Array sizes must match to be shuffled together First array length was ${array.length}Second array length was ${array2.length}`);
    }
    let counter = array.length;
    let index2 = 0;
    while (counter > 0) {
      index2 = Math.random() * counter | 0;
      counter--;
      swap(array, counter, index2);
      swap(array2, counter, index2);
    }
  }
  function clamp(min2, x, max2) {
    return Math.max(min2, Math.min(x, max2));
  }
  function nearestLargerEven(val) {
    return val % 2 === 0 ? val : val + 1;
  }
  function swap(object, left, right) {
    const temp = object[left];
    object[left] = object[right];
    object[right] = temp;
  }
  function sum$2(arr) {
    let sum2 = 0;
    for (let i = 0; i < arr.length; i++) {
      sum2 += arr[i];
    }
    return sum2;
  }
  function randUniform(a, b) {
    const r = Math.random();
    return b * r + (1 - r) * a;
  }
  function distSquared(a, b) {
    let result = 0;
    for (let i = 0; i < a.length; i++) {
      const diff = Number(a[i]) - Number(b[i]);
      result += diff * diff;
    }
    return result;
  }
  function assert(expr, msg) {
    if (!expr) {
      throw new Error(typeof msg === "string" ? msg : msg());
    }
  }
  function assertShapesMatch(shapeA, shapeB, errorMessagePrefix = "") {
    assert(arraysEqual(shapeA, shapeB), () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
  }
  function assertNonNull(a) {
    assert(a != null, () => `The input to the tensor constructor must be a non-null value.`);
  }
  function sizeFromShape(shape) {
    if (shape.length === 0) {
      return 1;
    }
    let size = shape[0];
    for (let i = 1; i < shape.length; i++) {
      size *= shape[i];
    }
    return size;
  }
  function isScalarShape(shape) {
    return shape.length === 0;
  }
  function arraysEqualWithNull(n1, n2) {
    if (n1 === n2) {
      return true;
    }
    if (n1 == null || n2 == null) {
      return false;
    }
    if (n1.length !== n2.length) {
      return false;
    }
    for (let i = 0; i < n1.length; i++) {
      if (n1[i] !== null && n2[i] !== null && n1[i] !== n2[i]) {
        return false;
      }
    }
    return true;
  }
  function arraysEqual(n1, n2) {
    if (n1 === n2) {
      return true;
    }
    if (n1 == null || n2 == null) {
      return false;
    }
    if (n1.length !== n2.length) {
      return false;
    }
    for (let i = 0; i < n1.length; i++) {
      if (n1[i] !== n2[i]) {
        return false;
      }
    }
    return true;
  }
  function isInt(a) {
    return a % 1 === 0;
  }
  function tanh$2(x) {
    if (Math.tanh != null) {
      return Math.tanh(x);
    }
    if (x === Infinity) {
      return 1;
    } else if (x === -Infinity) {
      return -1;
    } else {
      const e2x = Math.exp(2 * x);
      return (e2x - 1) / (e2x + 1);
    }
  }
  function sizeToSquarishShape(size) {
    const width = Math.ceil(Math.sqrt(size));
    return [width, Math.ceil(size / width)];
  }
  function createShuffledIndices(n) {
    const shuffledIndices = new Uint32Array(n);
    for (let i = 0; i < n; ++i) {
      shuffledIndices[i] = i;
    }
    shuffle(shuffledIndices);
    return shuffledIndices;
  }
  function rightPad(a, size) {
    if (size <= a.length) {
      return a;
    }
    return a + " ".repeat(size - a.length);
  }
  function repeatedTry(checkFn, delayFn = (counter) => 0, maxCounter, scheduleFn) {
    return new Promise((resolve, reject) => {
      let tryCount = 0;
      const tryFn = () => {
        if (checkFn()) {
          resolve();
          return;
        }
        tryCount++;
        const nextBackoff = delayFn(tryCount);
        if (maxCounter != null && tryCount >= maxCounter) {
          reject();
          return;
        }
        if (scheduleFn != null) {
          scheduleFn(tryFn, nextBackoff);
        } else {
          setTimeout(tryFn, nextBackoff);
        }
      };
      tryFn();
    });
  }
  function inferFromImplicitShape(shape, size) {
    let shapeProd = 1;
    let implicitIdx = -1;
    for (let i = 0; i < shape.length; ++i) {
      if (shape[i] >= 0) {
        shapeProd *= shape[i];
      } else if (shape[i] === -1) {
        if (implicitIdx !== -1) {
          throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${implicitIdx} and dim ${i}`);
        }
        implicitIdx = i;
      } else if (shape[i] < 0) {
        throw Error(`Shapes can not be < 0. Found ${shape[i]} at dim ${i}`);
      }
    }
    if (implicitIdx === -1) {
      if (size > 0 && size !== shapeProd) {
        throw Error(`Size(${size}) must match the product of shape ${shape}`);
      }
      return shape;
    }
    if (shapeProd === 0) {
      throw Error(`Cannot infer the missing size in [${shape}] when there are 0 elements`);
    }
    if (size % shapeProd !== 0) {
      throw Error(`The implicit shape can't be a fractional number. Got ${size} / ${shapeProd}`);
    }
    const newShape = shape.slice();
    newShape[implicitIdx] = size / shapeProd;
    return newShape;
  }
  function parseAxisParam(axis, shape) {
    const rank = shape.length;
    axis = axis == null ? shape.map((s, i) => i) : [].concat(axis);
    assert(axis.every((ax) => ax >= -rank && ax < rank), () => `All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`);
    assert(axis.every((ax) => isInt(ax)), () => `All values in axis param must be integers but got axis ${axis}`);
    return axis.map((a) => a < 0 ? rank + a : a);
  }
  function squeezeShape(shape, axis) {
    const newShape = [];
    const keptDims = [];
    const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
    const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape).sort();
    let j2 = 0;
    for (let i = 0; i < shape.length; ++i) {
      if (axes != null) {
        if (axes[j2] === i && shape[i] !== 1) {
          throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);
        }
        if ((axes[j2] == null || axes[j2] > i) && shape[i] === 1) {
          newShape.push(shape[i]);
          keptDims.push(i);
        }
        if (axes[j2] <= i) {
          j2++;
        }
      }
      if (shape[i] !== 1) {
        newShape.push(shape[i]);
        keptDims.push(i);
      }
    }
    return { newShape, keptDims };
  }
  function getTypedArrayFromDType(dtype, size) {
    return getArrayFromDType(dtype, size);
  }
  function getArrayFromDType(dtype, size) {
    let values = null;
    if (dtype == null || dtype === "float32") {
      values = new Float32Array(size);
    } else if (dtype === "int32") {
      values = new Int32Array(size);
    } else if (dtype === "bool") {
      values = new Uint8Array(size);
    } else if (dtype === "string") {
      values = new Array(size);
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
    return values;
  }
  function checkConversionForErrors(vals, dtype) {
    for (let i = 0; i < vals.length; i++) {
      const num = vals[i];
      if (isNaN(num) || !isFinite(num)) {
        throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);
      }
    }
  }
  function isValidDtype(dtype) {
    return dtype === "bool" || dtype === "complex64" || dtype === "float32" || dtype === "int32" || dtype === "string";
  }
  function hasEncodingLoss(oldType, newType) {
    if (newType === "complex64") {
      return false;
    }
    if (newType === "float32" && oldType !== "complex64") {
      return false;
    }
    if (newType === "int32" && oldType !== "float32" && oldType !== "complex64") {
      return false;
    }
    if (newType === "bool" && oldType === "bool") {
      return false;
    }
    return true;
  }
  function bytesPerElement(dtype) {
    if (dtype === "float32" || dtype === "int32") {
      return 4;
    } else if (dtype === "complex64") {
      return 8;
    } else if (dtype === "bool") {
      return 1;
    } else {
      throw new Error(`Unknown dtype ${dtype}`);
    }
  }
  function bytesFromStringArray(arr) {
    if (arr == null) {
      return 0;
    }
    let bytes = 0;
    arr.forEach((x) => bytes += x.length);
    return bytes;
  }
  function isString(value) {
    return typeof value === "string" || value instanceof String;
  }
  function isBoolean(value) {
    return typeof value === "boolean";
  }
  function isNumber(value) {
    return typeof value === "number";
  }
  function inferDtype(values) {
    if (Array.isArray(values)) {
      return inferDtype(values[0]);
    }
    if (values instanceof Float32Array) {
      return "float32";
    } else if (values instanceof Int32Array || values instanceof Uint8Array || values instanceof Uint8ClampedArray) {
      return "int32";
    } else if (isNumber(values)) {
      return "float32";
    } else if (isString(values)) {
      return "string";
    } else if (isBoolean(values)) {
      return "bool";
    }
    return "float32";
  }
  function isFunction(f) {
    return !!(f && f.constructor && f.call && f.apply);
  }
  function nearestDivisor(size, start) {
    for (let i = start; i < size; ++i) {
      if (size % i === 0) {
        return i;
      }
    }
    return size;
  }
  function computeStrides(shape) {
    const rank = shape.length;
    if (rank < 2) {
      return [];
    }
    const strides = new Array(rank - 1);
    strides[rank - 2] = shape[rank - 1];
    for (let i = rank - 3; i >= 0; --i) {
      strides[i] = strides[i + 1] * shape[i + 1];
    }
    return strides;
  }
  function createNestedArray(offset, shape, a, isComplex = false) {
    const ret = new Array();
    if (shape.length === 1) {
      const d = shape[0] * (isComplex ? 2 : 1);
      for (let i = 0; i < d; i++) {
        ret[i] = a[offset + i];
      }
    } else {
      const d = shape[0];
      const rest = shape.slice(1);
      const len = rest.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);
      for (let i = 0; i < d; i++) {
        ret[i] = createNestedArray(offset + i * len, rest, a, isComplex);
      }
    }
    return ret;
  }
  function toNestedArray(shape, a, isComplex = false) {
    if (shape.length === 0) {
      return a[0];
    }
    const size = shape.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);
    if (size === 0) {
      return [];
    }
    if (size !== a.length) {
      throw new Error(`[${shape}] does not match the input size ${a.length}${isComplex ? " for a complex tensor" : ""}.`);
    }
    return createNestedArray(0, shape, a, isComplex);
  }
  function convertBackendValuesAndArrayBuffer(data, dtype) {
    if (Array.isArray(data)) {
      return data;
    }
    if (dtype === "float32") {
      return data instanceof Float32Array ? data : new Float32Array(data);
    } else if (dtype === "int32") {
      return data instanceof Int32Array ? data : new Int32Array(data);
    } else if (dtype === "bool" || dtype === "string") {
      return Uint8Array.from(new Int32Array(data));
    } else {
      throw new Error(`Unknown dtype ${dtype}`);
    }
  }
  function makeOnesTypedArray(size, dtype) {
    const array = makeZerosTypedArray(size, dtype);
    for (let i = 0; i < array.length; i++) {
      array[i] = 1;
    }
    return array;
  }
  function makeZerosTypedArray(size, dtype) {
    if (dtype == null || dtype === "float32" || dtype === "complex64") {
      return new Float32Array(size);
    } else if (dtype === "int32") {
      return new Int32Array(size);
    } else if (dtype === "bool") {
      return new Uint8Array(size);
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
  }
  function makeZerosNestedTypedArray(shape, dtype) {
    const size = shape.reduce((prev, curr) => prev * curr, 1);
    if (dtype == null || dtype === "float32") {
      return toNestedArray(shape, new Float32Array(size));
    } else if (dtype === "int32") {
      return toNestedArray(shape, new Int32Array(size));
    } else if (dtype === "bool") {
      return toNestedArray(shape, new Uint8Array(size));
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
  }
  function assertNonNegativeIntegerDimensions(shape) {
    shape.forEach((dimSize) => {
      assert(Number.isInteger(dimSize) && dimSize >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${shape}].`);
    });
  }
  function locToIndex(locs, rank, strides) {
    if (rank === 0) {
      return 0;
    } else if (rank === 1) {
      return locs[0];
    }
    let index2 = locs[locs.length - 1];
    for (let i = 0; i < locs.length - 1; ++i) {
      index2 += strides[i] * locs[i];
    }
    return index2;
  }
  function indexToLoc(index2, rank, strides) {
    if (rank === 0) {
      return [];
    } else if (rank === 1) {
      return [index2];
    }
    const locs = new Array(rank);
    for (let i = 0; i < locs.length - 1; ++i) {
      locs[i] = Math.floor(index2 / strides[i]);
      index2 -= locs[i] * strides[i];
    }
    locs[locs.length - 1] = index2;
    return locs;
  }
  function isPromise(object) {
    return object && object.then && typeof object.then === "function";
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const TENSORFLOWJS_FLAGS_PREFIX = "tfjsflags";
  class Environment {
    // tslint:disable-next-line: no-any
    constructor(global2) {
      this.global = global2;
      this.flags = {};
      this.flagRegistry = {};
      this.urlFlags = {};
      this.getQueryParams = getQueryParams;
      this.populateURLFlags();
    }
    setPlatform(platformName, platform) {
      if (this.platform != null) {
        if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
          console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${platformName}.`);
        }
      }
      this.platformName = platformName;
      this.platform = platform;
    }
    registerFlag(flagName, evaluationFn, setHook) {
      this.flagRegistry[flagName] = { evaluationFn, setHook };
      if (this.urlFlags[flagName] != null) {
        const flagValue = this.urlFlags[flagName];
        if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
          console.warn(`Setting feature override from URL ${flagName}: ${flagValue}.`);
        }
        this.set(flagName, flagValue);
      }
    }
    async getAsync(flagName) {
      if (flagName in this.flags) {
        return this.flags[flagName];
      }
      this.flags[flagName] = await this.evaluateFlag(flagName);
      return this.flags[flagName];
    }
    get(flagName) {
      if (flagName in this.flags) {
        return this.flags[flagName];
      }
      const flagValue = this.evaluateFlag(flagName);
      if (isPromise(flagValue)) {
        throw new Error(`Flag ${flagName} cannot be synchronously evaluated. Please use getAsync() instead.`);
      }
      this.flags[flagName] = flagValue;
      return this.flags[flagName];
    }
    getNumber(flagName) {
      return this.get(flagName);
    }
    getBool(flagName) {
      return this.get(flagName);
    }
    getString(flagName) {
      return this.get(flagName);
    }
    getFlags() {
      return this.flags;
    }
    // For backwards compatibility.
    get features() {
      return this.flags;
    }
    set(flagName, value) {
      if (this.flagRegistry[flagName] == null) {
        throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);
      }
      this.flags[flagName] = value;
      if (this.flagRegistry[flagName].setHook != null) {
        this.flagRegistry[flagName].setHook(value);
      }
    }
    evaluateFlag(flagName) {
      if (this.flagRegistry[flagName] == null) {
        throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);
      }
      return this.flagRegistry[flagName].evaluationFn();
    }
    setFlags(flags) {
      this.flags = Object.assign({}, flags);
    }
    reset() {
      this.flags = {};
      this.urlFlags = {};
      this.populateURLFlags();
    }
    populateURLFlags() {
      if (typeof this.global === "undefined" || typeof this.global.location === "undefined" || typeof this.global.location.search === "undefined") {
        return;
      }
      const urlParams = this.getQueryParams(this.global.location.search);
      if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
        const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(",");
        keyValues.forEach((keyValue) => {
          const [key, value] = keyValue.split(":");
          this.urlFlags[key] = parseValue(key, value);
        });
      }
    }
  }
  function getQueryParams(queryString) {
    const params = {};
    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s, ...t) => {
      decodeParam(params, t[0], t[1]);
      return t.join("=");
    });
    return params;
  }
  function decodeParam(params, name, value) {
    params[decodeURIComponent(name)] = decodeURIComponent(value || "");
  }
  function parseValue(flagName, value) {
    const lowerCaseValue = value.toLowerCase();
    if (lowerCaseValue === "true" || lowerCaseValue === "false") {
      return lowerCaseValue === "true";
    } else if (`${+lowerCaseValue}` === lowerCaseValue) {
      return +lowerCaseValue;
    } else {
      return value;
    }
  }
  function env() {
    return ENV$3;
  }
  let ENV$3 = null;
  function setEnvironmentGlobal(environment) {
    ENV$3 = environment;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  let globalNameSpace;
  function getGlobalNamespace() {
    if (globalNameSpace == null) {
      let ns;
      if (typeof window !== "undefined") {
        ns = window;
      } else if (typeof global !== "undefined") {
        ns = global;
      } else if (typeof process !== "undefined") {
        ns = process;
      } else if (typeof self !== "undefined") {
        ns = self;
      } else {
        throw new Error("Could not find a global object");
      }
      globalNameSpace = ns;
    }
    return globalNameSpace;
  }
  function getGlobalMap() {
    const ns = getGlobalNamespace();
    if (ns._tfGlobals == null) {
      ns._tfGlobals = /* @__PURE__ */ new Map();
    }
    return ns._tfGlobals;
  }
  function getGlobal(key, init2) {
    const globalMap = getGlobalMap();
    if (globalMap.has(key)) {
      return globalMap.get(key);
    } else {
      const singleton = init2();
      globalMap.set(key, singleton);
      return globalMap.get(key);
    }
  }
  const Abs = "Abs";
  const Acos = "Acos";
  const Acosh = "Acosh";
  const Add = "Add";
  const AddN = "AddN";
  const All = "All";
  const Any = "Any";
  const ArgMax = "ArgMax";
  const ArgMin = "ArgMin";
  const Asin = "Asin";
  const Asinh = "Asinh";
  const Atan = "Atan";
  const Atanh = "Atanh";
  const Atan2 = "Atan2";
  const AvgPool = "AvgPool";
  const AvgPoolGrad = "AvgPoolGrad";
  const AvgPool3D = "AvgPool3D";
  const AvgPool3DGrad = "AvgPool3DGrad";
  const BatchMatMul = "BatchMatMul";
  const BatchToSpaceND = "BatchToSpaceND";
  const Bincount = "Bincount";
  const BitwiseAnd = "BitwiseAnd";
  const BroadcastTo = "BroadcastTo";
  const BroadcastArgs = "BroadcastArgs";
  const Cast = "Cast";
  const Ceil = "Ceil";
  const ClipByValue = "ClipByValue";
  const Complex = "Complex";
  const ComplexAbs = "ComplexAbs";
  const Concat = "Concat";
  const Conv2D = "Conv2D";
  const Conv2DBackpropFilter = "Conv2DBackpropFilter";
  const Conv2DBackpropInput = "Conv2DBackpropInput";
  const Conv3D = "Conv3D";
  const Conv3DBackpropFilterV2 = "Conv3DBackpropFilterV2";
  const Conv3DBackpropInputV2 = "Conv3DBackpropInputV2";
  const Cos = "Cos";
  const Cosh = "Cosh";
  const Cumprod = "Cumprod";
  const Cumsum = "Cumsum";
  const CropAndResize = "CropAndResize";
  const DenseBincount = "DenseBincount";
  const DepthToSpace = "DepthToSpace";
  const DepthwiseConv2dNative = "DepthwiseConv2dNative";
  const DepthwiseConv2dNativeBackpropFilter = "DepthwiseConv2dNativeBackpropFilter";
  const DepthwiseConv2dNativeBackpropInput = "DepthwiseConv2dNativeBackpropInput";
  const Diag = "Diag";
  const Dilation2D = "Dilation2D";
  const Dilation2DBackpropInput = "Dilation2DBackpropInput";
  const Dilation2DBackpropFilter = "Dilation2DBackpropFilter";
  const Draw = "Draw";
  const RealDiv = "RealDiv";
  const Einsum = "Einsum";
  const Elu = "Elu";
  const EluGrad = "EluGrad";
  const Erf = "Erf";
  const Equal = "Equal";
  const Exp = "Exp";
  const ExpandDims = "ExpandDims";
  const Expm1 = "Expm1";
  const FFT = "FFT";
  const Fill = "Fill";
  const FlipLeftRight = "FlipLeftRight";
  const Floor = "Floor";
  const FloorDiv = "FloorDiv";
  const FusedBatchNorm = "FusedBatchNorm";
  const GatherV2 = "GatherV2";
  const GatherNd = "GatherNd";
  const Greater = "Greater";
  const GreaterEqual = "GreaterEqual";
  const Identity = "Identity";
  const IFFT = "IFFT";
  const Imag = "Imag";
  const IsFinite = "IsFinite";
  const IsInf = "IsInf";
  const IsNan = "IsNan";
  const LeakyRelu = "LeakyRelu";
  const Less = "Less";
  const LessEqual = "LessEqual";
  const LinSpace = "LinSpace";
  const Log = "Log";
  const Log1p = "Log1p";
  const LogicalAnd = "LogicalAnd";
  const LogicalNot = "LogicalNot";
  const LogicalOr = "LogicalOr";
  const LogicalXor = "LogicalXor";
  const LogSoftmax = "LogSoftmax";
  const LowerBound = "LowerBound";
  const LRN = "LRN";
  const LRNGrad = "LRNGrad";
  const MatrixBandPart = "MatrixBandPart";
  const Max = "Max";
  const Maximum = "Maximum";
  const MaxPool = "MaxPool";
  const MaxPoolGrad = "MaxPoolGrad";
  const MaxPool3D = "MaxPool3D";
  const MaxPool3DGrad = "MaxPool3DGrad";
  const MaxPoolWithArgmax = "MaxPoolWithArgmax";
  const Mean = "Mean";
  const Min = "Min";
  const Minimum = "Minimum";
  const MirrorPad = "MirrorPad";
  const Mod = "Mod";
  const Multinomial = "Multinomial";
  const Multiply = "Multiply";
  const Neg = "Neg";
  const NotEqual = "NotEqual";
  const NonMaxSuppressionV3 = "NonMaxSuppressionV3";
  const NonMaxSuppressionV4 = "NonMaxSuppressionV4";
  const NonMaxSuppressionV5 = "NonMaxSuppressionV5";
  const OnesLike = "OnesLike";
  const OneHot = "OneHot";
  const Pack = "Pack";
  const PadV2 = "PadV2";
  const Pool = "Pool";
  const Pow = "Pow";
  const Prelu = "Prelu";
  const Prod = "Prod";
  const RaggedGather = "RaggedGather";
  const RaggedRange = "RaggedRange";
  const RaggedTensorToTensor = "RaggedTensorToTensor";
  const Range = "Range";
  const Real = "Real";
  const Reciprocal = "Reciprocal";
  const Relu = "Relu";
  const Reshape = "Reshape";
  const ResizeNearestNeighbor = "ResizeNearestNeighbor";
  const ResizeNearestNeighborGrad = "ResizeNearestNeighborGrad";
  const ResizeBilinear = "ResizeBilinear";
  const ResizeBilinearGrad = "ResizeBilinearGrad";
  const Relu6 = "Relu6";
  const Reverse = "Reverse";
  const Round = "Round";
  const Rsqrt = "Rsqrt";
  const ScatterNd = "ScatterNd";
  const TensorScatterUpdate = "TensorScatterUpdate";
  const SearchSorted = "SearchSorted";
  const Select = "Select";
  const Selu = "Selu";
  const Slice = "Slice";
  const Sin = "Sin";
  const Sinh = "Sinh";
  const Sign = "Sign";
  const Sigmoid = "Sigmoid";
  const Softplus = "Softplus";
  const Sqrt = "Sqrt";
  const Sum = "Sum";
  const SpaceToBatchND = "SpaceToBatchND";
  const SplitV = "SplitV";
  const Softmax = "Softmax";
  const SparseFillEmptyRows = "SparseFillEmptyRows";
  const SparseReshape = "SparseReshape";
  const SparseSegmentMean = "SparseSegmentMean";
  const SparseSegmentSum = "SparseSegmentSum";
  const SparseToDense = "SparseToDense";
  const SquaredDifference = "SquaredDifference";
  const Square = "Square";
  const StaticRegexReplace = "StaticRegexReplace";
  const StridedSlice = "StridedSlice";
  const StringNGrams = "StringNGrams";
  const StringSplit = "StringSplit";
  const StringToHashBucketFast = "StringToHashBucketFast";
  const Sub = "Sub";
  const Tan = "Tan";
  const Tanh = "Tanh";
  const Tile = "Tile";
  const TopK = "TopK";
  const Transform = "Transform";
  const Transpose = "Transpose";
  const Unique = "Unique";
  const Unpack = "Unpack";
  const UnsortedSegmentSum = "UnsortedSegmentSum";
  const UpperBound = "UpperBound";
  const ZerosLike = "ZerosLike";
  const Step = "Step";
  const FromPixels = "FromPixels";
  const RotateWithOffset = "RotateWithOffset";
  const _FusedMatMul = "_FusedMatMul";
  const FusedConv2D = "FusedConv2D";
  const FusedDepthwiseConv2D = "FusedDepthwiseConv2D";
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function warn(...msg) {
    if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
      console.warn(...msg);
    }
  }
  function log$2(...msg) {
    if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
      console.log(...msg);
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const kernelRegistry = getGlobal("kernelRegistry", () => /* @__PURE__ */ new Map());
  const gradRegistry = getGlobal("gradRegistry", () => /* @__PURE__ */ new Map());
  function getKernel(kernelName, backendName) {
    const key = makeKey(kernelName, backendName);
    return kernelRegistry.get(key);
  }
  function getGradient(kernelName) {
    return gradRegistry.get(kernelName);
  }
  function getKernelsForBackend(backendName) {
    const it2 = kernelRegistry.entries();
    const result = [];
    while (true) {
      const { done, value } = it2.next();
      if (done) {
        break;
      }
      const [key, config] = value;
      const [backend2] = key.split("_");
      if (backend2 === backendName) {
        result.push(config);
      }
    }
    return result;
  }
  function registerKernel(config) {
    const { kernelName, backendName } = config;
    const key = makeKey(kernelName, backendName);
    if (kernelRegistry.has(key)) {
      warn(`The kernel '${kernelName}' for backend '${backendName}' is already registered`);
    }
    kernelRegistry.set(key, config);
  }
  function registerGradient(config) {
    const { kernelName } = config;
    if (gradRegistry.has(kernelName)) {
      if (env().getBool("DEBUG")) {
        warn(`Overriding the gradient for '${kernelName}'`);
      }
    }
    gradRegistry.set(kernelName, config);
  }
  function unregisterKernel(kernelName, backendName) {
    const key = makeKey(kernelName, backendName);
    if (!kernelRegistry.has(key)) {
      throw new Error(`The kernel '${kernelName}' for backend '${backendName}' is not registered`);
    }
    kernelRegistry.delete(key);
  }
  function unregisterGradient(kernelName) {
    if (!gradRegistry.has(kernelName)) {
      throw new Error(`The gradient '${kernelName}' for backend is not registered`);
    }
    gradRegistry.delete(kernelName);
  }
  function copyRegisteredKernels(registeredBackendName, newBackendName) {
    const kernels = getKernelsForBackend(registeredBackendName);
    kernels.forEach((kernelConfig) => {
      const newKernelConfig = Object.assign({}, kernelConfig, { backendName: newBackendName });
      registerKernel(newKernelConfig);
    });
  }
  function makeKey(kernelName, backendName) {
    return `${backendName}_${kernelName}`;
  }
  /**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function isTypedArrayBrowser(a) {
    return a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array || a instanceof Uint8ClampedArray;
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n) {
    if (n.__esModule)
      return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f, arguments, this.constructor);
        }
        return f.apply(this, arguments);
      };
      a.prototype = f.prototype;
    } else
      a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n).forEach(function(k3) {
      var d = Object.getOwnPropertyDescriptor(n, k3);
      Object.defineProperty(a, k3, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k3];
        }
      });
    });
    return a;
  }
  var long = Long$1;
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      13,
      2,
      96,
      0,
      1,
      127,
      96,
      4,
      127,
      127,
      127,
      127,
      1,
      127,
      3,
      7,
      6,
      0,
      1,
      1,
      1,
      1,
      1,
      6,
      6,
      1,
      127,
      1,
      65,
      0,
      11,
      7,
      50,
      6,
      3,
      109,
      117,
      108,
      0,
      1,
      5,
      100,
      105,
      118,
      95,
      115,
      0,
      2,
      5,
      100,
      105,
      118,
      95,
      117,
      0,
      3,
      5,
      114,
      101,
      109,
      95,
      115,
      0,
      4,
      5,
      114,
      101,
      109,
      95,
      117,
      0,
      5,
      8,
      103,
      101,
      116,
      95,
      104,
      105,
      103,
      104,
      0,
      0,
      10,
      191,
      1,
      6,
      4,
      0,
      35,
      0,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      126,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      127,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      128,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      129,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      130,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11
    ])), {}).exports;
  } catch (e) {
  }
  function Long$1(low, high, unsigned) {
    this.low = low | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  }
  Long$1.prototype.__isLong__;
  Object.defineProperty(Long$1.prototype, "__isLong__", { value: true });
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  Long$1.isLong = isLong;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
      value >>>= 0;
      if (cache = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
      if (cache)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  Long$1.fromInt = fromInt;
  function fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  Long$1.fromNumber = fromNumber;
  function fromBits(lowBits, highBits, unsigned) {
    return new Long$1(lowBits, highBits, unsigned);
  }
  Long$1.fromBits = fromBits;
  var pow_dbl = Math.pow;
  function fromString(str, unsigned, radix) {
    if (str.length === 0)
      throw Error("empty string");
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
      return ZERO;
    if (typeof unsigned === "number") {
      radix = unsigned, unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    var p;
    if ((p = str.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  Long$1.fromString = fromString;
  function fromValue(val, unsigned) {
    if (typeof val === "number")
      return fromNumber(val, unsigned);
    if (typeof val === "string")
      return fromString(val, unsigned);
    return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
  }
  Long$1.fromValue = fromValue;
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  var ZERO = fromInt(0);
  Long$1.ZERO = ZERO;
  var UZERO = fromInt(0, true);
  Long$1.UZERO = UZERO;
  var ONE = fromInt(1);
  Long$1.ONE = ONE;
  var UONE = fromInt(1, true);
  Long$1.UONE = UONE;
  var NEG_ONE = fromInt(-1);
  Long$1.NEG_ONE = NEG_ONE;
  var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long$1.MAX_VALUE = MAX_VALUE;
  var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long$1.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
  Long$1.MIN_VALUE = MIN_VALUE;
  var LongPrototype = Long$1.prototype;
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(MIN_VALUE)) {
        var radixLong = fromNumber(radix), div2 = this.div(radixLong), rem1 = div2.mul(radixLong).sub(this);
        return div2.toString(radix) + rem1.toInt().toString(radix);
      } else
        return "-" + this.neg().toString(radix);
    }
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
    var result = "";
    while (true) {
      var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero())
        return digits + result;
      else {
        while (digits.length < 6)
          digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  };
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
      if ((val & 1 << bit) != 0)
        break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  LongPrototype.eqz = LongPrototype.isZero;
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  LongPrototype.isEven = function isEven2() {
    return (this.low & 1) === 0;
  };
  LongPrototype.equals = function equals(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
      return false;
    return this.high === other.high && this.low === other.low;
  };
  LongPrototype.eq = LongPrototype.equals;
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(
      /* validates */
      other
    );
  };
  LongPrototype.neq = LongPrototype.notEquals;
  LongPrototype.ne = LongPrototype.notEquals;
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(
      /* validates */
      other
    ) < 0;
  };
  LongPrototype.lt = LongPrototype.lessThan;
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) <= 0;
  };
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(
      /* validates */
      other
    ) > 0;
  };
  LongPrototype.gt = LongPrototype.greaterThan;
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) >= 0;
  };
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  LongPrototype.compare = function compare(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.eq(other))
      return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
      return -1;
    if (!thisNeg && otherNeg)
      return 1;
    if (!this.unsigned)
      return this.sub(other).isNegative() ? -1 : 1;
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  LongPrototype.comp = LongPrototype.compare;
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
      return MIN_VALUE;
    return this.not().add(ONE);
  };
  LongPrototype.neg = LongPrototype.negate;
  LongPrototype.add = function add2(addend) {
    if (!isLong(addend))
      addend = fromValue(addend);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 65535;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
      subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  LongPrototype.sub = LongPrototype.subtract;
  LongPrototype.multiply = function multiply2(multiplier) {
    if (this.isZero())
      return ZERO;
    if (!isLong(multiplier))
      multiplier = fromValue(multiplier);
    if (wasm) {
      var low = wasm.mul(
        this.low,
        this.high,
        multiplier.low,
        multiplier.high
      );
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    if (multiplier.isZero())
      return ZERO;
    if (this.eq(MIN_VALUE))
      return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
      return this.isOdd() ? MIN_VALUE : ZERO;
    if (this.isNegative()) {
      if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
      else
        return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
      return this.mul(multiplier.neg()).neg();
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
      return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 65535;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.mul = LongPrototype.multiply;
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (divisor.isZero())
      throw Error("division by zero");
    if (wasm) {
      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
        return this;
      }
      var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
          return MIN_VALUE;
        else if (divisor.eq(MIN_VALUE))
          return ONE;
        else {
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(ZERO)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE))
        return this.unsigned ? UZERO : ZERO;
      if (this.isNegative()) {
        if (divisor.isNegative())
          return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
      res = ZERO;
    } else {
      if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
      if (divisor.gt(this))
        return UZERO;
      if (divisor.gt(this.shru(1)))
        return UONE;
      res = UZERO;
    }
    rem = this;
    while (rem.gte(divisor)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
      var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }
      if (approxRes.isZero())
        approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  };
  LongPrototype.div = LongPrototype.divide;
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (wasm) {
      var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
  };
  LongPrototype.mod = LongPrototype.modulo;
  LongPrototype.rem = LongPrototype.modulo;
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  LongPrototype.and = function and(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  LongPrototype.or = function or(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  LongPrototype.xor = function xor(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else
      return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  LongPrototype.shl = LongPrototype.shiftLeft;
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else
      return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  LongPrototype.shr = LongPrototype.shiftRight;
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
      return this;
    else {
      var high = this.high;
      if (numBits < 32) {
        var low = this.low;
        return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
      } else if (numBits === 32)
        return fromBits(high, 0, this.unsigned);
      else
        return fromBits(high >>> numBits - 32, 0, this.unsigned);
    }
  };
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
      return this;
    return fromBits(this.low, this.high, false);
  };
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
      return this;
    return fromBits(this.low, this.high, true);
  };
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high, lo = this.low;
    return [
      lo & 255,
      lo >>> 8 & 255,
      lo >>> 16 & 255,
      lo >>> 24,
      hi & 255,
      hi >>> 8 & 255,
      hi >>> 16 & 255,
      hi >>> 24
    ];
  };
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high, lo = this.low;
    return [
      hi >>> 24,
      hi >>> 16 & 255,
      hi >>> 8 & 255,
      hi & 255,
      lo >>> 24,
      lo >>> 16 & 255,
      lo >>> 8 & 255,
      lo & 255
    ];
  };
  Long$1.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long$1.fromBytesLE(bytes, unsigned) : Long$1.fromBytesBE(bytes, unsigned);
  };
  Long$1.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long$1(
      bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
      bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
      unsigned
    );
  };
  Long$1.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long$1(
      bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
      bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
      unsigned
    );
  };
  const long$1 = /* @__PURE__ */ getDefaultExportFromCjs(long);
  const LongExports = /* @__PURE__ */ _mergeNamespaces({
    __proto__: null,
    default: long$1
  }, [long]);
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const Long = (
    // tslint:disable-next-line
    long$1 || LongExports
  );
  function hexToLong(hex) {
    return Long.fromString(hex, true, 16);
  }
  const k0 = hexToLong("c3a5c85c97cb3127");
  const k1 = hexToLong("b492b66fbe98f273");
  const k2 = hexToLong("9ae16a3b2f90404f");
  function shiftMix(val) {
    return val.xor(val.shru(47));
  }
  function fetch$2(s, offset, numBytes) {
    const bytes = s.slice(offset, offset + numBytes);
    return Long.fromBytes(Array.from(bytes), true, true);
  }
  function fetch64(s, offset) {
    return fetch$2(s, offset, 8);
  }
  function fetch32(s, offset) {
    return fetch$2(s, offset, 4);
  }
  function rotate64(val, shift) {
    return shift === 0 ? val : val.shru(shift).or(val.shl(64 - shift));
  }
  function hashLen16(u, v, mul2 = hexToLong("9ddfea08eb382d69")) {
    let a = u.xor(v).mul(mul2);
    a = a.xor(a.shru(47));
    let b = v.xor(a).mul(mul2);
    b = b.xor(b.shru(47));
    b = b.mul(mul2);
    return b;
  }
  function weakHashLen32WithSeeds(w, x, y, z2, a, b) {
    a = a.add(w);
    b = rotate64(b.add(a).add(z2), 21);
    const c = a;
    a = a.add(x);
    a = a.add(y);
    b = b.add(rotate64(a, 44));
    return [a.add(z2), b.add(c)];
  }
  function weakHashLen32WithSeedsStr(s, offset, a, b) {
    return weakHashLen32WithSeeds(fetch64(s, offset), fetch64(s, offset + 8), fetch64(s, offset + 16), fetch64(s, offset + 24), a, b);
  }
  function hashLen0to16(s, len = s.length) {
    if (len >= 8) {
      const mul2 = k2.add(len * 2);
      const a = fetch64(s, 0).add(k2);
      const b = fetch64(s, len - 8);
      const c = rotate64(b, 37).mul(mul2).add(a);
      const d = rotate64(a, 25).add(b).mul(mul2);
      return hashLen16(c, d, mul2);
    }
    if (len >= 4) {
      const mul2 = k2.add(len * 2);
      const a = fetch32(s, 0);
      return hashLen16(a.shl(3).add(len), fetch32(s, len - 4), mul2);
    }
    if (len > 0) {
      const a = s[0];
      const b = s[len >> 1];
      const c = s[len - 1];
      const y = a + (b << 8);
      const z2 = len + (c << 2);
      return shiftMix(k2.mul(y).xor(k0.mul(z2))).mul(k2);
    }
    return k2;
  }
  function hashLen17to32(s, len = s.length) {
    const mul2 = k2.add(len * 2);
    const a = fetch64(s, 0).mul(k1);
    const b = fetch64(s, 8);
    const c = fetch64(s, len - 8).mul(mul2);
    const d = fetch64(s, len - 16).mul(k2);
    return hashLen16(rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d), a.add(rotate64(b.add(k2), 18)).add(c), mul2);
  }
  function hashLen33to64(s, len = s.length) {
    const mul2 = k2.add(len * 2);
    const a = fetch64(s, 0).mul(k2);
    const b = fetch64(s, 8);
    const c = fetch64(s, len - 8).mul(mul2);
    const d = fetch64(s, len - 16).mul(k2);
    const y = rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d);
    const z2 = hashLen16(y, a.add(rotate64(b.add(k2), 18)).add(c), mul2);
    const e = fetch64(s, 16).mul(mul2);
    const f = fetch64(s, 24);
    const g = y.add(fetch64(s, len - 32)).mul(mul2);
    const h = z2.add(fetch64(s, len - 24)).mul(mul2);
    return hashLen16(rotate64(e.add(f), 43).add(rotate64(g, 30)).add(h), e.add(rotate64(f.add(a), 18)).add(g), mul2);
  }
  function fingerPrint64(s, len = s.length) {
    const seed = Long.fromNumber(81, true);
    if (len <= 32) {
      if (len <= 16) {
        return hashLen0to16(s, len);
      } else {
        return hashLen17to32(s, len);
      }
    } else if (len <= 64) {
      return hashLen33to64(s, len);
    }
    let x = seed;
    let y = seed.mul(k1).add(113);
    let z2 = shiftMix(y.mul(k2).add(113)).mul(k2);
    let v = [Long.UZERO, Long.UZERO];
    let w = [Long.UZERO, Long.UZERO];
    x = x.mul(k2).add(fetch64(s, 0));
    let offset = 0;
    const end = (len - 1 >> 6) * 64;
    const last64 = end + (len - 1 & 63) - 63;
    do {
      x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(k1);
      y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(k1);
      x = x.xor(w[1]);
      y = y.add(v[0]).add(fetch64(s, offset + 40));
      z2 = rotate64(z2.add(w[0]), 33).mul(k1);
      v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(k1), x.add(w[0]));
      w = weakHashLen32WithSeedsStr(s, offset + 32, z2.add(w[1]), y.add(fetch64(s, offset + 16)));
      [z2, x] = [x, z2];
      offset += 64;
    } while (offset !== end);
    const mul2 = k1.add(z2.and(255).shl(1));
    offset = last64;
    w[0] = w[0].add(len - 1 & 63);
    v[0] = v[0].add(w[0]);
    w[0] = w[0].add(v[0]);
    x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(mul2);
    y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(mul2);
    x = x.xor(w[1].mul(9));
    y = y.add(v[0].mul(9).add(fetch64(s, offset + 40)));
    z2 = rotate64(z2.add(w[0]), 33).mul(mul2);
    v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(mul2), x.add(w[0]));
    w = weakHashLen32WithSeedsStr(s, offset + 32, z2.add(w[1]), y.add(fetch64(s, offset + 16)));
    [z2, x] = [x, z2];
    return hashLen16(hashLen16(v[0], w[0], mul2).add(shiftMix(y).mul(k0)).add(z2), hashLen16(v[1], w[1], mul2).add(x), mul2);
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function createScalarValue(value, dtype) {
    if (dtype === "string") {
      return encodeString(value);
    }
    return toTypedArray([value], dtype);
  }
  function noConversionNeeded(a, dtype) {
    return a instanceof Float32Array && dtype === "float32" || a instanceof Int32Array && dtype === "int32" || a instanceof Uint8Array && dtype === "bool";
  }
  function toTypedArray(a, dtype) {
    if (dtype === "string") {
      throw new Error("Cannot convert a string[] to a TypedArray");
    }
    if (Array.isArray(a)) {
      a = flatten(a);
    }
    if (env().getBool("DEBUG")) {
      checkConversionForErrors(a, dtype);
    }
    if (noConversionNeeded(a, dtype)) {
      return a;
    }
    if (dtype == null || dtype === "float32" || dtype === "complex64") {
      return new Float32Array(a);
    } else if (dtype === "int32") {
      return new Int32Array(a);
    } else if (dtype === "bool") {
      const bool = new Uint8Array(a.length);
      for (let i = 0; i < bool.length; ++i) {
        if (Math.round(a[i]) !== 0) {
          bool[i] = 1;
        }
      }
      return bool;
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
  }
  function now() {
    return env().platform.now();
  }
  function fetch$1(path, requestInits) {
    return env().platform.fetch(path, requestInits);
  }
  function encodeString(s, encoding = "utf-8") {
    encoding = encoding || "utf-8";
    return env().platform.encode(s, encoding);
  }
  function decodeString(bytes, encoding = "utf-8") {
    encoding = encoding || "utf-8";
    return env().platform.decode(bytes, encoding);
  }
  function isTypedArray(a) {
    if (env().platform.isTypedArray != null) {
      return env().platform.isTypedArray(a);
    } else {
      return isTypedArrayBrowser(a);
    }
  }
  function flatten(arr, result = [], skipTypedArray = false) {
    if (result == null) {
      result = [];
    }
    if (typeof arr === "boolean" || typeof arr === "number" || typeof arr === "string" || isPromise(arr) || arr == null || isTypedArray(arr) && skipTypedArray) {
      result.push(arr);
    } else if (Array.isArray(arr) || isTypedArray(arr)) {
      for (let i = 0; i < arr.length; ++i) {
        flatten(arr[i], result, skipTypedArray);
      }
    } else {
      let maxIndex = -1;
      for (const key of Object.keys(arr)) {
        if (/^([1-9]+[0-9]*|0)$/.test(key)) {
          maxIndex = Math.max(maxIndex, Number(key));
        }
      }
      for (let i = 0; i <= maxIndex; i++) {
        flatten(arr[i], result, skipTypedArray);
      }
    }
    return result;
  }
  const util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    arraysEqual,
    arraysEqualWithNull,
    assert,
    assertNonNegativeIntegerDimensions,
    assertNonNull,
    assertShapesMatch,
    bytesFromStringArray,
    bytesPerElement,
    checkConversionForErrors,
    clamp,
    computeStrides,
    convertBackendValuesAndArrayBuffer,
    createScalarValue,
    createShuffledIndices,
    decodeString,
    distSquared,
    encodeString,
    fetch: fetch$1,
    fingerPrint64,
    flatten,
    getArrayFromDType,
    getTypedArrayFromDType,
    hasEncodingLoss,
    hexToLong,
    indexToLoc,
    inferDtype,
    inferFromImplicitShape,
    isBoolean,
    isFunction,
    isInt,
    isNumber,
    isPromise,
    isScalarShape,
    isString,
    isTypedArray,
    isValidDtype,
    locToIndex,
    makeOnesTypedArray,
    makeZerosNestedTypedArray,
    makeZerosTypedArray,
    nearestDivisor,
    nearestLargerEven,
    now,
    parseAxisParam,
    randUniform,
    repeatedTry,
    rightPad,
    shuffle,
    shuffleCombo,
    sizeFromShape,
    sizeToSquarishShape,
    squeezeShape,
    sum: sum$2,
    swap,
    tanh: tanh$2,
    toNestedArray,
    toTypedArray
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class Profiler {
    constructor(backendTimer, logger) {
      this.backendTimer = backendTimer;
      this.logger = logger;
      if (logger == null) {
        this.logger = new Logger();
      }
    }
    profileKernel(kernelName, inputs, f) {
      let outputs;
      const holdResultWrapperFn = () => {
        outputs = f();
      };
      let timer;
      const start = now();
      if (this.backendTimer.timerAvailable()) {
        timer = this.backendTimer.time(holdResultWrapperFn);
      } else {
        holdResultWrapperFn();
        for (const output of outputs) {
          output.dataSync();
        }
        timer = Promise.resolve({ kernelMs: now() - start });
      }
      if (env().getBool("CHECK_COMPUTATION_FOR_ERRORS")) {
        for (let i = 0; i < outputs.length; i++) {
          const output = outputs[i];
          output.data().then((tensorVals) => {
            checkComputationForErrors(tensorVals, output.dtype, kernelName);
          });
        }
      }
      const kernelProfile = {
        kernelName,
        outputs,
        inputs,
        timeMs: timer.then((timing) => timing.kernelMs),
        extraInfo: timer.then((timing) => timing.getExtraProfileInfo != null ? timing.getExtraProfileInfo() : "")
      };
      return kernelProfile;
    }
    logKernelProfile(kernelProfile) {
      const { kernelName, outputs, timeMs, inputs, extraInfo } = kernelProfile;
      outputs.forEach((result) => {
        Promise.all([result.data(), timeMs, extraInfo]).then((valueContainer) => {
          this.logger.logKernelProfile(kernelName, result, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);
        });
      });
    }
  }
  function checkComputationForErrors(vals, dtype, kernelName) {
    if (dtype !== "float32") {
      return false;
    }
    for (let i = 0; i < vals.length; i++) {
      const num = vals[i];
      if (isNaN(num) || !isFinite(num)) {
        console.warn(`Found ${num} in the result of '${kernelName}'`);
        return true;
      }
    }
    return false;
  }
  class Logger {
    logKernelProfile(name, result, vals, timeMs, inputs, extraInfo) {
      const time2 = typeof timeMs === "number" ? rightPad(`${timeMs}ms`, 9) : timeMs["error"];
      const paddedName = rightPad(name, 25);
      const rank = result.rank;
      const size = result.size;
      const shape = rightPad(result.shape.toString(), 14);
      let inputShapesDescription = "";
      for (const name2 in inputs) {
        const input = inputs[name2];
        if (input != null) {
          const inputShape = input.shape || result.shape;
          const inputRank = inputShape.length;
          inputShapesDescription += `${name2}: ${inputRank}D ${inputRank > 0 ? inputShape : ""} `;
        }
      }
      console.log(`%c${paddedName}	%c${time2}	%c${rank}D ${shape}	%c${size}	%c${inputShapesDescription}	%c${extraInfo}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
    }
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getFilteredNodesXToY(tape, xs, y) {
    const tensorsFromX = {};
    const nodesFromX = {};
    for (let i = 0; i < xs.length; i++) {
      tensorsFromX[xs[i].id] = true;
    }
    for (let i = 0; i < tape.length; i++) {
      const node = tape[i];
      const nodeInputs = node.inputs;
      for (const inputName in nodeInputs) {
        const input = nodeInputs[inputName];
        let anyInputFromX = false;
        for (let j2 = 0; j2 < xs.length; j2++) {
          if (tensorsFromX[input.id]) {
            node.outputs.forEach((output) => tensorsFromX[output.id] = true);
            anyInputFromX = true;
            nodesFromX[node.id] = true;
            break;
          }
        }
        if (anyInputFromX) {
          break;
        }
      }
    }
    const tensorsLeadToY = {};
    tensorsLeadToY[y.id] = true;
    const nodesToY = {};
    for (let i = tape.length - 1; i >= 0; i--) {
      const node = tape[i];
      const nodeInputs = node.inputs;
      for (let j2 = 0; j2 < node.outputs.length; j2++) {
        if (tensorsLeadToY[node.outputs[j2].id]) {
          for (const inputName in nodeInputs) {
            tensorsLeadToY[nodeInputs[inputName].id] = true;
            nodesToY[node.id] = true;
          }
          break;
        }
      }
    }
    const filteredTape = [];
    for (let i = 0; i < tape.length; i++) {
      const node = tape[i];
      if (nodesFromX[node.id] && nodesToY[node.id]) {
        const prunedInputs = {};
        for (const inputName in node.inputs) {
          const nodeInput = node.inputs[inputName];
          if (tensorsFromX[nodeInput.id]) {
            prunedInputs[inputName] = nodeInput;
          }
        }
        const prunedNode = Object.assign({}, node);
        prunedNode.inputs = prunedInputs;
        prunedNode.outputs = node.outputs;
        filteredTape.push(prunedNode);
      }
    }
    return filteredTape;
  }
  function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape, tidy2, add2) {
    for (let i = filteredTape.length - 1; i >= 0; i--) {
      const node = filteredTape[i];
      const dys = [];
      node.outputs.forEach((o) => {
        const gradTensor = tensorAccumulatedGradientMap[o.id];
        if (gradTensor != null) {
          dys.push(gradTensor);
        } else {
          dys.push(null);
        }
      });
      if (node.gradient == null) {
        throw new Error(`Cannot compute gradient: gradient function not found for ${node.kernelName}.`);
      }
      const inputGradients = node.gradient(dys);
      for (const inputName in node.inputs) {
        if (!(inputName in inputGradients)) {
          throw new Error(`Cannot backprop through input ${inputName}. Available gradients found: ${Object.keys(inputGradients)}.`);
        }
        const dx = tidy2(() => inputGradients[inputName]());
        if (dx.dtype !== "float32") {
          throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);
        }
        const x = node.inputs[inputName];
        if (!arraysEqual(dx.shape, x.shape)) {
          throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input '${inputName}' has shape '${dx.shape}', which does not match the shape of the input '${x.shape}'`);
        }
        if (tensorAccumulatedGradientMap[x.id] == null) {
          tensorAccumulatedGradientMap[x.id] = dx;
        } else {
          const curGradient = tensorAccumulatedGradientMap[x.id];
          tensorAccumulatedGradientMap[x.id] = add2(curGradient, dx);
          curGradient.dispose();
        }
      }
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const FORMAT_LIMIT_NUM_VALS = 20;
  const FORMAT_NUM_FIRST_LAST_VALS = 3;
  const FORMAT_NUM_SIG_DIGITS = 7;
  function tensorToString(vals, shape, dtype, verbose) {
    const strides = computeStrides(shape);
    const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);
    const rank = shape.length;
    const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);
    const lines = ["Tensor"];
    if (verbose) {
      lines.push(`  dtype: ${dtype}`);
      lines.push(`  rank: ${rank}`);
      lines.push(`  shape: [${shape}]`);
      lines.push(`  values:`);
    }
    lines.push(valsLines.map((l) => "    " + l).join("\n"));
    return lines.join("\n");
  }
  function computeMaxSizePerColumn(vals, shape, dtype, strides) {
    const n = sizeFromShape(shape);
    const numCols = strides[strides.length - 1];
    const padPerCol = new Array(numCols).fill(0);
    const rank = shape.length;
    const valuesOrTuples = dtype === "complex64" ? createComplexTuples(vals) : vals;
    if (rank > 1) {
      for (let row = 0; row < n / numCols; row++) {
        const offset = row * numCols;
        for (let j2 = 0; j2 < numCols; j2++) {
          padPerCol[j2] = Math.max(padPerCol[j2], valToString(valuesOrTuples[offset + j2], 0, dtype).length);
        }
      }
    }
    return padPerCol;
  }
  function valToString(val, pad2, dtype) {
    let valStr;
    if (Array.isArray(val)) {
      valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;
    } else if (isString(val)) {
      valStr = `'${val}'`;
    } else if (dtype === "bool") {
      valStr = boolNumToString(val);
    } else {
      valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();
    }
    return rightPad(valStr, pad2);
  }
  function boolNumToString(v) {
    return v === 0 ? "false" : "true";
  }
  function subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {
    const storagePerElement = dtype === "complex64" ? 2 : 1;
    const size = shape[0];
    const rank = shape.length;
    if (rank === 0) {
      if (dtype === "complex64") {
        const complexTuple = createComplexTuples(vals);
        return [valToString(complexTuple[0], 0, dtype)];
      }
      if (dtype === "bool") {
        return [boolNumToString(vals[0])];
      }
      return [vals[0].toString()];
    }
    if (rank === 1) {
      if (size > FORMAT_LIMIT_NUM_VALS) {
        const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;
        let firstVals = Array.from(vals.slice(0, firstValsSize));
        let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));
        if (dtype === "complex64") {
          firstVals = createComplexTuples(firstVals);
          lastVals = createComplexTuples(lastVals);
        }
        return [
          "[" + firstVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(", ") + ", ..., " + lastVals.map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype)).join(", ") + "]"
        ];
      }
      const displayVals = dtype === "complex64" ? createComplexTuples(vals) : Array.from(vals);
      return [
        "[" + displayVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(", ") + "]"
      ];
    }
    const subshape = shape.slice(1);
    const substrides = strides.slice(1);
    const stride = strides[0] * storagePerElement;
    const lines = [];
    if (size > FORMAT_LIMIT_NUM_VALS) {
      for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {
        const start = i * stride;
        const end = start + stride;
        lines.push(...subTensorToString(
          vals.slice(start, end),
          subshape,
          dtype,
          substrides,
          padPerCol,
          false
          /* isLast */
        ));
      }
      lines.push("...");
      for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {
        const start = i * stride;
        const end = start + stride;
        lines.push(...subTensorToString(
          vals.slice(start, end),
          subshape,
          dtype,
          substrides,
          padPerCol,
          i === size - 1
          /* isLast */
        ));
      }
    } else {
      for (let i = 0; i < size; i++) {
        const start = i * stride;
        const end = start + stride;
        lines.push(...subTensorToString(
          vals.slice(start, end),
          subshape,
          dtype,
          substrides,
          padPerCol,
          i === size - 1
          /* isLast */
        ));
      }
    }
    const sep = rank === 2 ? "," : "";
    lines[0] = "[" + (size > 0 ? lines[0] + sep : "");
    for (let i = 1; i < lines.length - 1; i++) {
      lines[i] = " " + lines[i] + sep;
    }
    let newLineSep = ",\n";
    for (let i = 2; i < rank; i++) {
      newLineSep += "\n";
    }
    lines[lines.length - 1] = " " + lines[lines.length - 1] + "]" + (isLast ? "" : newLineSep);
    return lines;
  }
  function createComplexTuples(vals) {
    const complexTuples = [];
    for (let i = 0; i < vals.length; i += 2) {
      complexTuples.push([vals[i], vals[i + 1]]);
    }
    return complexTuples;
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class TensorBuffer {
    constructor(shape, dtype, values) {
      this.dtype = dtype;
      this.shape = shape.slice();
      this.size = sizeFromShape(shape);
      if (values != null) {
        const n = values.length;
        assert(n === this.size, () => `Length of values '${n}' does not match the size inferred by the shape '${this.size}'.`);
      }
      if (dtype === "complex64") {
        throw new Error(`complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).`);
      }
      this.values = values || getArrayFromDType(dtype, this.size);
      this.strides = computeStrides(shape);
    }
    /**
     * Sets a value in the buffer at a given location.
     *
     * @param value The value to set.
     * @param locs  The location indices.
     *
     * @doc {heading: 'Tensors', subheading: 'Creation'}
     */
    set(value, ...locs) {
      if (locs.length === 0) {
        locs = [0];
      }
      assert(locs.length === this.rank, () => `The number of provided coordinates (${locs.length}) must match the rank (${this.rank})`);
      const index2 = this.locToIndex(locs);
      this.values[index2] = value;
    }
    /**
     * Returns the value in the buffer at the provided location.
     *
     * @param locs The location indices.
     *
     * @doc {heading: 'Tensors', subheading: 'Creation'}
     */
    get(...locs) {
      if (locs.length === 0) {
        locs = [0];
      }
      let i = 0;
      for (const loc of locs) {
        if (loc < 0 || loc >= this.shape[i]) {
          const msg = `Requested out of range element at ${locs}.   Buffer shape=${this.shape}`;
          throw new Error(msg);
        }
        i++;
      }
      let index2 = locs[locs.length - 1];
      for (let i2 = 0; i2 < locs.length - 1; ++i2) {
        index2 += this.strides[i2] * locs[i2];
      }
      return this.values[index2];
    }
    locToIndex(locs) {
      if (this.rank === 0) {
        return 0;
      } else if (this.rank === 1) {
        return locs[0];
      }
      let index2 = locs[locs.length - 1];
      for (let i = 0; i < locs.length - 1; ++i) {
        index2 += this.strides[i] * locs[i];
      }
      return index2;
    }
    indexToLoc(index2) {
      if (this.rank === 0) {
        return [];
      } else if (this.rank === 1) {
        return [index2];
      }
      const locs = new Array(this.shape.length);
      for (let i = 0; i < locs.length - 1; ++i) {
        locs[i] = Math.floor(index2 / this.strides[i]);
        index2 -= locs[i] * this.strides[i];
      }
      locs[locs.length - 1] = index2;
      return locs;
    }
    get rank() {
      return this.shape.length;
    }
    /**
     * Creates an immutable `tf.Tensor` object from the buffer.
     *
     * @doc {heading: 'Tensors', subheading: 'Creation'}
     */
    toTensor() {
      return trackerFn().makeTensor(this.values, this.shape, this.dtype);
    }
  }
  let trackerFn = null;
  let opHandler$1 = null;
  function setTensorTracker(fn) {
    trackerFn = fn;
  }
  function setOpHandler(handler) {
    opHandler$1 = handler;
  }
  class Tensor {
    constructor(shape, dtype, dataId, id) {
      this.kept = false;
      this.isDisposedInternal = false;
      this.shape = shape.slice();
      this.dtype = dtype || "float32";
      this.size = sizeFromShape(shape);
      this.strides = computeStrides(shape);
      this.dataId = dataId;
      this.id = id;
      this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
    }
    get rank() {
      return this.shape.length;
    }
    /**
     * Returns a promise of `tf.TensorBuffer` that holds the underlying data.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    async buffer() {
      const vals = await this.data();
      return opHandler$1.buffer(this.shape, this.dtype, vals);
    }
    /**
     * Returns a `tf.TensorBuffer` that holds the underlying data.
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    bufferSync() {
      return opHandler$1.buffer(this.shape, this.dtype, this.dataSync());
    }
    /**
     * Returns the tensor data as a nested array. The transfer of data is done
     * asynchronously.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    async array() {
      const vals = await this.data();
      return toNestedArray(this.shape, vals, this.dtype === "complex64");
    }
    /**
     * Returns the tensor data as a nested array. The transfer of data is done
     * synchronously.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    arraySync() {
      return toNestedArray(this.shape, this.dataSync(), this.dtype === "complex64");
    }
    /**
     * Asynchronously downloads the values from the `tf.Tensor`. Returns a
     * promise of `TypedArray` that resolves when the computation has finished.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    async data() {
      this.throwIfDisposed();
      const data = trackerFn().read(this.dataId);
      if (this.dtype === "string") {
        const bytes = await data;
        try {
          return bytes.map((b) => decodeString(b));
        } catch (_a) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      }
      return data;
    }
    /**
     * Copy the tensor's data to a new GPU resource. Comparing to the `dataSync()`
     * and `data()`, this method prevents data from being downloaded to CPU.
     *
     * For WebGL backend, the data will be stored on a densely packed texture.
     * This means that the texture will use the RGBA channels to store value.
     *
     * For WebGPU backend, the data will be stored on a buffer. There is no
     * parameter, so can not use a user-defined size to create the buffer.
     *
     * @param options:
     *     For WebGL,
     *         - customTexShape: Optional. If set, will use the user defined
     *     texture shape to create the texture.
     *
     * @returns For WebGL backend, a GPUData contains the new texture and
     *     its information.
     *     {
     *        tensorRef: The tensor that is associated with this texture,
     *        texture: WebGLTexture,
     *        texShape: [number, number] // [height, width]
     *     }
     *
     *     For WebGPU backend, a GPUData contains the new buffer.
     *     {
     *        tensorRef: The tensor that is associated with this buffer,
     *        buffer: GPUBuffer,
     *     }
     *
     *     Remember to dispose the GPUData after it is used by
     *     `res.tensorRef.dispose()`.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    dataToGPU(options) {
      this.throwIfDisposed();
      return trackerFn().readToGPU(this.dataId, options);
    }
    /**
     * Synchronously downloads the values from the `tf.Tensor`. This blocks the
     * UI thread until the values are ready, which can cause performance issues.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    dataSync() {
      this.throwIfDisposed();
      const data = trackerFn().readSync(this.dataId);
      if (this.dtype === "string") {
        try {
          return data.map((b) => decodeString(b));
        } catch (_a) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      }
      return data;
    }
    /** Returns the underlying bytes of the tensor's data. */
    async bytes() {
      this.throwIfDisposed();
      const data = await trackerFn().read(this.dataId);
      if (this.dtype === "string") {
        return data;
      } else {
        return new Uint8Array(data.buffer);
      }
    }
    /**
     * Disposes `tf.Tensor` from memory.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    dispose() {
      if (this.isDisposed) {
        return;
      }
      if (this.kerasMask) {
        this.kerasMask.dispose();
      }
      trackerFn().disposeTensor(this);
      this.isDisposedInternal = true;
    }
    get isDisposed() {
      return this.isDisposedInternal;
    }
    throwIfDisposed() {
      if (this.isDisposed) {
        throw new Error(`Tensor is disposed.`);
      }
    }
    /**
     * Prints the `tf.Tensor`. See `tf.print` for details.
     *
     * @param verbose Whether to print verbose information about the tensor,
     *    including dtype and size.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    print(verbose = false) {
      return opHandler$1.print(this, verbose);
    }
    /**
     * Returns a copy of the tensor. See `tf.clone` for details.
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    clone() {
      this.throwIfDisposed();
      return opHandler$1.clone(this);
    }
    /**
     * Returns a human-readable description of the tensor. Useful for logging.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    toString(verbose = false) {
      const vals = this.dataSync();
      return tensorToString(vals, this.shape, this.dtype, verbose);
    }
    cast(dtype) {
      this.throwIfDisposed();
      return opHandler$1.cast(this, dtype);
    }
    variable(trainable = true, name, dtype) {
      this.throwIfDisposed();
      return trackerFn().makeVariable(this, trainable, name, dtype);
    }
  }
  Object.defineProperty(Tensor, Symbol.hasInstance, {
    value: (instance) => {
      return !!instance && instance.data != null && instance.dataSync != null && instance.throwIfDisposed != null;
    }
  });
  function getGlobalTensorClass() {
    return getGlobal("Tensor", () => {
      return Tensor;
    });
  }
  getGlobalTensorClass();
  class Variable extends Tensor {
    constructor(initialValue, trainable, name, tensorId) {
      super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);
      this.trainable = trainable;
      this.name = name;
    }
    /**
     * Assign a new `tf.Tensor` to this variable. The new `tf.Tensor` must have
     * the same shape and dtype as the old `tf.Tensor`.
     *
     * @param newValue New tensor to be assigned to this variable.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    assign(newValue) {
      if (newValue.dtype !== this.dtype) {
        throw new Error(`dtype of the new value (${newValue.dtype}) and previous value (${this.dtype}) must match`);
      }
      if (!arraysEqual(newValue.shape, this.shape)) {
        throw new Error(`shape of the new value (${newValue.shape}) and previous value (${this.shape}) must match`);
      }
      trackerFn().disposeTensor(this);
      this.dataId = newValue.dataId;
      trackerFn().incRef(
        this,
        null
        /* backend */
      );
    }
    dispose() {
      trackerFn().disposeVariable(this);
      this.isDisposedInternal = true;
    }
  }
  Object.defineProperty(Variable, Symbol.hasInstance, {
    value: (instance) => {
      return instance instanceof Tensor && instance.assign != null && instance.assign instanceof Function;
    }
  });
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  var Rank;
  (function(Rank2) {
    Rank2["R0"] = "R0";
    Rank2["R1"] = "R1";
    Rank2["R2"] = "R2";
    Rank2["R3"] = "R3";
    Rank2["R4"] = "R4";
    Rank2["R5"] = "R5";
    Rank2["R6"] = "R6";
  })(Rank || (Rank = {}));
  var UpcastInt32AndMap;
  (function(UpcastInt32AndMap2) {
    UpcastInt32AndMap2["float32"] = "float32";
    UpcastInt32AndMap2["int32"] = "int32";
    UpcastInt32AndMap2["bool"] = "int32";
    UpcastInt32AndMap2["complex64"] = "complex64";
  })(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
  var UpcastBoolAndMap;
  (function(UpcastBoolAndMap2) {
    UpcastBoolAndMap2["float32"] = "float32";
    UpcastBoolAndMap2["int32"] = "int32";
    UpcastBoolAndMap2["bool"] = "bool";
    UpcastBoolAndMap2["complex64"] = "complex64";
  })(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
  var UpcastFloat32AndMap;
  (function(UpcastFloat32AndMap2) {
    UpcastFloat32AndMap2["float32"] = "float32";
    UpcastFloat32AndMap2["int32"] = "float32";
    UpcastFloat32AndMap2["bool"] = "float32";
    UpcastFloat32AndMap2["complex64"] = "complex64";
  })(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
  var UpcastComplex64AndMap;
  (function(UpcastComplex64AndMap2) {
    UpcastComplex64AndMap2["float32"] = "complex64";
    UpcastComplex64AndMap2["int32"] = "complex64";
    UpcastComplex64AndMap2["bool"] = "complex64";
    UpcastComplex64AndMap2["complex64"] = "complex64";
  })(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));
  const upcastTypeMap = {
    "float32": UpcastFloat32AndMap,
    "int32": UpcastInt32AndMap,
    "bool": UpcastBoolAndMap,
    "complex64": UpcastComplex64AndMap
  };
  function upcastType(typeA, typeB) {
    if (typeA === "string" || typeB === "string") {
      if (typeA === "string" && typeB === "string") {
        return "string";
      }
      throw new Error(`Can not upcast ${typeA} with ${typeB}`);
    }
    return upcastTypeMap[typeA][typeB];
  }
  function sumOutType(type) {
    return upcastType(type, "int32");
  }
  function isWebGLData(values) {
    return values != null && typeof values === "object" && "texture" in values && values.texture instanceof WebGLTexture;
  }
  function isWebGPUData(values) {
    return typeof GPUBuffer !== "undefined" && values != null && typeof values === "object" && "buffer" in values && values.buffer instanceof GPUBuffer;
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function makeTypesMatch(a, b) {
    if (a.dtype === b.dtype) {
      return [a, b];
    }
    const dtype = upcastType(a.dtype, b.dtype);
    return [a.cast(dtype), b.cast(dtype)];
  }
  function assertTypesMatch(a, b) {
    assert(a.dtype === b.dtype, () => `The dtypes of the first(${a.dtype}) and second(${b.dtype}) input must match`);
  }
  function isTensorInList(tensor2, tensorList) {
    return tensorList.some((x) => x.id === tensor2.id);
  }
  function getTensorsInContainer(result) {
    const list = [];
    const seen2 = /* @__PURE__ */ new Set();
    walkTensorContainer(result, list, seen2);
    return list;
  }
  function walkTensorContainer(container, list, seen2) {
    if (container == null) {
      return;
    }
    if (container instanceof Tensor) {
      list.push(container);
      return;
    }
    if (!isIterable(container)) {
      return;
    }
    const iterable = container;
    for (const k3 in iterable) {
      const val = iterable[k3];
      if (!seen2.has(val)) {
        seen2.add(val);
        walkTensorContainer(val, list, seen2);
      }
    }
  }
  function isIterable(obj) {
    return Array.isArray(obj) || typeof obj === "object";
  }
  const tensor_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    assertTypesMatch,
    getTensorsInContainer,
    isTensorInList,
    makeTypesMatch
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function isRegisteredKernelInvocation(kernelInvocation) {
    return kernelInvocation.kernelName != null;
  }
  class EngineState {
    constructor() {
      this.registeredVariables = {};
      this.nextTapeNodeId = 0;
      this.numBytes = 0;
      this.numTensors = 0;
      this.numStringTensors = 0;
      this.numDataBuffers = 0;
      this.gradientDepth = 0;
      this.kernelDepth = 0;
      this.scopeStack = [];
      this.numDataMovesStack = [];
      this.nextScopeId = 0;
      this.tensorInfo = /* @__PURE__ */ new WeakMap();
      this.profiling = false;
      this.activeProfile = {
        newBytes: 0,
        newTensors: 0,
        peakBytes: 0,
        kernels: [],
        result: null,
        get kernelNames() {
          return Array.from(new Set(this.kernels.map((k3) => k3.name)));
        }
      };
    }
    dispose() {
      for (const variableName in this.registeredVariables) {
        this.registeredVariables[variableName].dispose();
      }
    }
  }
  class Engine {
    constructor(ENV2) {
      this.ENV = ENV2;
      this.registry = {};
      this.registryFactory = {};
      this.pendingBackendInitId = 0;
      this.state = new EngineState();
    }
    async ready() {
      if (this.pendingBackendInit != null) {
        return this.pendingBackendInit.then(() => {
        });
      }
      if (this.backendInstance != null) {
        return;
      }
      const sortedBackends = this.getSortedBackends();
      for (let i = 0; i < sortedBackends.length; i++) {
        const backendName = sortedBackends[i];
        const success = await this.initializeBackend(backendName).success;
        if (success) {
          await this.setBackend(backendName);
          return;
        }
      }
      throw new Error(`Could not initialize any backends, all backend initializations failed.`);
    }
    get backend() {
      if (this.pendingBackendInit != null) {
        throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      }
      if (this.backendInstance == null) {
        const { name, asyncInit } = this.initializeBackendsAndReturnBest();
        if (asyncInit) {
          throw new Error(`The highest priority backend '${name}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
        }
        this.setBackend(name);
      }
      return this.backendInstance;
    }
    backendNames() {
      return Object.keys(this.registryFactory);
    }
    findBackend(backendName) {
      if (!(backendName in this.registry)) {
        if (backendName in this.registryFactory) {
          const { asyncInit } = this.initializeBackend(backendName);
          if (asyncInit) {
            return null;
          }
        } else {
          return null;
        }
      }
      return this.registry[backendName];
    }
    findBackendFactory(backendName) {
      if (!(backendName in this.registryFactory)) {
        return null;
      }
      return this.registryFactory[backendName].factory;
    }
    registerBackend(backendName, factory, priority = 1) {
      if (backendName in this.registryFactory) {
        warn(`${backendName} backend was already registered. Reusing existing backend factory.`);
        return false;
      }
      this.registryFactory[backendName] = { factory, priority };
      return true;
    }
    async setBackend(backendName) {
      if (this.registryFactory[backendName] == null) {
        throw new Error(`Backend name '${backendName}' not found in registry`);
      }
      this.backendName = backendName;
      if (this.registry[backendName] == null) {
        this.backendInstance = null;
        const { success, asyncInit } = this.initializeBackend(backendName);
        const result = asyncInit ? await success : success;
        if (!result) {
          return false;
        }
      }
      this.backendInstance = this.registry[backendName];
      this.setupRegisteredKernels();
      this.profiler = new Profiler(this.backendInstance);
      return true;
    }
    setupRegisteredKernels() {
      const kernels = getKernelsForBackend(this.backendName);
      kernels.forEach((kernel) => {
        if (kernel.setupFunc != null) {
          kernel.setupFunc(this.backendInstance);
        }
      });
    }
    disposeRegisteredKernels(backendName) {
      const kernels = getKernelsForBackend(backendName);
      kernels.forEach((kernel) => {
        if (kernel.disposeFunc != null) {
          kernel.disposeFunc(this.registry[backendName]);
        }
      });
    }
    /**
     * Initializes a backend by looking up the backend name in the factory
     * registry and calling the factory method. Returns a boolean representing
     * whether the initialization of the backend succeeded. Throws an error if
     * there is no backend in the factory registry.
     */
    initializeBackend(backendName) {
      const registryFactoryEntry = this.registryFactory[backendName];
      if (registryFactoryEntry == null) {
        throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);
      }
      try {
        const backend2 = registryFactoryEntry.factory();
        if (backend2 && !(backend2 instanceof KernelBackend) && typeof backend2.then === "function") {
          const promiseId = ++this.pendingBackendInitId;
          const success = backend2.then((backendInstance) => {
            if (promiseId < this.pendingBackendInitId) {
              return false;
            }
            this.registry[backendName] = backendInstance;
            this.pendingBackendInit = null;
            return true;
          }).catch((err) => {
            if (promiseId < this.pendingBackendInitId) {
              return false;
            }
            this.pendingBackendInit = null;
            warn(`Initialization of backend ${backendName} failed`);
            warn(err.stack || err.message);
            return false;
          });
          this.pendingBackendInit = success;
          return { success, asyncInit: true };
        } else {
          this.registry[backendName] = backend2;
          return { success: true, asyncInit: false };
        }
      } catch (err) {
        warn(`Initialization of backend ${backendName} failed`);
        warn(err.stack || err.message);
        return { success: false, asyncInit: false };
      }
    }
    removeBackend(backendName) {
      if (!(backendName in this.registryFactory)) {
        throw new Error(`${backendName} backend not found in registry`);
      }
      if (this.backendName === backendName && this.pendingBackendInit != null) {
        this.pendingBackendInitId++;
      }
      if (backendName in this.registry) {
        this.disposeRegisteredKernels(backendName);
        this.registry[backendName].dispose();
        delete this.registry[backendName];
      }
      delete this.registryFactory[backendName];
      if (this.backendName === backendName) {
        this.pendingBackendInit = null;
        this.backendName = null;
        this.backendInstance = null;
      }
    }
    getSortedBackends() {
      if (Object.keys(this.registryFactory).length === 0) {
        throw new Error("No backend found in registry.");
      }
      return Object.keys(this.registryFactory).sort((a, b) => {
        return this.registryFactory[b].priority - this.registryFactory[a].priority;
      });
    }
    initializeBackendsAndReturnBest() {
      const sortedBackends = this.getSortedBackends();
      for (let i = 0; i < sortedBackends.length; i++) {
        const backendName = sortedBackends[i];
        const { success, asyncInit } = this.initializeBackend(backendName);
        if (asyncInit || success) {
          return { name: backendName, asyncInit };
        }
      }
      throw new Error(`Could not initialize any backends, all backend initializations failed.`);
    }
    moveData(backend2, dataId) {
      const info = this.state.tensorInfo.get(dataId);
      const srcBackend = info.backend;
      const values = this.readSync(dataId);
      const refCount = srcBackend.refCount(dataId);
      srcBackend.disposeData(dataId, true);
      info.backend = backend2;
      backend2.move(dataId, values, info.shape, info.dtype, refCount);
      if (this.shouldCheckForMemLeaks()) {
        this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
      }
    }
    tidy(nameOrFn, fn) {
      let name = null;
      if (fn == null) {
        if (typeof nameOrFn !== "function") {
          throw new Error("Please provide a function to tidy()");
        }
        fn = nameOrFn;
      } else {
        if (typeof nameOrFn !== "string" && !(nameOrFn instanceof String)) {
          throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
        }
        if (typeof fn !== "function") {
          throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
        }
        name = nameOrFn;
      }
      let result;
      return this.scopedRun(() => this.startScope(name), () => this.endScope(result), () => {
        result = fn();
        if (result instanceof Promise) {
          console.error("Cannot return a Promise inside of tidy.");
        }
        return result;
      });
    }
    scopedRun(start, end, f) {
      start();
      try {
        const res = f();
        end();
        return res;
      } catch (ex) {
        end();
        throw ex;
      }
    }
    nextTensorId() {
      return Engine.nextTensorId++;
    }
    nextVariableId() {
      return Engine.nextVariableId++;
    }
    /**
     * This method is called instead of the public-facing tensor.clone() when
     * saving a tensor for backwards pass. It makes sure to add the clone
     * operation to the tape regardless of being called inside a kernel
     * execution.
     */
    clone(x) {
      const y = ENGINE.runKernel(Identity, { x });
      const inputs = { x };
      const grad2 = (dy) => ({
        x: () => {
          const dtype = "float32";
          const gradInputs = { x: dy };
          const attrs = { dtype };
          return ENGINE.runKernel(
            Cast,
            gradInputs,
            // tslint:disable-next-line: no-unnecessary-type-assertion
            attrs
          );
        }
      });
      const saved = [];
      this.addTapeNode(this.state.activeScope.name, inputs, [y], grad2, saved, {});
      return y;
    }
    /**
     * Execute a kernel with the given name and return the output tensor.
     *
     * @param kernelName The name of the kernel to execute.
     * @param inputs A map of input names to tensors.
     * @param attrs A map of attribute names to their values. An attribute is a
     *     primitive (non-tensor) input to the kernel.
     * @param inputsToSave A list of tensors, inputs to save for the backprop
     *     computation.
     * @param outputsToSave A list of booleans, specifying which output to save
     *     for the backprop computation. These are booleans since the output
     * tensors are not visible to the user.
     */
    runKernel(kernelName, inputs, attrs) {
      if (this.backendName == null) {
        this.backend;
      }
      const hasKernel = getKernel(kernelName, this.backendName) != null;
      if (!hasKernel) {
        throw new Error(`Kernel '${kernelName}' not registered for backend '${this.backendName}'`);
      }
      return this.runKernelFunc({ kernelName, inputs, attrs });
    }
    shouldCheckForMemLeaks() {
      return this.ENV.getBool("IS_TEST");
    }
    checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {
      const numDataIdsAfter = this.backend.numDataIds();
      let numOutputDataIds = 0;
      outInfos.forEach((info) => {
        numOutputDataIds += info.dtype === "complex64" ? 3 : 1;
      });
      const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
      const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;
      if (dataIdsLeaked > 0) {
        throw new Error(`Backend '${this.backendName}' has an internal memory leak (${dataIdsLeaked} data ids) after running '${kernelName}'`);
      }
    }
    /**
     * Internal helper method to execute a kernel Func
     *
     * Use `runKernel` to execute kernels from outside of engine.
     */
    runKernelFunc(kernelParams) {
      let outputs;
      let saved = [];
      const isTapeOn = this.isTapeOn();
      const startingBytecount = this.state.numBytes;
      const startingNumTensors = this.state.numTensors;
      if (this.shouldCheckForMemLeaks()) {
        this.state.numDataMovesStack.push(0);
      }
      let kernelFunc;
      if (this.backendName == null) {
        this.backend;
      }
      let out;
      const kernelOrScopeName = isRegisteredKernelInvocation(kernelParams) ? kernelParams.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
      if (isRegisteredKernelInvocation(kernelParams)) {
        const { kernelName, inputs: inputs2, attrs: attrs2 } = kernelParams;
        if (this.backendName == null) {
          this.backend;
        }
        const kernel = getKernel(kernelName, this.backendName);
        assert(kernel != null, () => `Cannot find registered kernel '${kernelName}' for backend '${this.backendName}'`);
        kernelFunc = () => {
          const numDataIdsBefore = this.backend.numDataIds();
          out = kernel.kernelFunc({ inputs: inputs2, attrs: attrs2, backend: this.backend });
          const outInfos = Array.isArray(out) ? out : [out];
          if (this.shouldCheckForMemLeaks()) {
            this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);
          }
          const outTensors = outInfos.map((outInfo) => {
            if (outInfo.rank != null) {
              return outInfo;
            }
            return this.makeTensorFromTensorInfo(outInfo);
          });
          if (isTapeOn) {
            const tensorsToSave = this.getTensorsForGradient(kernelName, inputs2, outTensors);
            saved = this.saveTensorsForBackwardMode(tensorsToSave);
          }
          return outTensors;
        };
      } else {
        const { forwardFunc } = kernelParams;
        const saveFunc = (tensors) => {
          if (!isTapeOn) {
            return;
          }
          saved = tensors.map((tensor2) => this.keep(this.clone(tensor2)));
        };
        kernelFunc = () => {
          const numDataIdsBefore = this.backend.numDataIds();
          out = this.tidy(() => forwardFunc(this.backend, saveFunc));
          const outs = Array.isArray(out) ? out : [out];
          if (this.shouldCheckForMemLeaks()) {
            this.checkKernelForMemLeak(kernelOrScopeName, numDataIdsBefore, outs);
          }
          return outs;
        };
      }
      const { inputs, attrs } = kernelParams;
      const backwardsFunc = isRegisteredKernelInvocation(kernelParams) ? null : kernelParams.backwardsFunc;
      let kernelProfile;
      this.scopedRun(
        // Stop recording to a tape when running a kernel.
        () => this.state.kernelDepth++,
        () => this.state.kernelDepth--,
        () => {
          if (!this.ENV.getBool("DEBUG") && !this.state.profiling) {
            outputs = kernelFunc();
          } else {
            kernelProfile = this.profiler.profileKernel(kernelOrScopeName, inputs, () => kernelFunc());
            if (this.ENV.getBool("DEBUG")) {
              this.profiler.logKernelProfile(kernelProfile);
            }
            outputs = kernelProfile.outputs;
          }
        }
      );
      if (isTapeOn) {
        this.addTapeNode(kernelOrScopeName, inputs, outputs, backwardsFunc, saved, attrs);
      }
      if (this.state.profiling) {
        this.state.activeProfile.kernels.push({
          name: kernelOrScopeName,
          bytesAdded: this.state.numBytes - startingBytecount,
          totalBytesSnapshot: this.state.numBytes,
          tensorsAdded: this.state.numTensors - startingNumTensors,
          totalTensorsSnapshot: this.state.numTensors,
          inputShapes: Object.keys(inputs).map((key) => inputs[key] != null ? inputs[key].shape : null),
          outputShapes: outputs.map((item) => item.shape),
          kernelTimeMs: kernelProfile.timeMs,
          extraInfo: kernelProfile.extraInfo
        });
      }
      return Array.isArray(out) ? outputs : outputs[0];
    }
    /**
     * Saves tensors used in forward mode for use in backward mode.
     *
     * @param tensors the list of tensors to save.
     */
    saveTensorsForBackwardMode(tensors) {
      const saved = tensors.map((tensor2) => this.keep(this.clone(tensor2)));
      return saved;
    }
    /**
     * Returns a list of tensors to save for a given gradient calculation.
     *
     * @param kernelName name of kernel to look up gradient for.
     * @param inputs a map of input tensors.
     * @param outputs an array of output tensors from forward mode of kernel.
     */
    getTensorsForGradient(kernelName, inputs, outputs) {
      const gradConfig = getGradient(kernelName);
      if (gradConfig != null) {
        const inputsToSave = gradConfig.inputsToSave || [];
        const outputsToSave = gradConfig.outputsToSave || [];
        let inputTensorsToSave;
        if (gradConfig.saveAllInputs) {
          assert(Array.isArray(inputs), () => "saveAllInputs is true, expected inputs to be an array.");
          inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);
        } else {
          inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);
        }
        const outputTensorsToSave = outputs.filter((_, i) => outputsToSave[i]);
        return inputTensorsToSave.concat(outputTensorsToSave);
      }
      return [];
    }
    /**
     * Internal method used by public APIs for tensor creation. Makes a new
     * tensor with the provided shape, dtype and values. It always
     * creates a new data id and writes the values to the underlying backend.
     */
    makeTensor(values, shape, dtype, backend2) {
      if (values == null) {
        throw new Error("Values passed to engine.makeTensor() are null");
      }
      dtype = dtype || "float32";
      backend2 = backend2 || this.backend;
      let backendVals = values;
      if (dtype === "string" && isString(values[0])) {
        backendVals = values.map((d) => encodeString(d));
      }
      const dataId = backend2.write(backendVals, shape, dtype);
      const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
      this.trackTensor(t, backend2);
      if (dtype === "string") {
        const info = this.state.tensorInfo.get(dataId);
        const newBytes = bytesFromStringArray(backendVals);
        this.state.numBytes += newBytes - info.bytes;
        info.bytes = newBytes;
      }
      return t;
    }
    /**
     * Internal method used by backends. Makes a new tensor
     * that is a wrapper around an existing data id. It doesn't create
     * a new data id, only increments the ref count used in memory tracking.
     * @deprecated
     */
    makeTensorFromDataId(dataId, shape, dtype, backend2) {
      dtype = dtype || "float32";
      const tensorInfo = { dataId, shape, dtype };
      return this.makeTensorFromTensorInfo(tensorInfo, backend2);
    }
    /**
     * Internal method used by backends. Makes a new tensor that is a wrapper
     * around an existing data id in TensorInfo. It doesn't create a new data id,
     * only increments the ref count used in memory tracking.
     */
    makeTensorFromTensorInfo(tensorInfo, backend2) {
      const { dataId, shape, dtype } = tensorInfo;
      const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
      this.trackTensor(t, backend2);
      return t;
    }
    makeVariable(initialValue, trainable = true, name, dtype) {
      name = name || this.nextVariableId().toString();
      if (dtype != null && dtype !== initialValue.dtype) {
        initialValue = initialValue.cast(dtype);
      }
      const v = new Variable(initialValue, trainable, name, this.nextTensorId());
      if (this.state.registeredVariables[v.name] != null) {
        throw new Error(`Variable with name ${v.name} was already registered`);
      }
      this.state.registeredVariables[v.name] = v;
      this.incRef(v, this.backend);
      return v;
    }
    trackTensor(a, backend2) {
      this.state.numTensors++;
      if (a.dtype === "string") {
        this.state.numStringTensors++;
      }
      let bytes = 0;
      if (a.dtype !== "complex64" && a.dtype !== "string") {
        bytes = a.size * bytesPerElement(a.dtype);
      }
      this.state.numBytes += bytes;
      if (!this.state.tensorInfo.has(a.dataId)) {
        this.state.numDataBuffers++;
        this.state.tensorInfo.set(a.dataId, {
          backend: backend2 || this.backend,
          dtype: a.dtype,
          shape: a.shape,
          bytes
        });
      }
      if (!(a instanceof Variable)) {
        this.track(a);
      }
    }
    // Track the tensor by dataId and increase the refCount for the dataId in the
    // backend.
    // TODO(pyu10055): This is currently used by makeVariable method, to increase
    // refCount on the backend for the dataId. It can potentially be replaced with
    // Identity op indead of calling backend directly.
    incRef(a, backend2) {
      this.trackTensor(a, backend2);
      this.backend.incRef(a.dataId);
    }
    removeDataId(dataId, backend2) {
      if (this.state.tensorInfo.has(dataId) && this.state.tensorInfo.get(dataId).backend === backend2) {
        this.state.tensorInfo.delete(dataId);
        this.state.numDataBuffers--;
      }
    }
    disposeTensor(a) {
      if (!this.state.tensorInfo.has(a.dataId)) {
        return;
      }
      const info = this.state.tensorInfo.get(a.dataId);
      this.state.numTensors--;
      if (a.dtype === "string") {
        this.state.numStringTensors--;
        this.state.numBytes -= info.bytes;
      }
      if (a.dtype !== "complex64" && a.dtype !== "string") {
        const bytes = a.size * bytesPerElement(a.dtype);
        this.state.numBytes -= bytes;
      }
      if (info.backend.disposeData(a.dataId)) {
        this.removeDataId(a.dataId, info.backend);
      }
    }
    disposeVariables() {
      for (const varName in this.state.registeredVariables) {
        const v = this.state.registeredVariables[varName];
        this.disposeVariable(v);
      }
    }
    disposeVariable(v) {
      this.disposeTensor(v);
      if (this.state.registeredVariables[v.name] != null) {
        delete this.state.registeredVariables[v.name];
      }
    }
    memory() {
      const info = this.backend.memory();
      info.numTensors = this.state.numTensors;
      info.numDataBuffers = this.state.numDataBuffers;
      info.numBytes = this.state.numBytes;
      if (this.state.numStringTensors > 0) {
        info.unreliable = true;
        if (info.reasons == null) {
          info.reasons = [];
        }
        info.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)");
      }
      return info;
    }
    async profile(query) {
      this.state.profiling = true;
      const startBytes = this.state.numBytes;
      const startNumTensors = this.state.numTensors;
      this.state.activeProfile.kernels = [];
      this.state.activeProfile.result = await query();
      this.state.profiling = false;
      this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((d) => d.totalBytesSnapshot));
      this.state.activeProfile.newBytes = this.state.numBytes - startBytes;
      this.state.activeProfile.newTensors = this.state.numTensors - startNumTensors;
      for (const kernel of this.state.activeProfile.kernels) {
        kernel.kernelTimeMs = await kernel.kernelTimeMs;
        kernel.extraInfo = await kernel.extraInfo;
      }
      return this.state.activeProfile;
    }
    isTapeOn() {
      return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
    }
    addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {
      const tapeNode = { id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved };
      const gradConfig = getGradient(kernelName);
      if (gradConfig != null) {
        gradientsFunc = gradConfig.gradFunc;
      }
      if (gradientsFunc != null) {
        tapeNode.gradient = (dys) => {
          dys = dys.map((dy, i) => {
            if (dy == null) {
              const output = outputs[i];
              const vals = makeZerosTypedArray(output.size, output.dtype);
              return this.makeTensor(vals, output.shape, output.dtype);
            }
            return dy;
          });
          return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);
        };
      }
      this.state.activeTape.push(tapeNode);
    }
    keep(result) {
      result.kept = true;
      return result;
    }
    startTape() {
      if (this.state.gradientDepth === 0) {
        this.state.activeTape = [];
      }
      this.state.gradientDepth++;
    }
    endTape() {
      this.state.gradientDepth--;
    }
    /**
     * Start a scope. Use this with endScope() to achieve the same functionality
     * as scope() without the need for a function closure.
     */
    startScope(name) {
      const scopeInfo = {
        track: [],
        name: "unnamed scope",
        id: this.state.nextScopeId++
      };
      if (name) {
        scopeInfo.name = name;
      }
      this.state.scopeStack.push(scopeInfo);
      this.state.activeScope = scopeInfo;
    }
    /**
     * End a scope. Use this with startScope() to achieve the same functionality
     * as scope() without the need for a function closure.
     */
    endScope(result) {
      const tensorsToTrackInParent = getTensorsInContainer(result);
      const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map((t) => t.id));
      for (let i = 0; i < this.state.activeScope.track.length; i++) {
        const tensor2 = this.state.activeScope.track[i];
        if (!tensor2.kept && !tensorsToTrackInParentSet.has(tensor2.id)) {
          tensor2.dispose();
        }
      }
      const oldScope = this.state.scopeStack.pop();
      this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1];
      tensorsToTrackInParent.forEach((tensor2) => {
        if (!tensor2.kept && tensor2.scopeId === oldScope.id) {
          this.track(tensor2);
        }
      });
    }
    /**
     * Returns gradients of `f` with respect to each of the `xs`. The gradients
     * returned are of the same length as `xs`, but some might be null if `f`
     * was not a function of that `x`. It also takes optional dy to multiply the
     * gradient, which defaults to `1`.
     */
    gradients(f, xs, dy, allowNoGradients = false) {
      assert(xs.length > 0, () => "gradients() received an empty list of xs.");
      if (dy != null && dy.dtype !== "float32") {
        throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);
      }
      const y = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", f));
      assert(y instanceof Tensor, () => "The result y returned by f() must be a tensor.");
      const filteredTape = getFilteredNodesXToY(this.state.activeTape, xs, y);
      if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
        throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
      }
      return this.tidy("backward", () => {
        const accumulatedGradientMap = {};
        accumulatedGradientMap[y.id] = dy == null ? ones$1(y.shape) : dy;
        backpropagateGradients(
          accumulatedGradientMap,
          filteredTape,
          // Pass the tidy function to avoid circular dep with `tape.ts`.
          (f2) => this.tidy(f2),
          // Pass an add function to avoide a circular dep with `tape.ts`.
          add$1
        );
        const grads2 = xs.map((x) => accumulatedGradientMap[x.id]);
        if (this.state.gradientDepth === 0) {
          this.state.activeTape.forEach((node) => {
            for (const tensor2 of node.saved) {
              tensor2.dispose();
            }
          });
          this.state.activeTape = null;
        }
        return { value: y, grads: grads2 };
      });
    }
    customGrad(f) {
      assert(isFunction(f), () => "The f passed in customGrad(f) must be a function.");
      return (...inputs) => {
        assert(inputs.every((t) => t instanceof Tensor), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
        let res;
        const inputMap = {};
        inputs.forEach((input, i) => {
          inputMap[i] = input;
        });
        const forwardFunc = (_, save) => {
          res = f(...[...inputs, save]);
          assert(res.value instanceof Tensor, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor");
          assert(isFunction(res.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.");
          return res.value;
        };
        const backwardsFunc = (dy, saved) => {
          const gradRes = res.gradFunc(dy, saved);
          const grads2 = Array.isArray(gradRes) ? gradRes : [gradRes];
          assert(grads2.length === inputs.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).");
          assert(grads2.every((t) => t instanceof Tensor), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
          const gradMap = {};
          grads2.forEach((grad2, i) => {
            gradMap[i] = () => grad2;
          });
          return gradMap;
        };
        return this.runKernelFunc({
          forwardFunc,
          backwardsFunc,
          inputs: inputMap
        });
      };
    }
    readSync(dataId) {
      const info = this.state.tensorInfo.get(dataId);
      return info.backend.readSync(dataId);
    }
    read(dataId) {
      const info = this.state.tensorInfo.get(dataId);
      return info.backend.read(dataId);
    }
    readToGPU(dataId, options) {
      const info = this.state.tensorInfo.get(dataId);
      return info.backend.readToGPU(dataId, options);
    }
    async time(query) {
      const start = now();
      const timingInfo = await this.backend.time(query);
      timingInfo.wallMs = now() - start;
      return timingInfo;
    }
    /**
     * Tracks a Tensor in the current scope to be automatically cleaned up
     * when the current scope ends, and returns the value.
     *
     * @param result The Tensor to track in the current scope.
     */
    track(result) {
      if (this.state.activeScope != null) {
        result.scopeId = this.state.activeScope.id;
        this.state.activeScope.track.push(result);
      }
      return result;
    }
    get registeredVariables() {
      return this.state.registeredVariables;
    }
    /**
     * Resets the engine state. Removes all backends but does not remove
     * registered backend factories.
     */
    reset() {
      this.pendingBackendInitId++;
      this.state.dispose();
      this.ENV.reset();
      this.state = new EngineState();
      for (const backendName in this.registry) {
        this.disposeRegisteredKernels(backendName);
        this.registry[backendName].dispose();
        delete this.registry[backendName];
      }
      this.backendName = null;
      this.backendInstance = null;
      this.pendingBackendInit = null;
    }
  }
  Engine.nextTensorId = 0;
  Engine.nextVariableId = 0;
  function ones$1(shape) {
    const values = makeOnesTypedArray(sizeFromShape(shape), "float32");
    return ENGINE.makeTensor(values, shape, "float32");
  }
  function getOrMakeEngine() {
    const ns = getGlobalNamespace();
    if (ns._tfengine == null) {
      const environment = new Environment(ns);
      ns._tfengine = new Engine(environment);
    }
    setEnvironmentGlobal(ns._tfengine.ENV);
    setTensorTracker(() => ns._tfengine);
    return ns._tfengine;
  }
  const ENGINE = getOrMakeEngine();
  function add$1(a, b) {
    const inputs = { a, b };
    return ENGINE.runKernel(Add, inputs);
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function _isNavigatorDefined() {
    return typeof navigator !== "undefined" && navigator != null;
  }
  let isMobileMockValue;
  function mockIsMobile(value) {
    isMobileMockValue = value;
  }
  function isMobile(nav) {
    if (isMobileMockValue !== void 0) {
      return isMobileMockValue;
    }
    if (nav || _isNavigatorDefined()) {
      if (!nav) {
        nav = navigator;
      }
      if (nav.product === "ReactNative") {
        return true;
      }
      const a = nav.userAgent || nav.vendor || // tslint:disable-next-line:no-any
      (typeof window !== "undefined" ? window.opera : "");
      if (!a) {
        const navAny = nav;
        return navAny.userAgentData && navAny.userAgentData.mobile;
      }
      return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || // tslint:disable-next-line:max-line-length
      /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
    }
    return false;
  }
  function isBrowser() {
    return typeof window !== "undefined" && window.document != null || //@ts-ignore
    typeof WorkerGlobalScope !== "undefined";
  }
  const device_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    isBrowser,
    isMobile,
    mockIsMobile
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ENV$2 = env();
  ENV$2.registerFlag("DEBUG", () => false, (debugValue) => {
    if (debugValue) {
      console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
    }
  });
  ENV$2.registerFlag("IS_BROWSER", () => isBrowser());
  ENV$2.registerFlag("IS_NODE", () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined");
  ENV$2.registerFlag("IS_CHROME", () => typeof navigator !== "undefined" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
  ENV$2.registerFlag("IS_SAFARI", () => typeof navigator !== "undefined" && navigator != null && navigator.userAgent != null && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor));
  ENV$2.registerFlag("PROD", () => false);
  ENV$2.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => ENV$2.getBool("DEBUG"));
  ENV$2.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
  ENV$2.registerFlag("IS_TEST", () => false);
  ENV$2.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => ENV$2.getBool("DEBUG"));
  ENV$2.registerFlag("WRAP_TO_IMAGEBITMAP", () => false);
  ENV$2.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => false);
  ENV$2.registerFlag("USE_SETTIMEOUTCUSTOM", () => false);
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function inferShape(val, dtype) {
    let firstElem = val;
    if (isTypedArray(val)) {
      return dtype === "string" ? [] : [val.length];
    }
    if (isWebGLData(val)) {
      const usedChannels = val.channels || "RGBA";
      return [val.height, val.width * usedChannels.length];
    } else if (isWebGPUData(val)) {
      return [val.buffer.size / (dtype == null ? 4 : bytesPerElement(dtype))];
    }
    if (!Array.isArray(val)) {
      return [];
    }
    const shape = [];
    while (Array.isArray(firstElem) || isTypedArray(firstElem) && dtype !== "string") {
      shape.push(firstElem.length);
      firstElem = firstElem[0];
    }
    if (Array.isArray(val) && env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")) {
      deepAssertShapeConsistency(val, shape, []);
    }
    return shape;
  }
  function deepAssertShapeConsistency(val, shape, indices) {
    indices = indices || [];
    if (!Array.isArray(val) && !isTypedArray(val)) {
      assert(shape.length === 0, () => `Element arr[${indices.join("][")}] is a primitive, but should be an array/TypedArray of ${shape[0]} elements`);
      return;
    }
    assert(shape.length > 0, () => `Element arr[${indices.join("][")}] should be a primitive, but is an array of ${val.length} elements`);
    assert(val.length === shape[0], () => `Element arr[${indices.join("][")}] should have ${shape[0]} elements, but has ${val.length} elements`);
    const subShape = shape.slice(1);
    for (let i = 0; i < val.length; ++i) {
      deepAssertShapeConsistency(val[i], subShape, indices.concat(i));
    }
  }
  function assertDtype(expectedDtype, actualDType, argName, functionName) {
    if (expectedDtype === "string_or_numeric") {
      return;
    }
    if (expectedDtype == null) {
      throw new Error(`Expected dtype cannot be null.`);
    }
    if (expectedDtype !== "numeric" && expectedDtype !== actualDType || expectedDtype === "numeric" && actualDType === "string") {
      throw new Error(`Argument '${argName}' passed to '${functionName}' must be ${expectedDtype} tensor, but got ${actualDType} tensor`);
    }
  }
  function convertToTensor(x, argName, functionName, parseAsDtype = "numeric") {
    if (x instanceof getGlobalTensorClass()) {
      assertDtype(parseAsDtype, x.dtype, argName, functionName);
      return x;
    }
    let inferredDtype = inferDtype(x);
    if (inferredDtype !== "string" && ["bool", "int32", "float32"].indexOf(parseAsDtype) >= 0) {
      inferredDtype = parseAsDtype;
    }
    assertDtype(parseAsDtype, inferredDtype, argName, functionName);
    if (x == null || !isTypedArray(x) && !Array.isArray(x) && typeof x !== "number" && typeof x !== "boolean" && typeof x !== "string") {
      const type = x == null ? "null" : x.constructor.name;
      throw new Error(`Argument '${argName}' passed to '${functionName}' must be a Tensor or TensorLike, but got '${type}'`);
    }
    const inferredShape = inferShape(x, inferredDtype);
    if (!isTypedArray(x) && !Array.isArray(x)) {
      x = [x];
    }
    const skipTypedArray = true;
    const values = inferredDtype !== "string" ? toTypedArray(x, inferredDtype) : flatten(x, [], skipTypedArray);
    return ENGINE.makeTensor(values, inferredShape, inferredDtype);
  }
  function convertToTensorArray(arg, argName, functionName, parseAsDtype = "numeric") {
    if (!Array.isArray(arg)) {
      throw new Error(`Argument ${argName} passed to ${functionName} must be a \`Tensor[]\` or \`TensorLike[]\``);
    }
    const tensors = arg;
    return tensors.map((t, i) => convertToTensor(t, `${argName}[${i}]`, functionName, parseAsDtype));
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const OP_SCOPE_SUFFIX = "__op";
  function op(f) {
    const keys = Object.keys(f);
    if (keys.length !== 1) {
      throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${keys.length} keys.`);
    }
    let opName = keys[0];
    const fn = f[opName];
    if (opName.endsWith("_")) {
      opName = opName.substring(0, opName.length - 1);
    }
    opName = opName + OP_SCOPE_SUFFIX;
    const f2 = (...args) => {
      ENGINE.startScope(opName);
      try {
        const result = fn(...args);
        if (isPromise(result)) {
          console.error("Cannot return a Promise inside of tidy.");
        }
        ENGINE.endScope(result);
        return result;
      } catch (ex) {
        ENGINE.endScope(null);
        throw ex;
      }
    };
    Object.defineProperty(f2, "name", { value: opName, configurable: true });
    return f2;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function complex_(real2, imag2) {
    const $real = convertToTensor(real2, "real", "complex");
    const $imag = convertToTensor(imag2, "imag", "complex");
    assertShapesMatch($real.shape, $imag.shape, `real and imag shapes, ${$real.shape} and ${$imag.shape}, must match in call to tf.complex().`);
    const inputs = { real: $real, imag: $imag };
    return ENGINE.runKernel(Complex, inputs);
  }
  const complex$1 = /* @__PURE__ */ op({ complex_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function makeTensor(values, shape, inferredShape, dtype) {
    if (dtype == null) {
      dtype = inferDtype(values);
    } else if (dtype === "complex64") {
      throw new Error(`Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).`);
    }
    if (isWebGPUData(values) || isWebGLData(values)) {
      if (dtype !== "float32" && dtype !== "int32") {
        throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${dtype}.`);
      }
      return ENGINE.backend.createTensorFromGPUData(values, shape || inferredShape, dtype);
    }
    if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== "number" && typeof values !== "boolean" && typeof values !== "string") {
      throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    }
    if (shape != null) {
      assertNonNegativeIntegerDimensions(shape);
      const providedSize = sizeFromShape(shape);
      const inferredSize = sizeFromShape(inferredShape);
      assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ${providedSize} values but has ${inferredSize}`);
      for (let i = 0; i < inferredShape.length; ++i) {
        const inferred = inferredShape[i];
        const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;
        assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape (${inferredShape}) does not match the provided shape (${shape}). `);
      }
    }
    if (!isTypedArray(values) && !Array.isArray(values)) {
      values = [values];
    }
    shape = shape || inferredShape;
    values = dtype !== "string" ? toTypedArray(values, dtype) : flatten(values, [], true);
    return ENGINE.makeTensor(values, shape, dtype);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tensor(values, shape, dtype) {
    const inferredShape = inferShape(values, dtype);
    return makeTensor(values, shape, inferredShape, dtype);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const DTYPE_VALUE_SIZE_MAP = {
    "float32": 4,
    "float16": 2,
    "int32": 4,
    "uint16": 2,
    "uint8": 1,
    "bool": 1,
    "complex64": 8
  };
  class CompositeArrayBuffer {
    /**
     * Concatenate a number of ArrayBuffers into one.
     *
     * @param buffers An array of ArrayBuffers to concatenate, or a single
     *     ArrayBuffer.
     * @returns Result of concatenating `buffers` in order.
     */
    static join(buffers) {
      return new CompositeArrayBuffer(buffers).slice();
    }
    constructor(buffers) {
      this.shards = [];
      this.previousShardIndex = 0;
      if (buffers == null) {
        return;
      }
      if (!(buffers instanceof Array)) {
        buffers = [buffers];
      }
      buffers = buffers.map((bufferOrTypedArray) => {
        if (isTypedArray(bufferOrTypedArray)) {
          return bufferOrTypedArray.buffer;
        }
        return bufferOrTypedArray;
      });
      if (buffers.length === 0) {
        return;
      }
      this.bufferUniformSize = buffers[0].byteLength;
      let start = 0;
      for (let i = 0; i < buffers.length; i++) {
        const buffer2 = buffers[i];
        if (i !== buffers.length - 1 && buffer2.byteLength !== this.bufferUniformSize) {
          this.bufferUniformSize = void 0;
        }
        const end = start + buffer2.byteLength;
        this.shards.push({ buffer: buffer2, start, end });
        start = end;
      }
      if (this.shards.length === 0) {
        this.byteLength = 0;
      }
      this.byteLength = this.shards[this.shards.length - 1].end;
    }
    slice(start = 0, end = this.byteLength) {
      if (this.shards.length === 0) {
        return new ArrayBuffer(0);
      }
      start = isNaN(Number(start)) ? 0 : start;
      end = isNaN(Number(end)) ? 0 : end;
      start = Math.max(0, start);
      end = Math.min(this.byteLength, end);
      if (end <= start) {
        return new ArrayBuffer(0);
      }
      const startShardIndex = this.findShardForByte(start);
      if (startShardIndex === -1) {
        throw new Error(`Could not find start shard for byte ${start}`);
      }
      const size = end - start;
      const outputBuffer = new ArrayBuffer(size);
      const outputArray = new Uint8Array(outputBuffer);
      let sliced = 0;
      for (let i = startShardIndex; i < this.shards.length; i++) {
        const shard = this.shards[i];
        const globalStart = start + sliced;
        const localStart = globalStart - shard.start;
        const outputStart = sliced;
        const globalEnd = Math.min(end, shard.end);
        const localEnd = globalEnd - shard.start;
        const outputSlice = new Uint8Array(shard.buffer, localStart, localEnd - localStart);
        outputArray.set(outputSlice, outputStart);
        sliced += outputSlice.length;
        if (end < shard.end) {
          break;
        }
      }
      return outputBuffer;
    }
    /**
     * Get the index of the shard that contains the byte at `byteIndex`.
     */
    findShardForByte(byteIndex) {
      if (this.shards.length === 0 || byteIndex < 0 || byteIndex >= this.byteLength) {
        return -1;
      }
      if (this.bufferUniformSize != null) {
        this.previousShardIndex = Math.floor(byteIndex / this.bufferUniformSize);
        return this.previousShardIndex;
      }
      function check(shard) {
        if (byteIndex < shard.start) {
          return -1;
        }
        if (byteIndex >= shard.end) {
          return 1;
        }
        return 0;
      }
      if (check(this.shards[this.previousShardIndex]) === 0) {
        return this.previousShardIndex;
      }
      const index2 = search(this.shards, check);
      if (index2 === -1) {
        return -1;
      }
      this.previousShardIndex = index2;
      return this.previousShardIndex;
    }
  }
  function search(sortedArray, compare) {
    let min2 = 0;
    let max2 = sortedArray.length;
    while (min2 <= max2) {
      const middle = Math.floor((max2 - min2) / 2) + min2;
      const side = compare(sortedArray[middle]);
      if (side === 0) {
        return middle;
      } else if (side < 0) {
        max2 = middle;
      } else {
        min2 = middle + 1;
      }
    }
    return -1;
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function enableProdMode() {
    env().set("PROD", true);
  }
  function enableDebugMode() {
    env().set("DEBUG", true);
  }
  function disableDeprecationWarnings() {
    env().set("DEPRECATION_WARNINGS_ENABLED", false);
    console.warn(`TensorFlow.js deprecation warnings have been disabled.`);
  }
  function deprecationWarn(msg) {
    if (env().getBool("DEPRECATION_WARNINGS_ENABLED")) {
      console.warn(msg + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
    }
  }
  function disposeVariables() {
    ENGINE.disposeVariables();
  }
  function engine() {
    return ENGINE;
  }
  function memory() {
    return ENGINE.memory();
  }
  function profile(f) {
    return ENGINE.profile(f);
  }
  function tidy(nameOrFn, fn) {
    return ENGINE.tidy(nameOrFn, fn);
  }
  function dispose(container) {
    const tensors = getTensorsInContainer(container);
    tensors.forEach((tensor2) => tensor2.dispose());
  }
  function keep(result) {
    return ENGINE.keep(result);
  }
  function time(f) {
    return ENGINE.time(f);
  }
  function setBackend(backendName) {
    return ENGINE.setBackend(backendName);
  }
  function ready() {
    return ENGINE.ready();
  }
  function getBackend() {
    return ENGINE.backendName;
  }
  function removeBackend(name) {
    ENGINE.removeBackend(name);
  }
  function findBackend(name) {
    return ENGINE.findBackend(name);
  }
  function findBackendFactory(name) {
    return ENGINE.findBackendFactory(name);
  }
  function registerBackend(name, factory, priority = 1) {
    return ENGINE.registerBackend(name, factory, priority);
  }
  function backend() {
    return ENGINE.backend;
  }
  function setPlatform(platformName, platform) {
    env().setPlatform(platformName, platform);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const NUM_BYTES_STRING_LENGTH = 4;
  async function encodeWeights(tensors, group) {
    const specs = [];
    const dataPromises = [];
    const names = Array.isArray(tensors) ? tensors.map((tensor2) => tensor2.name) : Object.keys(tensors);
    for (let i = 0; i < names.length; ++i) {
      const name = names[i];
      const t = Array.isArray(tensors) ? tensors[i].tensor : tensors[name];
      if (t.dtype !== "float32" && t.dtype !== "int32" && t.dtype !== "bool" && t.dtype !== "string" && t.dtype !== "complex64") {
        throw new Error(`Unsupported dtype in weight '${name}': ${t.dtype}`);
      }
      const spec = { name, shape: t.shape, dtype: t.dtype };
      if (t.dtype === "string") {
        const utf8bytes = new Promise(async (resolve) => {
          const vals = await t.bytes();
          const totalNumBytes = vals.reduce((p, c) => p + c.length, 0) + NUM_BYTES_STRING_LENGTH * vals.length;
          const bytes = new Uint8Array(totalNumBytes);
          let offset = 0;
          for (let i2 = 0; i2 < vals.length; i2++) {
            const val = vals[i2];
            const bytesOfLength = new Uint8Array(new Uint32Array([val.length]).buffer);
            bytes.set(bytesOfLength, offset);
            offset += NUM_BYTES_STRING_LENGTH;
            bytes.set(val, offset);
            offset += val.length;
          }
          resolve(bytes);
        });
        dataPromises.push(utf8bytes);
      } else {
        dataPromises.push(t.data());
      }
      if (group != null) {
        spec.group = group;
      }
      specs.push(spec);
    }
    const tensorValues = await Promise.all(dataPromises);
    return { data: concatenateTypedArrays(tensorValues), specs };
  }
  function decodeWeights(weightData, specs) {
    const compositeBuffer = new CompositeArrayBuffer(weightData);
    const out = {};
    let offset = 0;
    for (const spec of specs) {
      const byteLength = getWeightBytelength(spec, (start, end) => {
        return compositeBuffer.slice(offset + start, offset + end);
      });
      out[spec.name] = decodeWeight(spec, compositeBuffer.slice(offset, offset + byteLength));
      offset += byteLength;
    }
    return out;
  }
  function getWeightBytelength(spec, slice2) {
    const size = sizeFromShape(spec.shape);
    let bytesPerValue;
    if ("quantization" in spec) {
      const quantization = spec.quantization;
      bytesPerValue = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
    } else if (spec.dtype === "string") {
      let byteLength = 0;
      for (let i = 0; i < size; i++) {
        byteLength += NUM_BYTES_STRING_LENGTH + new Uint32Array(slice2(byteLength, byteLength + NUM_BYTES_STRING_LENGTH))[0];
      }
      return byteLength;
    } else {
      bytesPerValue = DTYPE_VALUE_SIZE_MAP[spec.dtype];
    }
    return size * bytesPerValue;
  }
  async function getWeightBytelengthAsync(spec, slice2) {
    const size = sizeFromShape(spec.shape);
    let bytesPerValue;
    if ("quantization" in spec) {
      const quantization = spec.quantization;
      bytesPerValue = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
    } else if (spec.dtype === "string") {
      let byteLength = 0;
      for (let i = 0; i < size; i++) {
        byteLength += NUM_BYTES_STRING_LENGTH + new Uint32Array(await slice2(byteLength, byteLength + NUM_BYTES_STRING_LENGTH))[0];
      }
      return byteLength;
    } else {
      bytesPerValue = DTYPE_VALUE_SIZE_MAP[spec.dtype];
    }
    return size * bytesPerValue;
  }
  function decodeWeight(spec, byteBuffer) {
    const name = spec.name;
    const dtype = spec.dtype;
    const shape = spec.shape;
    const size = sizeFromShape(shape);
    let values;
    let offset = 0;
    if ("quantization" in spec) {
      const quantization = spec.quantization;
      if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
        if (!("min" in quantization && "scale" in quantization)) {
          throw new Error(`Weight ${spec.name} with quantization ${quantization.dtype} doesn't have corresponding metadata min and scale.`);
        }
      } else if (quantization.dtype === "float16") {
        if (dtype !== "float32") {
          throw new Error(`Weight ${spec.name} is quantized with ${quantization.dtype} which only supports weights of type float32 not ${dtype}.`);
        }
      } else {
        throw new Error(`Weight ${spec.name} has unknown quantization dtype ${quantization.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
      }
      const quantizationSizeFactor = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
      const quantizedArray = quantization.dtype === "uint8" ? new Uint8Array(byteBuffer) : new Uint16Array(byteBuffer);
      if (dtype === "float32") {
        if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
          values = new Float32Array(quantizedArray.length);
          for (let i = 0; i < quantizedArray.length; i++) {
            const v = quantizedArray[i];
            values[i] = v * quantization.scale + quantization.min;
          }
        } else if (quantization.dtype === "float16") {
          const float16Decode = getFloat16Decoder();
          values = float16Decode(quantizedArray);
        } else {
          throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type float32.`);
        }
      } else if (dtype === "int32") {
        if (quantization.dtype !== "uint8" && quantization.dtype !== "uint16") {
          throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type int32.`);
        }
        values = new Int32Array(quantizedArray.length);
        for (let i = 0; i < quantizedArray.length; i++) {
          const v = quantizedArray[i];
          values[i] = Math.round(v * quantization.scale + quantization.min);
        }
      } else {
        throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
      }
      offset += size * quantizationSizeFactor;
    } else if (dtype === "string") {
      const size2 = sizeFromShape(spec.shape);
      values = [];
      for (let i = 0; i < size2; i++) {
        const byteLength = new Uint32Array(byteBuffer.slice(offset, offset + NUM_BYTES_STRING_LENGTH))[0];
        offset += NUM_BYTES_STRING_LENGTH;
        const bytes = new Uint8Array(byteBuffer.slice(offset, offset + byteLength));
        values.push(bytes);
        offset += byteLength;
      }
    } else {
      const dtypeFactor = DTYPE_VALUE_SIZE_MAP[dtype];
      if (dtype === "float32") {
        values = new Float32Array(byteBuffer);
      } else if (dtype === "int32") {
        values = new Int32Array(byteBuffer);
      } else if (dtype === "bool") {
        values = new Uint8Array(byteBuffer);
      } else if (dtype === "complex64") {
        values = new Float32Array(byteBuffer);
        const real2 = new Float32Array(values.length / 2);
        const image2 = new Float32Array(values.length / 2);
        for (let i = 0; i < real2.length; i++) {
          real2[i] = values[i * 2];
          image2[i] = values[i * 2 + 1];
        }
        const realTensor = tensor(real2, shape, "float32");
        const imageTensor = tensor(image2, shape, "float32");
        const complexTensor = complex$1(realTensor, imageTensor);
        realTensor.dispose();
        imageTensor.dispose();
        return complexTensor;
      } else {
        throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
      }
      offset += size * dtypeFactor;
    }
    return tensor(values, shape, dtype);
  }
  async function readToLength(reader, initialData, length) {
    let data = new Uint8Array(initialData);
    while (data.byteLength < length) {
      const { done, value } = await reader.read();
      if (done && value == null) {
        const missing = length - data.byteLength;
        throw new Error(`Reader is done but ${missing} bytes are still expected`);
      }
      const newData = new Uint8Array(data.length + value.byteLength);
      newData.set(data, 0);
      newData.set(new Uint8Array(value), data.length);
      data = newData;
    }
    return data.buffer;
  }
  async function decodeWeightsStream(weightStream, specs) {
    const tensors = {};
    const reader = weightStream.getReader();
    let data = new ArrayBuffer(0);
    for (const spec of specs) {
      const byteLength = await getWeightBytelengthAsync(spec, async (start, end) => {
        data = await readToLength(reader, data, end);
        return data.slice(start, end);
      });
      data = await readToLength(reader, data, byteLength);
      const tensorData = data.slice(0, byteLength);
      data = data.slice(byteLength);
      const weightTensor = decodeWeight(spec, tensorData);
      tensors[spec.name] = weightTensor;
      if (getBackend() === "webgpu") {
        const b = backend();
        if ("uploadToGPU" in b && sizeFromShape(weightTensor.shape) >= env().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")) {
          b.uploadToGPU(weightTensor.dataId);
        }
      }
    }
    return tensors;
  }
  function concatenateTypedArrays(xs) {
    if (xs === null) {
      throw new Error(`Invalid input value: ${JSON.stringify(xs)}`);
    }
    let totalByteLength = 0;
    const normalizedXs = [];
    xs.forEach((x) => {
      totalByteLength += x.byteLength;
      normalizedXs.push(x.byteLength === x.buffer.byteLength ? x : new x.constructor(x));
      if (!(x instanceof Float32Array || x instanceof Int32Array || x instanceof Uint8Array)) {
        throw new Error(`Unsupported TypedArray subtype: ${x.constructor.name}`);
      }
    });
    const y = new Uint8Array(totalByteLength);
    let offset = 0;
    normalizedXs.forEach((x) => {
      y.set(new Uint8Array(x.buffer), offset);
      offset += x.byteLength;
    });
    return y.buffer;
  }
  const useNodeBuffer = typeof Buffer !== "undefined" && (typeof Blob === "undefined" || typeof atob === "undefined" || typeof btoa === "undefined");
  function stringByteLength(str) {
    if (useNodeBuffer) {
      return Buffer.byteLength(str, "utf8");
    }
    return new Blob([str]).size;
  }
  function arrayBufferToBase64String(buffer2) {
    if (useNodeBuffer) {
      return Buffer.from(buffer2).toString("base64");
    }
    const buf = new Uint8Array(buffer2);
    let s = "";
    for (let i = 0, l = buf.length; i < l; i++) {
      s += String.fromCharCode(buf[i]);
    }
    return btoa(s);
  }
  function base64StringToArrayBuffer(str) {
    if (useNodeBuffer) {
      const buf = Buffer.from(str, "base64");
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    const s = atob(str);
    const buffer2 = new Uint8Array(s.length);
    for (let i = 0; i < s.length; ++i) {
      buffer2.set([s.charCodeAt(i)], i);
    }
    return buffer2.buffer;
  }
  function concatenateArrayBuffers(buffers) {
    return CompositeArrayBuffer.join(buffers);
  }
  function basename(path) {
    const SEPARATOR = "/";
    path = path.trim();
    while (path.endsWith(SEPARATOR)) {
      path = path.slice(0, path.length - 1);
    }
    const items = path.split(SEPARATOR);
    return items[items.length - 1];
  }
  function getModelJSONForModelArtifacts(artifacts, manifest) {
    const result = {
      modelTopology: artifacts.modelTopology,
      format: artifacts.format,
      generatedBy: artifacts.generatedBy,
      convertedBy: artifacts.convertedBy,
      weightsManifest: manifest
    };
    if (artifacts.signature != null) {
      result.signature = artifacts.signature;
    }
    if (artifacts.userDefinedMetadata != null) {
      result.userDefinedMetadata = artifacts.userDefinedMetadata;
    }
    if (artifacts.modelInitializer != null) {
      result.modelInitializer = artifacts.modelInitializer;
    }
    if (artifacts.initializerSignature != null) {
      result.initializerSignature = artifacts.initializerSignature;
    }
    if (artifacts.trainingConfig != null) {
      result.trainingConfig = artifacts.trainingConfig;
    }
    return result;
  }
  function getModelArtifactsForJSONSync(modelJSON, weightSpecs, weightData) {
    const modelArtifacts = {
      modelTopology: modelJSON.modelTopology,
      format: modelJSON.format,
      generatedBy: modelJSON.generatedBy,
      convertedBy: modelJSON.convertedBy
    };
    if (modelJSON.trainingConfig != null) {
      modelArtifacts.trainingConfig = modelJSON.trainingConfig;
    }
    if (modelJSON.weightsManifest != null) {
      if (!weightSpecs) {
        throw new Error("modelJSON has weightsManifest but weightSpecs is null");
      }
      if (!weightData) {
        throw new Error("modelJSON has weightsManifest but weightData is null");
      }
      modelArtifacts.weightSpecs = weightSpecs;
      modelArtifacts.weightData = weightData;
    }
    if (modelJSON.signature != null) {
      modelArtifacts.signature = modelJSON.signature;
    }
    if (modelJSON.userDefinedMetadata != null) {
      modelArtifacts.userDefinedMetadata = modelJSON.userDefinedMetadata;
    }
    if (modelJSON.modelInitializer != null) {
      modelArtifacts.modelInitializer = modelJSON.modelInitializer;
    }
    if (modelJSON.initializerSignature != null) {
      modelArtifacts.initializerSignature = modelJSON.initializerSignature;
    }
    return modelArtifacts;
  }
  async function getModelArtifactsForJSON(modelJSON, loadWeights2) {
    let weightSpecs;
    let weightData;
    if (modelJSON.weightsManifest != null) {
      [weightSpecs, weightData] = await loadWeights2(modelJSON.weightsManifest);
    }
    return getModelArtifactsForJSONSync(modelJSON, weightSpecs, weightData);
  }
  function getModelArtifactsInfoForJSON(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("Expected JSON model topology, received ArrayBuffer.");
    }
    return {
      dateSaved: /* @__PURE__ */ new Date(),
      modelTopologyType: "JSON",
      modelTopologyBytes: modelArtifacts.modelTopology == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),
      weightSpecsBytes: modelArtifacts.weightSpecs == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),
      weightDataBytes: modelArtifacts.weightData == null ? 0 : new CompositeArrayBuffer(modelArtifacts.weightData).byteLength
    };
  }
  function getWeightSpecs(weightsManifest) {
    const weightSpecs = [];
    for (const entry of weightsManifest) {
      weightSpecs.push(...entry.weights);
    }
    return weightSpecs;
  }
  function computeFloat16MantisaTable() {
    const convertMantissa = (i) => {
      let m = i << 13;
      let e = 0;
      while ((m & 8388608) === 0) {
        e -= 8388608;
        m <<= 1;
      }
      m &= ~8388608;
      e += 947912704;
      return m | e;
    };
    const mantisaTable = new Uint32Array(2048);
    mantisaTable[0] = 0;
    for (let i = 1; i < 1024; i++) {
      mantisaTable[i] = convertMantissa(i);
    }
    for (let i = 1024; i < 2048; i++) {
      mantisaTable[i] = 939524096 + (i - 1024 << 13);
    }
    return mantisaTable;
  }
  function computeFloat16ExponentTable() {
    const exponentTable = new Uint32Array(64);
    exponentTable[0] = 0;
    exponentTable[31] = 1199570944;
    exponentTable[32] = 2147483648;
    exponentTable[63] = 3347054592;
    for (let i = 1; i < 31; i++) {
      exponentTable[i] = i << 23;
    }
    for (let i = 33; i < 63; i++) {
      exponentTable[i] = 2147483648 + (i - 32 << 23);
    }
    return exponentTable;
  }
  function computeFloat16OffsetTable() {
    const offsetTable = new Uint32Array(64);
    for (let i = 0; i < 64; i++) {
      offsetTable[i] = 1024;
    }
    offsetTable[0] = offsetTable[32] = 0;
    return offsetTable;
  }
  function getFloat16Decoder() {
    const mantisaTable = computeFloat16MantisaTable();
    const exponentTable = computeFloat16ExponentTable();
    const offsetTable = computeFloat16OffsetTable();
    return (quantizedArray) => {
      const buffer2 = new ArrayBuffer(4 * quantizedArray.length);
      const bufferUint32View = new Uint32Array(buffer2);
      for (let index2 = 0; index2 < quantizedArray.length; index2++) {
        const float16Bits = quantizedArray[index2];
        const float32Bits = mantisaTable[offsetTable[float16Bits >> 10] + (float16Bits & 1023)] + exponentTable[float16Bits >> 10];
        bufferUint32View[index2] = float32Bits;
      }
      return new Float32Array(buffer2);
    };
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class IORouterRegistry {
    constructor() {
      this.saveRouters = [];
      this.loadRouters = [];
    }
    static getInstance() {
      if (IORouterRegistry.instance == null) {
        IORouterRegistry.instance = new IORouterRegistry();
      }
      return IORouterRegistry.instance;
    }
    /**
     * Register a save-handler router.
     *
     * @param saveRouter A function that maps a URL-like string onto an instance
     * of `IOHandler` with the `save` method defined or `null`.
     */
    static registerSaveRouter(saveRouter) {
      IORouterRegistry.getInstance().saveRouters.push(saveRouter);
    }
    /**
     * Register a load-handler router.
     *
     * @param loadRouter A function that maps a URL-like string onto an instance
     * of `IOHandler` with the `load` method defined or `null`.
     */
    static registerLoadRouter(loadRouter) {
      IORouterRegistry.getInstance().loadRouters.push(loadRouter);
    }
    /**
     * Look up IOHandler for saving, given a URL-like string.
     *
     * @param url
     * @returns If only one match is found, an instance of IOHandler with the
     * `save` method defined. If no match is found, `null`.
     * @throws Error, if more than one match is found.
     */
    static getSaveHandlers(url) {
      return IORouterRegistry.getHandlers(url, "save");
    }
    /**
     * Look up IOHandler for loading, given a URL-like string.
     *
     * @param url
     * @param loadOptions Optional, custom load options.
     * @returns All valid handlers for `url`, given the currently registered
     *   handler routers.
     */
    static getLoadHandlers(url, loadOptions) {
      return IORouterRegistry.getHandlers(url, "load", loadOptions);
    }
    static getHandlers(url, handlerType, loadOptions) {
      const validHandlers = [];
      const routers = handlerType === "load" ? IORouterRegistry.getInstance().loadRouters : IORouterRegistry.getInstance().saveRouters;
      routers.forEach((router) => {
        const handler = router(url, loadOptions);
        if (handler !== null) {
          validHandlers.push(handler);
        }
      });
      return validHandlers;
    }
  }
  const registerSaveRouter = (loudRouter) => IORouterRegistry.registerSaveRouter(loudRouter);
  const registerLoadRouter = (loudRouter) => IORouterRegistry.registerLoadRouter(loudRouter);
  const getSaveHandlers = (url) => IORouterRegistry.getSaveHandlers(url);
  const getLoadHandlers = (url, loadOptions) => IORouterRegistry.getLoadHandlers(url, loadOptions);
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const DATABASE_NAME = "tensorflowjs";
  const DATABASE_VERSION = 1;
  const MODEL_STORE_NAME = "models_store";
  const INFO_STORE_NAME = "model_info_store";
  function getIndexedDBFactory() {
    if (!env().getBool("IS_BROWSER")) {
      throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    }
    const theWindow = typeof window === "undefined" ? self : window;
    const factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;
    if (factory == null) {
      throw new Error("The current browser does not appear to support IndexedDB.");
    }
    return factory;
  }
  function setUpDatabase(openRequest) {
    const db = openRequest.result;
    db.createObjectStore(MODEL_STORE_NAME, { keyPath: "modelPath" });
    db.createObjectStore(INFO_STORE_NAME, { keyPath: "modelPath" });
  }
  class BrowserIndexedDB {
    constructor(modelPath) {
      this.indexedDB = getIndexedDBFactory();
      if (modelPath == null || !modelPath) {
        throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
      }
      this.modelPath = modelPath;
    }
    async save(modelArtifacts) {
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      }
      return this.databaseAction(this.modelPath, modelArtifacts);
    }
    async load() {
      return this.databaseAction(this.modelPath);
    }
    /**
     * Perform database action to put model artifacts into or read model artifacts
     * from IndexedDB object store.
     *
     * Whether the action is put or get depends on whether `modelArtifacts` is
     * specified. If it is specified, the action will be put; otherwise the action
     * will be get.
     *
     * @param modelPath A unique string path for the model.
     * @param modelArtifacts If specified, it will be the model artifacts to be
     *   stored in IndexedDB.
     * @returns A `Promise` of `SaveResult`, if the action is put, or a `Promise`
     *   of `ModelArtifacts`, if the action is get.
     */
    databaseAction(modelPath, modelArtifacts) {
      return new Promise((resolve, reject) => {
        const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
        openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
        openRequest.onsuccess = () => {
          const db = openRequest.result;
          if (modelArtifacts == null) {
            const modelTx = db.transaction(MODEL_STORE_NAME, "readonly");
            const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
            const getRequest = modelStore.get(this.modelPath);
            getRequest.onsuccess = () => {
              if (getRequest.result == null) {
                db.close();
                return reject(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
              } else {
                resolve(getRequest.result.modelArtifacts);
              }
            };
            getRequest.onerror = (error) => {
              db.close();
              return reject(getRequest.error);
            };
            modelTx.oncomplete = () => db.close();
          } else {
            modelArtifacts.weightData = CompositeArrayBuffer.join(modelArtifacts.weightData);
            const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
            const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
            let infoStore = infoTx.objectStore(INFO_STORE_NAME);
            let putInfoRequest;
            try {
              putInfoRequest = infoStore.put({ modelPath: this.modelPath, modelArtifactsInfo });
            } catch (error) {
              return reject(error);
            }
            let modelTx;
            putInfoRequest.onsuccess = () => {
              modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
              const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
              let putModelRequest;
              try {
                putModelRequest = modelStore.put({
                  modelPath: this.modelPath,
                  modelArtifacts,
                  modelArtifactsInfo
                });
              } catch (error) {
                return reject(error);
              }
              putModelRequest.onsuccess = () => resolve({ modelArtifactsInfo });
              putModelRequest.onerror = (error) => {
                infoStore = infoTx.objectStore(INFO_STORE_NAME);
                const deleteInfoRequest = infoStore.delete(this.modelPath);
                deleteInfoRequest.onsuccess = () => {
                  db.close();
                  return reject(putModelRequest.error);
                };
                deleteInfoRequest.onerror = (error2) => {
                  db.close();
                  return reject(putModelRequest.error);
                };
              };
            };
            putInfoRequest.onerror = (error) => {
              db.close();
              return reject(putInfoRequest.error);
            };
            infoTx.oncomplete = () => {
              if (modelTx == null) {
                db.close();
              } else {
                modelTx.oncomplete = () => db.close();
              }
            };
          }
        };
        openRequest.onerror = (error) => reject(openRequest.error);
      });
    }
  }
  BrowserIndexedDB.URL_SCHEME = "indexeddb://";
  const indexedDBRouter = (url) => {
    if (!env().getBool("IS_BROWSER")) {
      return null;
    } else {
      if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {
        return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));
      } else {
        return null;
      }
    }
  };
  IORouterRegistry.registerSaveRouter(indexedDBRouter);
  IORouterRegistry.registerLoadRouter(indexedDBRouter);
  function browserIndexedDB(modelPath) {
    return new BrowserIndexedDB(modelPath);
  }
  function maybeStripScheme$1(key) {
    return key.startsWith(BrowserIndexedDB.URL_SCHEME) ? key.slice(BrowserIndexedDB.URL_SCHEME.length) : key;
  }
  class BrowserIndexedDBManager {
    constructor() {
      this.indexedDB = getIndexedDBFactory();
    }
    async listModels() {
      return new Promise((resolve, reject) => {
        const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
        openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
        openRequest.onsuccess = () => {
          const db = openRequest.result;
          const tx = db.transaction(INFO_STORE_NAME, "readonly");
          const store = tx.objectStore(INFO_STORE_NAME);
          const getAllInfoRequest = store.getAll();
          getAllInfoRequest.onsuccess = () => {
            const out = {};
            for (const item of getAllInfoRequest.result) {
              out[item.modelPath] = item.modelArtifactsInfo;
            }
            resolve(out);
          };
          getAllInfoRequest.onerror = (error) => {
            db.close();
            return reject(getAllInfoRequest.error);
          };
          tx.oncomplete = () => db.close();
        };
        openRequest.onerror = (error) => reject(openRequest.error);
      });
    }
    async removeModel(path) {
      path = maybeStripScheme$1(path);
      return new Promise((resolve, reject) => {
        const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
        openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
        openRequest.onsuccess = () => {
          const db = openRequest.result;
          const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
          const infoStore = infoTx.objectStore(INFO_STORE_NAME);
          const getInfoRequest = infoStore.get(path);
          let modelTx;
          getInfoRequest.onsuccess = () => {
            if (getInfoRequest.result == null) {
              db.close();
              return reject(new Error(`Cannot find model with path '${path}' in IndexedDB.`));
            } else {
              const deleteInfoRequest = infoStore.delete(path);
              const deleteModelData = () => {
                modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
                const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                const deleteModelRequest = modelStore.delete(path);
                deleteModelRequest.onsuccess = () => resolve(getInfoRequest.result.modelArtifactsInfo);
                deleteModelRequest.onerror = (error) => reject(getInfoRequest.error);
              };
              deleteInfoRequest.onsuccess = deleteModelData;
              deleteInfoRequest.onerror = (error) => {
                deleteModelData();
                db.close();
                return reject(getInfoRequest.error);
              };
            }
          };
          getInfoRequest.onerror = (error) => {
            db.close();
            return reject(getInfoRequest.error);
          };
          infoTx.oncomplete = () => {
            if (modelTx == null) {
              db.close();
            } else {
              modelTx.oncomplete = () => db.close();
            }
          };
        };
        openRequest.onerror = (error) => reject(openRequest.error);
      });
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const PATH_SEPARATOR = "/";
  const PATH_PREFIX = "tensorflowjs_models";
  const INFO_SUFFIX = "info";
  const MODEL_TOPOLOGY_SUFFIX = "model_topology";
  const WEIGHT_SPECS_SUFFIX = "weight_specs";
  const WEIGHT_DATA_SUFFIX = "weight_data";
  const MODEL_METADATA_SUFFIX = "model_metadata";
  function getModelKeys(path) {
    return {
      info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),
      topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),
      weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),
      weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),
      modelMetadata: [PATH_PREFIX, path, MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)
    };
  }
  function removeItems(keys) {
    for (const key of Object.values(keys)) {
      window.localStorage.removeItem(key);
    }
  }
  function getModelPathFromKey(key) {
    const items = key.split(PATH_SEPARATOR);
    if (items.length < 3) {
      throw new Error(`Invalid key format: ${key}`);
    }
    return items.slice(1, items.length - 1).join(PATH_SEPARATOR);
  }
  function maybeStripScheme(key) {
    return key.startsWith(BrowserLocalStorage.URL_SCHEME) ? key.slice(BrowserLocalStorage.URL_SCHEME.length) : key;
  }
  class BrowserLocalStorage {
    constructor(modelPath) {
      if (!env().getBool("IS_BROWSER") || typeof window === "undefined" || typeof window.localStorage === "undefined") {
        throw new Error("The current environment does not support local storage.");
      }
      this.LS = window.localStorage;
      if (modelPath == null || !modelPath) {
        throw new Error("For local storage, modelPath must not be null, undefined or empty.");
      }
      this.modelPath = modelPath;
      this.keys = getModelKeys(this.modelPath);
    }
    /**
     * Save model artifacts to browser local storage.
     *
     * See the documentation to `browserLocalStorage` for details on the saved
     * artifacts.
     *
     * @param modelArtifacts The model artifacts to be stored.
     * @returns An instance of SaveResult.
     */
    async save(modelArtifacts) {
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      } else {
        const topology = JSON.stringify(modelArtifacts.modelTopology);
        const weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
        const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
        const weightBuffer = CompositeArrayBuffer.join(modelArtifacts.weightData);
        try {
          this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
          this.LS.setItem(this.keys.topology, topology);
          this.LS.setItem(this.keys.weightSpecs, weightSpecs);
          this.LS.setItem(this.keys.weightData, arrayBufferToBase64String(weightBuffer));
          const metadata = {
            format: modelArtifacts.format,
            generatedBy: modelArtifacts.generatedBy,
            convertedBy: modelArtifacts.convertedBy,
            signature: modelArtifacts.signature != null ? modelArtifacts.signature : void 0,
            userDefinedMetadata: modelArtifacts.userDefinedMetadata != null ? modelArtifacts.userDefinedMetadata : void 0,
            modelInitializer: modelArtifacts.modelInitializer != null ? modelArtifacts.modelInitializer : void 0,
            initializerSignature: modelArtifacts.initializerSignature != null ? modelArtifacts.initializerSignature : void 0,
            trainingConfig: modelArtifacts.trainingConfig != null ? modelArtifacts.trainingConfig : void 0
          };
          this.LS.setItem(this.keys.modelMetadata, JSON.stringify(metadata));
          return { modelArtifactsInfo };
        } catch (err) {
          removeItems(this.keys);
          throw new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${modelArtifactsInfo.modelTopologyBytes}, weightSpecsBytes=${modelArtifactsInfo.weightSpecsBytes}, weightDataBytes=${modelArtifactsInfo.weightDataBytes}.`);
        }
      }
    }
    /**
     * Load a model from local storage.
     *
     * See the documentation to `browserLocalStorage` for details on the saved
     * artifacts.
     *
     * @returns The loaded model (if loading succeeds).
     */
    async load() {
      const info = JSON.parse(this.LS.getItem(this.keys.info));
      if (info == null) {
        throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
      }
      if (info.modelTopologyType !== "JSON") {
        throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
      }
      const out = {};
      const topology = JSON.parse(this.LS.getItem(this.keys.topology));
      if (topology == null) {
        throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
      }
      out.modelTopology = topology;
      const weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
      if (weightSpecs == null) {
        throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
      }
      out.weightSpecs = weightSpecs;
      const metadataString = this.LS.getItem(this.keys.modelMetadata);
      if (metadataString != null) {
        const metadata = JSON.parse(metadataString);
        out.format = metadata.format;
        out.generatedBy = metadata.generatedBy;
        out.convertedBy = metadata.convertedBy;
        if (metadata.signature != null) {
          out.signature = metadata.signature;
        }
        if (metadata.userDefinedMetadata != null) {
          out.userDefinedMetadata = metadata.userDefinedMetadata;
        }
        if (metadata.modelInitializer != null) {
          out.modelInitializer = metadata.modelInitializer;
        }
        if (metadata.initializerSignature != null) {
          out.initializerSignature = metadata.initializerSignature;
        }
        if (metadata.trainingConfig != null) {
          out.trainingConfig = metadata.trainingConfig;
        }
      }
      const weightDataBase64 = this.LS.getItem(this.keys.weightData);
      if (weightDataBase64 == null) {
        throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
      }
      out.weightData = base64StringToArrayBuffer(weightDataBase64);
      return out;
    }
  }
  BrowserLocalStorage.URL_SCHEME = "localstorage://";
  const localStorageRouter = (url) => {
    if (!env().getBool("IS_BROWSER")) {
      return null;
    } else {
      if (!Array.isArray(url) && url.startsWith(BrowserLocalStorage.URL_SCHEME)) {
        return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length));
      } else {
        return null;
      }
    }
  };
  IORouterRegistry.registerSaveRouter(localStorageRouter);
  IORouterRegistry.registerLoadRouter(localStorageRouter);
  function browserLocalStorage(modelPath) {
    return new BrowserLocalStorage(modelPath);
  }
  class BrowserLocalStorageManager {
    constructor() {
      assert(env().getBool("IS_BROWSER"), () => "Current environment is not a web browser");
      assert(typeof window === "undefined" || typeof window.localStorage !== "undefined", () => "Current browser does not appear to support localStorage");
      this.LS = window.localStorage;
    }
    async listModels() {
      const out = {};
      const prefix = PATH_PREFIX + PATH_SEPARATOR;
      const suffix = PATH_SEPARATOR + INFO_SUFFIX;
      for (let i = 0; i < this.LS.length; ++i) {
        const key = this.LS.key(i);
        if (key.startsWith(prefix) && key.endsWith(suffix)) {
          const modelPath = getModelPathFromKey(key);
          out[modelPath] = JSON.parse(this.LS.getItem(key));
        }
      }
      return out;
    }
    async removeModel(path) {
      path = maybeStripScheme(path);
      const keys = getModelKeys(path);
      if (this.LS.getItem(keys.info) == null) {
        throw new Error(`Cannot find model at path '${path}'`);
      }
      const info = JSON.parse(this.LS.getItem(keys.info));
      removeItems(keys);
      return info;
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const URL_SCHEME_SUFFIX = "://";
  class ModelStoreManagerRegistry {
    constructor() {
      this.managers = {};
    }
    static getInstance() {
      if (ModelStoreManagerRegistry.instance == null) {
        ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry();
      }
      return ModelStoreManagerRegistry.instance;
    }
    /**
     * Register a save-handler router.
     *
     * @param saveRouter A function that maps a URL-like string onto an instance
     * of `IOHandler` with the `save` method defined or `null`.
     */
    static registerManager(scheme, manager) {
      assert(scheme != null, () => "scheme must not be undefined or null.");
      if (scheme.endsWith(URL_SCHEME_SUFFIX)) {
        scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX));
      }
      assert(scheme.length > 0, () => "scheme must not be an empty string.");
      const registry = ModelStoreManagerRegistry.getInstance();
      assert(registry.managers[scheme] == null, () => `A model store manager is already registered for scheme '${scheme}'.`);
      registry.managers[scheme] = manager;
    }
    static getManager(scheme) {
      const manager = ModelStoreManagerRegistry.getInstance().managers[scheme];
      if (manager == null) {
        throw new Error(`Cannot find model manager for scheme '${scheme}'`);
      }
      return manager;
    }
    static getSchemes() {
      return Object.keys(ModelStoreManagerRegistry.getInstance().managers);
    }
  }
  function parseURL(url) {
    if (url.indexOf(URL_SCHEME_SUFFIX) === -1) {
      throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ModelStoreManagerRegistry.getSchemes().join(",")}`);
    }
    return {
      scheme: url.split(URL_SCHEME_SUFFIX)[0],
      path: url.split(URL_SCHEME_SUFFIX)[1]
    };
  }
  async function cloneModelInternal(sourceURL, destURL, deleteSource = false) {
    assert(sourceURL !== destURL, () => `Old path and new path are the same: '${sourceURL}'`);
    const loadHandlers = IORouterRegistry.getLoadHandlers(sourceURL);
    assert(loadHandlers.length > 0, () => `Copying failed because no load handler is found for source URL ${sourceURL}.`);
    assert(loadHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) load handlers for source URL ${sourceURL}.`);
    const loadHandler = loadHandlers[0];
    const saveHandlers = IORouterRegistry.getSaveHandlers(destURL);
    assert(saveHandlers.length > 0, () => `Copying failed because no save handler is found for destination URL ${destURL}.`);
    assert(saveHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) save handlers for destination URL ${destURL}.`);
    const saveHandler = saveHandlers[0];
    const sourceScheme = parseURL(sourceURL).scheme;
    const sourcePath = parseURL(sourceURL).path;
    const sameMedium = sourceScheme === parseURL(sourceURL).scheme;
    const modelArtifacts = await loadHandler.load();
    if (deleteSource && sameMedium) {
      await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
    }
    const saveResult = await saveHandler.save(modelArtifacts);
    if (deleteSource && !sameMedium) {
      await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
    }
    return saveResult.modelArtifactsInfo;
  }
  async function listModels() {
    const schemes = ModelStoreManagerRegistry.getSchemes();
    const out = {};
    for (const scheme of schemes) {
      const schemeOut = await ModelStoreManagerRegistry.getManager(scheme).listModels();
      for (const path in schemeOut) {
        const url = scheme + URL_SCHEME_SUFFIX + path;
        out[url] = schemeOut[path];
      }
    }
    return out;
  }
  async function removeModel(url) {
    const schemeAndPath = parseURL(url);
    const manager = ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);
    return manager.removeModel(schemeAndPath.path);
  }
  async function copyModel(sourceURL, destURL) {
    const deleteSource = false;
    return cloneModelInternal(sourceURL, destURL, deleteSource);
  }
  async function moveModel(sourceURL, destURL) {
    const deleteSource = true;
    return cloneModelInternal(sourceURL, destURL, deleteSource);
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class PlatformBrowser {
    constructor() {
      this.messageName = "setTimeoutCustom";
      this.functionRefs = [];
      this.handledMessageCount = 0;
      this.hasEventListener = false;
    }
    fetch(path, init2) {
      return fetch(path, init2);
    }
    now() {
      return performance.now();
    }
    encode(text, encoding) {
      if (encoding !== "utf-8" && encoding !== "utf8") {
        throw new Error(`Browser's encoder only supports utf-8, but got ${encoding}`);
      }
      if (this.textEncoder == null) {
        this.textEncoder = new TextEncoder();
      }
      return this.textEncoder.encode(text);
    }
    decode(bytes, encoding) {
      return new TextDecoder(encoding).decode(bytes);
    }
    // If the setTimeout nesting level is greater than 5 and timeout is less
    // than 4ms, timeout will be clamped to 4ms, which hurts the perf.
    // Interleaving window.postMessage and setTimeout will trick the browser and
    // avoid the clamp.
    setTimeoutCustom(functionRef, delay) {
      if (typeof window === "undefined" || !env().getBool("USE_SETTIMEOUTCUSTOM")) {
        setTimeout(functionRef, delay);
        return;
      }
      this.functionRefs.push(functionRef);
      setTimeout(() => {
        window.postMessage({ name: this.messageName, index: this.functionRefs.length - 1 }, "*");
      }, delay);
      if (!this.hasEventListener) {
        this.hasEventListener = true;
        window.addEventListener("message", (event) => {
          if (event.source === window && event.data.name === this.messageName) {
            event.stopPropagation();
            const functionRef2 = this.functionRefs[event.data.index];
            functionRef2();
            this.handledMessageCount++;
            if (this.handledMessageCount === this.functionRefs.length) {
              this.functionRefs = [];
              this.handledMessageCount = 0;
            }
          }
        }, true);
      }
    }
    isTypedArray(a) {
      return isTypedArrayBrowser(a);
    }
  }
  if (env().get("IS_BROWSER")) {
    env().setPlatform("browser", new PlatformBrowser());
    try {
      ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());
    } catch (err) {
    }
    try {
      ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());
    } catch (err) {
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const getNodeFetch = {
    // tslint:disable-next-line:no-require-imports
    importFetch: () => require("node-fetch")
  };
  let systemFetch;
  class PlatformNode {
    constructor() {
      this.util = require("util");
      this.textEncoder = new this.util.TextEncoder();
    }
    fetch(path, requestInits) {
      if (env().global.fetch != null) {
        return env().global.fetch(path, requestInits);
      }
      if (systemFetch == null) {
        systemFetch = getNodeFetch.importFetch();
      }
      return systemFetch(path, requestInits);
    }
    now() {
      const time2 = process.hrtime();
      return time2[0] * 1e3 + time2[1] / 1e6;
    }
    encode(text, encoding) {
      if (encoding !== "utf-8" && encoding !== "utf8") {
        throw new Error(`Node built-in encoder only supports utf-8, but got ${encoding}`);
      }
      return this.textEncoder.encode(text);
    }
    decode(bytes, encoding) {
      if (bytes.length === 0) {
        return "";
      }
      return new this.util.TextDecoder(encoding).decode(bytes);
    }
    isTypedArray(a) {
      return this.util.types.isFloat32Array(a) || this.util.types.isInt32Array(a) || this.util.types.isUint8Array(a) || this.util.types.isUint8ClampedArray(a);
    }
  }
  if (env().get("IS_NODE") && !env().get("IS_BROWSER")) {
    env().setPlatform("node", new PlatformNode());
  }
  /**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function buffer(shape, dtype = "float32", values) {
    dtype = dtype || "float32";
    assertNonNegativeIntegerDimensions(shape);
    return new TensorBuffer(shape, dtype, values);
  }
  /**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function cast_(x, dtype) {
    const $x = convertToTensor(x, "x", "cast");
    if (!isValidDtype(dtype)) {
      throw new Error(`Failed to cast to unknown dtype ${dtype}`);
    }
    if (dtype === "string" && $x.dtype !== "string" || dtype !== "string" && $x.dtype === "string") {
      throw new Error("Only strings can be casted to strings");
    }
    const inputs = { x: $x };
    const attrs = { dtype };
    return ENGINE.runKernel(Cast, inputs, attrs);
  }
  const cast$1 = /* @__PURE__ */ op({ cast_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function clone_(x) {
    const $x = convertToTensor(x, "x", "clone", "string_or_numeric");
    const inputs = { x: $x };
    return ENGINE.runKernel(Identity, inputs);
  }
  const clone = /* @__PURE__ */ op({ clone_ });
  /**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function print(x, verbose = false) {
    console.log(x.toString(verbose));
  }
  /**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  getOrMakeEngine();
  const opHandler = {
    buffer,
    cast: cast$1,
    clone,
    print
  };
  setOpHandler(opHandler);
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function add_(a, b) {
    let $a = convertToTensor(a, "a", "add");
    let $b = convertToTensor(b, "b", "add");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Add, inputs);
  }
  const add = /* @__PURE__ */ op({ add_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function floorDiv_(a, b) {
    let $a = convertToTensor(a, "a", "floorDiv");
    let $b = convertToTensor(b, "b", "floorDiv");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(FloorDiv, inputs);
  }
  const floorDiv$1 = /* @__PURE__ */ op({ floorDiv_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function div_(a, b) {
    let $a = convertToTensor(a, "a", "div");
    let $b = convertToTensor(b, "b", "div");
    [$a, $b] = makeTypesMatch($a, $b);
    if ($a.dtype === "int32" && $b.dtype === "int32") {
      return floorDiv$1($a, $b);
    }
    const inputs = { a: $a, b: $b };
    const attrs = {};
    return ENGINE.runKernel(RealDiv, inputs, attrs);
  }
  const div = /* @__PURE__ */ op({ div_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function mul_(a, b) {
    let $a = convertToTensor(a, "a", "mul");
    let $b = convertToTensor(b, "b", "mul");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Multiply, inputs);
  }
  const mul = /* @__PURE__ */ op({ mul_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function abs_(x) {
    const $x = convertToTensor(x, "x", "abs");
    if ($x.dtype === "complex64") {
      const inputs = { x: $x };
      return ENGINE.runKernel(ComplexAbs, inputs);
    } else {
      const inputs = { x: $x };
      return ENGINE.runKernel(Abs, inputs);
    }
  }
  const abs$1 = /* @__PURE__ */ op({ abs_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function acos_(x) {
    const $x = convertToTensor(x, "x", "acos");
    const inputs = { x: $x };
    return ENGINE.runKernel(Acos, inputs);
  }
  const acos$1 = /* @__PURE__ */ op({ acos_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function acosh_(x) {
    const $x = convertToTensor(x, "x", "acosh");
    const inputs = { x: $x };
    return ENGINE.runKernel(Acosh, inputs);
  }
  const acosh$1 = /* @__PURE__ */ op({ acosh_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function addN_(tensors) {
    assert(Array.isArray(tensors), () => "The argument passed to tf.addN() must be a list of tensors");
    assert(tensors.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ${tensors.length}`);
    const $tensors = tensors.map((t, i) => convertToTensor(t, `tensors${i}`, "addN"));
    const firstTensor = $tensors[0];
    $tensors.forEach((t) => {
      if (t.dtype !== firstTensor.dtype) {
        throw new Error("All tensors passed to tf.addN() must have the same dtype");
      }
    });
    $tensors.forEach((t) => {
      if (!arraysEqual(t.shape, firstTensor.shape)) {
        throw new Error("All tensors passed to tf.addN() must have the same shape");
      }
    });
    const inputs = $tensors;
    return ENGINE.runKernel(AddN, inputs);
  }
  const addN$1 = /* @__PURE__ */ op({ addN_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function all_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, "x", "all", "bool");
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(All, inputs, attrs);
  }
  const all$1 = /* @__PURE__ */ op({ all_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function any_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, "x", "any", "bool");
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Any, inputs, attrs);
  }
  const any$1 = /* @__PURE__ */ op({ any_ });
  /**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function argMax_(x, axis = 0) {
    const $x = convertToTensor(x, "x", "argMax");
    const inputs = { x: $x };
    const attrs = { axis };
    return ENGINE.runKernel(ArgMax, inputs, attrs);
  }
  const argMax$1 = /* @__PURE__ */ op({ argMax_ });
  /**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function argMin_(x, axis = 0) {
    const $x = convertToTensor(x, "x", "argMin");
    const inputs = { x: $x };
    const attrs = { axis };
    return ENGINE.runKernel(ArgMin, inputs, attrs);
  }
  const argMin$1 = /* @__PURE__ */ op({ argMin_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function asin_(x) {
    const $x = convertToTensor(x, "x", "asin");
    const inputs = { x: $x };
    return ENGINE.runKernel(Asin, inputs);
  }
  const asin$1 = /* @__PURE__ */ op({ asin_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function asinh_(x) {
    const $x = convertToTensor(x, "x", "asinh");
    const inputs = { x: $x };
    return ENGINE.runKernel(Asinh, inputs);
  }
  const asinh$1 = /* @__PURE__ */ op({ asinh_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function atan_(x) {
    const $x = convertToTensor(x, "x", "atan");
    const inputs = { x: $x };
    return ENGINE.runKernel(Atan, inputs);
  }
  const atan$1 = /* @__PURE__ */ op({ atan_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function atan2_(a, b) {
    let $a = convertToTensor(a, "a", "atan2");
    let $b = convertToTensor(b, "b", "atan2");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Atan2, inputs);
  }
  const atan2$1 = /* @__PURE__ */ op({ atan2_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function atanh_(x) {
    const $x = convertToTensor(x, "x", "atanh");
    const inputs = { x: $x };
    return ENGINE.runKernel(Atanh, inputs);
  }
  const atanh$1 = /* @__PURE__ */ op({ atanh_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function computeDilation2DInfo(inputShape, filterShape, strides, pad2, dataFormat = "NHWC", dilations) {
    const inputChannels = inputShape[3];
    const $filterShape = [...filterShape, inputChannels];
    const $dataFormat = convertConv2DDataFormat(dataFormat);
    return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad2, null, null, $dataFormat);
  }
  function computePool2DInfo(inShape, filterSize, strides, dilations, pad2, roundingMode, dataFormat = "channelsLast") {
    const [filterHeight, filterWidth] = parseTupleParam(filterSize);
    let filterShape;
    if (dataFormat === "channelsLast") {
      filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
    } else if (dataFormat === "channelsFirst") {
      filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    return computeConv2DInfo(inShape, filterShape, strides, dilations, pad2, roundingMode, false, dataFormat);
  }
  function computePool3DInfo(inShape, filterSize, strides, dilations, pad2, roundingMode, dataFormat = "NDHWC") {
    const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);
    let filterShape;
    let $dataFormat;
    if (dataFormat === "NDHWC") {
      $dataFormat = "channelsLast";
      filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];
    } else if (dataFormat === "NCDHW") {
      $dataFormat = "channelsFirst";
      filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    return computeConv3DInfo(inShape, filterShape, strides, dilations, pad2, false, $dataFormat, roundingMode);
  }
  function computeConv2DInfo(inShape, filterShape, strides, dilations, pad2, roundingMode, depthwise = false, dataFormat = "channelsLast") {
    let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];
    if (dataFormat === "channelsLast") {
      [batchSize, inHeight, inWidth, inChannels] = inShape;
    } else if (dataFormat === "channelsFirst") {
      [batchSize, inChannels, inHeight, inWidth] = inShape;
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    const [filterHeight, filterWidth, , filterChannels] = filterShape;
    const [strideHeight, strideWidth] = parseTupleParam(strides);
    const [dilationHeight, dilationWidth] = parseTupleParam(dilations);
    const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
    const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
    const { padInfo, outHeight, outWidth } = getPadAndOutInfo(pad2, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);
    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    let outShape;
    if (dataFormat === "channelsFirst") {
      outShape = [batchSize, outChannels, outHeight, outWidth];
    } else if (dataFormat === "channelsLast") {
      outShape = [batchSize, outHeight, outWidth, outChannels];
    }
    return {
      batchSize,
      dataFormat,
      inHeight,
      inWidth,
      inChannels,
      outHeight,
      outWidth,
      outChannels,
      padInfo,
      strideHeight,
      strideWidth,
      filterHeight,
      filterWidth,
      effectiveFilterHeight,
      effectiveFilterWidth,
      dilationHeight,
      dilationWidth,
      inShape,
      outShape,
      filterShape
    };
  }
  function computeConv3DInfo(inShape, filterShape, strides, dilations, pad2, depthwise = false, dataFormat = "channelsLast", roundingMode) {
    let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];
    if (dataFormat === "channelsLast") {
      [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
    } else if (dataFormat === "channelsFirst") {
      [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    const [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;
    const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
    const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
    const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
    const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
    const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
    const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);
    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    let outShape;
    if (dataFormat === "channelsFirst") {
      outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
    } else if (dataFormat === "channelsLast") {
      outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
    }
    return {
      batchSize,
      dataFormat,
      inDepth,
      inHeight,
      inWidth,
      inChannels,
      outDepth,
      outHeight,
      outWidth,
      outChannels,
      padInfo,
      strideDepth,
      strideHeight,
      strideWidth,
      filterDepth,
      filterHeight,
      filterWidth,
      effectiveFilterDepth,
      effectiveFilterHeight,
      effectiveFilterWidth,
      dilationDepth,
      dilationHeight,
      dilationWidth,
      inShape,
      outShape,
      filterShape
    };
  }
  function computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {
    if (zeroPad == null) {
      zeroPad = computeDefaultPad(inShape, fieldSize, stride);
    }
    const inputRows = inShape[0];
    const inputCols = inShape[1];
    const outputRows = round$2((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    const outputCols = round$2((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    return [outputRows, outputCols];
  }
  function computeOutputShape4D(inShape, filterShape, outChannels, strides, zeroPad, roundingMode) {
    if (zeroPad == null) {
      zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);
    }
    const outShape = [0, 0, 0, outChannels];
    for (let index2 = 0; index2 < 3; index2++) {
      if (inShape[index2] + 2 * zeroPad >= filterShape[index2]) {
        outShape[index2] = round$2((inShape[index2] - filterShape[index2] + 2 * zeroPad) / strides[index2] + 1, roundingMode);
      }
    }
    return outShape;
  }
  function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {
    const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
    return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
  }
  function parseTupleParam(param) {
    if (typeof param === "number") {
      return [param, param, param];
    }
    if (param.length === 2) {
      return [param[0], param[1], 1];
    }
    return param;
  }
  function parse3TupleParam(param) {
    return typeof param === "number" ? [param, param, param] : param;
  }
  function getEffectiveFilterSize(filterSize, dilation) {
    if (dilation <= 1) {
      return filterSize;
    }
    return filterSize + (filterSize - 1) * (dilation - 1);
  }
  function getPadAndOutInfo(pad2, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {
    let padInfo;
    let outHeight;
    let outWidth;
    if (typeof pad2 === "number") {
      const padType = pad2 === 0 ? "VALID" : "NUMBER";
      padInfo = { top: pad2, bottom: pad2, left: pad2, right: pad2, type: padType };
      const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad2, roundingMode);
      outHeight = outShape[0];
      outWidth = outShape[1];
    } else if (pad2 === "same") {
      outHeight = Math.ceil(inHeight / strideHeight);
      outWidth = Math.ceil(inWidth / strideWidth);
      const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);
      const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);
      const top = Math.floor(padAlongHeight / 2);
      const bottom = padAlongHeight - top;
      const left = Math.floor(padAlongWidth / 2);
      const right = padAlongWidth - left;
      padInfo = { top, bottom, left, right, type: "SAME" };
    } else if (pad2 === "valid") {
      padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" };
      outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
      outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    } else if (typeof pad2 === "object") {
      const top = dataFormat === "channelsLast" ? pad2[1][0] : pad2[2][0];
      const bottom = dataFormat === "channelsLast" ? pad2[1][1] : pad2[2][1];
      const left = dataFormat === "channelsLast" ? pad2[2][0] : pad2[3][0];
      const right = dataFormat === "channelsLast" ? pad2[2][1] : pad2[3][1];
      const padType = top === 0 && bottom === 0 && left === 0 && right === 0 ? "VALID" : "EXPLICIT";
      padInfo = { top, bottom, left, right, type: padType };
      outHeight = round$2((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);
      outWidth = round$2((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);
    } else {
      throw Error(`Unknown padding parameter: ${pad2}`);
    }
    return { padInfo, outHeight, outWidth };
  }
  function get3DPadAndOutInfo(pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {
    let padInfo;
    let outDepth;
    let outHeight;
    let outWidth;
    if (pad2 === "valid") {
      pad2 = 0;
    }
    if (typeof pad2 === "number") {
      const padType = pad2 === 0 ? "VALID" : "NUMBER";
      padInfo = {
        top: pad2,
        bottom: pad2,
        left: pad2,
        right: pad2,
        front: pad2,
        back: pad2,
        type: padType
      };
      const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], [filterDepth, filterHeight, filterWidth], 1, [strideDepth, strideHeight, strideWidth], pad2, roundingMode);
      outDepth = outShape[0];
      outHeight = outShape[1];
      outWidth = outShape[2];
    } else if (pad2 === "same") {
      outDepth = Math.ceil(inDepth / strideDepth);
      outHeight = Math.ceil(inHeight / strideHeight);
      outWidth = Math.ceil(inWidth / strideWidth);
      const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
      const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
      const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
      const front = Math.floor(padAlongDepth / 2);
      const back = padAlongDepth - front;
      const top = Math.floor(padAlongHeight / 2);
      const bottom = padAlongHeight - top;
      const left = Math.floor(padAlongWidth / 2);
      const right = padAlongWidth - left;
      padInfo = { top, bottom, left, right, front, back, type: "SAME" };
    } else {
      throw Error(`Unknown padding parameter: ${pad2}`);
    }
    return { padInfo, outDepth, outHeight, outWidth };
  }
  function round$2(value, roundingMode) {
    if (!roundingMode) {
      return Math.trunc(value);
    }
    switch (roundingMode) {
      case "round":
        return Math.round(value);
      case "ceil":
        return Math.ceil(value);
      case "floor":
        return Math.floor(value);
      default:
        throw new Error(`Unknown roundingMode ${roundingMode}`);
    }
  }
  function tupleValuesAreOne(param) {
    const [dimA, dimB, dimC] = parseTupleParam(param);
    return dimA === 1 && dimB === 1 && dimC === 1;
  }
  function eitherStridesOrDilationsAreOne(strides, dilations) {
    return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);
  }
  function stridesOrDilationsArePositive(values) {
    return parseTupleParam(values).every((value) => value > 0);
  }
  function convertConv2DDataFormat(dataFormat) {
    if (dataFormat === "NHWC") {
      return "channelsLast";
    } else if (dataFormat === "NCHW") {
      return "channelsFirst";
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
  }
  function checkPadOnDimRoundingMode(opDesc, pad2, dimRoundingMode) {
    if (dimRoundingMode != null) {
      if (typeof pad2 === "string") {
        throw Error(`Error in ${opDesc}: pad must be an integer when using dimRoundingMode ${dimRoundingMode} but got pad ${pad2}.`);
      } else if (typeof pad2 === "number") {
        assert(isInt(pad2), () => `Error in ${opDesc}: pad must be an integer when using dimRoundingMode ${dimRoundingMode} but got pad ${pad2}.`);
      } else if (typeof pad2 === "object") {
        pad2.forEach((p) => {
          p.forEach((v) => {
            assert(isInt(v), () => `Error in ${opDesc}: pad must be an integer when using dimRoundingMode ${dimRoundingMode} but got pad ${v}.`);
          });
        });
      } else {
        throw Error(`Error in ${opDesc}: Unknown padding parameter: ${pad2}`);
      }
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function reshape_(x, shape) {
    const $x = convertToTensor(x, "x", "reshape", "string_or_numeric");
    const inputs = { x: $x };
    const attrs = { shape };
    return ENGINE.runKernel(Reshape, inputs, attrs);
  }
  const reshape$1 = /* @__PURE__ */ op({ reshape_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function avgPool_(x, filterSize, strides, pad2, dimRoundingMode) {
    const $x = convertToTensor(x, "x", "avgPool", "float32");
    const dilations = 1;
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape$1($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${x4D.rank}.`);
    checkPadOnDimRoundingMode("avgPool", pad2, dimRoundingMode);
    const inputs = { x: x4D };
    const attrs = { filterSize, strides, pad: pad2, dimRoundingMode };
    let res = ENGINE.runKernel(AvgPool, inputs, attrs);
    res = cast$1(res, $x.dtype);
    if (reshapedTo4D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  const avgPool$1 = /* @__PURE__ */ op({ avgPool_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function avgPool3d_(x, filterSize, strides, pad2, dimRoundingMode, dataFormat = "NDHWC") {
    const $x = convertToTensor(x, "x", "avgPool3d", "float32");
    let x5D = $x;
    let reshapedTo5D = false;
    if ($x.rank === 4) {
      reshapedTo5D = true;
      x5D = reshape$1($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
    }
    assert(x5D.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
    assert(dataFormat === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`);
    assert(typeof strides === "number" && strides > 0 || Array.isArray(strides) && strides[0] > 0 && strides[1] > 0 && strides[2] > 0, () => `Error in avgPool3d: Stride must be > 0, but got '${strides}'`);
    checkPadOnDimRoundingMode("avgPool3d", pad2, dimRoundingMode);
    const inputs = { x: x5D };
    const attrs = { filterSize, strides, pad: pad2, dimRoundingMode, dataFormat };
    let res = ENGINE.runKernel(AvgPool3D, inputs, attrs);
    res = cast$1(res, x5D.dtype);
    if (reshapedTo5D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  const avgPool3d = /* @__PURE__ */ op({ avgPool3d_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function concat_(tensors, axis = 0) {
    assert(tensors.length >= 1, () => "Pass at least one tensor to concat");
    const $tensors = convertToTensorArray(tensors, "tensors", "concat", "string_or_numeric");
    if ($tensors[0].dtype === "complex64") {
      $tensors.forEach((tensor2) => {
        if (tensor2.dtype !== "complex64") {
          throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${tensor2.dtype}. `);
        }
      });
    }
    if ($tensors.length === 1) {
      return clone($tensors[0]);
    }
    const inputs = $tensors;
    const attr = { axis };
    return ENGINE.runKernel(Concat, inputs, attr);
  }
  const concat$1 = /* @__PURE__ */ op({ concat_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function matMul_(a, b, transposeA = false, transposeB = false) {
    let $a = convertToTensor(a, "a", "matMul");
    let $b = convertToTensor(b, "b", "matMul");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    const attrs = { transposeA, transposeB };
    return ENGINE.runKernel(BatchMatMul, inputs, attrs);
  }
  const matMul$1 = /* @__PURE__ */ op({ matMul_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sigmoid_(x) {
    const $x = convertToTensor(x, "x", "sigmoid", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sigmoid, inputs);
  }
  const sigmoid$1 = /* @__PURE__ */ op({ sigmoid_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function slice_(x, begin, size) {
    const $x = convertToTensor(x, "x", "slice", "string_or_numeric");
    if ($x.rank === 0) {
      throw new Error("Slicing scalar is not possible");
    }
    const inputs = { x: $x };
    const attrs = { begin, size };
    return ENGINE.runKernel(Slice, inputs, attrs);
  }
  const slice$1 = /* @__PURE__ */ op({ slice_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tanh_(x) {
    const $x = convertToTensor(x, "x", "tanh", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Tanh, inputs);
  }
  const tanh$1 = /* @__PURE__ */ op({ tanh_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function basicLSTMCell_(forgetBias, lstmKernel, lstmBias, data, c, h) {
    const $forgetBias = convertToTensor(forgetBias, "forgetBias", "basicLSTMCell");
    const $lstmKernel = convertToTensor(lstmKernel, "lstmKernel", "basicLSTMCell");
    const $lstmBias = convertToTensor(lstmBias, "lstmBias", "basicLSTMCell");
    const $data = convertToTensor(data, "data", "basicLSTMCell");
    const $c = convertToTensor(c, "c", "basicLSTMCell");
    const $h = convertToTensor(h, "h", "basicLSTMCell");
    const combined = concat$1([$data, $h], 1);
    const weighted = matMul$1(combined, $lstmKernel);
    const res = add(weighted, $lstmBias);
    const batchSize = res.shape[0];
    const sliceCols = res.shape[1] / 4;
    const sliceSize = [batchSize, sliceCols];
    const i = slice$1(res, [0, 0], sliceSize);
    const j2 = slice$1(res, [0, sliceCols], sliceSize);
    const f = slice$1(res, [0, sliceCols * 2], sliceSize);
    const o = slice$1(res, [0, sliceCols * 3], sliceSize);
    const newC = add(mul(sigmoid$1(i), tanh$1(j2)), mul($c, sigmoid$1(add($forgetBias, f))));
    const newH = mul(tanh$1(newC), sigmoid$1(o));
    return [newC, newH];
  }
  const basicLSTMCell = /* @__PURE__ */ op({ basicLSTMCell_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function batchToSpaceND_(x, blockShape, crops) {
    const $x = convertToTensor(x, "x", "batchToSpaceND");
    const prod2 = blockShape.reduce((a, b) => a * b);
    assert($x.rank >= 1 + blockShape.length, () => `input rank is ${$x.rank} but should be > than blockShape.length ${blockShape.length}`);
    assert(crops.length === blockShape.length, () => `crops.length is ${crops.length} but should be equal to blockShape.length  ${blockShape.length}`);
    assert($x.shape[0] % prod2 === 0, () => `input tensor batch is ${$x.shape[0]} but is not divisible by the product of the elements of blockShape ${blockShape.join(" * ")} === ${prod2}`);
    const inputs = { x: $x };
    const attrs = { blockShape, crops };
    return ENGINE.runKernel(BatchToSpaceND, inputs, attrs);
  }
  const batchToSpaceND$1 = /* @__PURE__ */ op({ batchToSpaceND_ });
  function xAs4D(x) {
    let x4D;
    if (x.rank === 0 || x.rank === 1) {
      x4D = reshape$1(x, [1, 1, 1, x.size]);
    } else if (x.rank === 2) {
      x4D = reshape$1(x, [1, 1, x.shape[0], x.shape[1]]);
    } else if (x.rank === 3) {
      x4D = reshape$1(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
    } else {
      x4D = x;
    }
    return x4D;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function batchNorm_(x, mean2, variance, offset, scale, varianceEpsilon) {
    if (varianceEpsilon == null) {
      varianceEpsilon = 1e-3;
    }
    const $x = convertToTensor(x, "x", "batchNorm");
    const $mean = convertToTensor(mean2, "mean", "batchNorm");
    const $variance = convertToTensor(variance, "variance", "batchNorm");
    let $scale;
    if (scale != null) {
      $scale = convertToTensor(scale, "scale", "batchNorm");
    }
    let $offset;
    if (offset != null) {
      $offset = convertToTensor(offset, "offset", "batchNorm");
    }
    assert($mean.rank === $variance.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
    assert($offset == null || $mean.rank === $offset.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
    assert($scale == null || $mean.rank === $scale.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    const x4D = xAs4D($x);
    const inputs = {
      x: x4D,
      scale: $scale,
      offset: $offset,
      mean: $mean,
      variance: $variance
    };
    const attrs = { varianceEpsilon };
    const res = ENGINE.runKernel(FusedBatchNorm, inputs, attrs);
    return reshape$1(res, $x.shape);
  }
  const batchNorm$1 = /* @__PURE__ */ op({ batchNorm_ });
  function batchNorm2d_(x, mean2, variance, offset, scale, varianceEpsilon) {
    const $x = convertToTensor(x, "x", "batchNorm");
    const $mean = convertToTensor(mean2, "mean", "batchNorm");
    const $variance = convertToTensor(variance, "variance", "batchNorm");
    let $scale;
    if (scale != null) {
      $scale = convertToTensor(scale, "scale", "batchNorm");
    }
    let $offset;
    if (offset != null) {
      $offset = convertToTensor(offset, "offset", "batchNorm");
    }
    assert($x.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${$x.rank}.`);
    assert($mean.rank === 2 || $mean.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${$mean.rank}.`);
    assert($variance.rank === 2 || $variance.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${$variance.rank}.`);
    if ($scale != null) {
      assert($scale.rank === 2 || $scale.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${$scale.rank}.`);
    }
    if ($offset != null) {
      assert($offset.rank === 2 || $offset.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${$offset.rank}.`);
    }
    return batchNorm$1($x, $mean, $variance, $offset, $scale, varianceEpsilon);
  }
  const batchNorm2d = /* @__PURE__ */ op({ batchNorm2d_ });
  function batchNorm3d_(x, mean2, variance, offset, scale, varianceEpsilon) {
    const $x = convertToTensor(x, "x", "batchNorm");
    const $mean = convertToTensor(mean2, "mean", "batchNorm");
    const $variance = convertToTensor(variance, "variance", "batchNorm");
    let $scale;
    if (scale != null) {
      $scale = convertToTensor(scale, "scale", "batchNorm");
    }
    let $offset;
    if (offset != null) {
      $offset = convertToTensor(offset, "offset", "batchNorm");
    }
    assert($x.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${$x.rank}.`);
    assert($mean.rank === 3 || $mean.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${$mean.rank}.`);
    assert($variance.rank === 3 || $variance.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${$variance.rank}.`);
    if ($scale != null) {
      assert($scale.rank === 3 || $scale.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${$scale.rank}.`);
    }
    if ($offset != null) {
      assert($offset.rank === 3 || $offset.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${$offset.rank}.`);
    }
    return batchNorm$1($x, $mean, $variance, $offset, $scale, varianceEpsilon);
  }
  const batchNorm3d = /* @__PURE__ */ op({ batchNorm3d_ });
  function batchNorm4d_(x, mean2, variance, offset, scale, varianceEpsilon) {
    const $x = convertToTensor(x, "x", "batchNorm");
    const $mean = convertToTensor(mean2, "mean", "batchNorm");
    const $variance = convertToTensor(variance, "variance", "batchNorm");
    let $scale;
    if (scale != null) {
      $scale = convertToTensor(scale, "scale", "batchNorm");
    }
    let $offset;
    if (offset != null) {
      $offset = convertToTensor(offset, "offset", "batchNorm");
    }
    assert($x.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${$x.rank}.`);
    assert($mean.rank === 4 || $mean.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${$mean.rank}.`);
    assert($variance.rank === 4 || $variance.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${$variance.rank}.`);
    if ($scale != null) {
      assert($scale.rank === 4 || $scale.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${$scale.rank}.`);
    }
    if ($offset != null) {
      assert($offset.rank === 4 || $offset.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${$offset.rank}.`);
    }
    return batchNorm$1($x, $mean, $variance, $offset, $scale, varianceEpsilon);
  }
  const batchNorm4d = /* @__PURE__ */ op({ batchNorm4d_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function bincount_(x, weights, size) {
    const $x = convertToTensor(x, "x", "bincount");
    const $weights = convertToTensor(weights, "weights", "bincount");
    assert($x.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${$x.dtype}`);
    assert(size >= 0, () => `size must be non-negative, but got ${size}.`);
    assert($weights.size === $x.size || $weights.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${$x.shape}, weights shape: ${$weights.shape}.`);
    const inputs = { x: $x, weights: $weights };
    const attrs = { size };
    return ENGINE.runKernel(Bincount, inputs, attrs);
  }
  const bincount$1 = /* @__PURE__ */ op({ bincount_ });
  /**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function bitwiseAnd_(x, y) {
    const $x = convertToTensor(x, "x", "bitwiseAnd");
    const $y = convertToTensor(y, "y", "bitwiseAnd");
    if (!arraysEqual($x.shape, $y.shape)) {
      throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${$x.shape}, y: ${$y.shape}`);
    }
    if ($x.dtype !== "int32" || $y.dtype !== "int32") {
      throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${$x.dtype} and type of y: ${$y.dtype}`);
    }
    const inputs = { a: $x, b: $y };
    return ENGINE.runKernel(BitwiseAnd, inputs);
  }
  const bitwiseAnd$1 = /* @__PURE__ */ op({ bitwiseAnd_ });
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function broadcastArgs_(s0, s1) {
    const shape1Input = convertToTensor(s0, "s0", "broadcastArgs", "int32");
    const shape2Input = convertToTensor(s1, "s1", "broadcastArgs", "int32");
    if (shape1Input.rank !== 1) {
      throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${shape1Input.rank}`);
    }
    if (shape2Input.rank !== 1) {
      throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${shape2Input.rank}`);
    }
    const inputs = { s0: shape1Input, s1: shape2Input };
    return ENGINE.runKernel(BroadcastArgs, inputs);
  }
  const broadcastArgs$1 = /* @__PURE__ */ op({ broadcastArgs_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function broadcastTo_(x, shape) {
    let input = convertToTensor(x, "broadcastTo", "x");
    const xShape = input.shape;
    assertNonNegativeIntegerDimensions(shape);
    if (shape.length < input.rank) {
      throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${input.rank}.`);
    }
    if (shape.length > input.rank) {
      const newShape = input.shape.slice();
      while (newShape.length < shape.length) {
        newShape.unshift(1);
      }
      input = reshape$1(input, newShape);
    }
    const inputShape = input.shape;
    const reps = Array.from(shape);
    for (let i = shape.length - 1; i >= 0; i--) {
      if (inputShape[i] === shape[i]) {
        reps[i] = 1;
      } else if (input.shape[i] !== 1) {
        throw new Error(`broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);
      }
    }
    const axes = reps.map((n, i) => n > 1 ? i : -1).filter((i) => i >= 0);
    if (axes.length === 0) {
      return clone(input);
    }
    const inputs = { x: input };
    const attrs = { reps };
    return ENGINE.runKernel(Tile, inputs, attrs);
  }
  const broadcastTo = /* @__PURE__ */ op({ broadcastTo_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function ceil_(x) {
    const $x = convertToTensor(x, "x", "ceil", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Ceil, inputs);
  }
  const ceil$1 = /* @__PURE__ */ op({ ceil_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function fill$1(shape, value, dtype) {
    assertNonNegativeIntegerDimensions(shape);
    dtype = dtype || inferDtype(value);
    const attrs = { shape, value, dtype };
    return ENGINE.runKernel(Fill, {}, attrs);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function clipByValue_(x, clipValueMin, clipValueMax) {
    const $x = convertToTensor(x, "x", "clipByValue");
    assert(clipValueMin <= clipValueMax, () => `Error in clip: min (${clipValueMin}) must be less than or equal to max (${clipValueMax}).`);
    if (clipValueMin === clipValueMax) {
      return fill$1($x.shape, clipValueMin, $x.dtype);
    }
    const inputs = { x: $x };
    const attrs = { clipValueMin, clipValueMax };
    return ENGINE.runKernel(ClipByValue, inputs, attrs);
  }
  const clipByValue$1 = /* @__PURE__ */ op({ clipByValue_ });
  function concat1d_(tensors) {
    return concat$1(
      tensors,
      0
      /* axis */
    );
  }
  const concat1d = /* @__PURE__ */ op({ concat1d_ });
  function concat2d_(tensors, axis) {
    return concat$1(tensors, axis);
  }
  const concat2d = /* @__PURE__ */ op({ concat2d_ });
  function concat3d_(tensors, axis) {
    return concat$1(tensors, axis);
  }
  const concat3d = /* @__PURE__ */ op({ concat3d_ });
  function concat4d_(tensors, axis) {
    return concat$1(tensors, axis);
  }
  const concat4d = /* @__PURE__ */ op({ concat4d_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function conv2d_(x, filter, strides, pad2, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
    const $x = convertToTensor(x, "x", "conv2d", "float32");
    const $filter = convertToTensor(filter, "filter", "conv2d", "float32");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape$1($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert($filter.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
    checkPadOnDimRoundingMode("conv2d", pad2, dimRoundingMode);
    const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
    assert(inDepth === $filter.shape[2], () => `Error in conv2d: depth of input (${inDepth}) must match input depth for filter ${$filter.shape[2]}.`);
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    assert(stridesOrDilationsArePositive(dilations), () => "Error in conv2D: Dilated rates should be larger than 0.");
    assert(stridesOrDilationsArePositive(strides), () => "Error in conv2D: Strides should be larger than 0.");
    const inputs = { x: x4D, filter: $filter };
    const attrs = { strides, pad: pad2, dataFormat, dilations, dimRoundingMode };
    const res = ENGINE.runKernel(Conv2D, inputs, attrs);
    if (reshapedTo4D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  const conv2d$2 = /* @__PURE__ */ op({ conv2d_ });
  function conv1d_(x, filter, stride, pad2, dataFormat = "NWC", dilation = 1, dimRoundingMode) {
    const $x = convertToTensor(x, "x", "conv1d");
    const $filter = convertToTensor(filter, "filter", "conv1d");
    let x3D = $x;
    let reshapedTo3D = false;
    if ($x.rank === 2) {
      reshapedTo3D = true;
      x3D = reshape$1($x, [1, $x.shape[0], $x.shape[1]]);
    }
    assert(x3D.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);
    assert($filter.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${$filter.rank}.`);
    checkPadOnDimRoundingMode("conv1d", pad2, dimRoundingMode);
    assert(x3D.shape[2] === $filter.shape[1], () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match input depth for filter ${$filter.shape[1]}.`);
    assert(eitherStridesOrDilationsAreOne(stride, dilation), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${stride} and dilation '${dilation}'`);
    assert(stridesOrDilationsArePositive(dilation), () => "Error in conv1D: Dilated rates should be larger than 0.");
    assert(stridesOrDilationsArePositive(stride), () => "Error in conv1D: Stride should be larger than 0.");
    assert(dataFormat === "NWC", () => `Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);
    const filter4D = reshape$1($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);
    const input4D = reshape$1(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);
    const strides = [1, stride];
    const dilations = [1, dilation];
    const conv2dDataFormat = "NHWC";
    const res = conv2d$2(input4D, filter4D, strides, pad2, conv2dDataFormat, dilations, dimRoundingMode);
    if (reshapedTo3D) {
      return reshape$1(res, [res.shape[2], res.shape[3]]);
    }
    return reshape$1(res, [res.shape[0], res.shape[2], res.shape[3]]);
  }
  const conv1d = /* @__PURE__ */ op({ conv1d_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function conv2DBackpropInput_(xShape, dy, filter, strides, pad2, dataFormat = "NHWC", dimRoundingMode) {
    assert(xShape.length === dy.rank, () => `Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);
    let xShape4D = xShape;
    let dy4D = dy;
    let reshapedTo4D = false;
    if (dy.rank === 3) {
      reshapedTo4D = true;
      dy4D = reshape$1(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
      xShape4D = [1, xShape[0], xShape[1], xShape[2]];
    }
    assert(xShape4D.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${xShape4D.length}.`);
    assert(dy4D.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${dy4D.rank}`);
    assert(filter.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${filter.rank}`);
    const inDepth = dataFormat === "NHWC" ? xShape4D[3] : xShape4D[1];
    const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
    assert(inDepth === filter.shape[2], () => `Error in conv2dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter.shape[2]}.`);
    assert(outDepth === filter.shape[3], () => `Error in conv2dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter.shape[3]}.`);
    checkPadOnDimRoundingMode("conv2dDerInput", pad2, dimRoundingMode);
    const inputs = { dy: dy4D, filter };
    const attrs = { strides, pad: pad2, dataFormat, dimRoundingMode, inputShape: xShape4D };
    const res = ENGINE.runKernel(Conv2DBackpropInput, inputs, attrs);
    if (reshapedTo4D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  const conv2DBackpropInput$1 = /* @__PURE__ */ op({ conv2DBackpropInput_ });
  function conv2dTranspose_(x, filter, outputShape, strides, pad2, dimRoundingMode) {
    const $x = convertToTensor(x, "x", "conv2dTranspose");
    const $filter = convertToTensor(filter, "filter", "conv2dTranspose");
    return conv2DBackpropInput$1(outputShape, $x, $filter, strides, pad2, "NHWC", dimRoundingMode);
  }
  const conv2dTranspose = /* @__PURE__ */ op({ conv2dTranspose_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function conv3d_(x, filter, strides, pad2, dataFormat = "NDHWC", dilations = [1, 1, 1]) {
    const $x = convertToTensor(x, "x", "conv3d");
    const $filter = convertToTensor(filter, "filter", "conv3d");
    let x5D = $x;
    let reshapedTo5D = false;
    if ($x.rank === 4) {
      reshapedTo5D = true;
      x5D = reshape$1($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
    }
    assert(x5D.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${x5D.rank}.`);
    assert($filter.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${$filter.rank}.`);
    assert(x5D.shape[4] === $filter.shape[3], () => `Error in conv3d: depth of input (${x5D.shape[4]}) must match input depth for filter ${$filter.shape[3]}.`);
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    assert(dataFormat === "NDHWC", () => `Error in conv3d: got dataFormat of ${dataFormat} but only NDHWC is currently supported.`);
    assert(stridesOrDilationsArePositive(dilations), () => "Error in conv3D: Dilated rates should be larger than 0.");
    assert(stridesOrDilationsArePositive(strides), () => "Error in conv3D: Strides should be larger than 0.");
    const inputs = { x: x5D, filter: $filter };
    const attrs = { strides, pad: pad2, dataFormat, dilations };
    const res = ENGINE.runKernel(Conv3D, inputs, attrs);
    if (reshapedTo5D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  const conv3d = /* @__PURE__ */ op({ conv3d_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function conv3DBackpropInput_(xShape, dy, filter, strides, pad2) {
    assert(xShape.length === dy.rank, () => `Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);
    let xShape5D = xShape;
    let dy5D = dy;
    let reshapedTo5D = false;
    if (dy.rank === 4) {
      reshapedTo5D = true;
      dy5D = reshape$1(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]]);
      xShape5D = [1, xShape[0], xShape[1], xShape[2], xShape[3]];
    }
    const inDepth = xShape5D[4];
    const outDepth = dy5D.shape[4];
    assert(xShape5D.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${xShape5D.length}.`);
    assert(dy5D.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${dy5D.rank}`);
    assert(filter.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${filter.rank}`);
    assert(inDepth === filter.shape[3], () => `Error in conv3dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter.shape[3]}.`);
    assert(outDepth === filter.shape[4], () => `Error in conv3dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter.shape[4]}.`);
    const inputs = { dy: dy5D, filter };
    const attrs = { pad: pad2, strides, inputShape: xShape5D };
    const res = ENGINE.runKernel(Conv3DBackpropInputV2, inputs, attrs);
    if (reshapedTo5D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  const conv3DBackpropInput$1 = /* @__PURE__ */ op({ conv3DBackpropInput_ });
  function conv3dTranspose_(x, filter, outputShape, strides, pad2) {
    const $x = convertToTensor(x, "x", "conv3dTranspose");
    const $filter = convertToTensor(filter, "filter", "conv3dTranspose");
    return conv3DBackpropInput$1(outputShape, $x, $filter, strides, pad2);
  }
  const conv3dTranspose = /* @__PURE__ */ op({ conv3dTranspose_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function cos_(x) {
    const $x = convertToTensor(x, "x", "cos", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Cos, inputs);
  }
  const cos$1 = /* @__PURE__ */ op({ cos_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function cosh_(x) {
    const $x = convertToTensor(x, "x", "cosh", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Cosh, inputs);
  }
  const cosh$1 = /* @__PURE__ */ op({ cosh_ });
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the 'License');
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an 'AS IS' BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function cumprod_(x, axis = 0, exclusive = false, reverse2 = false) {
    const $x = convertToTensor(x, "x", "cumprod");
    const inputs = { x: $x };
    const attrs = { axis, exclusive, reverse: reverse2 };
    return ENGINE.runKernel(Cumprod, inputs, attrs);
  }
  const cumprod$1 = /* @__PURE__ */ op({ cumprod_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function cumsum_(x, axis = 0, exclusive = false, reverse2 = false) {
    const $x = convertToTensor(x, "x", "cumsum");
    const inputs = { x: $x };
    const attrs = { axis, exclusive, reverse: reverse2 };
    return ENGINE.runKernel(Cumsum, inputs, attrs);
  }
  const cumsum$1 = /* @__PURE__ */ op({ cumsum_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function denseBincount_(x, weights, size, binaryOutput = false) {
    const $x = convertToTensor(x, "x", "denseBincount");
    const $weights = convertToTensor(weights, "weights", "denseBincount");
    assert($x.dtype === "int32", () => `Error in denseBincount: input dtype must be int32, but got ${$x.dtype}`);
    assert($x.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got rank ${$x.rank}.`);
    assert(size >= 0, () => `size must be non-negative, but got ${size}.`);
    assert($weights.size === $x.size || $weights.size === 0, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${$x.shape}, weights shape: ${$weights.shape}.`);
    const inputs = { x: $x, weights: $weights };
    const attrs = { size, binaryOutput };
    return ENGINE.runKernel(DenseBincount, inputs, attrs);
  }
  const denseBincount$1 = /* @__PURE__ */ op({ denseBincount_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function depthToSpace_(x, blockSize, dataFormat = "NHWC") {
    const $x = convertToTensor(x, "x", "depthToSpace", "float32");
    const inputHeight = dataFormat === "NHWC" ? $x.shape[1] : $x.shape[2];
    const inputWidth = dataFormat === "NHWC" ? $x.shape[2] : $x.shape[3];
    const inputDepth = dataFormat === "NHWC" ? $x.shape[3] : $x.shape[1];
    assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
    assert(inputHeight * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputHeight} and ${blockSize}  for depthToSpace with input shape
    ${$x.shape}`);
    assert(inputWidth * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputWidth} and ${blockSize} for depthToSpace with input shape
        ${$x.shape}`);
    assert(inputDepth % (blockSize * blockSize) === 0, () => `Dimension size must be evenly divisible by ${blockSize * blockSize} but is ${inputDepth} for depthToSpace with input shape ${$x.shape}`);
    const inputs = { x: $x };
    const attrs = { blockSize, dataFormat };
    return ENGINE.runKernel(DepthToSpace, inputs, attrs);
  }
  const depthToSpace$1 = /* @__PURE__ */ op({ depthToSpace_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function depthwiseConv2d_(x, filter, strides, pad2, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
    const $x = convertToTensor(x, "x", "depthwiseConv2d", "float32");
    const $filter = convertToTensor(filter, "filter", "depthwiseConv2d", "float32");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape$1($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert($filter.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
    const inChannels = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
    assert(inChannels === $filter.shape[2], () => `Error in depthwiseConv2d: number of input channels (${inChannels}) must match the inChannels dimension in filter ${$filter.shape[2]}.`);
    checkPadOnDimRoundingMode("depthwiseConv2d", pad2, dimRoundingMode);
    const inputs = { x: x4D, filter: $filter };
    const attrs = { strides, pad: pad2, dataFormat, dilations, dimRoundingMode };
    const res = ENGINE.runKernel(DepthwiseConv2dNative, inputs, attrs);
    if (reshapedTo4D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  const depthwiseConv2d$1 = /* @__PURE__ */ op({ depthwiseConv2d_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function diag_(x) {
    const $x = convertToTensor(x, "x", "diag");
    const inputs = { x: $x };
    return ENGINE.runKernel(Diag, inputs);
  }
  const diag$1 = /* @__PURE__ */ op({ diag_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function dilation2d_(x, filter, strides, pad2, dilations = [1, 1], dataFormat = "NHWC") {
    const $x = convertToTensor(x, "x", "dilation2d");
    const $filter = convertToTensor(filter, "filter", "dilation2d");
    assert($x.rank === 3 || $x.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${$x.rank}.`);
    assert($filter.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${$filter.rank}.`);
    assert(dataFormat === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${dataFormat}`);
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      x4D = reshape$1($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
      reshapedTo4D = true;
    }
    assert(x4D.shape[3] === $filter.shape[2], () => `Error in dilation2d:  input and filter must have the same depth: ${x4D.shape[3]} vs ${$filter.shape[2]}`);
    const inputs = { x: x4D, filter: $filter };
    const attrs = { strides, pad: pad2, dilations };
    const res = ENGINE.runKernel(Dilation2D, inputs, attrs);
    if (reshapedTo4D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  const dilation2d = /* @__PURE__ */ op({ dilation2d_ });
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getBroadcastDims$1(inShape, outShape) {
    const inRank = inShape.length;
    const dims = [];
    for (let i = 0; i < inRank; i++) {
      const dim = inRank - 1 - i;
      const a = inShape[dim] || 1;
      const b = outShape[outShape.length - 1 - i] || 1;
      if (b > 1 && a === 1) {
        dims.unshift(dim);
      }
    }
    return dims;
  }
  function getReductionAxes(inShape, outShape) {
    const result = [];
    for (let i = 0; i < outShape.length; i++) {
      const inDim = inShape[inShape.length - i - 1];
      const outAxis = outShape.length - i - 1;
      const outDim = outShape[outAxis];
      if (inDim == null || inDim === 1 && outDim > 1) {
        result.unshift(outAxis);
      }
    }
    return result;
  }
  function assertAndGetBroadcastShape(shapeA, shapeB) {
    const l = Math.max(shapeA.length, shapeB.length);
    const result = new Array(l);
    for (let i = 0; i < l; i++) {
      let a = shapeA[shapeA.length - i - 1];
      if (a == null) {
        a = 1;
      }
      let b = shapeB[shapeB.length - i - 1];
      if (b == null) {
        b = 1;
      }
      if (a === 1) {
        result[l - i - 1] = b;
      } else if (b === 1) {
        result[l - i - 1] = a;
      } else if (a !== b) {
        const errMsg = `Operands could not be broadcast together with shapes ${shapeA} and ${shapeB}.`;
        throw Error(errMsg);
      } else {
        result[l - i - 1] = a;
      }
    }
    return result;
  }
  const broadcast_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    assertAndGetBroadcastShape,
    getBroadcastDims: getBroadcastDims$1,
    getReductionAxes
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function equal_(a, b) {
    let $a = convertToTensor(a, "a", "equal", "string_or_numeric");
    let $b = convertToTensor(b, "b", "equal", "string_or_numeric");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Equal, inputs);
  }
  const equal$1 = /* @__PURE__ */ op({ equal_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function where_(condition, a, b) {
    const $a = convertToTensor(a, "a", "where");
    const $b = convertToTensor(b, "b", "where");
    const $condition = convertToTensor(condition, "condition", "where", "bool");
    const broadcastShape = assertAndGetBroadcastShape(assertAndGetBroadcastShape($condition.shape, $a.shape), $b.shape);
    const $broadcastedCondition = broadcastTo($condition, broadcastShape);
    const $broadcastedA = broadcastTo($a, broadcastShape);
    const $broadcastedB = broadcastTo($b, broadcastShape);
    const inputs = {
      condition: $broadcastedCondition,
      t: $broadcastedA,
      e: $broadcastedB
    };
    return ENGINE.runKernel(Select, inputs);
  }
  const where = /* @__PURE__ */ op({ where_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function zerosLike_(x) {
    const $x = convertToTensor(x, "x", "zerosLike");
    const inputs = { x: $x };
    return ENGINE.runKernel(ZerosLike, inputs);
  }
  const zerosLike$1 = /* @__PURE__ */ op({ zerosLike_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function divNoNan_(a, b) {
    let $a = convertToTensor(a, "a", "div");
    let $b = convertToTensor(b, "b", "div");
    [$a, $b] = makeTypesMatch($a, $b);
    const divResult = div($a, $b);
    const zeros2 = zerosLike$1(divResult);
    const bEqualsZero = equal$1($b, zeros2);
    return where(bEqualsZero, zeros2, divResult);
  }
  const divNoNan = /* @__PURE__ */ op({ divNoNan_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function dot_(t1, t2) {
    const $t1 = convertToTensor(t1, "t1", "dot");
    const $t2 = convertToTensor(t2, "t2", "dot");
    assert(($t1.rank === 1 || $t1.rank === 2) && ($t2.rank === 1 || $t2.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${$t1.rank} and ${$t2.rank}.`);
    const t1Inner = $t1.rank === 1 ? $t1.size : $t1.shape[1];
    const t2Inner = $t2.rank === 1 ? $t2.size : $t2.shape[0];
    assert(t1Inner === t2Inner, () => `Error in dot: inner dimensions of inputs must match, but got ${t1Inner} and ${t2Inner}.`);
    if ($t1.rank === 1 && $t2.rank === 1) {
      const t12D = reshape$1($t1, [1, -1]);
      const t22D = reshape$1($t2, [-1, 1]);
      const t1t2 = matMul$1(t12D, t22D);
      return reshape$1(t1t2, []);
    } else if ($t1.rank === 1 && $t2.rank === 2) {
      const t12D = reshape$1($t1, [1, -1]);
      const t22D = reshape$1($t2, [$t2.shape[0], $t2.shape[1]]);
      const t1t2 = matMul$1(t12D, t22D);
      return reshape$1(t1t2, [t1t2.size]);
    } else if ($t1.rank === 2 && $t2.rank === 1) {
      const t22D = reshape$1($t2, [-1, 1]);
      const t1t2 = matMul$1($t1, t22D);
      return reshape$1(t1t2, [t1t2.size]);
    } else {
      const t22D = reshape$1($t2, [$t2.shape[0], $t2.shape[1]]);
      const t1t2 = matMul$1($t1, t22D);
      return t1t2;
    }
  }
  const dot = /* @__PURE__ */ op({ dot_ });
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function einsum_(equation, ...tensors) {
    const $tensors = tensors.map((t, i) => convertToTensor(t, `tensors${i}`, "einsum"));
    const attrs = { equation };
    return ENGINE.runKernel(Einsum, $tensors, attrs);
  }
  const einsum$1 = /* @__PURE__ */ op({ einsum_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function elu_(x) {
    const $x = convertToTensor(x, "x", "elu", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Elu, inputs);
  }
  const elu$1 = /* @__PURE__ */ op({ elu_ });
  /**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function ensureShape_(x, shape) {
    const $x = convertToTensor(x, "x", "ensureShape", "string_or_numeric");
    if (!arraysEqualWithNull($x.shape, shape)) {
      throw new Error(`EnsureShape: Shape of tensor ${$x.shape} is not compatible with expected shape ${shape}`);
    }
    return x;
  }
  const ensureShape = /* @__PURE__ */ op({ ensureShape_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function erf_(x) {
    let $x = convertToTensor(x, "x", "erf");
    assert($x.dtype === "int32" || $x.dtype === "float32", () => "Input dtype must be `int32` or `float32`.");
    if ($x.dtype === "int32") {
      $x = cast$1($x, "float32");
    }
    const inputs = { x: $x };
    return ENGINE.runKernel(Erf, inputs);
  }
  const erf$1 = /* @__PURE__ */ op({ erf_ });
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function axesAreInnerMostDims(axes, rank) {
    for (let i = 0; i < axes.length; ++i) {
      if (axes[axes.length - i - 1] !== rank - 1 - i) {
        return false;
      }
    }
    return true;
  }
  function combineLocations(outputLoc, reduceLoc, axes) {
    const rank = outputLoc.length + reduceLoc.length;
    const loc = [];
    let outIdx = 0;
    let reduceIdx = 0;
    for (let dim = 0; dim < rank; dim++) {
      if (axes.indexOf(dim) === -1) {
        loc.push(outputLoc[outIdx++]);
      } else {
        loc.push(reduceLoc[reduceIdx++]);
      }
    }
    return loc;
  }
  function computeOutAndReduceShapes(aShape, axes) {
    const outShape = [];
    const rank = aShape.length;
    for (let dim = 0; dim < rank; dim++) {
      if (axes.indexOf(dim) === -1) {
        outShape.push(aShape[dim]);
      }
    }
    const reduceShape = axes.map((dim) => aShape[dim]);
    return [outShape, reduceShape];
  }
  function expandShapeToKeepDim(shape, axes) {
    const reduceSubShape = axes.map((x) => 1);
    return combineLocations(shape, reduceSubShape, axes);
  }
  function assertAxesAreInnerMostDims(msg, axes, rank) {
    assert(axesAreInnerMostDims(axes, rank), () => `${msg} supports only inner-most axes for now. Got axes ${axes} and rank-${rank} input.`);
  }
  function getAxesPermutation(axes, rank) {
    if (axesAreInnerMostDims(axes, rank)) {
      return null;
    }
    const result = [];
    for (let i = 0; i < rank; ++i) {
      if (axes.indexOf(i) === -1) {
        result.push(i);
      }
    }
    axes.forEach((axis) => result.push(axis));
    return result;
  }
  function getUndoAxesPermutation(axes) {
    return axes.map((axis, i) => [i, axis]).sort((a, b) => a[1] - b[1]).map((x) => x[0]);
  }
  function getInnerMostAxes(numAxes, rank) {
    const res = [];
    for (let i = rank - numAxes; i < rank; ++i) {
      res.push(i);
    }
    return res;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function max_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, "x", "max");
    const inputs = { x: $x };
    const attrs = { reductionIndices: axis, keepDims };
    return ENGINE.runKernel(Max, inputs, attrs);
  }
  const max$1 = /* @__PURE__ */ op({ max_ });
  /**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function min_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, "x", "min");
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Min, inputs, attrs);
  }
  const min$1 = /* @__PURE__ */ op({ min_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function pow_(base, exp2) {
    let $base = convertToTensor(base, "base", "pow");
    let $exp = convertToTensor(exp2, "exp", "pow");
    [$base, $exp] = makeTypesMatch($base, $exp);
    const inputs = { a: $base, b: $exp };
    return ENGINE.runKernel(Pow, inputs);
  }
  const pow$1 = /* @__PURE__ */ op({ pow_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function scalar(value, dtype) {
    if ((isTypedArray(value) && dtype !== "string" || Array.isArray(value)) && dtype !== "complex64") {
      throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    }
    if (dtype === "string" && isTypedArray(value) && !(value instanceof Uint8Array)) {
      throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    }
    const shape = [];
    const inferredShape = [];
    return makeTensor(value, shape, inferredShape, dtype);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sqrt_(x) {
    const $x = convertToTensor(x, "x", "sqrt", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sqrt, inputs);
  }
  const sqrt$1 = /* @__PURE__ */ op({ sqrt_ });
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function square_(x) {
    const $x = convertToTensor(x, "x", "square");
    const attrs = {};
    return ENGINE.runKernel("Square", { x: $x }, attrs);
  }
  const square$1 = /* @__PURE__ */ op({ square_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sum_(x, axis = null, keepDims = false) {
    let $x = convertToTensor(x, "x", "sum");
    if ($x.dtype === "bool") {
      $x = cast$1($x, "int32");
    }
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Sum, inputs, attrs);
  }
  const sum$1 = /* @__PURE__ */ op({ sum_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function norm_(x, ord = "euclidean", axis = null, keepDims = false) {
    x = convertToTensor(x, "x", "norm");
    const norm2 = normImpl(x, ord, axis);
    let keepDimsShape = norm2.shape;
    if (keepDims) {
      const axes = parseAxisParam(axis, x.shape);
      keepDimsShape = expandShapeToKeepDim(norm2.shape, axes);
    }
    return reshape$1(norm2, keepDimsShape);
  }
  function normImpl(x, p, axis = null) {
    if (x.rank === 0) {
      return abs$1(x);
    }
    if (x.rank !== 1 && axis === null) {
      return normImpl(reshape$1(x, [-1]), p, axis);
    }
    if (x.rank === 1 || typeof axis === "number" || Array.isArray(axis) && axis.length === 1) {
      if (p === 1) {
        return sum$1(abs$1(x), axis);
      }
      if (p === Infinity) {
        return max$1(abs$1(x), axis);
      }
      if (p === -Infinity) {
        return min$1(abs$1(x), axis);
      }
      if (p === "euclidean" || p === 2) {
        return sqrt$1(sum$1(pow$1(abs$1(x), scalar(2, "int32")), axis));
      }
      throw new Error(`Error in norm: invalid ord value: ${p}`);
    }
    if (Array.isArray(axis) && axis.length === 2) {
      if (p === 1) {
        return max$1(sum$1(abs$1(x), axis[0]), axis[1] - 1);
      }
      if (p === Infinity) {
        return max$1(sum$1(abs$1(x), axis[1]), axis[0]);
      }
      if (p === -Infinity) {
        return min$1(sum$1(abs$1(x), axis[1]), axis[0]);
      }
      if (p === "fro" || p === "euclidean") {
        return sqrt$1(sum$1(square$1(x), axis));
      }
      throw new Error(`Error in norm: invalid ord value: ${p}`);
    }
    throw new Error(`Error in norm: invalid axis: ${axis}`);
  }
  const norm = /* @__PURE__ */ op({ norm_ });
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function euclideanNorm_(x, axis = null, keepDims = false) {
    return norm(x, "euclidean", axis, keepDims);
  }
  const euclideanNorm = /* @__PURE__ */ op({ euclideanNorm_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function exp_(x) {
    const $x = convertToTensor(x, "x", "exp");
    const inputs = { x: $x };
    return ENGINE.runKernel(Exp, inputs);
  }
  const exp$1 = /* @__PURE__ */ op({ exp_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function expandDims_(x, axis = 0) {
    const $x = convertToTensor(x, "x", "expandDims", "string_or_numeric");
    assert(axis <= $x.rank, () => "Axis must be <= rank of the tensor");
    const inputs = { input: $x };
    const attrs = { dim: axis };
    return ENGINE.runKernel(ExpandDims, inputs, attrs);
  }
  const expandDims$1 = /* @__PURE__ */ op({ expandDims_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function expm1_(x) {
    const $x = convertToTensor(x, "x", "expm1");
    const inputs = { x: $x };
    return ENGINE.runKernel(Expm1, inputs);
  }
  const expm1$1 = /* @__PURE__ */ op({ expm1_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tile_(x, reps) {
    const $x = convertToTensor(x, "x", "tile", "string_or_numeric");
    assert($x.rank === reps.length, () => `Error in transpose: rank of input ${$x.rank} must match length of reps ${reps}.`);
    const inputs = { x: $x };
    const attrs = { reps };
    return ENGINE.runKernel(Tile, inputs, attrs);
  }
  const tile$1 = /* @__PURE__ */ op({ tile_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function eye_(numRows, numColumns, batchShape, dtype = "float32") {
    if (numColumns == null) {
      numColumns = numRows;
    }
    const buff = buffer([numRows, numColumns], dtype);
    const n = numRows <= numColumns ? numRows : numColumns;
    for (let i = 0; i < n; ++i) {
      buff.set(1, i, i);
    }
    const out = reshape$1(buff.toTensor(), [numRows, numColumns]);
    if (batchShape == null) {
      return out;
    } else {
      if (batchShape.length === 1) {
        return tile$1(expandDims$1(out, 0), [batchShape[0], 1, 1]);
      } else if (batchShape.length === 2) {
        return tile$1(expandDims$1(expandDims$1(out, 0), 0), [batchShape[0], batchShape[1], 1, 1]);
      } else if (batchShape.length === 3) {
        return tile$1(expandDims$1(expandDims$1(expandDims$1(out, 0), 0), 0), [
          batchShape[0],
          batchShape[1],
          batchShape[2],
          1,
          1
        ]);
      } else {
        throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${batchShape.length}D.`);
      }
    }
  }
  const eye = /* @__PURE__ */ op({ eye_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function floor_(x) {
    const $x = convertToTensor(x, "x", "floor", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Floor, inputs);
  }
  const floor$1 = /* @__PURE__ */ op({ floor_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function gather_(x, indices, axis = 0, batchDims = 0) {
    const $x = convertToTensor(x, "x", "gather");
    const $indices = convertToTensor(indices, "indices", "gather", "int32");
    const inputs = { x: $x, indices: $indices };
    const attrs = { axis, batchDims };
    return ENGINE.runKernel(GatherV2, inputs, attrs);
  }
  const gather = /* @__PURE__ */ op({ gather_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function greater_(a, b) {
    let $a = convertToTensor(a, "a", "greater", "string_or_numeric");
    let $b = convertToTensor(b, "b", "greater", "string_or_numeric");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Greater, inputs);
  }
  const greater$1 = /* @__PURE__ */ op({ greater_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function greaterEqual_(a, b) {
    let $a = convertToTensor(a, "a", "greaterEqual", "string_or_numeric");
    let $b = convertToTensor(b, "b", "greaterEqual", "string_or_numeric");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(GreaterEqual, inputs);
  }
  const greaterEqual$1 = /* @__PURE__ */ op({ greaterEqual_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function imag_(input) {
    const $input = convertToTensor(input, "input", "imag");
    const inputs = { input: $input };
    return ENGINE.runKernel(Imag, inputs);
  }
  const imag$1 = /* @__PURE__ */ op({ imag_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function isFinite_(x) {
    const $x = convertToTensor(x, "x", "isFinite");
    const inputs = { x: $x };
    return ENGINE.runKernel(IsFinite, inputs);
  }
  const isFinite$2 = /* @__PURE__ */ op({ isFinite_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function isInf_(x) {
    const $x = convertToTensor(x, "x", "isInf");
    const inputs = { x: $x };
    return ENGINE.runKernel(IsInf, inputs);
  }
  const isInf$1 = /* @__PURE__ */ op({ isInf_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function isNaN_(x) {
    const $x = convertToTensor(x, "x", "isNaN");
    const inputs = { x: $x };
    return ENGINE.runKernel(IsNan, inputs);
  }
  const isNaN$2 = /* @__PURE__ */ op({ isNaN_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function leakyRelu_(x, alpha = 0.2) {
    const $x = convertToTensor(x, "x", "leakyRelu");
    const inputs = { x: $x };
    const attrs = { alpha };
    return ENGINE.runKernel(LeakyRelu, inputs, attrs);
  }
  const leakyRelu$1 = /* @__PURE__ */ op({ leakyRelu_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function less_(a, b) {
    let $a = convertToTensor(a, "a", "less", "string_or_numeric");
    let $b = convertToTensor(b, "b", "less", "string_or_numeric");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Less, inputs);
  }
  const less$1 = /* @__PURE__ */ op({ less_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function lessEqual_(a, b) {
    let $a = convertToTensor(a, "a", "lessEqual", "string_or_numeric");
    let $b = convertToTensor(b, "b", "lessEqual", "string_or_numeric");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(LessEqual, inputs);
  }
  const lessEqual$1 = /* @__PURE__ */ op({ lessEqual_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function linspace(start, stop, num) {
    if (num <= 0) {
      throw new Error("The number of values should be positive.");
    }
    const attrs = { start, stop, num };
    return ENGINE.runKernel(LinSpace, {}, attrs);
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function localResponseNormalization_(x, depthRadius = 5, bias = 1, alpha = 1, beta = 0.5) {
    const $x = convertToTensor(x, "x", "localResponseNormalization");
    assert($x.rank === 4 || $x.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${$x.rank}.`);
    assert(isInt(depthRadius), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${depthRadius}.`);
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape$1($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    const inputs = { x: x4D };
    const attrs = { depthRadius, bias, alpha, beta };
    const res = ENGINE.runKernel(LRN, inputs, attrs);
    if (reshapedTo4D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
    } else {
      return res;
    }
  }
  const localResponseNormalization = /* @__PURE__ */ op({ localResponseNormalization_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function log_(x) {
    const $x = convertToTensor(x, "x", "log", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Log, inputs);
  }
  const log$1 = /* @__PURE__ */ op({ log_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function log1p_(x) {
    const $x = convertToTensor(x, "x", "log1p");
    const inputs = { x: $x };
    return ENGINE.runKernel(Log1p, inputs);
  }
  const log1p$1 = /* @__PURE__ */ op({ log1p_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function grad(f) {
    assert(isFunction(f), () => "The f passed in grad(f) must be a function");
    return (x, dy) => {
      const $x = convertToTensor(x, "x", "tf.grad", "string_or_numeric");
      const $dy = dy != null ? convertToTensor(dy, "dy", "tf.grad") : null;
      return ENGINE.tidy(() => {
        const { value, grads: grads2 } = ENGINE.gradients(() => f($x), [$x], $dy);
        if ($dy != null) {
          assertShapesMatch(value.shape, $dy.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)");
        }
        checkGrads(grads2);
        return grads2[0];
      });
    };
  }
  function grads(f) {
    assert(isFunction(f), () => "The f passed in grads(f) must be a function");
    return (args, dy) => {
      assert(Array.isArray(args), () => "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");
      const $args = convertToTensorArray(args, "args", "tf.grads", "string_or_numeric");
      const $dy = dy != null ? convertToTensor(dy, "dy", "tf.grads") : null;
      return ENGINE.tidy(() => {
        const { value, grads: grads2 } = ENGINE.gradients(() => f(...$args), $args, $dy);
        if ($dy != null) {
          assertShapesMatch(value.shape, $dy.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
        }
        checkGrads(grads2);
        return grads2;
      });
    };
  }
  function valueAndGrad(f) {
    assert(isFunction(f), () => "The f passed in valueAndGrad(f) must be a function");
    return (x, dy) => {
      assert(x instanceof Tensor, () => "The x passed in valueAndGrad(f)(x) must be a tensor");
      assert(dy == null || dy instanceof Tensor, () => "The dy passed in valueAndGrad(f)(x, dy) must be a tensor");
      const { grads: grads2, value } = ENGINE.gradients(() => f(x), [x], dy);
      checkGrads(grads2);
      return { grad: grads2[0], value };
    };
  }
  function valueAndGrads(f) {
    assert(isFunction(f), () => "The f passed in valueAndGrads(f) must be a function");
    return (args, dy) => {
      assert(Array.isArray(args) && args.every((arg) => arg instanceof Tensor), () => "The args passed in valueAndGrads(f)(args) must be array of tensors");
      assert(dy == null || dy instanceof Tensor, () => "The dy passed in valueAndGrads(f)(args, dy) must be a tensor");
      const res = ENGINE.gradients(() => f(...args), args, dy);
      if (dy != null) {
        assertShapesMatch(res.value.shape, dy.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
      }
      checkGrads(res.grads);
      return res;
    };
  }
  function variableGrads(f, varList) {
    assert(isFunction(f), () => "The f passed in variableGrads(f) must be a function");
    assert(varList == null || Array.isArray(varList) && varList.every((v) => v instanceof Variable), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
    const specifiedVarList = varList != null;
    if (!specifiedVarList) {
      varList = [];
      for (const varName in ENGINE.registeredVariables) {
        varList.push(ENGINE.registeredVariables[varName]);
      }
    }
    const specifiedNonTrainable = specifiedVarList ? varList.filter((variable2) => !variable2.trainable) : null;
    const originalVarCount = varList.length;
    varList = varList.filter((variable2) => variable2.trainable);
    assert(varList.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${originalVarCount} variables is trainable.`);
    const allowNoGradients = true;
    const { value, grads: grads2 } = ENGINE.gradients(f, varList, null, allowNoGradients);
    assert(grads2.some((g) => g != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().");
    assert(value.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${value.rank} tensor`);
    const namedGrads = {};
    varList.forEach((v, i) => {
      if (grads2[i] != null) {
        namedGrads[v.name] = grads2[i];
      }
    });
    if (specifiedNonTrainable != null) {
      specifiedNonTrainable.forEach((v) => namedGrads[v.name] = null);
    }
    return { value, grads: namedGrads };
  }
  function customGrad(f) {
    return ENGINE.customGrad(f);
  }
  function checkGrads(grads2) {
    const numNullGradients = grads2.filter((g) => g == null).length;
    if (numNullGradients > 0) {
      throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`);
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function neg_(x) {
    const $x = convertToTensor(x, "x", "neg");
    const inputs = { x: $x };
    return ENGINE.runKernel(Neg, inputs);
  }
  const neg$1 = /* @__PURE__ */ op({ neg_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function softplus_(x) {
    const $x = convertToTensor(x, "x", "softplus");
    const inputs = { x: $x };
    return ENGINE.runKernel(Softplus, inputs);
  }
  const softplus$1 = /* @__PURE__ */ op({ softplus_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function logSigmoid_(x) {
    const $x = convertToTensor(x, "x", "logSigmoid");
    const customOp = customGrad((x2) => {
      const value = neg$1(softplus$1(neg$1(x2)));
      const gradFunc = (dy) => {
        const derX = mul(dy, sigmoid$1(neg$1(x2)));
        return derX;
      };
      return { value, gradFunc };
    });
    return customOp($x);
  }
  const logSigmoid = /* @__PURE__ */ op({ logSigmoid_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sub_(a, b) {
    let $a = convertToTensor(a, "a", "sub");
    let $b = convertToTensor(b, "b", "sub");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Sub, inputs);
  }
  const sub$1 = /* @__PURE__ */ op({ sub_ });
  /**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function logSoftmax_(logits, axis = -1) {
    const $logits = convertToTensor(logits, "logits", "logSoftmax");
    if (axis === -1) {
      axis = $logits.rank - 1;
    }
    if (axis !== $logits.rank - 1) {
      throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and axis was ${axis}`);
    }
    const customOp = customGrad((logits2, save) => {
      const keepDims = true;
      const xMax = max$1(logits2, axis, true);
      const shifted = sub$1(logits2, xMax);
      const value = sub$1(cast$1(shifted, "float32"), log$1(sum$1(exp$1(shifted), axis, keepDims)));
      save([value]);
      const gradFunc = (dy, saved) => {
        const [value2] = saved;
        const keepDims2 = true;
        const softmax2 = exp$1(value2);
        return sub$1(dy, mul(sum$1(dy, axis, keepDims2), softmax2));
      };
      return { value, gradFunc };
    });
    return customOp($logits);
  }
  const logSoftmax = /* @__PURE__ */ op({ logSoftmax_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function logSumExp_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, "x", "logSumExp");
    const axes = parseAxisParam(axis, $x.shape);
    const xMax = max$1(
      $x,
      axes,
      true
      /* keepDims */
    );
    const a = sub$1($x, xMax);
    const b = exp$1(a);
    const c = sum$1(b, axes);
    const d = log$1(c);
    const res = add(reshape$1(xMax, d.shape), d);
    if (keepDims) {
      const newShape = expandShapeToKeepDim(res.shape, axes);
      return reshape$1(res, newShape);
    }
    return res;
  }
  const logSumExp = /* @__PURE__ */ op({ logSumExp_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function logicalAnd_(a, b) {
    const $a = convertToTensor(a, "a", "logicalAnd", "bool");
    const $b = convertToTensor(b, "b", "logicalAnd", "bool");
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(LogicalAnd, inputs);
  }
  const logicalAnd$1 = /* @__PURE__ */ op({ logicalAnd_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function logicalNot_(x) {
    const $x = convertToTensor(x, "x", "logicalNot", "bool");
    const inputs = { x: $x };
    return ENGINE.runKernel(LogicalNot, inputs);
  }
  const logicalNot$1 = /* @__PURE__ */ op({ logicalNot_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function logicalOr_(a, b) {
    const $a = convertToTensor(a, "a", "logicalOr", "bool");
    const $b = convertToTensor(b, "b", "logicalOr", "bool");
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(LogicalOr, inputs);
  }
  const logicalOr$1 = /* @__PURE__ */ op({ logicalOr_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function logicalXor_(a, b) {
    const $a = convertToTensor(a, "a", "logicalXor", "bool");
    const $b = convertToTensor(b, "b", "logicalXor", "bool");
    assertAndGetBroadcastShape($a.shape, $b.shape);
    return logicalAnd$1(logicalOr$1(a, b), logicalNot$1(logicalAnd$1(a, b)));
  }
  const logicalXor = /* @__PURE__ */ op({ logicalXor_ });
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const INT32_MAX$1 = 2147483648;
  function searchSorted_(sortedSequence, values, side = "left") {
    const $sortedSequence = convertToTensor(sortedSequence, "sortedSequence", "searchSorted");
    const $values = convertToTensor(values, "values", "searchSorted");
    const sequenceSize = $sortedSequence.shape[$sortedSequence.shape.length - 1];
    const valuesSize = $values.shape[$values.shape.length - 1];
    const $sortedSequence2D = reshape$1($sortedSequence, [-1, sequenceSize]);
    const $values2D = reshape$1($values, [-1, valuesSize]);
    if ($sortedSequence2D.rank < 2) {
      throw new Error(`Sorted input argument must be at least 2-dimensional`);
    }
    if ($sortedSequence2D.shape[0] !== $values2D.shape[0]) {
      throw new Error(`Leading dimension of 'sortedSequence' and 'values' must match.`);
    }
    if (sizeFromShape($values2D.shape) >= INT32_MAX$1) {
      throw new Error(`values tensor size must less than ${INT32_MAX$1}`);
    }
    if ($sortedSequence2D.shape[1] >= INT32_MAX$1) {
      throw new Error(`trailing dim_size must less than ${INT32_MAX$1} for int32 output type, was ${$sortedSequence2D.shape[1]}`);
    }
    const inputs = {
      sortedSequence: $sortedSequence2D,
      values: $values2D
    };
    const attrs = { side };
    return ENGINE.runKernel(SearchSorted, inputs, attrs);
  }
  const searchSorted$1 = /* @__PURE__ */ op({ searchSorted_ });
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function lowerBound(sortedSequence, values) {
    return searchSorted$1(sortedSequence, values, "left");
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function maxPool_(x, filterSize, strides, pad2, dimRoundingMode) {
    const $x = convertToTensor(x, "x", "maxPool");
    const dilations = 1;
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape$1($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x4D.rank}.`);
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    checkPadOnDimRoundingMode("maxPool", pad2, dimRoundingMode);
    const inputs = { x: x4D };
    const attrs = { filterSize, strides, pad: pad2, dimRoundingMode };
    const res = ENGINE.runKernel(MaxPool, inputs, attrs);
    if (reshapedTo4D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  const maxPool$1 = /* @__PURE__ */ op({ maxPool_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function maxPool3d_(x, filterSize = [1, 1, 1], strides, pad2, dimRoundingMode, dataFormat = "NDHWC") {
    const $x = convertToTensor(x, "x", "maxPool3d");
    let x5D = $x;
    let reshapedTo5D = false;
    if ($x.rank === 4) {
      reshapedTo5D = true;
      x5D = reshape$1($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
    }
    assert(x5D.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
    assert(dataFormat === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`);
    checkPadOnDimRoundingMode("maxPool3d", pad2, dimRoundingMode);
    const inputs = { x: x5D };
    const attrs = { filterSize, strides, pad: pad2, dimRoundingMode, dataFormat };
    const res = ENGINE.runKernel(MaxPool3D, inputs, attrs);
    if (reshapedTo5D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  const maxPool3d$1 = /* @__PURE__ */ op({ maxPool3d_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function maxPoolWithArgmax_(x, filterSize, strides, pad2, includeBatchInIndex = false) {
    const $x = convertToTensor(x, "x", "maxPoolWithArgmax");
    const inputs = { x: $x };
    const attrs = { filterSize, strides, pad: pad2, includeBatchInIndex };
    const result = ENGINE.runKernel(MaxPoolWithArgmax, inputs, attrs);
    return { result: result[0], indexes: result[1] };
  }
  const maxPoolWithArgmax = /* @__PURE__ */ op({ maxPoolWithArgmax_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function maximum_(a, b) {
    let $a = convertToTensor(a, "a", "maximum");
    let $b = convertToTensor(b, "b", "maximum");
    [$a, $b] = makeTypesMatch($a, $b);
    if ($a.dtype === "bool") {
      $a = cast$1($a, "int32");
      $b = cast$1($b, "int32");
    }
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Maximum, inputs);
  }
  const maximum$1 = /* @__PURE__ */ op({ maximum_ });
  /**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function mean_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, "x", "mean");
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Mean, inputs, attrs);
  }
  const mean = /* @__PURE__ */ op({ mean_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function zeros(shape, dtype = "float32") {
    assertNonNegativeIntegerDimensions(shape);
    if (dtype === "complex64") {
      const real2 = zeros(shape, "float32");
      const imag2 = zeros(shape, "float32");
      return complex$1(real2, imag2);
    }
    const values = makeZerosTypedArray(sizeFromShape(shape), dtype);
    return ENGINE.makeTensor(values, shape, dtype);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function ones(shape, dtype = "float32") {
    assertNonNegativeIntegerDimensions(shape);
    if (dtype === "complex64") {
      const real2 = ones(shape, "float32");
      const imag2 = zeros(shape, "float32");
      return complex$1(real2, imag2);
    }
    const values = makeOnesTypedArray(sizeFromShape(shape), dtype);
    return ENGINE.makeTensor(values, shape, dtype);
  }
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function meshgrid(x, y, { indexing = "xy" } = {}) {
    if (indexing !== "xy" && indexing !== "ij") {
      throw new TypeError(`${indexing} is not a valid third argument to meshgrid`);
    }
    if (x === void 0) {
      return [];
    }
    let $x = convertToTensor(x, "x", "meshgrid", x instanceof Tensor ? x.dtype : "float32");
    if (y === void 0) {
      return [$x];
    }
    let $y = convertToTensor(y, "y", "meshgrid", y instanceof Tensor ? y.dtype : "float32");
    const w = sizeFromShape($x.shape);
    const h = sizeFromShape($y.shape);
    if (indexing === "xy") {
      $x = reshape$1($x, [1, -1]);
      $y = reshape$1($y, [-1, 1]);
      return [
        matMul$1(ones([h, 1], $x.dtype), $x),
        matMul$1($y, ones([1, w], $y.dtype))
      ];
    }
    $x = reshape$1($x, [-1, 1]);
    $y = reshape$1($y, [1, -1]);
    return [
      matMul$1($x, ones([1, h], $x.dtype)),
      matMul$1(ones([w, 1], $y.dtype), $y)
    ];
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function minimum_(a, b) {
    let $a = convertToTensor(a, "a", "minimum");
    let $b = convertToTensor(b, "b", "minimum");
    [$a, $b] = makeTypesMatch($a, $b);
    if ($a.dtype === "bool") {
      $a = cast$1($a, "int32");
      $b = cast$1($b, "int32");
    }
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Minimum, inputs);
  }
  const minimum$1 = /* @__PURE__ */ op({ minimum_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function mirrorPad_(x, paddings, mode) {
    assert(mode === "reflect" || mode === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${mode}.`);
    const $x = convertToTensor(x, "x", "mirrorPad");
    if ($x.rank === 0) {
      throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
    }
    assert(paddings.length === $x.rank, () => `Padding doesn't match input. Must be ${$x.rank}. Got ${paddings.length}.`);
    const shapeOffset = mode === "reflect" ? 1 : 0;
    for (let i = 0; i < $x.rank; i++) {
      assert(paddings[i].length === 2, () => `Invalid number of paddings. Must be length of 2 each.`);
      assert(paddings[i][0] >= 0 && paddings[i][0] <= $x.shape[i] - shapeOffset && paddings[i][1] >= 0 && paddings[i][1] <= $x.shape[i] - shapeOffset, () => `Padding in dimension ${i} cannot be greater than or equal to ${$x.shape[i] - shapeOffset} or less than 0 for input of shape ${$x.shape}`);
    }
    const attrs = { paddings, mode };
    const inputs = { x: $x };
    return ENGINE.runKernel(MirrorPad, inputs, attrs);
  }
  const mirrorPad = /* @__PURE__ */ op({ mirrorPad_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function mod_(a, b) {
    let $a = convertToTensor(a, "a", "mod");
    let $b = convertToTensor(b, "b", "mod");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Mod, inputs);
  }
  const mod$1 = /* @__PURE__ */ op({ mod_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function moments_(x, axis = null, keepDims = false) {
    x = convertToTensor(x, "x", "moments");
    const axes = parseAxisParam(axis, x.shape);
    const xMean = mean(x, axes, keepDims);
    let keepDimsShape = xMean.shape;
    if (!keepDims) {
      keepDimsShape = expandShapeToKeepDim(xMean.shape, axes);
    }
    const devSquared = square$1(sub$1(cast$1(x, "float32"), reshape$1(xMean, keepDimsShape)));
    const variance = mean(devSquared, axes, keepDims);
    return { mean: xMean, variance };
  }
  const moments = /* @__PURE__ */ op({ moments_ });
  function multiRNNCell_(lstmCells, data, c, h) {
    const $data = convertToTensor(data, "data", "multiRNNCell");
    const $c = convertToTensorArray(c, "c", "multiRNNCell");
    const $h = convertToTensorArray(h, "h", "multiRNNCell");
    let input = $data;
    const newStates = [];
    for (let i = 0; i < lstmCells.length; i++) {
      const output = lstmCells[i](input, $c[i], $h[i]);
      newStates.push(output[0]);
      newStates.push(output[1]);
      input = output[1];
    }
    const newC = [];
    const newH = [];
    for (let i = 0; i < newStates.length; i += 2) {
      newC.push(newStates[i]);
      newH.push(newStates[i + 1]);
    }
    return [newC, newH];
  }
  const multiRNNCell = /* @__PURE__ */ op({ multiRNNCell_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function multinomial_(logits, numSamples, seed, normalized = false) {
    const $logits = convertToTensor(logits, "logits", "multinomial");
    const numOutcomes = $logits.size;
    const origRank = $logits.rank;
    if (numOutcomes < 2) {
      throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${numOutcomes}.`);
    }
    if (origRank > 2) {
      throw new Error(`Rank of probabilities must be 1 or 2, but is ${origRank}`);
    }
    seed = seed || Math.random();
    const logits2D = origRank === 1 ? reshape$1($logits, [1, -1]) : $logits;
    const inputs = { logits: logits2D };
    const attrs = { numSamples, seed, normalized };
    const res = ENGINE.runKernel(Multinomial, inputs, attrs);
    return origRank === 1 ? reshape$1(res, [res.size]) : res;
  }
  const multinomial$1 = /* @__PURE__ */ op({ multinomial_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function notEqual_(a, b) {
    let $a = convertToTensor(a, "a", "notEqual", "string_or_numeric");
    let $b = convertToTensor(b, "b", "notEqual", "string_or_numeric");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(NotEqual, inputs);
  }
  const notEqual$1 = /* @__PURE__ */ op({ notEqual_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function oneHot_(indices, depth, onValue = 1, offValue = 0, dtype = "int32") {
    if (depth < 2) {
      throw new Error(`Error in oneHot: depth must be >=2, but it is ${depth}`);
    }
    const $indices = convertToTensor(indices, "indices", "oneHot", "int32");
    const inputs = { indices: $indices };
    const attrs = { dtype, depth, onValue, offValue };
    return ENGINE.runKernel(OneHot, inputs, attrs);
  }
  const oneHot$1 = /* @__PURE__ */ op({ oneHot_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function onesLike_(x) {
    const $x = convertToTensor(x, "x", "onesLike");
    const inputs = { x: $x };
    return ENGINE.runKernel(OnesLike, inputs);
  }
  const onesLike$1 = /* @__PURE__ */ op({ onesLike_ });
  function outerProduct_(v1, v2) {
    const $v1 = convertToTensor(v1, "v1", "outerProduct");
    const $v2 = convertToTensor(v2, "v2", "outerProduct");
    assert($v1.rank === 1 && $v2.rank === 1, () => `Error in outerProduct: inputs must be rank 1, but got ranks ${$v1.rank} and ${$v2.rank}.`);
    const v12D = reshape$1($v1, [-1, 1]);
    const v22D = reshape$1($v2, [1, -1]);
    return matMul$1(v12D, v22D);
  }
  const outerProduct = /* @__PURE__ */ op({ outerProduct_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function pad_(x, paddings, constantValue = 0) {
    const $x = convertToTensor(x, "x", "pad");
    if ($x.rank === 0) {
      throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    }
    const attrs = { paddings, constantValue };
    const inputs = { x: $x };
    return ENGINE.runKernel(PadV2, inputs, attrs);
  }
  const pad = /* @__PURE__ */ op({ pad_ });
  function pad1d_(x, paddings, constantValue = 0) {
    assert(paddings.length === 2, () => "Invalid number of paddings. Must be length of 2.");
    return pad(x, [paddings], constantValue);
  }
  const pad1d = /* @__PURE__ */ op({ pad1d_ });
  function pad2d_(x, paddings, constantValue = 0) {
    assert(paddings.length === 2 && paddings[0].length === 2 && paddings[1].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
    return pad(x, paddings, constantValue);
  }
  const pad2d = /* @__PURE__ */ op({ pad2d_ });
  function pad3d_(x, paddings, constantValue = 0) {
    assert(paddings.length === 3 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
    return pad(x, paddings, constantValue);
  }
  const pad3d = /* @__PURE__ */ op({ pad3d_ });
  function pad4d_(x, paddings, constantValue = 0) {
    assert(paddings.length === 4 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2 && paddings[3].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
    return pad(x, paddings, constantValue);
  }
  const pad4d = /* @__PURE__ */ op({ pad4d_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function spaceToBatchND_(x, blockShape, paddings) {
    const $x = convertToTensor(x, "x", "spaceToBatchND");
    assert($x.rank >= 1 + blockShape.length, () => `input rank ${$x.rank} should be > than [blockShape] ${blockShape.length}`);
    assert(paddings.length === blockShape.length, () => `paddings.shape[0] ${paddings.length} must be equal to [blockShape] ${blockShape.length}`);
    assert($x.shape.reduce((a, b, i) => {
      if (i > 0 && i <= blockShape.length) {
        return a && (b + paddings[i - 1][0] + paddings[i - 1][1]) % blockShape[i - 1] === 0;
      }
      return a;
    }, true), () => `input spatial dimensions ${$x.shape.slice(1)} with paddings ${paddings.toString()} must be divisible by blockShapes ${blockShape.toString()}`);
    const inputs = { x: $x };
    const attrs = { blockShape, paddings };
    return ENGINE.runKernel(SpaceToBatchND, inputs, attrs);
  }
  const spaceToBatchND$1 = /* @__PURE__ */ op({ spaceToBatchND_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function pool_(input, windowShape, poolingType, pad2, dilations, strides, dimRoundingMode) {
    if (dilations == null) {
      dilations = [1, 1];
    }
    if (strides == null) {
      strides = 1;
    }
    if (pad2 === 0) {
      pad2 = "valid";
    }
    const $x = convertToTensor(input, "x", "maxPool");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape$1($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in pool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = computePool2DInfo(x4D.shape, windowShape, strides, dilations, pad2);
    const dilation = [convInfo.dilationHeight, convInfo.dilationWidth];
    let basePadding;
    if (pad2 === "same") {
      basePadding = withSpaceToBatchBasePaddings([convInfo.filterHeight, convInfo.filterWidth], dilation);
    } else {
      basePadding = [[0, 0], [0, 0]];
    }
    const isDilationOne = dilation[0] === 1 && dilation[1] === 1;
    const [adjustedPadding, adjustedCrops] = requiredSpaceToBatchPaddings([convInfo.inHeight, convInfo.inWidth], dilation, basePadding);
    const convertedPad = isDilationOne ? pad2 : "valid";
    const convertedX = isDilationOne ? x4D : spaceToBatchND$1(x4D, dilation, adjustedPadding);
    const forwardOp = poolingType === "avg" ? () => avgPool$1(convertedX, windowShape, strides, convertedPad, dimRoundingMode) : () => maxPool$1(convertedX, windowShape, strides, convertedPad, dimRoundingMode);
    const y = forwardOp();
    const res = isDilationOne ? y : batchToSpaceND$1(y, dilation, adjustedCrops);
    if (reshapedTo4D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  function requiredSpaceToBatchPaddings(inputShape, blockShape, basePadding) {
    const padStart = basePadding.map((b) => b[0]);
    const origPadEnd = basePadding.map((b) => b[1]);
    const fullInputShape = inputShape.concat(padStart, origPadEnd);
    const padEndExtra = blockShape.map((b, i) => (b - fullInputShape[i] % b) % b);
    const padEnd = origPadEnd.map((s, i) => s + padEndExtra[i]);
    const paddings = blockShape.map((_, i) => [padStart[i], padEnd[i]]);
    const crops = blockShape.map((_, i) => [0, padEndExtra[i]]);
    return [paddings, crops];
  }
  function withSpaceToBatchBasePaddings(filterShape, dilation) {
    const dilatedFilterShape = filterShape.map((s, i) => {
      return s + (s - 1) * (dilation[i] - 1);
    });
    const padExtraShape = dilatedFilterShape.map((s) => s - 1);
    const padExtraStart = padExtraShape.map((s) => Math.floor(s / 2));
    const padExtraEnd = padExtraShape.map((s, i) => s - padExtraStart[i]);
    return padExtraShape.map((_, i) => {
      return [padExtraStart[i], padExtraEnd[i]];
    });
  }
  const pool = /* @__PURE__ */ op({ pool_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function prelu_(x, alpha) {
    const $x = convertToTensor(x, "x", "prelu");
    const $alpha = convertToTensor(alpha, "alpha", "prelu");
    const inputs = { x: $x, alpha: $alpha };
    return ENGINE.runKernel(Prelu, inputs);
  }
  const prelu$1 = /* @__PURE__ */ op({ prelu_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function prod_(x, axis = null, keepDims = false) {
    let $x = convertToTensor(x, "x", "prod");
    if ($x.dtype === "bool") {
      $x = cast$1($x, "int32");
    }
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Prod, inputs, attrs);
  }
  const prod$1 = /* @__PURE__ */ op({ prod_ });
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function raggedGather_(paramsNestedSplits, paramsDenseValues, indices, outputRaggedRank) {
    const $paramsNestedSplits = paramsNestedSplits.map((t, i) => convertToTensor(t, `tensors${i}`, "raggedGather", "int32"));
    const $paramsDenseValues = convertToTensor(paramsDenseValues, "paramsDenseValues", "raggedGather");
    const $indices = convertToTensor(indices, "indices", "raggedGather", "int32");
    const inputs = {
      paramsNestedSplits: $paramsNestedSplits,
      paramsDenseValues: $paramsDenseValues,
      indices: $indices
    };
    const attrs = { outputRaggedRank };
    const result = ENGINE.runKernel(RaggedGather, inputs, attrs);
    return {
      outputNestedSplits: result.slice(0, result.length - 1),
      outputDenseValues: result[result.length - 1]
    };
  }
  const raggedGather$1 = /* @__PURE__ */ op({ raggedGather_ });
  /**
   * @license
   * Copyright 2022 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function raggedRange_(starts, limits, deltas) {
    const $starts = convertToTensor(starts, "starts", "raggedRange");
    const $limits = convertToTensor(limits, "limits", "raggedRange", $starts.dtype);
    const $deltas = convertToTensor(deltas, "deltas", "raggedRange", $starts.dtype);
    const inputs = {
      starts: $starts,
      limits: $limits,
      deltas: $deltas
    };
    const result = ENGINE.runKernel(RaggedRange, inputs);
    return {
      rtNestedSplits: result[0],
      rtDenseValues: result[1]
    };
  }
  const raggedRange$1 = /* @__PURE__ */ op({ raggedRange_ });
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function raggedTensorToTensor_(shape, values, defaultValue, rowPartitionTensors, rowPartitionTypes) {
    const $shape = convertToTensor(shape, "shape", "raggedTensorToTensor", "int32");
    const $values = convertToTensor(values, "values", "raggedTensorToTensor");
    const $defaultValue = convertToTensor(defaultValue, "defaultValue", "raggedTensorToTensor", $values.dtype);
    const $rowPartitionTensors = rowPartitionTensors.map((t, i) => convertToTensor(t, `tensors${i}`, "raggedTensorToTensor", "int32"));
    const inputs = {
      shape: $shape,
      values: $values,
      defaultValue: $defaultValue,
      rowPartitionTensors: $rowPartitionTensors
    };
    const attrs = { rowPartitionTypes };
    return ENGINE.runKernel(RaggedTensorToTensor, inputs, attrs);
  }
  const raggedTensorToTensor$1 = /* @__PURE__ */ op({ raggedTensorToTensor_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function rand_(shape, randFunction, dtype) {
    assertNonNegativeIntegerDimensions(shape);
    const size = sizeFromShape(shape);
    let values = null;
    if (dtype == null || dtype === "float32") {
      values = new Float32Array(size);
    } else if (dtype === "int32") {
      values = new Int32Array(size);
    } else if (dtype === "bool") {
      values = new Uint8Array(size);
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
    for (let i = 0; i < size; i++) {
      values[i] = randFunction();
    }
    return ENGINE.makeTensor(values, shape, dtype);
  }
  const rand = /* @__PURE__ */ op({ rand_ });
  var alea$1 = { exports: {} };
  alea$1.exports;
  (function(module) {
    (function(global2, module2, define) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t - (me.c = t | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          return (n >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define && define.amd) {
        define(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(
      commonjsGlobal,
      module,
      // present in node.js
      false
      // present with an AMD loader
    );
  })(alea$1);
  var aleaExports = alea$1.exports;
  var xor128$1 = { exports: {} };
  xor128$1.exports;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k3 = 0; k3 < strseed.length + 64; k3++) {
          me.x ^= strseed.charCodeAt(k3) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define && define.amd) {
        define(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(
      commonjsGlobal,
      module,
      // present in node.js
      false
      // present with an AMD loader
    );
  })(xor128$1);
  var xor128Exports = xor128$1.exports;
  var xorwow$1 = { exports: {} };
  xorwow$1.exports;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k3 = 0; k3 < strseed.length + 64; k3++) {
          me.x ^= strseed.charCodeAt(k3) | 0;
          if (k3 == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define && define.amd) {
        define(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(
      commonjsGlobal,
      module,
      // present in node.js
      false
      // present with an AMD loader
    );
  })(xorwow$1);
  var xorwowExports = xorwow$1.exports;
  var xorshift7$1 = { exports: {} };
  xorshift7$1.exports;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X2 = me.x, i = me.i, t, v;
          t = X2[i];
          t ^= t >>> 7;
          v = t ^ t << 24;
          t = X2[i + 1 & 7];
          v ^= t ^ t >>> 10;
          t = X2[i + 3 & 7];
          v ^= t ^ t >>> 3;
          t = X2[i + 4 & 7];
          v ^= t ^ t << 7;
          t = X2[i + 7 & 7];
          t = t ^ t << 13;
          v ^= t ^ t << 9;
          X2[i] = v;
          me.i = i + 1 & 7;
          return v;
        };
        function init2(me2, seed2) {
          var j2, X2 = [];
          if (seed2 === (seed2 | 0)) {
            X2[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j2 = 0; j2 < seed2.length; ++j2) {
              X2[j2 & 7] = X2[j2 & 7] << 15 ^ seed2.charCodeAt(j2) + X2[j2 + 1 & 7] << 13;
            }
          }
          while (X2.length < 8)
            X2.push(0);
          for (j2 = 0; j2 < 8 && X2[j2] === 0; ++j2)
            ;
          if (j2 == 8)
            X2[7] = -1;
          else
            X2[j2];
          me2.x = X2;
          me2.i = 0;
          for (j2 = 256; j2 > 0; --j2) {
            me2.next();
          }
        }
        init2(me, seed);
      }
      function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
      }
      function impl(seed, opts) {
        if (seed == null)
          seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define && define.amd) {
        define(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(
      commonjsGlobal,
      module,
      // present in node.js
      false
      // present with an AMD loader
    );
  })(xorshift7$1);
  var xorshift7Exports = xorshift7$1.exports;
  var xor4096$1 = { exports: {} };
  xor4096$1.exports;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w = me.w, X2 = me.X, i = me.i, t, v;
          me.w = w = w + 1640531527 | 0;
          v = X2[i + 34 & 127];
          t = X2[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          v = X2[i] = v ^ t;
          me.i = i;
          return v + (w ^ w >>> 16) | 0;
        };
        function init2(me2, seed2) {
          var t, v, i, j2, w, X2 = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i = 0, j2 = -32; j2 < limit; ++j2) {
            if (seed2)
              v ^= seed2.charCodeAt((j2 + 32) % seed2.length);
            if (j2 === 0)
              w = v;
            v ^= v << 10;
            v ^= v >>> 15;
            v ^= v << 4;
            v ^= v >>> 13;
            if (j2 >= 0) {
              w = w + 1640531527 | 0;
              t = X2[j2 & 127] ^= v + w;
              i = 0 == t ? i + 1 : 0;
            }
          }
          if (i >= 128) {
            X2[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i = 127;
          for (j2 = 4 * 128; j2 > 0; --j2) {
            v = X2[i + 34 & 127];
            t = X2[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            X2[i] = v ^ t;
          }
          me2.w = w;
          me2.X = X2;
          me2.i = i;
        }
        init2(me, seed);
      }
      function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
      }
      function impl(seed, opts) {
        if (seed == null)
          seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define && define.amd) {
        define(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(
      commonjsGlobal,
      // window object or global
      module,
      // present in node.js
      false
      // present with an AMD loader
    );
  })(xor4096$1);
  var xor4096Exports = xor4096$1.exports;
  var tychei$1 = { exports: {} };
  tychei$1.exports;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b = me.b, c = me.c, d = me.d, a = me.a;
          b = b << 25 ^ b >>> 7 ^ c;
          c = c - d | 0;
          d = d << 24 ^ d >>> 8 ^ a;
          a = a - b | 0;
          me.b = b = b << 20 ^ b >>> 12 ^ c;
          me.c = c = c - d | 0;
          me.d = d << 16 ^ c >>> 16 ^ a;
          return me.a = a - b | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k3 = 0; k3 < strseed.length + 20; k3++) {
          me.b ^= strseed.charCodeAt(k3) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define && define.amd) {
        define(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(
      commonjsGlobal,
      module,
      // present in node.js
      false
      // present with an AMD loader
    );
  })(tychei$1);
  var tycheiExports = tychei$1.exports;
  var seedrandom$1 = { exports: {} };
  const __viteBrowserExternal = {};
  const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
  (function(module) {
    (function(global2, pool2, math2) {
      var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math2.pow(width, chunks), significance = math2.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom2(seed, options, callback) {
        var key = [];
        options = options == true ? { entropy: true } : options || {};
        var shortseed = mixkey(flatten2(
          options.entropy ? [seed, tostring(pool2)] : seed == null ? autoseed() : seed,
          3
        ), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n = arc4.g(chunks), d = startdenom, x = 0;
          while (n < significance) {
            n = (n + x) * width;
            d *= width;
            x = arc4.g(1);
          }
          while (n >= overflow) {
            n /= 2;
            d /= 2;
            x >>>= 1;
          }
          return (n + x) / d;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool2);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math2[rngname] = prng2;
            return seed2;
          } else
            return prng2;
        })(
          prng,
          shortseed,
          "global" in options ? options.global : this == math2,
          options.state
        );
      }
      function ARC4(key) {
        var t, keylen = key.length, me = this, i = 0, j2 = me.i = me.j = 0, s = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i < width) {
          s[i] = i++;
        }
        for (i = 0; i < width; i++) {
          s[i] = s[j2 = mask & j2 + key[i % keylen] + (t = s[i])];
          s[j2] = t;
        }
        (me.g = function(count) {
          var t2, r = 0, i2 = me.i, j3 = me.j, s2 = me.S;
          while (count--) {
            t2 = s2[i2 = mask & i2 + 1];
            r = r * width + s2[mask & (s2[i2] = s2[j3 = mask & j3 + t2]) + (s2[j3] = t2)];
          }
          me.i = i2;
          me.j = j3;
          return r;
        })(width);
      }
      function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      }
      function flatten2(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten2(obj[prop], depth - 1));
            } catch (e) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j2 = 0;
        while (j2 < stringseed.length) {
          key[mask & j2] = mask & (smear ^= key[mask & j2] * 19) + stringseed.charCodeAt(j2++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e) {
          var browser2 = global2.navigator, plugins = browser2 && browser2.plugins;
          return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool2)];
        }
      }
      function tostring(a) {
        return String.fromCharCode.apply(0, a);
      }
      mixkey(math2.random(), pool2);
      if (module.exports) {
        module.exports = seedrandom2;
        try {
          nodecrypto = require$$0;
        } catch (ex) {
        }
      } else {
        math2["seed" + rngname] = seedrandom2;
      }
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      typeof self !== "undefined" ? self : commonjsGlobal,
      [],
      // pool: entropy pool starts empty
      Math
      // math: package containing random, pow, and seedrandom
    );
  })(seedrandom$1);
  var seedrandomExports = seedrandom$1.exports;
  var alea = aleaExports;
  var xor128 = xor128Exports;
  var xorwow = xorwowExports;
  var xorshift7 = xorshift7Exports;
  var xor4096 = xor4096Exports;
  var tychei = tycheiExports;
  var sr = seedrandomExports;
  sr.alea = alea;
  sr.xor128 = xor128;
  sr.xorwow = xorwow;
  sr.xorshift7 = xorshift7;
  sr.xor4096 = xor4096;
  sr.tychei = tychei;
  var seedrandom = sr;
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const TEST_EPSILON_FLOAT32 = 1e-3;
  const TEST_EPSILON_FLOAT16 = 0.1;
  function expectArraysClose(actual, expected, epsilon) {
    if (epsilon == null) {
      epsilon = testEpsilon();
    }
    return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, epsilon));
  }
  function testEpsilon() {
    return ENGINE.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 : TEST_EPSILON_FLOAT16;
  }
  function expectArraysPredicate(actual, expected, predicate) {
    let checkClassType = true;
    if (isTypedArray(actual) || isTypedArray(expected)) {
      checkClassType = false;
    }
    if (isTypedArray(actual) && isTypedArray(expected)) {
      checkClassType = true;
    }
    if (checkClassType) {
      const aType = actual.constructor.name;
      const bType = expected.constructor.name;
      if (aType !== bType) {
        throw new Error(`Arrays are of different type. Actual: ${aType}. Expected: ${bType}`);
      }
    }
    if (Array.isArray(actual) && Array.isArray(expected)) {
      const actualShape = inferShape(actual);
      const expectedShape = inferShape(expected);
      if (!arraysEqual(actualShape, expectedShape)) {
        throw new Error(`Arrays have different shapes. Actual: [${actualShape}]. Expected: [${expectedShape}]`);
      }
    }
    const actualFlat = isTypedArray(actual) ? actual : flatten(actual);
    const expectedFlat = isTypedArray(expected) ? expected : flatten(expected);
    if (actualFlat.length !== expectedFlat.length) {
      throw new Error(`Arrays have different lengths actual: ${actualFlat.length} vs expected: ${expectedFlat.length}.
Actual:   ${actualFlat}.
Expected: ${expectedFlat}.`);
    }
    for (let i = 0; i < expectedFlat.length; ++i) {
      const a = actualFlat[i];
      const e = expectedFlat[i];
      if (!predicate(a, e)) {
        throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${e}.
Actual:   ${actualFlat}.
Expected: ${expectedFlat}.`);
      }
    }
    if (typeof expect !== "undefined") {
      expect().nothing();
    }
  }
  function expectPromiseToFail(fn, done) {
    fn().then(() => done.fail(), () => done());
    if (typeof expect !== "undefined") {
      expect().nothing();
    }
  }
  function expectArraysEqual(actual, expected) {
    const exp2 = typeof expected === "string" || typeof expected === "number" || typeof expected === "boolean" ? [expected] : expected;
    if (isString(actual) || isString(actual[0]) || isString(expected) || isString(expected[0])) {
      return expectArraysPredicate(actual, exp2, (a, b) => a == b);
    }
    return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, 0));
  }
  function expectNumbersClose(a, e, epsilon) {
    if (epsilon == null) {
      epsilon = testEpsilon();
    }
    if (!areClose(a, e, epsilon)) {
      throw new Error(`Numbers differ: actual === ${a}, expected === ${e}`);
    }
    if (typeof expect !== "undefined") {
      expect().nothing();
    }
  }
  function areClose(a, e, epsilon) {
    if (!isFinite(a) && !isFinite(e)) {
      return true;
    }
    if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
      return false;
    }
    return true;
  }
  function expectValuesInRange(actual, low, high) {
    for (let i = 0; i < actual.length; i++) {
      if (actual[i] < low || actual[i] > high) {
        throw new Error(`Value out of range:${actual[i]} low: ${low}, high: ${high}`);
      }
    }
  }
  function expectArrayBuffersEqual(actual, expected) {
    const actualArray = new Float32Array(actual);
    const expectedArray = new Float32Array(expected);
    if (actualArray.length !== expectedArray.length) {
      throw new Error(`Expected ArrayBuffer to be of length ${expectedArray.length}, but it was ${actualArray.length}`);
    }
    for (let i = 0; i < expectedArray.length; i++) {
      if (actualArray[i] !== expectedArray[i]) {
        throw new Error(`Expected ArrayBuffer value at ${i} to be ${expectedArray[i]} but got ${actualArray[i]} instead`);
      }
    }
  }
  function encodeStrings(a) {
    for (let i = 0; i < a.length; i++) {
      const val = a[i];
      if (Array.isArray(val)) {
        encodeStrings(val);
      } else {
        a[i] = encodeString(val);
      }
    }
    return a;
  }
  function createVideoElement(source) {
    const video = document.createElement("video");
    if ("playsInline" in video) {
      video.playsInline = true;
    }
    video.muted = true;
    video.loop = true;
    video.style.position = "fixed";
    video.style.left = "0px";
    video.style.top = "0px";
    video.preload = "auto";
    video.appendChild(source);
    return new Promise((resolve) => {
      video.addEventListener("loadeddata", (_) => resolve(video));
      video.load();
    });
  }
  async function play(video) {
    await video.play();
    if ("requestVideoFrameCallback" in video) {
      await new Promise((resolve) => {
        video.requestVideoFrameCallback(resolve);
      });
    }
  }
  const test_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    TEST_EPSILON_FLOAT16,
    createVideoElement,
    encodeStrings,
    expectArrayBuffersEqual,
    expectArraysClose,
    expectArraysEqual,
    expectNumbersClose,
    expectPromiseToFail,
    expectValuesInRange,
    play,
    testEpsilon
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class MPRandGauss {
    constructor(mean2, stdDeviation, dtype, truncated, seed) {
      this.mean = mean2;
      this.stdDev = stdDeviation;
      this.dtype = dtype;
      this.nextVal = NaN;
      this.truncated = truncated;
      if (this.truncated) {
        this.upper = this.mean + this.stdDev * 2;
        this.lower = this.mean - this.stdDev * 2;
      }
      const seedValue = seed ? seed : Math.random();
      this.random = seedrandom.alea(seedValue.toString());
    }
    /** Returns next sample from a Gaussian distribution. */
    nextValue() {
      if (!isNaN(this.nextVal)) {
        const value = this.nextVal;
        this.nextVal = NaN;
        return value;
      }
      let resultX, resultY;
      let isValid = false;
      while (!isValid) {
        let v1, v2, s;
        do {
          v1 = 2 * this.random() - 1;
          v2 = 2 * this.random() - 1;
          s = v1 * v1 + v2 * v2;
        } while (s >= 1 || s === 0);
        const mul2 = Math.sqrt(-2 * Math.log(s) / s);
        resultX = this.mean + this.stdDev * v1 * mul2;
        resultY = this.mean + this.stdDev * v2 * mul2;
        if (!this.truncated || this.isValidTruncated(resultX)) {
          isValid = true;
        }
      }
      if (!this.truncated || this.isValidTruncated(resultY)) {
        this.nextVal = this.convertValue(resultY);
      }
      return this.convertValue(resultX);
    }
    /** Handles proper rounding for non-floating-point numbers. */
    convertValue(value) {
      if (this.dtype == null || this.dtype === "float32") {
        return value;
      }
      return Math.round(value);
    }
    /** Returns true if less than 2-standard-deviations from the mean. */
    isValidTruncated(value) {
      return value <= this.upper && value >= this.lower;
    }
  }
  class RandGamma {
    constructor(alpha, beta, dtype, seed) {
      this.alpha = alpha;
      this.beta = 1 / beta;
      this.dtype = dtype;
      const seedValue = seed ? seed : Math.random();
      this.randu = seedrandom.alea(seedValue.toString());
      this.randn = new MPRandGauss(0, 1, dtype, false, this.randu());
      if (alpha < 1) {
        this.d = alpha + 2 / 3;
      } else {
        this.d = alpha - 1 / 3;
      }
      this.c = 1 / Math.sqrt(9 * this.d);
    }
    /** Returns next sample from a gamma distribution. */
    nextValue() {
      let x2, v0, v1, x, u, v;
      while (true) {
        do {
          x = this.randn.nextValue();
          v = 1 + this.c * x;
        } while (v <= 0);
        v *= v * v;
        x2 = x * x;
        v0 = 1 - 0.331 * x2 * x2;
        v1 = 0.5 * x2 + this.d * (1 - v + Math.log(v));
        u = this.randu();
        if (u < v0 || Math.log(u) < v1) {
          break;
        }
      }
      v = 1 / this.beta * this.d * v;
      if (this.alpha < 1) {
        v *= Math.pow(this.randu(), 1 / this.alpha);
      }
      return this.convertValue(v);
    }
    /** Handles proper rounding for non-floating-point numbers. */
    convertValue(value) {
      if (this.dtype === "float32") {
        return value;
      }
      return Math.round(value);
    }
  }
  class UniformRandom {
    constructor(min2 = 0, max2 = 1, dtype, seed) {
      this.canReturnFloat = () => this.dtype == null || this.dtype === "float32";
      this.min = min2;
      this.range = max2 - min2;
      this.dtype = dtype;
      if (seed == null) {
        seed = Math.random();
      }
      if (typeof seed === "number") {
        seed = seed.toString();
      }
      if (!this.canReturnFloat() && this.range <= 1) {
        throw new Error(`The difference between ${min2} - ${max2} <= 1 and dtype is not float`);
      }
      this.random = seedrandom.alea(seed);
    }
    convertValue(value) {
      if (this.canReturnFloat()) {
        return value;
      }
      return Math.round(value);
    }
    nextValue() {
      return this.convertValue(this.min + this.range * this.random());
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function randomGamma_(shape, alpha, beta = 1, dtype = "float32", seed) {
    assertNonNegativeIntegerDimensions(shape);
    if (beta == null) {
      beta = 1;
    }
    if (dtype == null) {
      dtype = "float32";
    }
    if (dtype !== "float32" && dtype !== "int32") {
      throw new Error(`Unsupported data type ${dtype}`);
    }
    const rgamma = new RandGamma(alpha, beta, dtype, seed);
    const res = buffer(shape, dtype);
    for (let i = 0; i < res.values.length; i++) {
      res.values[i] = rgamma.nextValue();
    }
    return res.toTensor();
  }
  const randomGamma = /* @__PURE__ */ op({ randomGamma_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function randomNormal_(shape, mean2 = 0, stdDev = 1, dtype, seed) {
    assertNonNegativeIntegerDimensions(shape);
    if (dtype != null && dtype === "bool") {
      throw new Error(`Unsupported data type ${dtype}`);
    }
    const randGauss = new MPRandGauss(mean2, stdDev, dtype, false, seed);
    const res = buffer(shape, dtype);
    for (let i = 0; i < res.values.length; i++) {
      res.values[i] = randGauss.nextValue();
    }
    return res.toTensor();
  }
  const randomNormal = /* @__PURE__ */ op({ randomNormal_ });
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function randomStandardNormal_(shape, dtype, seed) {
    if (dtype != null && dtype === "bool") {
      throw new Error(`Unsupported data type ${dtype}`);
    }
    return randomNormal(shape, 0, 1, dtype, seed);
  }
  const randomStandardNormal = /* @__PURE__ */ op({ randomStandardNormal_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function randomUniform_(shape, minval = 0, maxval = 1, dtype = "float32", seed) {
    assertNonNegativeIntegerDimensions(shape);
    const res = buffer(shape, dtype);
    const random = new UniformRandom(minval, maxval, null, seed);
    for (let i = 0; i < res.values.length; i++) {
      res.values[i] = random.nextValue();
    }
    return res.toTensor();
  }
  const randomUniform = /* @__PURE__ */ op({ randomUniform_ });
  /**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function randomUniformInt_(shape, minval, maxval, seed) {
    return randomUniform(shape, minval, maxval, "int32", seed);
  }
  const randomUniformInt = /* @__PURE__ */ op({ randomUniformInt_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function range$1(start, stop, step2 = 1, dtype = "float32") {
    if (step2 === 0) {
      throw new Error("Cannot have a step of zero");
    }
    const attrs = { start, stop, step: step2, dtype };
    return ENGINE.runKernel(Range, {}, attrs);
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function real_(input) {
    const $input = convertToTensor(input, "input", "real");
    const inputs = { input: $input };
    return ENGINE.runKernel(Real, inputs);
  }
  const real$1 = /* @__PURE__ */ op({ real_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function reciprocal_(x) {
    const $x = convertToTensor(x, "x", "reciprocal");
    const inputs = { x: $x };
    return ENGINE.runKernel(Reciprocal, inputs);
  }
  const reciprocal$1 = /* @__PURE__ */ op({ reciprocal_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function relu_(x) {
    const $x = convertToTensor(x, "x", "relu");
    const inputs = { x: $x };
    return ENGINE.runKernel(Relu, inputs);
  }
  const relu$1 = /* @__PURE__ */ op({ relu_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function relu6_(x) {
    const $x = convertToTensor(x, "x", "relu6");
    const inputs = { x: $x };
    return ENGINE.runKernel(Relu6, inputs);
  }
  const relu6$1 = /* @__PURE__ */ op({ relu6_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function reverse_(x, axis) {
    const $x = convertToTensor(x, "x", "reverse");
    const inputs = { x: $x };
    const attrs = { dims: axis };
    return ENGINE.runKernel(Reverse, inputs, attrs);
  }
  const reverse$1 = /* @__PURE__ */ op({ reverse_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function reverse1d_(x) {
    const $x = convertToTensor(x, "x", "reverse");
    assert($x.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${$x.rank}.`);
    return reverse$1($x, 0);
  }
  const reverse1d = /* @__PURE__ */ op({ reverse1d_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function reverse2d_(x, axis) {
    const $x = convertToTensor(x, "x", "reverse");
    assert($x.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${$x.rank}.`);
    return reverse$1($x, axis);
  }
  const reverse2d = /* @__PURE__ */ op({ reverse2d_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function reverse3d_(x, axis) {
    const $x = convertToTensor(x, "x", "reverse");
    assert($x.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${$x.rank}.`);
    return reverse$1($x, axis);
  }
  const reverse3d = /* @__PURE__ */ op({ reverse3d_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function reverse4d_(x, axis) {
    const $x = convertToTensor(x, "x", "reverse");
    assert($x.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${$x.rank}.`);
    return reverse$1($x, axis);
  }
  const reverse4d = /* @__PURE__ */ op({ reverse4d_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function round_(x) {
    const $x = convertToTensor(x, "x", "round");
    const inputs = { x: $x };
    return ENGINE.runKernel(Round, inputs);
  }
  const round$1 = /* @__PURE__ */ op({ round_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function rsqrt_(x) {
    const $x = convertToTensor(x, "x", "rsqrt", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Rsqrt, inputs);
  }
  const rsqrt$1 = /* @__PURE__ */ op({ rsqrt_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function selu_(x) {
    const $x = convertToTensor(x, "x", "selu");
    const inputs = { x: $x };
    return ENGINE.runKernel(Selu, inputs);
  }
  const selu$1 = /* @__PURE__ */ op({ selu_ });
  function separableConv2d_(x, depthwiseFilter, pointwiseFilter, strides, pad2, dilation = [1, 1], dataFormat = "NHWC") {
    const $x = convertToTensor(x, "x", "separableConv2d");
    const $depthwiseFilter = convertToTensor(depthwiseFilter, "depthwiseFilter", "separableConv2d");
    const $pointwiseFilter = convertToTensor(pointwiseFilter, "pointwiseFilter", "separableConv2d");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape$1($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    if (dataFormat === "NCHW") {
      throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    }
    assert(x4D.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert($depthwiseFilter.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`);
    assert($pointwiseFilter.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`);
    assert($pointwiseFilter.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${$pointwiseFilter.shape[0]}.`);
    assert($pointwiseFilter.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${$pointwiseFilter.shape[1]}.`);
    const inChannels = $depthwiseFilter.shape[2];
    const channelMultiplier = $depthwiseFilter.shape[3];
    assert($pointwiseFilter.shape[2] === inChannels * channelMultiplier, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${inChannels * channelMultiplier}, but got ${$pointwiseFilter.shape[2]}.`);
    const depthwise = depthwiseConv2d$1(x4D, $depthwiseFilter, strides, pad2, dataFormat, dilation);
    const pointwiseStride = 1;
    const res = conv2d$2(depthwise, $pointwiseFilter, pointwiseStride, "valid", dataFormat);
    if (reshapedTo4D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  const separableConv2d = /* @__PURE__ */ op({ separableConv2d_ });
  /**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  async function setdiff1dAsync_(x, y) {
    const $x = convertToTensor(x, "x", "setdiff1d");
    const $y = convertToTensor(y, "y", "setdiff1d");
    assert($x.dtype === $y.dtype, () => `x and y should have the same dtype, but got x (${$x.dtype}) and y (${$y.dtype}).`);
    assert($x.rank === 1, () => `x should be 1D tensor, but got x (${$x.shape}).`);
    assert($y.rank === 1, () => `y should be 1D tensor, but got y (${$y.shape}).`);
    const xVals = await $x.data();
    const yVals = await $y.data();
    const ySet = new Set(yVals);
    let outputSize = 0;
    for (let i = 0; i < xVals.length; i++) {
      if (!ySet.has(xVals[i])) {
        outputSize++;
      }
    }
    const buffer2 = new TensorBuffer([outputSize], $x.dtype);
    const indices = new TensorBuffer([outputSize], "int32");
    for (let i = 0, p = 0; i < xVals.length; i++) {
      if (!ySet.has(xVals[i])) {
        buffer2.values[p] = xVals[i];
        indices.values[p] = i;
        p++;
      }
    }
    return [buffer2.toTensor(), indices.toTensor()];
  }
  const setdiff1dAsync = setdiff1dAsync_;
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sign_(x) {
    const $x = convertToTensor(x, "x", "sign");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sign, inputs);
  }
  const sign$1 = /* @__PURE__ */ op({ sign_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sin_(x) {
    const $x = convertToTensor(x, "x", "sin", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sin, inputs);
  }
  const sin$1 = /* @__PURE__ */ op({ sin_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sinh_(x) {
    const $x = convertToTensor(x, "x", "sinh");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sinh, inputs);
  }
  const sinh$1 = /* @__PURE__ */ op({ sinh_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function slice1d_(x, begin, size) {
    const $x = convertToTensor(x, "x", "slice1d");
    assert($x.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`);
    return slice$1($x, [begin], [size]);
  }
  const slice1d = /* @__PURE__ */ op({ slice1d_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function slice2d_(x, begin, size) {
    const $x = convertToTensor(x, "x", "slice2d");
    assert($x.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`);
    return slice$1($x, begin, size);
  }
  const slice2d = /* @__PURE__ */ op({ slice2d_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function slice3d_(x, begin, size) {
    const $x = convertToTensor(x, "x", "slice3d");
    assert($x.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`);
    return slice$1($x, begin, size);
  }
  const slice3d = /* @__PURE__ */ op({ slice3d_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function slice4d_(x, begin, size) {
    const $x = convertToTensor(x, "x", "slice4d");
    assert($x.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`);
    return slice$1($x, begin, size);
  }
  const slice4d = /* @__PURE__ */ op({ slice4d_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function softmax_(logits, dim = -1) {
    const $logits = convertToTensor(logits, "logits", "softmax", "float32");
    if (dim === -1) {
      dim = $logits.rank - 1;
    }
    if (dim !== $logits.rank - 1) {
      throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and dim was ${dim}`);
    }
    const inputs = { logits: $logits };
    const attrs = { dim };
    return ENGINE.runKernel(Softmax, inputs, attrs);
  }
  const softmax$1 = /* @__PURE__ */ op({ softmax_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function fft_(input) {
    assert(input.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${input.dtype}.`);
    const inputs = { input };
    return ENGINE.runKernel(FFT, inputs);
  }
  const fft$1 = /* @__PURE__ */ op({ fft_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function ifft_(input) {
    assert(input.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${input.dtype}.`);
    const inputs = { input };
    return ENGINE.runKernel(IFFT, inputs);
  }
  const ifft$1 = /* @__PURE__ */ op({ ifft_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function irfft_(input) {
    const innerDimensionSize = input.shape[input.shape.length - 1];
    const batch = input.size / innerDimensionSize;
    let ret;
    if (innerDimensionSize <= 2) {
      const complexInput = reshape$1(input, [batch, innerDimensionSize]);
      ret = ifft$1(complexInput);
    } else {
      const outputShape = [batch, 2 * (innerDimensionSize - 1)];
      const realInput = reshape$1(real$1(input), [batch, innerDimensionSize]);
      const imagInput = reshape$1(imag$1(input), [batch, innerDimensionSize]);
      const realConjugate = reverse$1(slice$1(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);
      const imagConjugate = mul(reverse$1(slice$1(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar(-1));
      const r = concat$1([realInput, realConjugate], 1);
      const i = concat$1([imagInput, imagConjugate], 1);
      const complexInput = reshape$1(complex$1(r, i), [outputShape[0], outputShape[1]]);
      ret = ifft$1(complexInput);
    }
    ret = real$1(ret);
    if (input.rank === 3 && input.shape[0] !== 0) {
      const temp = ret;
      const batch2 = input.shape[0];
      ret = reshape$1(ret, [batch2, ret.shape[0] / batch2, ret.shape[1]]);
      temp.dispose();
    }
    return ret;
  }
  const irfft = /* @__PURE__ */ op({ irfft_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function split_(x, numOrSizeSplits, axis = 0) {
    const $x = convertToTensor(x, "x", "split");
    const inputs = { x: $x };
    const attr = { numOrSizeSplits, axis };
    return ENGINE.runKernel(SplitV, inputs, attr);
  }
  const split$2 = /* @__PURE__ */ op({ split_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function rfft_(input, fftLength) {
    assert(input.dtype === "float32", () => `The dtype for rfft() must be real value but got ${input.dtype}`);
    let innerDimensionSize = input.shape[input.shape.length - 1];
    const batch = input.size / innerDimensionSize;
    let adjustedInput;
    if (fftLength != null && fftLength < innerDimensionSize) {
      const begin = input.shape.map((v) => 0);
      const size = input.shape.map((v) => v);
      size[input.shape.length - 1] = fftLength;
      adjustedInput = slice$1(input, begin, size);
      innerDimensionSize = fftLength;
    } else if (fftLength != null && fftLength > innerDimensionSize) {
      const zerosShape = input.shape.map((v) => v);
      zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;
      adjustedInput = concat$1([input, zeros(zerosShape)], input.shape.length - 1);
      innerDimensionSize = fftLength;
    } else {
      adjustedInput = input;
    }
    const zerosInput = zerosLike$1(adjustedInput);
    const complexInput = reshape$1(complex$1(adjustedInput, zerosInput), [batch, innerDimensionSize]);
    const ret = fft$1(complexInput);
    const half = Math.floor(innerDimensionSize / 2) + 1;
    const realValues = real$1(ret);
    const imagValues = imag$1(ret);
    const realComplexConjugate = split$2(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);
    const imagComplexConjugate = split$2(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);
    const outputShape = adjustedInput.shape.slice();
    outputShape[adjustedInput.shape.length - 1] = half;
    return reshape$1(complex$1(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);
  }
  const rfft = /* @__PURE__ */ op({ rfft_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function squaredDifference_(a, b) {
    let $a = convertToTensor(a, "a", "squaredDifference");
    let $b = convertToTensor(b, "b", "squaredDifference");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    const attrs = {};
    return ENGINE.runKernel(SquaredDifference, inputs, attrs);
  }
  const squaredDifference$1 = /* @__PURE__ */ op({ squaredDifference_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function squeeze_(x, axis) {
    const $x = convertToTensor(x, "x", "squeeze", "string_or_numeric");
    return reshape$1($x, squeezeShape($x.shape, axis).newShape);
  }
  const squeeze = /* @__PURE__ */ op({ squeeze_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function stack_(tensors, axis = 0) {
    const $tensors = convertToTensorArray(tensors, "tensors", "stack", "string_or_numeric");
    assert($tensors.length >= 1, () => "Pass at least one tensor to tf.stack");
    if ($tensors.length > 0) {
      assert(axis <= $tensors[0].rank, () => "Axis must be <= rank of the tensor");
    }
    const inputs = $tensors;
    const attrs = { axis };
    return ENGINE.runKernel(Pack, inputs, attrs);
  }
  const stack = /* @__PURE__ */ op({ stack_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function step_(x, alpha = 0) {
    const $x = convertToTensor(x, "x", "step");
    const inputs = { x: $x };
    const attrs = { alpha };
    return ENGINE.runKernel(Step, inputs, attrs);
  }
  const step$1 = /* @__PURE__ */ op({ step_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function stridedSlice_(x, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {
    const $x = convertToTensor(x, "x", "stridedSlice", "string_or_numeric");
    const inputs = { x: $x };
    const attrs = {
      begin,
      end,
      strides,
      beginMask,
      endMask,
      ellipsisMask,
      newAxisMask,
      shrinkAxisMask
    };
    return ENGINE.runKernel(StridedSlice, inputs, attrs);
  }
  const stridedSlice$1 = /* @__PURE__ */ op({ stridedSlice_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tan_(x) {
    const $x = convertToTensor(x, "x", "tan", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Tan, inputs);
  }
  const tan$1 = /* @__PURE__ */ op({ tan_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tensor1d(values, dtype) {
    assertNonNull(values);
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 1) {
      throw new Error("tensor1d() requires values to be a flat/TypedArray");
    }
    const shape = null;
    return makeTensor(values, shape, inferredShape, dtype);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tensor2d(values, shape, dtype) {
    assertNonNull(values);
    if (shape != null && shape.length !== 2) {
      throw new Error("tensor2d() requires shape to have two numbers");
    }
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 2 && inferredShape.length !== 1) {
      throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
    }
    if (inferredShape.length === 1 && shape == null) {
      throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    }
    return makeTensor(values, shape, inferredShape, dtype);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tensor3d(values, shape, dtype) {
    assertNonNull(values);
    if (shape != null && shape.length !== 3) {
      throw new Error("tensor3d() requires shape to have three numbers");
    }
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 3 && inferredShape.length !== 1) {
      throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
    }
    if (inferredShape.length === 1 && shape == null) {
      throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
    }
    return makeTensor(values, shape, inferredShape, dtype);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tensor4d(values, shape, dtype) {
    assertNonNull(values);
    if (shape != null && shape.length !== 4) {
      throw new Error("tensor4d() requires shape to have four numbers");
    }
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 4 && inferredShape.length !== 1) {
      throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
    }
    if (inferredShape.length === 1 && shape == null) {
      throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
    }
    return makeTensor(values, shape, inferredShape, dtype);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tensor5d(values, shape, dtype) {
    assertNonNull(values);
    if (shape != null && shape.length !== 5) {
      throw new Error("tensor5d() requires shape to have five numbers");
    }
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 5 && inferredShape.length !== 1) {
      throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
    }
    if (inferredShape.length === 1 && shape == null) {
      throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
    }
    return makeTensor(values, shape, inferredShape, dtype);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tensor6d(values, shape, dtype) {
    assertNonNull(values);
    if (shape != null && shape.length !== 6) {
      throw new Error("tensor6d() requires shape to have six numbers");
    }
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 6 && inferredShape.length !== 1) {
      throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
    }
    if (inferredShape.length === 1 && shape == null) {
      throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
    }
    shape = shape || inferredShape;
    return makeTensor(values, shape, inferredShape, dtype);
  }
  function validateUpdateShape(shape, indices, updates) {
    const sliceDim = indices.rank > 1 ? indices.shape[indices.rank - 1] : 1;
    const batchDim = indices.rank > 1 ? indices.rank - 1 : 1;
    const shapeError = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${updates.shape}, indices.shape: ${indices.shape}, shape: ${shape}, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;
    if (updates.rank < batchDim) {
      throw new Error(shapeError + ` update.rank < ${batchDim}. `);
    }
    if (shape.length < sliceDim + (updates.rank - batchDim)) {
      throw new Error(shapeError + ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);
    }
    if (updates.rank !== batchDim + shape.length - sliceDim) {
      throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);
    }
    for (let d = 0; d < batchDim; ++d) {
      if (updates.shape[d] !== indices.shape[d]) {
        throw new Error(shapeError + ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);
      }
    }
    for (let d = 0; d < updates.rank - batchDim; ++d) {
      if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {
        throw new Error(shapeError + ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);
      }
    }
  }
  function validateInput$1(updates, indices, shape) {
    if (indices.rank < 1) {
      throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${indices.rank}.`);
    }
    if (updates.rank < 1) {
      throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${updates.rank}.`);
    }
    if (indices.dtype !== "int32") {
      throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);
    }
    if (shape.length < 1) {
      throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);
    }
    if (shape.length === 0) {
      if (indices.size === 0) {
        throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);
      }
      if (updates.size === 0) {
        throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);
      }
    }
    validateUpdateShape(shape, indices, updates);
  }
  function calculateShapes(updates, indices, shape) {
    const indicesRank = indices.shape.length;
    const sliceRank = indicesRank > 1 ? indices.shape[indicesRank - 1] : 1;
    const totalNd = shape.length;
    let sliceSize = 1;
    for (let i = sliceRank; i < totalNd; ++i) {
      sliceSize *= shape[i];
    }
    const safeSliceDim = sliceRank < 1 ? 1 : sliceRank;
    const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;
    const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];
    const outputSize = sizeFromShape(shape);
    return { sliceRank, numUpdates, sliceSize, strides, outputSize };
  }
  const scatter_nd_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    calculateShapes,
    validateInput: validateInput$1,
    validateUpdateShape
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tensorScatterUpdate_(tensor2, indices, updates) {
    const $tensor = convertToTensor(tensor2, "tensor", "tensorScatterupdate");
    const $indices = convertToTensor(indices, "indices", "tensorScatterupdate", "int32");
    const $updates = convertToTensor(updates, "updates", "tensorScatterupdate");
    validateInput$1($updates, $indices, $tensor.shape);
    if ($tensor.dtype !== $updates.dtype) {
      throw new Error(`tensor and updates must have the same dtype, instead they are ${$tensor.dtype} and ${$updates.dtype}.`);
    }
    const inputs = {
      tensor: $tensor,
      indices: $indices,
      updates: $updates
    };
    const attrs = {};
    return ENGINE.runKernel(TensorScatterUpdate, inputs, attrs);
  }
  const tensorScatterUpdate$1 = op({ tensorScatterUpdate_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function topk_(x, k3 = 1, sorted = true) {
    const $x = convertToTensor(x, "x", "topk");
    if ($x.rank === 0) {
      throw new Error("topk() expects the input to be of rank 1 or higher");
    }
    const lastDim = $x.shape[$x.shape.length - 1];
    if (k3 < 0) {
      throw new Error(`'k' passed to topk() must be >= 0 but got ${k3}`);
    }
    if (k3 > lastDim) {
      throw new Error(`'k' passed to topk() must be <= the last dimension (${lastDim}) but got ${k3}`);
    }
    const inputs = { x: $x };
    const attrs = { k: k3, sorted };
    const [values, indices] = ENGINE.runKernel(TopK, inputs, attrs);
    return { values, indices };
  }
  const topk = /* @__PURE__ */ op({ topk_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function truncatedNormal_(shape, mean2 = 0, stdDev = 1, dtype, seed) {
    assertNonNegativeIntegerDimensions(shape);
    if (dtype != null && dtype === "bool") {
      throw new Error(`Unsupported data type $ { dtype }`);
    }
    const randGauss = new MPRandGauss(mean2, stdDev, dtype, true, seed);
    const res = buffer(shape, dtype);
    for (let i = 0; i < res.values.length; i++) {
      res.values[i] = randGauss.nextValue();
    }
    return res.toTensor();
  }
  const truncatedNormal = /* @__PURE__ */ op({ truncatedNormal_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function unique_(x, axis = 0) {
    const $x = convertToTensor(x, "x", "unique", "string_or_numeric");
    assert($x.rank > 0, () => "The input tensor must be at least 1D");
    const inputs = { x: $x };
    const attrs = { axis };
    const [values, indices] = ENGINE.runKernel(Unique, inputs, attrs);
    return { values, indices };
  }
  const unique$1 = /* @__PURE__ */ op({ unique_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function unsortedSegmentSum_(x, segmentIds, numSegments) {
    const $x = convertToTensor(x, "x", "unsortedSegmentSum");
    const $segmentIds = convertToTensor(segmentIds, "segmentIds", "unsortedSegmentSum", "int32");
    assert(isInt(numSegments), () => "numSegments must be of dtype int");
    const inputs = { x: $x, segmentIds: $segmentIds };
    const attrs = { numSegments };
    return ENGINE.runKernel(UnsortedSegmentSum, inputs, attrs);
  }
  const unsortedSegmentSum$1 = /* @__PURE__ */ op({ unsortedSegmentSum_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function unstack_(x, axis = 0) {
    const $x = convertToTensor(x, "x", "unstack", "string_or_numeric");
    assert(axis >= -$x.shape.length && axis < $x.shape.length, () => `Axis = ${axis} is not in [-${$x.shape.length}, ${$x.shape.length})`);
    const inputs = { value: $x };
    const attrs = { axis };
    return ENGINE.runKernel(Unpack, inputs, attrs);
  }
  const unstack = /* @__PURE__ */ op({ unstack_ });
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function upperBound(sortedSequence, values) {
    return searchSorted$1(sortedSequence, values, "right");
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function variable(initialValue, trainable = true, name, dtype) {
    return ENGINE.makeVariable(initialValue, trainable, name, dtype);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function whereImpl$1(condShape, condVals) {
    const indices = [];
    for (let i = 0; i < condVals.length; i++) {
      if (condVals[i]) {
        indices.push(i);
      }
    }
    const inBuffer = buffer(condShape, "int32");
    const out = buffer([indices.length, condShape.length], "int32");
    for (let i = 0; i < indices.length; i++) {
      const loc = inBuffer.indexToLoc(indices[i]);
      const offset = i * condShape.length;
      out.values.set(loc, offset);
    }
    return out.toTensor();
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  async function whereAsync_(condition) {
    const $condition = convertToTensor(condition, "condition", "whereAsync", "bool");
    const vals = await $condition.data();
    const res = whereImpl$1($condition.shape, vals);
    if (condition !== $condition) {
      $condition.dispose();
    }
    return res;
  }
  const whereAsync = whereAsync_;
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  async function booleanMaskAsync_(tensor2, mask, axis) {
    const $tensor = convertToTensor(tensor2, "tensor", "boolMask");
    const $mask = convertToTensor(mask, "mask", "boolMask", "bool");
    const axisFrom = axis == null ? 0 : axis;
    const maskDim = $mask.rank;
    const tensorShape = $tensor.shape;
    assert(maskDim > 0, () => "mask cannot be scalar");
    assertShapesMatch(tensorShape.slice(axisFrom, axisFrom + maskDim), $mask.shape, `mask's shape must match the first K dimensions of tensor's shape,`);
    let leadingSize = 1;
    for (let i = axisFrom; i < axisFrom + maskDim; i++) {
      leadingSize *= tensorShape[i];
    }
    const targetTensorShape = tensorShape.slice(0, axisFrom).concat([leadingSize], tensorShape.slice(axisFrom + maskDim));
    const reshapedTensor = reshape$1($tensor, targetTensorShape);
    const reshapedMask = reshape$1($mask, [-1]);
    const positivePositions = await whereAsync(reshapedMask);
    const indices = squeeze(positivePositions, [1]);
    const res = gather(reshapedTensor, indices, axisFrom);
    if (tensor2 !== $tensor) {
      $tensor.dispose();
    }
    if (mask !== $mask) {
      $mask.dispose();
    }
    indices.dispose();
    reshapedTensor.dispose();
    reshapedMask.dispose();
    positivePositions.dispose();
    return res;
  }
  const booleanMaskAsync = booleanMaskAsync_;
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function transpose_(x, perm, conjugate) {
    const $x = convertToTensor(x, "x", "transpose");
    if (perm == null) {
      perm = $x.shape.map((s, i) => i).reverse();
    }
    assert($x.rank === perm.length, () => `Error in transpose: rank of input ${$x.rank} must match length of perm ${perm}.`);
    perm.forEach((axis) => {
      assert(axis >= 0 && axis < $x.rank, () => `All entries in 'perm' must be between 0 and ${$x.rank - 1} but got ${perm}`);
    });
    if ($x.rank <= 1) {
      return $x.clone();
    }
    const inputs = { x: $x };
    const attrs = { perm };
    if ($x.dtype === "complex64") {
      return tidy(() => {
        let $real = real$1($x);
        let $imag = imag$1($x);
        $real = ENGINE.runKernel(Transpose, { x: $real }, attrs);
        $imag = ENGINE.runKernel(Transpose, { x: $imag }, attrs);
        if (conjugate) {
          $imag = neg$1($imag);
        }
        return complex$1($real, $imag);
      });
    }
    return ENGINE.runKernel(Transpose, inputs, attrs);
  }
  const transpose$1 = /* @__PURE__ */ op({ transpose_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function movingAverage_(v, x, decay, step2, zeroDebias = true) {
    const $v = convertToTensor(v, "v", "movingAverage");
    const $x = convertToTensor(x, "x", "movingAverage");
    const $decay = convertToTensor(decay, "decay", "movingAverage");
    assertTypesMatch($v, $x);
    assert(arraysEqual($v.shape, $x.shape), () => "Shape mismatch in v and x");
    const one = scalar(1);
    const oneMinusDecay = sub$1(one, $decay);
    let update = mul(sub$1($x, $v), oneMinusDecay);
    if (zeroDebias) {
      assert(step2 != null, () => "When using zeroDebias: true, step is required.");
      const $step = convertToTensor(step2, "step", "movingAverage");
      update = div(update, sub$1(one, pow$1($decay, $step)));
    }
    return add($v, update);
  }
  const movingAverage = /* @__PURE__ */ op({ movingAverage_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function scatterND_(indices, updates, shape) {
    assertNonNegativeIntegerDimensions(shape);
    const $indices = convertToTensor(indices, "indices", "scatterND", "int32");
    const $updates = convertToTensor(updates, "updates", "scatterND");
    validateInput$1($updates, $indices, shape);
    const inputs = { indices: $indices, updates: $updates };
    const attrs = { shape };
    return ENGINE.runKernel(ScatterNd, inputs, attrs);
  }
  const scatterND = /* @__PURE__ */ op({ scatterND_ });
  function validateInput(sparseIndices, sparseValues, outputShape, defaultValues) {
    if (sparseIndices.dtype !== "int32") {
      throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${sparseIndices.dtype}.`);
    }
    if (sparseIndices.rank > 2) {
      throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${sparseIndices.shape}.`);
    }
    const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;
    const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;
    if (outputShape.length !== numDims) {
      throw new Error(`outputShape has incorrect number of elements:, ${outputShape.length}, should be: ${numDims}.`);
    }
    const numValues = sparseValues.size;
    if (!(sparseValues.rank === 0 || sparseValues.rank === 1 && numValues === numElems)) {
      throw new Error(`sparseValues has incorrect shape ${sparseValues.shape}, should be [] or [${numElems}]`);
    }
    if (sparseValues.dtype !== defaultValues.dtype) {
      throw new Error("sparseValues.dtype must match defaultValues.dtype");
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue = 0) {
    assertNonNegativeIntegerDimensions(outputShape);
    const $sparseIndices = convertToTensor(sparseIndices, "sparseIndices", "sparseToDense", "int32");
    const $sparseValues = convertToTensor(sparseValues, "sparseValues", "sparseToDense", "string_or_numeric");
    const $defaultValue = convertToTensor(defaultValue, "defaultValue", "sparseToDense", $sparseValues.dtype);
    validateInput($sparseIndices, $sparseValues, outputShape, $defaultValue);
    const inputs = {
      sparseIndices: $sparseIndices,
      sparseValues: $sparseValues,
      defaultValue: $defaultValue
    };
    const attrs = { outputShape };
    return ENGINE.runKernel(SparseToDense, inputs, attrs);
  }
  const sparseToDense$1 = /* @__PURE__ */ op({ sparseToDense_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function gatherND_(x, indices) {
    const $indices = convertToTensor(indices, "indices", "gatherND", "int32");
    const $x = convertToTensor(x, "x", "gatherND", "string_or_numeric");
    const inputs = { params: $x, indices: $indices };
    return ENGINE.runKernel(GatherNd, inputs);
  }
  const gatherND = /* @__PURE__ */ op({ gatherND_ });
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getNoiseShape(x, noiseShape) {
    if (noiseShape == null) {
      return x.shape.slice();
    }
    if (arraysEqual(x.shape, noiseShape)) {
      return noiseShape;
    }
    if (x.shape.length === noiseShape.length) {
      const newDimension = [];
      for (let i = 0; i < x.shape.length; i++) {
        if (noiseShape[i] == null && x.shape[i] != null) {
          newDimension.push(x.shape[i]);
        } else {
          newDimension.push(noiseShape[i]);
        }
      }
      return newDimension;
    }
    return noiseShape;
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function dropout_(x, rate, noiseShape, seed) {
    const $x = convertToTensor(x, "x", "dropout");
    assert($x.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${$x.dtype} tensor instead.`);
    assert(rate >= 0 && rate < 1, () => `rate must be a float in the range [0, 1), but got ${rate}.`);
    if (rate === 0) {
      return x instanceof Tensor ? $x.clone() : $x;
    }
    const $noiseShape = getNoiseShape($x, noiseShape);
    const keepProb = 1 - rate;
    const multiplier = div(floor$1(add(randomUniform($noiseShape, 0, 1, "float32", seed), keepProb)), keepProb);
    return mul($x, multiplier);
  }
  const dropout = /* @__PURE__ */ op({ dropout_ });
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function enclosingPowerOfTwo(value) {
    return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2))));
  }
  function cosineWindow(windowLength, a, b) {
    const even = 1 - windowLength % 2;
    const newValues = new Float32Array(windowLength);
    for (let i = 0; i < windowLength; ++i) {
      const cosArg = 2 * Math.PI * i / (windowLength + even - 1);
      newValues[i] = a - b * Math.cos(cosArg);
    }
    return tensor1d(newValues, "float32");
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  async function inTopKAsync_(predictions, targets, k3 = 1) {
    const $predictions = convertToTensor(predictions, "predictions", "inTopK");
    const $targets = convertToTensor(targets, "targets", "inTopK");
    assert($predictions.rank > 1, () => `inTopK() expects the predictions to be of rank 2 or higher, but got ${$predictions.rank}`);
    assert($predictions.rank - 1 === $targets.rank, () => `predictions rank should be 1 larger than targets rank, but got predictions rank ${$predictions.rank} and targets rank ${$targets.rank}`);
    assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, `predictions's shape should be align with the targets' shape, except the last dimension.`);
    const lastDim = $predictions.shape[$predictions.shape.length - 1];
    assert(k3 > 0 && k3 <= lastDim, () => `'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${lastDim}), but got ${k3}`);
    const predictionsVals = await $predictions.data();
    const targetsVals = await $targets.data();
    const [batch, size] = [predictionsVals.length / lastDim, lastDim];
    const precision = getTypedArrayFromDType("bool", batch);
    for (let b = 0; b < batch; b++) {
      const offset = b * size;
      const vals = predictionsVals.subarray(offset, offset + size);
      const valAndInd = [];
      for (let i = 0; i < vals.length; i++) {
        valAndInd.push({ value: vals[i], index: i });
      }
      valAndInd.sort((a, b2) => b2.value - a.value);
      precision[b] = 0;
      for (let i = 0; i < k3; i++) {
        if (valAndInd[i].index === targetsVals[b]) {
          precision[b] = 1;
          break;
        }
      }
    }
    if (predictions !== $predictions) {
      $predictions.dispose();
    }
    if (targets !== $targets) {
      $targets.dispose();
    }
    return tensor(precision, $targets.shape, "bool");
  }
  const inTopKAsync = inTopKAsync_;
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function conv2DBackpropFilter_(x, dy, filterShape, strides, pad2, dataFormat = "NHWC", dimRoundingMode) {
    let x4D = x;
    if (x.rank === 3) {
      x4D = reshape$1(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
    }
    let dy4D = dy;
    if (dy4D.rank === 3) {
      dy4D = reshape$1(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${x4D.shape}.`);
    assert(dy4D.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${dy4D.shape}.`);
    assert(filterShape.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${filterShape}.`);
    const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
    const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
    assert(inDepth === filterShape[2], () => `Error in conv2dDerFilter: depth of input ${inDepth}) must match input depth in filter (${filterShape[2]}.`);
    assert(outDepth === filterShape[3], () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must match output depth for filter (${filterShape[3]}).`);
    checkPadOnDimRoundingMode("conv2dDerFilter", pad2, dimRoundingMode);
    const inputs = { x: x4D, dy: dy4D };
    const attrs = { strides, pad: pad2, dataFormat, dimRoundingMode, filterShape };
    return ENGINE.runKernel(Conv2DBackpropFilter, inputs, attrs);
  }
  const conv2DBackpropFilter$1 = /* @__PURE__ */ op({ conv2DBackpropFilter_ });
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getFusedDyActivation(dy, y, activation) {
    if (activation == null || activation === "linear") {
      return dy;
    }
    if (activation === "relu") {
      return mul(dy, step$1(y));
    }
    throw new Error(`Cannot compute gradient for fused activation ${activation}.`);
  }
  function getFusedBiasGradient(bias, dyActivation) {
    let res = dyActivation;
    const reduceAxes = getReductionAxes(bias.shape, dyActivation.shape);
    if (reduceAxes.length > 0) {
      res = sum$1(res, reduceAxes);
    }
    return reshape$1(res, bias.shape);
  }
  function applyActivation(x, activation, preluActivationWeights, leakyreluAlpha) {
    if (activation === "linear") {
      return x;
    } else if (activation === "relu") {
      return relu$1(x);
    } else if (activation === "elu") {
      return elu$1(x);
    } else if (activation === "relu6") {
      return relu6$1(x);
    } else if (activation === "prelu") {
      return prelu$1(x, preluActivationWeights);
    } else if (activation === "leakyrelu") {
      return leakyRelu$1(x, leakyreluAlpha);
    } else if (activation === "sigmoid") {
      return sigmoid$1(x);
    }
    throw new Error(`Unknown fused activation ${activation}.`);
  }
  const shouldFuse = (gradientDepth, activation) => {
    const gradientMode = gradientDepth > 0;
    return !gradientMode || activation === "linear";
  };
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function fusedConv2d_({ x, filter, strides, pad: pad2, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation = "linear", preluActivationWeights, leakyreluAlpha }) {
    activation = activation || "linear";
    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
      assert(dataFormat === "NHWC", () => `Error in fused conv2d: got dataFormat of ${dataFormat} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);
      let result = conv2d$2(x, filter, strides, pad2, dataFormat, dilations, dimRoundingMode);
      if (bias != null) {
        result = add(result, bias);
      }
      return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
    }
    const $x = convertToTensor(x, "x", "conv2d", "float32");
    const $filter = convertToTensor(filter, "filter", "conv2d", "float32");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape$1($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert($filter.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
    checkPadOnDimRoundingMode("fused conv2d", pad2, dimRoundingMode);
    const inputChannels = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
    assert($filter.shape[2] === inputChannels, () => `Error in conv2d: depth of input (${inputChannels}) must match input depth for filter ${$filter.shape[2]}.`);
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad2, dimRoundingMode);
    let $bias;
    if (bias != null) {
      $bias = convertToTensor(bias, "bias", "fused conv2d");
      [$bias] = makeTypesMatch($bias, $x);
      if (dataFormat === "NHWC") {
        assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
      } else {
        assert($bias.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${$bias.shape.length}.`);
        assert($bias.shape.length === 0 || $bias.shape[0] === convInfo.outChannels || $bias.shape[0] === 1, () => `Error in fused conv2d: bias shape (${$bias.shape}) is not compatible with the number of output channels (${convInfo.outChannels})`);
      }
    }
    let $preluActivationWeights;
    if (preluActivationWeights != null) {
      const alphaShape = preluActivationWeights.shape;
      assert(alphaShape.length <= 1 || alphaShape.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${alphaShape.length}.`);
      if (alphaShape.length === 1) {
        assert(alphaShape[0] === 1 || alphaShape[0] === convInfo.outChannels, () => `Error in fused conv2d: PReLU activation weights (${alphaShape}) is not compatible with the number of output channels (${convInfo.outChannels}).`);
      } else if (alphaShape.length === 3) {
        try {
          assertAndGetBroadcastShape(alphaShape, convInfo.outShape);
        } catch (e) {
          const errMsg = `Error in fused conv2d: PReLU activation weights (${alphaShape}) is not compatible with the output shape of the conv2d (${convInfo.outShape}).`;
          throw Error(errMsg);
        }
      }
      $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused conv2d");
    }
    const grad2 = (dy, saved) => {
      assert(dataFormat === "NHWC", () => `Error in gradient of fused conv2D: got dataFormat of ${dataFormat} but only NHWC is currently supported.`);
      const [$filter2, x4D2, y, $bias2] = saved;
      const dyActivation = getFusedDyActivation(dy, y, activation);
      assert(tupleValuesAreOne(dilations), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);
      const xDer = conv2DBackpropInput$1(x4D2.shape, dyActivation, $filter2, strides, pad2);
      const filterDer = conv2DBackpropFilter$1(x4D2, dyActivation, $filter2.shape, strides, pad2);
      const der = [xDer, filterDer];
      if ($bias2 != null) {
        const biasDer = getFusedBiasGradient($bias2, dyActivation);
        der.push(biasDer);
      }
      return der;
    };
    const inputs = {
      x: x4D,
      filter: $filter,
      bias: $bias,
      preluActivationWeights: $preluActivationWeights
    };
    const attrs = {
      strides,
      pad: pad2,
      dataFormat,
      dilations,
      dimRoundingMode,
      activation,
      leakyreluAlpha
    };
    if (bias == null) {
      const customOp = customGrad((x4D2, filter2, save) => {
        let res = (
          // tslint:disable-next-line: no-unnecessary-type-assertion
          ENGINE.runKernel(FusedConv2D, inputs, attrs)
        );
        save([filter2, x4D2, res]);
        if (reshapedTo4D) {
          res = reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
        }
        return { value: res, gradFunc: grad2 };
      });
      return customOp(x4D, $filter);
    } else {
      const customOpWithBias = customGrad((x4D2, filter2, bias2, save) => {
        let res = ENGINE.runKernel(FusedConv2D, inputs, attrs);
        save([filter2, x4D2, res, bias2]);
        if (reshapedTo4D) {
          res = reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
        }
        return { value: res, gradFunc: grad2 };
      });
      return customOpWithBias(x4D, $filter, $bias);
    }
  }
  const conv2d$1 = /* @__PURE__ */ op({ fusedConv2d_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function depthwiseConv2dNativeBackpropFilter_(x, dy, filterShape, strides, pad2, dilations = [1, 1], dimRoundingMode) {
    let x4D = x;
    if (x.rank === 3) {
      x4D = reshape$1(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
    }
    let dy4D = dy;
    if (dy4D.rank === 3) {
      dy4D = reshape$1(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    }
    const inputs = { x: x4D, dy: dy4D };
    const attrs = { strides, pad: pad2, dimRoundingMode, dilations, filterShape };
    return ENGINE.runKernel(DepthwiseConv2dNativeBackpropFilter, inputs, attrs);
  }
  const depthwiseConv2dNativeBackpropFilter$1 = op({ depthwiseConv2dNativeBackpropFilter_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function depthwiseConv2dNativeBackpropInput_(xShape, dy, filter, strides, pad2, dilations = [1, 1], dimRoundingMode) {
    let dy4D = dy;
    let reshapedTo4D = false;
    if (dy.rank === 3) {
      reshapedTo4D = true;
      dy4D = reshape$1(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    }
    const inputs = { dy: dy4D, filter };
    const attrs = { strides, pad: pad2, dimRoundingMode, dilations, inputShape: xShape };
    const res = (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      ENGINE.runKernel(DepthwiseConv2dNativeBackpropInput, inputs, attrs)
    );
    if (reshapedTo4D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  const depthwiseConv2dNativeBackpropInput$1 = op({ depthwiseConv2dNativeBackpropInput_ });
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function fusedDepthwiseConv2d_({ x, filter, strides, pad: pad2, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation = "linear", preluActivationWeights, leakyreluAlpha }) {
    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
      let result = depthwiseConv2d$1(x, filter, strides, pad2, dataFormat, dilations, dimRoundingMode);
      if (bias != null) {
        result = add(result, bias);
      }
      return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
    }
    const $x = convertToTensor(x, "x", "depthwiseConv2d", "float32");
    const $filter = convertToTensor(filter, "filter", "depthwiseConv2d", "float32");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape$1($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert($filter.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
    assert(x4D.shape[3] === $filter.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${x4D.shape[3]}) must match the inChannels dimension in filter ${$filter.shape[2]}.`);
    if (dilations == null) {
      dilations = [1, 1];
    }
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    checkPadOnDimRoundingMode("fused depthwiseConv2d", pad2, dimRoundingMode);
    const convInfo = computeConv2DInfo(
      x4D.shape,
      $filter.shape,
      strides,
      dilations,
      pad2,
      dimRoundingMode,
      true
      /* depthwise */
    );
    let $bias;
    if (bias != null) {
      $bias = convertToTensor(bias, "bias", "fused conv2d");
      [$bias] = makeTypesMatch($bias, $x);
      assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
    }
    let $preluActivationWeights;
    if (preluActivationWeights != null) {
      $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused depthwiseConv2d");
    }
    const grad2 = (dy, saved) => {
      assert(tupleValuesAreOne(dilations), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${dilations}'`);
      const [$filter2, x4D2, y, bias2] = saved;
      const dyActivation = getFusedDyActivation(dy, y, activation);
      const xDer = depthwiseConv2dNativeBackpropInput$1(x4D2.shape, dyActivation, $filter2, strides, pad2, dilations, dimRoundingMode);
      const filterDer = depthwiseConv2dNativeBackpropFilter$1(x4D2, dyActivation, $filter2.shape, strides, pad2, dilations, dimRoundingMode);
      if (bias2 != null) {
        const biasDer = getFusedBiasGradient($bias, dyActivation);
        return [xDer, filterDer, biasDer];
      }
      return [xDer, filterDer];
    };
    const inputs = {
      x: x4D,
      filter: $filter,
      bias: $bias,
      preluActivationWeights: $preluActivationWeights
    };
    const attrs = {
      strides,
      pad: pad2,
      dataFormat,
      dilations,
      dimRoundingMode,
      activation,
      leakyreluAlpha
    };
    if (bias == null) {
      const customOp = customGrad((x4D2, filter2, save) => {
        let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
        save([filter2, x4D2, res]);
        if (reshapedTo4D) {
          res = reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
        }
        return { value: res, gradFunc: grad2 };
      });
      return customOp(x4D, $filter);
    } else {
      const customOpWithBias = customGrad((x4D2, filter2, bias2, save) => {
        let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
        save([filter2, x4D2, res, bias2]);
        if (reshapedTo4D) {
          res = reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
        }
        return { value: res, gradFunc: grad2 };
      });
      return customOpWithBias(x4D, $filter, $bias);
    }
  }
  const depthwiseConv2d = /* @__PURE__ */ op({ fusedDepthwiseConv2d_ });
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function fusedMatMul_({ a, b, transposeA = false, transposeB = false, bias, activation = "linear", preluActivationWeights, leakyreluAlpha = 0.2 }) {
    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
      let result = matMul$1(a, b, transposeA, transposeB);
      if (bias != null) {
        result = add(result, bias);
      }
      return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
    }
    let $a = convertToTensor(a, "a", "fused matMul");
    let $b = convertToTensor(b, "b", "fused matMul");
    [$a, $b] = makeTypesMatch($a, $b);
    const innerShapeA = transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];
    const innerShapeB = transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];
    const outerShapeA = transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];
    const outerShapeB = transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];
    const outerDimsA = $a.shape.slice(0, -2);
    const outerDimsB = $b.shape.slice(0, -2);
    const batchDimA = sizeFromShape(outerDimsA);
    const batchDimB = sizeFromShape(outerDimsB);
    assert(innerShapeA === innerShapeB, () => `Error in fused matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${$a.shape} and ${$b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
    const outShapeOuterDims = assertAndGetBroadcastShape($a.shape.slice(0, -2), $b.shape.slice(0, -2));
    const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
    const a3D = transposeA ? reshape$1($a, [batchDimA, innerShapeA, outerShapeA]) : reshape$1($a, [batchDimA, outerShapeA, innerShapeA]);
    const b3D = transposeB ? reshape$1($b, [batchDimB, outerShapeB, innerShapeB]) : reshape$1($b, [batchDimB, innerShapeB, outerShapeB]);
    let $bias;
    if (bias != null) {
      $bias = convertToTensor(bias, "bias", "fused matMul");
      [$bias] = makeTypesMatch($bias, $a);
      assertAndGetBroadcastShape(outShape, $bias.shape);
    }
    let $preluActivationWeights;
    if (preluActivationWeights != null) {
      $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused matMul");
    }
    const grad2 = (dy, saved) => {
      const [a3D2, b3D2, y, $bias2] = saved;
      const dyActivation = getFusedDyActivation(reshape$1(dy, y.shape), y, activation);
      let aDer;
      let bDer;
      if (!transposeA && !transposeB) {
        aDer = matMul$1(dyActivation, b3D2, false, true);
        bDer = matMul$1(a3D2, dyActivation, true, false);
      } else if (!transposeA && transposeB) {
        aDer = matMul$1(dyActivation, b3D2, false, false);
        bDer = matMul$1(dyActivation, a3D2, true, false);
      } else if (transposeA && !transposeB) {
        aDer = matMul$1(b3D2, dyActivation, false, true);
        bDer = matMul$1(a3D2, dyActivation, false, false);
      } else {
        aDer = matMul$1(b3D2, dyActivation, true, true);
        bDer = matMul$1(dyActivation, a3D2, true, true);
      }
      if (bias != null) {
        const biasDer = getFusedBiasGradient($bias2, dyActivation);
        return [aDer, bDer, biasDer];
      } else {
        return [aDer, bDer];
      }
    };
    const inputs = {
      a: a3D,
      b: b3D,
      bias: $bias,
      preluActivationWeights: $preluActivationWeights
    };
    const attrs = { transposeA, transposeB, activation, leakyreluAlpha };
    if (bias == null) {
      const customOp = customGrad((a3D2, b3D2, save) => {
        const res = (
          // tslint:disable-next-line: no-unnecessary-type-assertion
          ENGINE.runKernel(_FusedMatMul, inputs, attrs)
        );
        save([a3D2, b3D2, res]);
        return { value: reshape$1(res, outShape), gradFunc: grad2 };
      });
      return customOp(a3D, b3D);
    } else {
      const customOpWithBias = customGrad((a3D2, b3D2, $bias2, save) => {
        const res = (
          // tslint:disable-next-line: no-unnecessary-type-assertion
          ENGINE.runKernel(_FusedMatMul, inputs, attrs)
        );
        save([a3D2, b3D2, res, $bias2]);
        return { value: reshape$1(res, outShape), gradFunc: grad2 };
      });
      return customOpWithBias(a3D, b3D, $bias);
    }
  }
  const matMul = /* @__PURE__ */ op({ fusedMatMul_ });
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const fused_ops = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    conv2d: conv2d$1,
    depthwiseConv2d,
    matMul
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function hammingWindow_(windowLength) {
    return cosineWindow(windowLength, 0.54, 0.46);
  }
  const hammingWindow = /* @__PURE__ */ op({ hammingWindow_ });
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function hannWindow_(windowLength) {
    return cosineWindow(windowLength, 0.5, 0.5);
  }
  const hannWindow = /* @__PURE__ */ op({ hannWindow_ });
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function frame_(signal2, frameLength, frameStep, padEnd = false, padValue = 0) {
    let start = 0;
    const output = [];
    while (start + frameLength <= signal2.size) {
      output.push(slice$1(signal2, start, frameLength));
      start += frameStep;
    }
    if (padEnd) {
      while (start < signal2.size) {
        const padLen = start + frameLength - signal2.size;
        const pad2 = concat$1([
          slice$1(signal2, start, frameLength - padLen),
          fill$1([padLen], padValue)
        ]);
        output.push(pad2);
        start += frameStep;
      }
    }
    if (output.length === 0) {
      return tensor2d([], [0, frameLength]);
    }
    return reshape$1(concat$1(output), [output.length, frameLength]);
  }
  const frame = /* @__PURE__ */ op({ frame_ });
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function stft_(signal2, frameLength, frameStep, fftLength, windowFn = hannWindow) {
    if (fftLength == null) {
      fftLength = enclosingPowerOfTwo(frameLength);
    }
    const framedSignal = frame(signal2, frameLength, frameStep);
    const windowedSignal = mul(framedSignal, windowFn(frameLength));
    return rfft(windowedSignal, fftLength);
  }
  const stft = /* @__PURE__ */ op({ stft_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function cropAndResize_(image2, boxes, boxInd, cropSize, method = "bilinear", extrapolationValue = 0) {
    const $image = convertToTensor(image2, "image", "cropAndResize");
    const $boxes = convertToTensor(boxes, "boxes", "cropAndResize", "float32");
    const $boxInd = convertToTensor(boxInd, "boxInd", "cropAndResize", "int32");
    const numBoxes = $boxes.shape[0];
    assert($image.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${$image.rank}.`);
    assert($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] but had shape ${$boxes.shape}.`);
    assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] but had shape ${$boxes.shape}.`);
    assert(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${cropSize.length}.`);
    assert(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);
    assert(method === "bilinear" || method === "nearest", () => `method must be bilinear or nearest, but was ${method}`);
    const inputs = { image: $image, boxes: $boxes, boxInd: $boxInd };
    const attrs = { method, extrapolationValue, cropSize };
    const res = ENGINE.runKernel(CropAndResize, inputs, attrs);
    return res;
  }
  const cropAndResize$1 = /* @__PURE__ */ op({ cropAndResize_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function flipLeftRight_(image2) {
    const $image = convertToTensor(image2, "image", "flipLeftRight", "float32");
    assert($image.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${$image.rank}.`);
    const inputs = { image: $image };
    const res = ENGINE.runKernel(FlipLeftRight, inputs, {});
    return res;
  }
  const flipLeftRight = /* @__PURE__ */ op({ flipLeftRight_ });
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function grayscaleToRGB_(image2) {
    const $image = convertToTensor(image2, "image", "grayscaleToRGB");
    const lastDimsIdx = $image.rank - 1;
    const lastDims = $image.shape[lastDimsIdx];
    assert($image.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${$image.rank}.`);
    assert(lastDims === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${lastDims}.`);
    const reps = new Array($image.rank);
    reps.fill(1, 0, lastDimsIdx);
    reps[lastDimsIdx] = 3;
    return tile$1($image, reps);
  }
  const grayscaleToRGB = /* @__PURE__ */ op({ grayscaleToRGB_ });
  /**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function rgbToGrayscale_(image2) {
    const $image = convertToTensor(image2, "image", "RGBToGrayscale");
    const lastDimsIdx = $image.rank - 1;
    const lastDims = $image.shape[lastDimsIdx];
    assert($image.rank >= 2, () => `Error in RGBToGrayscale: images must be at least rank 2, but got rank ${$image.rank}.`);
    assert(lastDims === 3, () => `Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${lastDims}.`);
    const origDtype = $image.dtype;
    const fltImage = cast$1($image, "float32");
    const rgbWeights = tensor1d([0.2989, 0.587, 0.114]);
    let grayFloat;
    switch ($image.rank) {
      case 2:
        grayFloat = einsum$1("ij,j->i", fltImage, rgbWeights);
        break;
      case 3:
        grayFloat = einsum$1("ijk,k->ij", fltImage, rgbWeights);
        break;
      case 4:
        grayFloat = einsum$1("ijkl,l->ijk", fltImage, rgbWeights);
        break;
      case 5:
        grayFloat = einsum$1("ijklm,m->ijkl", fltImage, rgbWeights);
        break;
      case 6:
        grayFloat = einsum$1("ijklmn,n->ijklm", fltImage, rgbWeights);
        break;
      default:
        throw new Error("Not a valid tensor rank.");
    }
    grayFloat = expandDims$1(grayFloat, -1);
    return cast$1(grayFloat, origDtype);
  }
  const rgbToGrayscale = /* @__PURE__ */ op({ rgbToGrayscale_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function rotateWithOffset_(image2, radians, fillValue = 0, center = 0.5) {
    const $image = convertToTensor(image2, "image", "rotateWithOffset", "float32");
    assert($image.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${$image.rank}.`);
    const inputs = { image: $image };
    const attrs = { radians, fillValue, center };
    const res = ENGINE.runKernel(RotateWithOffset, inputs, attrs);
    return res;
  }
  const rotateWithOffset = /* @__PURE__ */ op({ rotateWithOffset_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function nonMaxSuppSanityCheck(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
    if (iouThreshold == null) {
      iouThreshold = 0.5;
    }
    if (scoreThreshold == null) {
      scoreThreshold = Number.NEGATIVE_INFINITY;
    }
    if (softNmsSigma == null) {
      softNmsSigma = 0;
    }
    const numBoxes = boxes.shape[0];
    maxOutputSize = Math.min(maxOutputSize, numBoxes);
    assert(0 <= iouThreshold && iouThreshold <= 1, () => `iouThreshold must be in [0, 1], but was '${iouThreshold}'`);
    assert(boxes.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${boxes.rank}'`);
    assert(boxes.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${boxes.shape[1]}`);
    assert(scores.rank === 1, () => "scores must be a 1D tensor");
    assert(scores.shape[0] === numBoxes, () => `scores has incompatible shape with boxes. Expected ${numBoxes}, but was ${scores.shape[0]}`);
    assert(0 <= softNmsSigma && softNmsSigma <= 1, () => `softNmsSigma must be in [0, 1], but was '${softNmsSigma}'`);
    return { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function nonMaxSuppression_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression", "float32");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppression", "float32");
    const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
    maxOutputSize = inputs.maxOutputSize;
    iouThreshold = inputs.iouThreshold;
    scoreThreshold = inputs.scoreThreshold;
    const attrs = { maxOutputSize, iouThreshold, scoreThreshold };
    return ENGINE.runKernel(NonMaxSuppressionV3, { boxes: $boxes, scores: $scores }, attrs);
  }
  const nonMaxSuppression = /* @__PURE__ */ op({ nonMaxSuppression_ });
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function binaryInsert(arr, element, comparator) {
    const index2 = binarySearch(arr, element, comparator);
    const insertionPoint = index2 < 0 ? -(index2 + 1) : index2;
    arr.splice(insertionPoint, 0, element);
  }
  function binarySearch(arr, target, comparator) {
    return binarySearch_(arr, target, comparator || defaultComparator);
  }
  function defaultComparator(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }
  function binarySearch_(arr, target, comparator) {
    let left = 0;
    let right = arr.length;
    let middle = 0;
    let found = false;
    while (left < right) {
      middle = left + (right - left >>> 1);
      const compareResult = comparator(target, arr[middle]);
      if (compareResult > 0) {
        left = middle + 1;
      } else {
        right = middle;
        found = !compareResult;
      }
    }
    return found ? left : -left - 1;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function nonMaxSuppressionV3Impl$1(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
    return nonMaxSuppressionImpl_(
      boxes,
      scores,
      maxOutputSize,
      iouThreshold,
      scoreThreshold,
      0
      /* softNmsSigma */
    );
  }
  function nonMaxSuppressionV4Impl$1(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {
    return nonMaxSuppressionImpl_(
      boxes,
      scores,
      maxOutputSize,
      iouThreshold,
      scoreThreshold,
      0,
      false,
      padToMaxOutputSize,
      true
      /* returnValidOutputs */
    );
  }
  function nonMaxSuppressionV5Impl$1(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
    return nonMaxSuppressionImpl_(
      boxes,
      scores,
      maxOutputSize,
      iouThreshold,
      scoreThreshold,
      softNmsSigma,
      true
      /* returnScoresTensor */
    );
  }
  function nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {
    const candidates = [];
    for (let i = 0; i < scores.length; i++) {
      if (scores[i] > scoreThreshold) {
        candidates.push({ score: scores[i], boxIndex: i, suppressBeginIndex: 0 });
      }
    }
    candidates.sort(ascendingComparator);
    const scale = softNmsSigma > 0 ? -0.5 / softNmsSigma : 0;
    const selectedIndices = [];
    const selectedScores = [];
    while (selectedIndices.length < maxOutputSize && candidates.length > 0) {
      const candidate = candidates.pop();
      const { score: originalScore, boxIndex, suppressBeginIndex } = candidate;
      if (originalScore < scoreThreshold) {
        break;
      }
      let ignoreCandidate = false;
      for (let j2 = selectedIndices.length - 1; j2 >= suppressBeginIndex; --j2) {
        const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j2]);
        if (iou >= iouThreshold) {
          ignoreCandidate = true;
          break;
        }
        candidate.score = candidate.score * suppressWeight(iouThreshold, scale, iou);
        if (candidate.score <= scoreThreshold) {
          break;
        }
      }
      candidate.suppressBeginIndex = selectedIndices.length;
      if (!ignoreCandidate) {
        if (candidate.score === originalScore) {
          selectedIndices.push(boxIndex);
          selectedScores.push(candidate.score);
        } else if (candidate.score > scoreThreshold) {
          binaryInsert(candidates, candidate, ascendingComparator);
        }
      }
    }
    const validOutputs = selectedIndices.length;
    const elemsToPad = maxOutputSize - validOutputs;
    if (padToMaxOutputSize && elemsToPad > 0) {
      selectedIndices.push(...new Array(elemsToPad).fill(0));
      selectedScores.push(...new Array(elemsToPad).fill(0));
    }
    const result = { selectedIndices };
    if (returnScoresTensor) {
      result["selectedScores"] = selectedScores;
    }
    if (returnValidOutputs) {
      result["validOutputs"] = validOutputs;
    }
    return result;
  }
  function intersectionOverUnion(boxes, i, j2) {
    const iCoord = boxes.subarray(i * 4, i * 4 + 4);
    const jCoord = boxes.subarray(j2 * 4, j2 * 4 + 4);
    const yminI = Math.min(iCoord[0], iCoord[2]);
    const xminI = Math.min(iCoord[1], iCoord[3]);
    const ymaxI = Math.max(iCoord[0], iCoord[2]);
    const xmaxI = Math.max(iCoord[1], iCoord[3]);
    const yminJ = Math.min(jCoord[0], jCoord[2]);
    const xminJ = Math.min(jCoord[1], jCoord[3]);
    const ymaxJ = Math.max(jCoord[0], jCoord[2]);
    const xmaxJ = Math.max(jCoord[1], jCoord[3]);
    const areaI = (ymaxI - yminI) * (xmaxI - xminI);
    const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
    if (areaI <= 0 || areaJ <= 0) {
      return 0;
    }
    const intersectionYmin = Math.max(yminI, yminJ);
    const intersectionXmin = Math.max(xminI, xminJ);
    const intersectionYmax = Math.min(ymaxI, ymaxJ);
    const intersectionXmax = Math.min(xmaxI, xmaxJ);
    const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0) * Math.max(intersectionXmax - intersectionXmin, 0);
    return intersectionArea / (areaI + areaJ - intersectionArea);
  }
  function suppressWeight(iouThreshold, scale, iou) {
    const weight = Math.exp(scale * iou * iou);
    return iou <= iouThreshold ? weight : 0;
  }
  function ascendingComparator(c1, c2) {
    return c1.score - c2.score || c1.score === c2.score && c2.boxIndex - c1.boxIndex;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  async function nonMaxSuppressionAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
    const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
    maxOutputSize = inputs.maxOutputSize;
    iouThreshold = inputs.iouThreshold;
    scoreThreshold = inputs.scoreThreshold;
    const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
    const boxesVals = boxesAndScores[0];
    const scoresVals = boxesAndScores[1];
    const { selectedIndices } = nonMaxSuppressionV3Impl$1(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
    if ($boxes !== boxes) {
      $boxes.dispose();
    }
    if ($scores !== scores) {
      $scores.dispose();
    }
    return tensor1d(selectedIndices, "int32");
  }
  const nonMaxSuppressionAsync = nonMaxSuppressionAsync_;
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function nonMaxSuppressionWithScore_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppression");
    const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    maxOutputSize = params.maxOutputSize;
    iouThreshold = params.iouThreshold;
    scoreThreshold = params.scoreThreshold;
    softNmsSigma = params.softNmsSigma;
    const inputs = { boxes: $boxes, scores: $scores };
    const attrs = { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
    const result = ENGINE.runKernel(NonMaxSuppressionV5, inputs, attrs);
    return { selectedIndices: result[0], selectedScores: result[1] };
  }
  const nonMaxSuppressionWithScore = /* @__PURE__ */ op({ nonMaxSuppressionWithScore_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  async function nonMaxSuppressionWithScoreAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
    const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    maxOutputSize = params.maxOutputSize;
    iouThreshold = params.iouThreshold;
    scoreThreshold = params.scoreThreshold;
    softNmsSigma = params.softNmsSigma;
    const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
    const boxesVals = boxesAndScores[0];
    const scoresVals = boxesAndScores[1];
    const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl$1(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    if ($boxes !== boxes) {
      $boxes.dispose();
    }
    if ($scores !== scores) {
      $scores.dispose();
    }
    return {
      selectedIndices: tensor1d(selectedIndices, "int32"),
      selectedScores: tensor1d(selectedScores)
    };
  }
  const nonMaxSuppressionWithScoreAsync = nonMaxSuppressionWithScoreAsync_;
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function nonMaxSuppressionPadded_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppression");
    const params = nonMaxSuppSanityCheck(
      $boxes,
      $scores,
      maxOutputSize,
      iouThreshold,
      scoreThreshold,
      null
      /* softNmsSigma */
    );
    const $maxOutputSize = params.maxOutputSize;
    const $iouThreshold = params.iouThreshold;
    const $scoreThreshold = params.scoreThreshold;
    const inputs = { boxes: $boxes, scores: $scores };
    const attrs = {
      maxOutputSize: $maxOutputSize,
      iouThreshold: $iouThreshold,
      scoreThreshold: $scoreThreshold,
      padToMaxOutputSize
    };
    const result = ENGINE.runKernel(NonMaxSuppressionV4, inputs, attrs);
    return { selectedIndices: result[0], validOutputs: result[1] };
  }
  const nonMaxSuppressionPadded = /* @__PURE__ */ op({ nonMaxSuppressionPadded_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  async function nonMaxSuppressionPaddedAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
    const params = nonMaxSuppSanityCheck(
      $boxes,
      $scores,
      maxOutputSize,
      iouThreshold,
      scoreThreshold,
      null
      /* softNmsSigma */
    );
    const $maxOutputSize = params.maxOutputSize;
    const $iouThreshold = params.iouThreshold;
    const $scoreThreshold = params.scoreThreshold;
    const [boxesVals, scoresVals] = await Promise.all([$boxes.data(), $scores.data()]);
    const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl$1(boxesVals, scoresVals, $maxOutputSize, $iouThreshold, $scoreThreshold, padToMaxOutputSize);
    if ($boxes !== boxes) {
      $boxes.dispose();
    }
    if ($scores !== scores) {
      $scores.dispose();
    }
    return {
      selectedIndices: tensor1d(selectedIndices, "int32"),
      validOutputs: scalar(validOutputs, "int32")
    };
  }
  const nonMaxSuppressionPaddedAsync = nonMaxSuppressionPaddedAsync_;
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function resizeBilinear_(images, size, alignCorners = false, halfPixelCenters = false) {
    const $images = convertToTensor(images, "images", "resizeBilinear");
    assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${$images.rank}.`);
    assert(size.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${size}.`);
    assert(halfPixelCenters === false || alignCorners === false, () => `Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.`);
    let batchImages = $images;
    let reshapedTo4D = false;
    if ($images.rank === 3) {
      reshapedTo4D = true;
      batchImages = reshape$1($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
    }
    const inputs = { images: batchImages };
    const attrs = { alignCorners, halfPixelCenters, size };
    const res = ENGINE.runKernel(ResizeBilinear, inputs, attrs);
    if (reshapedTo4D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  const resizeBilinear$1 = /* @__PURE__ */ op({ resizeBilinear_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function resizeNearestNeighbor_(images, size, alignCorners = false, halfPixelCenters = false) {
    const $images = convertToTensor(images, "images", "resizeNearestNeighbor");
    assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${$images.rank}.`);
    assert(size.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${size}.`);
    assert($images.dtype === "float32" || $images.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype");
    assert(halfPixelCenters === false || alignCorners === false, () => `Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.`);
    let batchImages = $images;
    let reshapedTo4D = false;
    if ($images.rank === 3) {
      reshapedTo4D = true;
      batchImages = reshape$1($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
    }
    const inputs = { images: batchImages };
    const attrs = { alignCorners, halfPixelCenters, size };
    const res = ENGINE.runKernel(ResizeNearestNeighbor, inputs, attrs);
    if (reshapedTo4D) {
      return reshape$1(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  const resizeNearestNeighbor$1 = /* @__PURE__ */ op({ resizeNearestNeighbor_ });
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function threshold_(image2, method = "binary", inverted = false, threshValue = 0.5) {
    const $image = convertToTensor(image2, "image", "threshold");
    const RED_INTENCITY_COEF = 0.2989;
    const GREEN_INTENCITY_COEF = 0.587;
    const BLUE_INTENCITY_COEF = 0.114;
    const totalPixelsInImage = $image.shape[0] * $image.shape[1];
    let $threshold = mul(tensor1d([threshValue]), 255);
    let r, g, b, grayscale;
    assert($image.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${$image.rank}.`);
    assert($image.shape[2] === 3 || $image.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${$image.shape[2]}.`);
    assert($image.dtype === "int32" || $image.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${$image.dtype}.`);
    assert(method === "otsu" || method === "binary", () => `Method must be binary or otsu, but was ${method}`);
    if ($image.shape[2] === 3) {
      [r, g, b] = split$2($image, [1, 1, 1], -1);
      const $r = mul(r, RED_INTENCITY_COEF);
      const $g = mul(g, GREEN_INTENCITY_COEF);
      const $b = mul(b, BLUE_INTENCITY_COEF);
      grayscale = add(add($r, $g), $b);
    } else {
      grayscale = image2;
    }
    if (method === "otsu") {
      const $histogram = bincount$1(cast$1(round$1(grayscale), "int32"), tensor([]), 256);
      $threshold = otsu($histogram, totalPixelsInImage);
    }
    const invCondition = inverted ? lessEqual$1(grayscale, $threshold) : greater$1(grayscale, $threshold);
    const result = cast$1(mul(invCondition, 255), "int32");
    return result;
  }
  function otsu(histogram, total) {
    let bestThresh = tensor1d([-1]);
    let bestInBetVar = tensor1d([0]);
    let cInBetVar = tensor1d([0]);
    let classFirst, classSecond, meanFirst, meanSec, weightForeground, weightBack;
    for (let index2 = 0; index2 < histogram.size - 1; index2++) {
      classFirst = slice$1(histogram, 0, index2 + 1);
      classSecond = slice$1(histogram, index2 + 1);
      weightForeground = div(sum$1(classFirst), total);
      weightBack = div(sum$1(classSecond), total);
      const meanFirstDivA = sum$1(mul(classFirst, range$1(0, classFirst.size)));
      meanFirst = div(meanFirstDivA, sum$1(classFirst));
      const meanSecFill = fill$1(classSecond.shape, classFirst.size);
      const meanSecAdd = add(range$1(0, classSecond.size), meanSecFill);
      const meanSecMul = mul(classSecond, meanSecAdd);
      meanSec = div(sum$1(meanSecMul), sum$1(classSecond));
      const cInBetVarSubA = sub$1(meanFirst, meanSec);
      const cInBetVarSubB = sub$1(meanFirst, meanSec);
      const cInBetVarMul = mul(weightForeground, weightBack);
      cInBetVar = mul(mul(cInBetVarMul, cInBetVarSubA), cInBetVarSubB);
      const condition = greater$1(cInBetVar, bestInBetVar);
      bestInBetVar = where(condition, cInBetVar, bestInBetVar);
      bestThresh = where(condition, tensor1d([index2]), bestThresh);
    }
    return bestThresh;
  }
  const threshold = /* @__PURE__ */ op({ threshold_ });
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function transform_(image2, transforms, interpolation = "nearest", fillMode = "constant", fillValue = 0, outputShape) {
    const $image = convertToTensor(image2, "image", "transform", "float32");
    const $transforms = convertToTensor(transforms, "transforms", "transform", "float32");
    assert($image.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${$image.rank}.`);
    assert($transforms.rank === 2 && ($transforms.shape[0] === $image.shape[0] || $transforms.shape[0] === 1) && $transforms.shape[1] === 8, () => `Error in transform: Input transform should be batch x 8 or 1 x 8`);
    assert(outputShape == null || outputShape.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${outputShape}.`);
    const inputs = { image: $image, transforms: $transforms };
    const attrs = { interpolation, fillMode, fillValue, outputShape };
    return ENGINE.runKernel(Transform, inputs, attrs);
  }
  const transform$1 = /* @__PURE__ */ op({ transform_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function bandPart_(a, numLower, numUpper) {
    const $a = convertToTensor(a, "a", "bandPart");
    assert($a.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${$a.rank}.`);
    const shape = $a.shape;
    const [M, N2] = $a.shape.slice(-2);
    let $numLower;
    let $numUpper;
    if (typeof numLower === "number") {
      assert(numLower % 1 === 0, () => `bandPart(): numLower must be an integer, got ${numLower}.`);
      assert(numLower <= M, () => `bandPart(): numLower (${numLower}) must not be greater than the number of rows (${M}).`);
      $numLower = convertToTensor(numLower < 0 ? M : numLower, "numLower", "bandPart");
    } else {
      assert(numLower.dtype === "int32", () => `bandPart(): numLower's dtype must be an int32.`);
      $numLower = where(less$1(numLower, 0), M, minimum$1(numLower, M));
    }
    if (typeof numUpper === "number") {
      assert(numUpper % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${numUpper}.`);
      assert(numUpper <= N2, () => `bandPart(): numUpper (${numUpper}) must not be greater than the number of columns (${N2}).`);
      $numUpper = convertToTensor(numUpper < 0 ? N2 : numUpper, "numUpper", "bandPart");
    } else {
      assert(numUpper.dtype === "int32", () => `bandPart(): numUpper's dtype must be an int32.`);
      $numUpper = where(less$1(numUpper, 0), N2, minimum$1(numUpper, N2));
    }
    const i = reshape$1(range$1(0, M, 1, "int32"), [-1, 1]);
    const j2 = range$1(0, N2, 1, "int32");
    const ij = sub$1(i, j2);
    const inBand = logicalAnd$1(lessEqual$1(ij, $numLower), greaterEqual$1(ij, neg$1($numUpper)));
    const zero = zeros([M, N2], $a.dtype);
    return reshape$1(stack(unstack(reshape$1($a, [-1, M, N2])).map((mat) => where(inBand, mat, zero))), shape);
  }
  const bandPart = /* @__PURE__ */ op({ bandPart_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function gramSchmidt_(xs) {
    let inputIsTensor2D;
    if (Array.isArray(xs)) {
      inputIsTensor2D = false;
      assert(xs != null && xs.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
      const dim = xs[0].shape[0];
      for (let i = 1; i < xs.length; ++i) {
        assert(xs[i].shape[0] === dim, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${xs[i].shape[0]} vs. ${dim})`);
      }
    } else {
      inputIsTensor2D = true;
      xs = split$2(xs, xs.shape[0], 0).map((x) => squeeze(x, [0]));
    }
    assert(xs.length <= xs[0].shape[0], () => `Gram-Schmidt: Number of vectors (${xs.length}) exceeds number of dimensions (${xs[0].shape[0]}).`);
    const ys = [];
    const xs1d = xs;
    for (let i = 0; i < xs.length; ++i) {
      ys.push(ENGINE.tidy(() => {
        let x = xs1d[i];
        if (i > 0) {
          for (let j2 = 0; j2 < i; ++j2) {
            const proj = mul(sum$1(mul(ys[j2], x)), ys[j2]);
            x = sub$1(x, proj);
          }
        }
        return div(x, norm(x, "euclidean"));
      }));
    }
    if (inputIsTensor2D) {
      return stack(ys, 0);
    } else {
      return ys;
    }
  }
  const gramSchmidt = /* @__PURE__ */ op({ gramSchmidt_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function qr_(x, fullMatrices = false) {
    assert(x.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${x.rank}`);
    if (x.rank === 2) {
      return qr2d(x, fullMatrices);
    } else {
      const outerDimsProd = x.shape.slice(0, x.shape.length - 2).reduce((value, prev) => value * prev);
      const x2ds = unstack(reshape$1(x, [
        outerDimsProd,
        x.shape[x.shape.length - 2],
        x.shape[x.shape.length - 1]
      ]), 0);
      const q2ds = [];
      const r2ds = [];
      x2ds.forEach((x2d) => {
        const [q2d, r2d] = qr2d(x2d, fullMatrices);
        q2ds.push(q2d);
        r2ds.push(r2d);
      });
      const q2 = reshape$1(stack(q2ds, 0), x.shape);
      const r = reshape$1(stack(r2ds, 0), x.shape);
      return [q2, r];
    }
  }
  function qr2d(x, fullMatrices = false) {
    return ENGINE.tidy(() => {
      assert(x.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${x.shape.length}D Tensor.`);
      const m = x.shape[0];
      const n = x.shape[1];
      let q2 = eye(m);
      let r = clone(x);
      const one2D = tensor2d([[1]], [1, 1]);
      let w = clone(one2D);
      const iters = m >= n ? n : m;
      for (let j2 = 0; j2 < iters; ++j2) {
        const rTemp = r;
        const wTemp = w;
        const qTemp = q2;
        [w, r, q2] = ENGINE.tidy(() => {
          const rjEnd1 = slice$1(r, [j2, j2], [m - j2, 1]);
          const normX = norm(rjEnd1);
          const rjj = slice$1(r, [j2, j2], [1, 1]);
          const s = where(greater$1(rjj, 0), tensor2d([[-1]]), tensor2d([[1]]));
          const u1 = sub$1(rjj, mul(s, normX));
          const wPre = div(rjEnd1, u1);
          if (wPre.shape[0] === 1) {
            w = clone(one2D);
          } else {
            w = concat$1([
              one2D,
              slice$1(wPre, [1, 0], [wPre.shape[0] - 1, wPre.shape[1]])
            ], 0);
          }
          const tau = neg$1(div(matMul$1(s, u1), normX));
          const rjEndAll = slice$1(r, [j2, 0], [m - j2, n]);
          const tauTimesW = mul(tau, w);
          const wT = transpose$1(w);
          if (j2 === 0) {
            r = sub$1(rjEndAll, matMul$1(tauTimesW, matMul$1(wT, rjEndAll)));
          } else {
            const rTimesTau = sub$1(rjEndAll, matMul$1(tauTimesW, matMul$1(wT, rjEndAll)));
            r = concat$1([slice$1(r, [0, 0], [j2, n]), rTimesTau], 0);
          }
          const tawTimesWT = transpose$1(tauTimesW);
          const qAllJEnd = slice$1(q2, [0, j2], [m, q2.shape[1] - j2]);
          if (j2 === 0) {
            q2 = sub$1(qAllJEnd, matMul$1(matMul$1(qAllJEnd, w), tawTimesWT));
          } else {
            const qTimesTau = sub$1(qAllJEnd, matMul$1(matMul$1(qAllJEnd, w), tawTimesWT));
            q2 = concat$1([slice$1(q2, [0, 0], [m, j2]), qTimesTau], 1);
          }
          return [w, r, q2];
        });
        dispose([rTemp, wTemp, qTemp]);
      }
      if (!fullMatrices && m > n) {
        q2 = slice$1(q2, [0, 0], [m, n]);
        r = slice$1(r, [0, 0], [n, n]);
      }
      return [q2, r];
    });
  }
  const qr = /* @__PURE__ */ op({ qr_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  var Reduction;
  (function(Reduction2) {
    Reduction2[Reduction2["NONE"] = 0] = "NONE";
    Reduction2[Reduction2["MEAN"] = 1] = "MEAN";
    Reduction2[Reduction2["SUM"] = 2] = "SUM";
    Reduction2[Reduction2["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS";
  })(Reduction || (Reduction = {}));
  function computeWeightedLoss_(losses2, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $losses = convertToTensor(losses2, "losses", "computeWeightedLoss");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "computeWeightedLoss");
    }
    const weightedLoss = $weights == null ? $losses : mul($losses, $weights);
    if (reduction2 === Reduction.NONE) {
      return weightedLoss;
    }
    if (reduction2 === Reduction.SUM) {
      return sum$1(weightedLoss);
    }
    if (reduction2 === Reduction.MEAN) {
      if ($weights == null) {
        return mean(weightedLoss);
      } else {
        const broadcastFactor = $losses.size / $weights.size;
        const result = div(sum$1(weightedLoss), sum$1($weights));
        return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) : result;
      }
    }
    if (reduction2 === Reduction.SUM_BY_NONZERO_WEIGHTS) {
      if ($weights == null) {
        return div(sum$1(weightedLoss), scalar($losses.size));
      } else {
        const broadcastedWeights = mul($weights, ones($losses.shape));
        const numNonZeros = cast$1(sum$1(notEqual$1(broadcastedWeights, scalar(0))), "float32");
        return div(sum$1(weightedLoss), numNonZeros);
      }
    }
    throw Error(`Unknown reduction: ${reduction2}`);
  }
  const computeWeightedLoss = /* @__PURE__ */ op({ computeWeightedLoss_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function absoluteDifference_(labels, predictions, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, "labels", "absoluteDifference");
    const $predictions = convertToTensor(predictions, "predictions", "absoluteDifference");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "absoluteDifference");
    }
    assertShapesMatch($labels.shape, $predictions.shape, "Error in absoluteDifference: ");
    const losses2 = abs$1(sub$1($labels, $predictions));
    return computeWeightedLoss(losses2, $weights, reduction2);
  }
  const absoluteDifference = /* @__PURE__ */ op({ absoluteDifference_ });
  function cosineDistance_(labels, predictions, axis, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, "labels", "cosineDistance");
    const $predictions = convertToTensor(predictions, "predictions", "cosineDistance");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "cosineDistance");
    }
    assertShapesMatch($labels.shape, $predictions.shape, "Error in cosineDistance: ");
    const one = scalar(1);
    const losses2 = sub$1(one, sum$1(mul($labels, $predictions), axis, true));
    return computeWeightedLoss(losses2, $weights, reduction2);
  }
  const cosineDistance = /* @__PURE__ */ op({ cosineDistance_ });
  function hingeLoss_(labels, predictions, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    let $labels = convertToTensor(labels, "labels", "hingeLoss");
    const $predictions = convertToTensor(predictions, "predictions", "hingeLoss");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "hingeLoss");
    }
    assertShapesMatch($labels.shape, $predictions.shape, "Error in hingeLoss: ");
    const one = scalar(1);
    $labels = sub$1(mul(scalar(2), $labels), one);
    const losses2 = relu$1(sub$1(one, mul($labels, $predictions)));
    return computeWeightedLoss(losses2, $weights, reduction2);
  }
  const hingeLoss = /* @__PURE__ */ op({ hingeLoss_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function huberLoss_(labels, predictions, weights, delta = 1, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, "labels", "huberLoss");
    const $predictions = convertToTensor(predictions, "predictions", "huberLoss");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "huberLoss");
    }
    assertShapesMatch($labels.shape, $predictions.shape, "Error in huberLoss: ");
    const deltaScalar = scalar(delta);
    const error = abs$1(sub$1($predictions, $labels));
    const quadratic = minimum$1(error, deltaScalar);
    const linear = sub$1(error, quadratic);
    const losses2 = add(mul(scalar(0.5), square$1(quadratic)), mul(deltaScalar, linear));
    return computeWeightedLoss(losses2, $weights, reduction2);
  }
  const huberLoss = /* @__PURE__ */ op({ huberLoss_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function logLoss_(labels, predictions, weights, epsilon = 1e-7, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, "labels", "logLoss");
    const $predictions = convertToTensor(predictions, "predictions", "logLoss");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "logLoss");
    }
    assertShapesMatch($labels.shape, $predictions.shape, "Error in logLoss: ");
    const one = scalar(1);
    const epsilonScalar = scalar(epsilon);
    const l1 = neg$1(mul($labels, log$1(add($predictions, epsilonScalar))));
    const l2 = mul(sub$1(one, $labels), log$1(add(sub$1(one, $predictions), epsilonScalar)));
    const losses2 = sub$1(l1, l2);
    return computeWeightedLoss(losses2, $weights, reduction2);
  }
  const logLoss = /* @__PURE__ */ op({ logLoss_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function meanSquaredError_(labels, predictions, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, "labels", "meanSquaredError");
    const $predictions = convertToTensor(predictions, "predictions", "meanSquaredError");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "meanSquaredError");
    }
    assertShapesMatch($labels.shape, $predictions.shape, "Error in meanSquaredError: ");
    const losses2 = squaredDifference$1($labels, $predictions);
    return computeWeightedLoss(losses2, $weights, reduction2);
  }
  const meanSquaredError = /* @__PURE__ */ op({ meanSquaredError_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sigmoidCrossEntropyWithLogits_(labels, logits) {
    const $labels = convertToTensor(labels, "labels", "sigmoidCrossEntropyWithLogits");
    const $logits = convertToTensor(logits, "logits", "sigmoidCrossEntropyWithLogits");
    assertShapesMatch($labels.shape, $logits.shape, "Error in sigmoidCrossEntropyWithLogits: ");
    const maxOutput = relu$1($logits);
    const outputXTarget = mul($logits, $labels);
    const sigmoidOutput = log1p$1(exp$1(neg$1(abs$1($logits))));
    return add(sub$1(maxOutput, outputXTarget), sigmoidOutput);
  }
  function sigmoidCrossEntropy_(multiClassLabels, logits, weights, labelSmoothing = 0, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    let $multiClassLabels = convertToTensor(multiClassLabels, "multiClassLabels", "sigmoidCrossEntropy");
    const $logits = convertToTensor(logits, "logits", "sigmoidCrossEntropy");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "sigmoidCrossEntropy");
    }
    assertShapesMatch($multiClassLabels.shape, $logits.shape, "Error in sigmoidCrossEntropy: ");
    if (labelSmoothing > 0) {
      const labelSmoothingScalar = scalar(labelSmoothing);
      const one = scalar(1);
      const half = scalar(0.5);
      $multiClassLabels = add(mul($multiClassLabels, sub$1(one, labelSmoothingScalar)), mul(half, labelSmoothingScalar));
    }
    const losses2 = sigmoidCrossEntropyWithLogits_($multiClassLabels, $logits);
    return computeWeightedLoss(losses2, $weights, reduction2);
  }
  const sigmoidCrossEntropy = /* @__PURE__ */ op({ sigmoidCrossEntropy_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function softmaxCrossEntropyWithLogits_(labels, logits, dim = -1) {
    if (dim === -1) {
      dim = logits.rank - 1;
    }
    if (dim !== logits.rank - 1) {
      throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${logits.rank} and dim was ${dim}`);
    }
    const customOp = customGrad((labels2, logits2, save) => {
      const keepDims = true;
      const lse = logSumExp(logits2, [dim], keepDims);
      const logResult = sub$1(cast$1(logits2, "float32"), lse);
      save([labels2, logResult]);
      const costVector = neg$1(mul(logResult, labels2));
      const value = sum$1(costVector, [dim]);
      const gradFunc = (dy, saved) => {
        const [labels3, logResult2] = saved;
        const dyShape = expandShapeToKeepDim(dy.shape, [dim]);
        return [
          mul(reshape$1(dy, dyShape), sub$1(cast$1(labels3, "float32"), exp$1(logResult2))),
          mul(reshape$1(dy, dyShape), sub$1(exp$1(logResult2), cast$1(labels3, "float32")))
        ];
      };
      return { value, gradFunc };
    });
    return customOp(labels, logits);
  }
  function softmaxCrossEntropy_(onehotLabels, logits, weights, labelSmoothing = 0, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    let $onehotLabels = convertToTensor(onehotLabels, "onehotLabels", "softmaxCrossEntropy");
    const $logits = convertToTensor(logits, "logits", "softmaxCrossEntropy");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "softmaxCrossEntropy");
    }
    assertShapesMatch($onehotLabels.shape, $logits.shape, "Error in softmaxCrossEntropy: ");
    if (labelSmoothing > 0) {
      const labelSmoothingScalar = scalar(labelSmoothing);
      const one = scalar(1);
      const numClasses = scalar($onehotLabels.shape[1]);
      $onehotLabels = add(mul($onehotLabels, sub$1(one, labelSmoothingScalar)), div(labelSmoothingScalar, numClasses));
    }
    const losses2 = softmaxCrossEntropyWithLogits_($onehotLabels, $logits);
    return computeWeightedLoss(losses2, $weights, reduction2);
  }
  const softmaxCrossEntropy = /* @__PURE__ */ op({ softmaxCrossEntropy_ });
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sparseFillEmptyRows_(indices, values, denseShape, defaultValue) {
    const $indices = convertToTensor(indices, "indices", "sparseFillEmptyRows", "int32");
    const $values = convertToTensor(values, "values", "sparseFillEmptyRows");
    const $denseShape = convertToTensor(denseShape, "denseShape", "sparseFillEmptyRows", "int32");
    const $defaultValue = convertToTensor(defaultValue, "defaultValue", "sparseFillEmptyRows", $values.dtype);
    if ($indices.rank !== 2) {
      throw new Error(`Indices should be Tensor2D but received shape
        ${$indices.shape}`);
    }
    if ($values.rank !== 1) {
      throw new Error(`Values should be Tensor1D but received shape ${$values.shape}`);
    }
    if ($denseShape.rank !== 1) {
      throw new Error(`Dense shape should be Tensor1D but received shape ${$denseShape.shape}`);
    }
    if ($defaultValue.rank !== 0) {
      throw new Error(`Default value should be a scalar but received shape ${$defaultValue.shape}`);
    }
    const inputs = {
      indices: $indices,
      values: $values,
      denseShape: $denseShape,
      defaultValue: $defaultValue
    };
    const result = ENGINE.runKernel(SparseFillEmptyRows, inputs);
    return {
      outputIndices: result[0],
      outputValues: result[1],
      emptyRowIndicator: result[2],
      reverseIndexMap: result[3]
    };
  }
  const sparseFillEmptyRows$1 = /* @__PURE__ */ op({ sparseFillEmptyRows_ });
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sparseReshape_(inputIndices, inputShape, newShape) {
    const $inputIndices = convertToTensor(inputIndices, "inputIndices", "sparseReshape", "int32");
    const $inputShape = convertToTensor(inputShape, "inputShape", "sparseReshape", "int32");
    const $newShape = convertToTensor(newShape, "newShape", "sparseReshape", "int32");
    if ($inputIndices.rank !== 2) {
      throw new Error(`Input indices should be Tensor2D but received shape
        ${$inputIndices.shape}`);
    }
    if ($inputShape.rank !== 1) {
      throw new Error(`Input shape should be Tensor1D but received shape ${$inputShape.shape}`);
    }
    if ($newShape.rank !== 1) {
      throw new Error(`New shape should be Tensor1D but received shape ${$newShape.shape}`);
    }
    const inputs = {
      inputIndices: $inputIndices,
      inputShape: $inputShape,
      newShape: $newShape
    };
    const result = ENGINE.runKernel(SparseReshape, inputs);
    return { outputIndices: result[0], outputShape: result[1] };
  }
  const sparseReshape$1 = /* @__PURE__ */ op({ sparseReshape_ });
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sparseSegmentMean_(data, indices, segmentIds) {
    const $data = convertToTensor(data, "data", "sparseSegmentMean");
    const $indices = convertToTensor(indices, "indices", "sparseSegmentMean", "int32");
    const $segmentIds = convertToTensor(segmentIds, "segmentIds", "sparseSegmentMean", "int32");
    if ($data.rank < 1) {
      throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if ($indices.rank !== 1) {
      throw new Error(`Indices should be Tensor1D but received shape
          ${$indices.shape}`);
    }
    if ($segmentIds.rank !== 1) {
      throw new Error(`Segment ids should be Tensor1D but received shape
          ${$segmentIds.shape}`);
    }
    const inputs = {
      data: $data,
      indices: $indices,
      segmentIds: $segmentIds
    };
    return ENGINE.runKernel(SparseSegmentMean, inputs);
  }
  const sparseSegmentMean$1 = /* @__PURE__ */ op({ sparseSegmentMean_ });
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sparseSegmentSum_(data, indices, segmentIds) {
    const $data = convertToTensor(data, "data", "sparseSegmentSum");
    const $indices = convertToTensor(indices, "indices", "sparseSegmentSum", "int32");
    const $segmentIds = convertToTensor(segmentIds, "segmentIds", "sparseSegmentSum", "int32");
    if ($data.rank < 1) {
      throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if ($indices.rank !== 1) {
      throw new Error(`Indices should be Tensor1D but received shape
         ${$indices.shape}`);
    }
    if ($segmentIds.rank !== 1) {
      throw new Error(`Segment ids should be Tensor1D but received shape
         ${$segmentIds.shape}`);
    }
    const inputs = {
      data: $data,
      indices: $indices,
      segmentIds: $segmentIds
    };
    return ENGINE.runKernel(SparseSegmentSum, inputs);
  }
  const sparseSegmentSum$1 = /* @__PURE__ */ op({ sparseSegmentSum_ });
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function stringNGrams_(data, dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
    const $data = convertToTensor(data, "data", "stringNGrams", "string");
    if ($data.dtype !== "string") {
      throw new Error("Data must be of datatype string");
    }
    if ($data.shape.length !== 1) {
      throw new Error(`Data must be a vector, saw: ${$data.shape}`);
    }
    const $dataSplits = convertToTensor(dataSplits, "dataSplits", "stringNGrams");
    if ($dataSplits.dtype !== "int32") {
      throw new Error("Data splits must be of datatype int32");
    }
    const attrs = {
      separator,
      nGramWidths,
      leftPad,
      rightPad: rightPad2,
      padWidth,
      preserveShortSequences
    };
    const inputs = { data: $data, dataSplits: $dataSplits };
    const result = ENGINE.runKernel(StringNGrams, inputs, attrs);
    return { nGrams: result[0], nGramsSplits: result[1] };
  }
  const stringNGrams$1 = /* @__PURE__ */ op({ stringNGrams_ });
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function stringSplit_(input, delimiter, skipEmpty = true) {
    const $input = convertToTensor(input, "input", "stringSplit", "string");
    const $delimiter = convertToTensor(delimiter, "delimiter", "stringSplit", "string");
    if ($input.rank !== 1) {
      throw new Error(`Input should be Tensor1D but received shape ${$input.shape}`);
    }
    if ($delimiter.rank !== 0) {
      throw new Error(`Delimiter should be a scalar but received shape ${$delimiter.shape}`);
    }
    const attrs = { skipEmpty };
    const inputs = { input: $input, delimiter: $delimiter };
    const result = ENGINE.runKernel(StringSplit, inputs, attrs);
    return { indices: result[0], values: result[1], shape: result[2] };
  }
  const stringSplit$1 = /* @__PURE__ */ op({ stringSplit_ });
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function stringToHashBucketFast_(input, numBuckets) {
    const $input = convertToTensor(input, "input", "stringToHashBucketFast", "string");
    const attrs = { numBuckets };
    if (numBuckets <= 0) {
      throw new Error(`Number of buckets must be at least 1`);
    }
    const inputs = { input: $input };
    return ENGINE.runKernel(StringToHashBucketFast, inputs, attrs);
  }
  const stringToHashBucketFast$1 = /* @__PURE__ */ op({ stringToHashBucketFast_ });
  /**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function staticRegexReplace_(input, pattern, rewrite, replaceGlobal = true) {
    const $input = convertToTensor(input, "input", "staticRegexReplace", "string");
    const attrs = { pattern, rewrite, replaceGlobal };
    return ENGINE.runKernel(StaticRegexReplace, { x: $input }, attrs);
  }
  const staticRegexReplace$1 = /* @__PURE__ */ op({ staticRegexReplace_ });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const spectral$1 = {
    fft: fft$1,
    ifft: ifft$1,
    rfft,
    irfft
  };
  const signal = {
    hammingWindow,
    hannWindow,
    frame,
    stft
  };
  const image$1 = {
    flipLeftRight,
    grayscaleToRGB,
    resizeNearestNeighbor: resizeNearestNeighbor$1,
    resizeBilinear: resizeBilinear$1,
    rgbToGrayscale,
    rotateWithOffset,
    cropAndResize: cropAndResize$1,
    nonMaxSuppression,
    nonMaxSuppressionAsync,
    nonMaxSuppressionWithScore,
    nonMaxSuppressionWithScoreAsync,
    nonMaxSuppressionPadded,
    nonMaxSuppressionPaddedAsync,
    threshold,
    transform: transform$1
  };
  const linalg = {
    bandPart,
    gramSchmidt,
    qr
  };
  const losses = {
    absoluteDifference,
    computeWeightedLoss,
    cosineDistance,
    hingeLoss,
    huberLoss,
    logLoss,
    meanSquaredError,
    sigmoidCrossEntropy,
    softmaxCrossEntropy
  };
  const sparse$1 = {
    sparseFillEmptyRows: sparseFillEmptyRows$1,
    sparseReshape: sparseReshape$1,
    sparseSegmentMean: sparseSegmentMean$1,
    sparseSegmentSum: sparseSegmentSum$1
  };
  const string$1 = {
    stringNGrams: stringNGrams$1,
    stringSplit: stringSplit$1,
    stringToHashBucketFast: stringToHashBucketFast$1,
    staticRegexReplace: staticRegexReplace$1
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const GLOBAL_CUSTOM_OBJECT = /* @__PURE__ */ new Map();
  const GLOBAL_CUSTOM_NAMES = /* @__PURE__ */ new Map();
  class Serializable {
    /**
     * Return the class name for this class to use in serialization contexts.
     *
     * Generally speaking this will be the same thing that constructor.name
     * would have returned.  However, the class name needs to be robust
     * against minification for serialization/deserialization to work properly.
     *
     * There's also places such as initializers.VarianceScaling, where
     * implementation details between different languages led to different
     * class hierarchies and a non-leaf node is used for serialization purposes.
     */
    getClassName() {
      return this.constructor.className;
    }
    /**
     * Creates an instance of T from a ConfigDict.
     *
     * This works for most descendants of serializable.  A few need to
     * provide special handling.
     * @param cls A Constructor for the class to instantiate.
     * @param config The Configuration for the object.
     */
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config);
    }
  }
  class SerializationMap {
    constructor() {
      this.classNameMap = {};
    }
    /**
     * Returns the singleton instance of the map.
     */
    static getMap() {
      if (SerializationMap.instance == null) {
        SerializationMap.instance = new SerializationMap();
      }
      return SerializationMap.instance;
    }
    /**
     * Registers the class as serializable.
     */
    static register(cls) {
      SerializationMap.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];
    }
  }
  function registerClass(cls, pkg, name) {
    assert(cls.className != null, () => `Class being registered does not have the static className property defined.`);
    assert(typeof cls.className === "string", () => `className is required to be a string, but got type ` + typeof cls.className);
    assert(cls.className.length > 0, () => `Class being registered has an empty-string as its className, which is disallowed.`);
    if (typeof pkg === "undefined") {
      pkg = "Custom";
    }
    if (typeof name === "undefined") {
      name = cls.className;
    }
    const className = name;
    const registerName = pkg + ">" + className;
    SerializationMap.register(cls);
    GLOBAL_CUSTOM_OBJECT.set(registerName, cls);
    GLOBAL_CUSTOM_NAMES.set(cls, registerName);
    return cls;
  }
  function getRegisteredName(cls) {
    if (GLOBAL_CUSTOM_NAMES.has(cls)) {
      return GLOBAL_CUSTOM_NAMES.get(cls);
    } else {
      return cls.className;
    }
  }
  const serialization = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Serializable,
    SerializationMap,
    getRegisteredName,
    registerClass
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class Optimizer extends Serializable {
    /**
     * Executes `f()` and minimizes the scalar output of `f()` by computing
     * gradients of y with respect to the list of trainable variables provided by
     * `varList`. If no list is provided, it defaults to all trainable variables.
     *
     * @param f The function to execute and whose output to minimize.
     * @param returnCost Whether to return the scalar cost value produced by
     * executing `f()`.
     * @param varList An optional list of variables to update. If specified, only
     * the trainable variables in varList will be updated by minimize. Defaults to
     * all trainable variables.
     *
     * @doc {heading: 'Training', subheading: 'Optimizers'}
     */
    minimize(f, returnCost = false, varList) {
      const { value, grads: grads2 } = this.computeGradients(f, varList);
      if (varList != null) {
        const gradArray = varList.map((v) => ({ name: v.name, tensor: grads2[v.name] }));
        this.applyGradients(gradArray);
      } else {
        this.applyGradients(grads2);
      }
      dispose(grads2);
      if (returnCost) {
        return value;
      } else {
        value.dispose();
        return null;
      }
    }
    /**
     * The number of iterations that this optimizer instance has been invoked for.
     */
    get iterations() {
      if (this.iterations_ == null) {
        this.iterations_ = 0;
      }
      return this.iterations_;
    }
    incrementIterations() {
      this.iterations_ = this.iterations + 1;
    }
    /**
     * Executes f() and computes the gradient of the scalar output of f() with
     * respect to the list of trainable variables provided by `varList`. If no
     * list is provided, it defaults to all trainable variables.
     *
     * @param f The function to execute and whose output to use for computing
     * gradients with respect to variables.
     * @param varList An optional list of variables to compute gradients with
     * respect to. If specified, only the trainable variables in varList will have
     * gradients computed with respect to. Defaults to all trainable variables.
     *
     * @doc {heading: 'Training', subheading: 'Optimizers'}
     */
    computeGradients(f, varList) {
      return variableGrads(f, varList);
    }
    /**
     * Dispose the variables (if any) owned by this optimizer instance.
     */
    dispose() {
      if (this.iterations_ != null) {
        dispose(this.iterations_);
      }
    }
    async saveIterations() {
      if (this.iterations_ == null) {
        this.iterations_ = 0;
      }
      return {
        name: "iter",
        // TODO(cais): Use 'int64' type when available.
        tensor: scalar(this.iterations_, "int32")
      };
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for this optimizer yet.");
    }
    async setWeights(weightValues) {
      throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
    }
    /**
     * Extract the first element of the weight values and set it
     * as the iterations counter variable of this instance of optimizer.
     *
     * @param weightValues
     * @returns Weight values with the first element consumed and excluded.
     */
    async extractIterations(weightValues) {
      this.iterations_ = (await weightValues[0].tensor.data())[0];
      return weightValues.slice(1);
    }
  }
  Object.defineProperty(Optimizer, Symbol.hasInstance, {
    value: (instance) => {
      return instance.minimize != null && instance.computeGradients != null && instance.applyGradients != null;
    }
  });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class AdadeltaOptimizer extends Optimizer {
    /** @nocollapse */
    static get className() {
      return "Adadelta";
    }
    constructor(learningRate, rho, epsilon = null) {
      super();
      this.learningRate = learningRate;
      this.rho = rho;
      this.epsilon = epsilon;
      this.accumulatedGrads = [];
      this.accumulatedUpdates = [];
      if (epsilon == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        const trainable = false;
        if (this.accumulatedGrads[i] == null) {
          this.accumulatedGrads[i] = {
            originalName: `${name}/accum_grad`,
            variable: tidy(() => zerosLike$1(value).variable(trainable))
          };
        }
        if (this.accumulatedUpdates[i] == null) {
          this.accumulatedUpdates[i] = {
            originalName: `${name}/accum_var`,
            variable: tidy(() => zerosLike$1(value).variable(trainable))
          };
        }
        const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const accumulatedGrad = this.accumulatedGrads[i].variable;
        const accumulatedUpdate = this.accumulatedUpdates[i].variable;
        tidy(() => {
          const newAccumulatedGrad = add(mul(accumulatedGrad, this.rho), mul(square$1(gradient), 1 - this.rho));
          const updates = mul(div(sqrt$1(add(accumulatedUpdate, this.epsilon)), sqrt$1(add(accumulatedGrad, this.epsilon))), gradient);
          const newAccumulatedUpdate = add(mul(accumulatedUpdate, this.rho), mul(square$1(updates), 1 - this.rho));
          accumulatedGrad.assign(newAccumulatedGrad);
          accumulatedUpdate.assign(newAccumulatedUpdate);
          const newValue = add(mul(updates, -this.learningRate), value);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    dispose() {
      if (this.accumulatedUpdates != null) {
        dispose(this.accumulatedGrads.map((v) => v.variable));
        dispose(this.accumulatedUpdates.map((v) => v.variable));
      }
    }
    async getWeights() {
      const variables = [...this.accumulatedGrads, ...this.accumulatedUpdates];
      return [await this.saveIterations()].concat(variables.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const variableCount = weightValues.length / 2;
      const trainable = false;
      this.accumulatedGrads = weightValues.slice(0, variableCount).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
      this.accumulatedUpdates = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "rho": this.rho,
        "epsilon": this.epsilon
      };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["rho"], config["epsilon"]);
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class AdagradOptimizer extends Optimizer {
    /** @nocollapse */
    static get className() {
      return "Adagrad";
    }
    constructor(learningRate, initialAccumulatorValue = 0.1) {
      super();
      this.learningRate = learningRate;
      this.initialAccumulatorValue = initialAccumulatorValue;
      this.accumulatedGrads = [];
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        if (this.accumulatedGrads[i] == null) {
          const trainable = false;
          this.accumulatedGrads[i] = {
            originalName: `${name}/accumulator`,
            variable: tidy(() => fill$1(value.shape, this.initialAccumulatorValue).variable(trainable))
          };
        }
        const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const accumulatedGrad = this.accumulatedGrads[i].variable;
        tidy(() => {
          const newAccumulatedGrad = add(accumulatedGrad, square$1(gradient));
          accumulatedGrad.assign(newAccumulatedGrad);
          const newValue = add(mul(div(gradient, sqrt$1(add(newAccumulatedGrad, ENGINE.backend.epsilon()))), -this.learningRate), value);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    dispose() {
      if (this.accumulatedGrads != null) {
        dispose(this.accumulatedGrads.map((v) => v.variable));
      }
    }
    async getWeights() {
      return [await this.saveIterations()].concat(this.accumulatedGrads.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const trainable = false;
      this.accumulatedGrads = weightValues.map((v) => ({ originalName: v.name, variable: v.tensor.variable(trainable) }));
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "initialAccumulatorValue": this.initialAccumulatorValue
      };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["initialAccumulatorValue"]);
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class AdamOptimizer extends Optimizer {
    /** @nocollapse */
    static get className() {
      return "Adam";
    }
    constructor(learningRate, beta1, beta2, epsilon = null) {
      super();
      this.learningRate = learningRate;
      this.beta1 = beta1;
      this.beta2 = beta2;
      this.epsilon = epsilon;
      this.accumulatedFirstMoment = [];
      this.accumulatedSecondMoment = [];
      tidy(() => {
        this.accBeta1 = scalar(beta1).variable();
        this.accBeta2 = scalar(beta2).variable();
      });
      if (epsilon == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
    }
    applyGradients(variableGradients) {
      const varNames = Array.isArray(variableGradients) ? variableGradients.map((v) => v.name) : Object.keys(variableGradients);
      tidy(() => {
        const oneMinusAccBeta1 = sub$1(1, this.accBeta1);
        const oneMinusAccBeta2 = sub$1(1, this.accBeta2);
        varNames.forEach((name, i) => {
          const value = ENGINE.registeredVariables[name];
          const trainable = false;
          if (this.accumulatedFirstMoment[i] == null) {
            this.accumulatedFirstMoment[i] = {
              originalName: `${name}/m`,
              variable: tidy(() => zerosLike$1(value).variable(trainable))
            };
          }
          if (this.accumulatedSecondMoment[i] == null) {
            this.accumulatedSecondMoment[i] = {
              originalName: `${name}/v`,
              variable: tidy(() => zerosLike$1(value).variable(trainable))
            };
          }
          const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
          if (gradient == null) {
            return;
          }
          const firstMoment = this.accumulatedFirstMoment[i].variable;
          const secondMoment = this.accumulatedSecondMoment[i].variable;
          const newFirstMoment = add(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));
          const newSecondMoment = add(mul(secondMoment, this.beta2), mul(square$1(gradient), 1 - this.beta2));
          const biasCorrectedFirstMoment = div(newFirstMoment, oneMinusAccBeta1);
          const biasCorrectedSecondMoment = div(newSecondMoment, oneMinusAccBeta2);
          firstMoment.assign(newFirstMoment);
          secondMoment.assign(newSecondMoment);
          const newValue = add(mul(div(biasCorrectedFirstMoment, add(sqrt$1(biasCorrectedSecondMoment), this.epsilon)), -this.learningRate), value);
          value.assign(newValue);
        });
        this.accBeta1.assign(mul(this.accBeta1, this.beta1));
        this.accBeta2.assign(mul(this.accBeta2, this.beta2));
      });
      this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose();
      this.accBeta2.dispose();
      if (this.accumulatedFirstMoment != null) {
        dispose(this.accumulatedFirstMoment.map((v) => v.variable));
      }
      if (this.accumulatedSecondMoment != null) {
        dispose(this.accumulatedSecondMoment.map((v) => v.variable));
      }
    }
    async getWeights() {
      const variables = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
      return [await this.saveIterations()].concat(variables.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      tidy(() => {
        this.accBeta1.assign(pow$1(this.beta1, this.iterations_ + 1));
        this.accBeta2.assign(pow$1(this.beta2, this.iterations_ + 1));
      });
      const variableCount = weightValues.length / 2;
      const trainable = false;
      this.accumulatedFirstMoment = weightValues.slice(0, variableCount).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
      this.accumulatedSecondMoment = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "beta1": this.beta1,
        "beta2": this.beta2,
        "epsilon": this.epsilon
      };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["beta1"], config["beta2"], config["epsilon"]);
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class AdamaxOptimizer extends Optimizer {
    /** @nocollapse */
    static get className() {
      return "Adamax";
    }
    constructor(learningRate, beta1, beta2, epsilon = null, decay = 0) {
      super();
      this.learningRate = learningRate;
      this.beta1 = beta1;
      this.beta2 = beta2;
      this.epsilon = epsilon;
      this.decay = decay;
      this.accumulatedFirstMoment = [];
      this.accumulatedWeightedInfNorm = [];
      tidy(() => {
        this.iteration = scalar(0).variable();
        this.accBeta1 = scalar(beta1).variable();
      });
      if (epsilon == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      tidy(() => {
        const oneMinusAccBeta1 = sub$1(1, this.accBeta1);
        const lr = div(-this.learningRate, add(mul(this.iteration, this.decay), 1));
        variableNames.forEach((name, i) => {
          const value = ENGINE.registeredVariables[name];
          const trainable = false;
          if (this.accumulatedFirstMoment[i] == null) {
            this.accumulatedFirstMoment[i] = {
              originalName: `${name}/m`,
              variable: zerosLike$1(value).variable(trainable)
            };
          }
          if (this.accumulatedWeightedInfNorm[i] == null) {
            this.accumulatedWeightedInfNorm[i] = {
              originalName: `${name}/v`,
              variable: zerosLike$1(value).variable(trainable)
            };
          }
          const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
          if (gradient == null) {
            return;
          }
          const firstMoment = this.accumulatedFirstMoment[i].variable;
          const weightedInfNorm = this.accumulatedWeightedInfNorm[i].variable;
          const newFirstMoment = add(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));
          const ut0 = mul(weightedInfNorm, this.beta2);
          const ut1 = abs$1(gradient);
          const newWeightedInfNorm = maximum$1(ut0, ut1);
          firstMoment.assign(newFirstMoment);
          weightedInfNorm.assign(newWeightedInfNorm);
          const newValue = add(mul(div(lr, oneMinusAccBeta1), div(newFirstMoment, add(newWeightedInfNorm, this.epsilon))), value);
          value.assign(newValue);
        });
        this.iteration.assign(add(this.iteration, 1));
        this.accBeta1.assign(mul(this.accBeta1, this.beta1));
      });
      this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose();
      this.iteration.dispose();
      if (this.accumulatedFirstMoment != null) {
        dispose(this.accumulatedFirstMoment.map((v) => v.variable));
      }
      if (this.accumulatedWeightedInfNorm != null) {
        dispose(this.accumulatedWeightedInfNorm.map((v) => v.variable));
      }
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for Adamax yet.");
    }
    async setWeights(weightValues) {
      throw new Error("setWeights() is not implemented for Adamax yet.");
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "beta1": this.beta1,
        "beta2": this.beta2,
        "epsilon": this.epsilon,
        "decay": this.decay
      };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["beta1"], config["beta2"], config["epsilon"], config["decay"]);
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class SGDOptimizer extends Optimizer {
    /** @nocollapse */
    static get className() {
      return "SGD";
    }
    constructor(learningRate) {
      super();
      this.learningRate = learningRate;
      this.setLearningRate(learningRate);
    }
    applyGradients(variableGradients) {
      const varNames = Array.isArray(variableGradients) ? variableGradients.map((v) => v.name) : Object.keys(variableGradients);
      varNames.forEach((name, i) => {
        const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const value = ENGINE.registeredVariables[name];
        tidy(() => {
          const newValue = add(mul(this.c, gradient), value);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    /**
     * Sets the learning rate of the optimizer.
     */
    setLearningRate(learningRate) {
      this.learningRate = learningRate;
      if (this.c != null) {
        this.c.dispose();
      }
      this.c = keep(scalar(-learningRate));
    }
    dispose() {
      this.c.dispose();
    }
    async getWeights() {
      return [await this.saveIterations()];
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      if (weightValues.length !== 0) {
        throw new Error("SGD optimizer does not have settable weights.");
      }
    }
    getConfig() {
      return { "learningRate": this.learningRate };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"]);
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class MomentumOptimizer extends SGDOptimizer {
    /** @nocollapse */
    // Name matters for Python compatibility.
    static get className() {
      return "Momentum";
    }
    constructor(learningRate, momentum, useNesterov = false) {
      super(learningRate);
      this.learningRate = learningRate;
      this.momentum = momentum;
      this.useNesterov = useNesterov;
      this.accumulations = [];
      this.m = scalar(this.momentum);
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        if (this.accumulations[i] == null) {
          const trainable = false;
          this.accumulations[i] = {
            originalName: `${name}/momentum`,
            variable: tidy(() => zerosLike$1(value).variable(trainable))
          };
        }
        const accumulation = this.accumulations[i].variable;
        const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        tidy(() => {
          let newValue;
          const newAccumulation = add(mul(this.m, accumulation), gradient);
          if (this.useNesterov) {
            newValue = add(mul(this.c, add(gradient, mul(newAccumulation, this.m))), value);
          } else {
            newValue = add(mul(this.c, newAccumulation), value);
          }
          accumulation.assign(newAccumulation);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    dispose() {
      this.m.dispose();
      if (this.accumulations != null) {
        dispose(this.accumulations.map((v) => v.variable));
      }
    }
    /**
     * Sets the momentum of the optimizer.
     *
     * @param momentum
     */
    setMomentum(momentum) {
      this.momentum = momentum;
    }
    async getWeights() {
      return [await this.saveIterations()].concat(this.accumulations.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const trainable = false;
      this.accumulations = weightValues.map((v) => ({ originalName: v.name, variable: v.tensor.variable(trainable) }));
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "momentum": this.momentum,
        "useNesterov": this.useNesterov
      };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["momentum"], config["useNesterov"]);
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class RMSPropOptimizer extends Optimizer {
    /** @nocollapse */
    static get className() {
      return "RMSProp";
    }
    constructor(learningRate, decay = 0.9, momentum = 0, epsilon = null, centered = false) {
      super();
      this.learningRate = learningRate;
      this.decay = decay;
      this.momentum = momentum;
      this.epsilon = epsilon;
      this.accumulatedMeanSquares = [];
      this.accumulatedMoments = [];
      this.accumulatedMeanGrads = [];
      this.centered = centered;
      if (epsilon == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
      if (learningRate == null) {
        throw new Error(`learningRate for RMSPropOptimizer must be defined.`);
      }
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        const trainable = false;
        if (this.accumulatedMeanSquares[i] == null) {
          this.accumulatedMeanSquares[i] = {
            originalName: `${name}/rms`,
            variable: tidy(() => zerosLike$1(value).variable(trainable))
          };
        }
        if (this.accumulatedMoments[i] == null) {
          this.accumulatedMoments[i] = {
            originalName: `${name}/momentum`,
            variable: tidy(() => zerosLike$1(value).variable(trainable))
          };
        }
        if (this.accumulatedMeanGrads[i] == null && this.centered) {
          this.accumulatedMeanGrads[i] = {
            originalName: `${name}/mg`,
            variable: tidy(() => zerosLike$1(value).variable(trainable))
          };
        }
        const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const accumulatedMeanSquare = this.accumulatedMeanSquares[i].variable;
        const accumulatedMoments = this.accumulatedMoments[i].variable;
        tidy(() => {
          const newAccumulatedMeanSquare = add(mul(accumulatedMeanSquare, this.decay), mul(square$1(gradient), 1 - this.decay));
          if (this.centered) {
            const accumulatedMeanGrad = this.accumulatedMeanGrads[i].variable;
            const newAccumulatedMeanGrad = add(mul(accumulatedMeanGrad, this.decay), mul(gradient, 1 - this.decay));
            const gradContribution = div(mul(gradient, this.learningRate), sqrt$1(sub$1(newAccumulatedMeanSquare, add(square$1(newAccumulatedMeanGrad), this.epsilon))));
            const newAccumulatedMoments = add(mul(accumulatedMoments, this.momentum), gradContribution);
            accumulatedMeanSquare.assign(newAccumulatedMeanSquare);
            accumulatedMeanGrad.assign(newAccumulatedMeanGrad);
            accumulatedMoments.assign(newAccumulatedMoments);
            const newValue = sub$1(value, newAccumulatedMoments);
            value.assign(newValue);
          } else {
            const newAccumulatedMeanSquare2 = add(mul(accumulatedMeanSquare, this.decay), mul(square$1(gradient), 1 - this.decay));
            const newAccumulatedMoments = add(mul(accumulatedMoments, this.momentum), div(mul(gradient, this.learningRate), sqrt$1(add(newAccumulatedMeanSquare2, this.epsilon))));
            accumulatedMeanSquare.assign(newAccumulatedMeanSquare2);
            accumulatedMoments.assign(newAccumulatedMoments);
            const newValue = sub$1(value, newAccumulatedMoments);
            value.assign(newValue);
          }
        });
      });
      this.incrementIterations();
    }
    dispose() {
      if (this.accumulatedMeanSquares != null) {
        dispose(this.accumulatedMeanSquares.map((v) => v.variable));
      }
      if (this.accumulatedMeanGrads != null && this.centered) {
        dispose(this.accumulatedMeanGrads.map((v) => v.variable));
      }
      if (this.accumulatedMoments != null) {
        dispose(this.accumulatedMoments.map((v) => v.variable));
      }
    }
    async getWeights() {
      const variables = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
      if (this.centered) {
        variables.push(...this.accumulatedMeanGrads);
      }
      return [await this.saveIterations()].concat(variables.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const variableCount = this.centered ? weightValues.length / 3 : weightValues.length / 2;
      const trainable = false;
      this.accumulatedMeanSquares = weightValues.slice(0, variableCount).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
      this.accumulatedMoments = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
      if (this.centered) {
        this.accumulatedMeanGrads = weightValues.slice(variableCount * 2, variableCount * 3).map((v) => ({
          originalName: v.name,
          variable: v.tensor.variable(trainable)
        }));
      }
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "decay": this.decay,
        "momentum": this.momentum,
        "epsilon": this.epsilon,
        "centered": this.centered
      };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["decay"], config["momentum"], config["epsilon"], config["centered"]);
    }
  }
  /**
   * @license
   * Copyright 2022 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const OPTIMIZERS = [
    AdadeltaOptimizer,
    AdagradOptimizer,
    AdamOptimizer,
    AdamaxOptimizer,
    MomentumOptimizer,
    RMSPropOptimizer,
    SGDOptimizer
  ];
  function registerOptimizers() {
    for (const optimizer of OPTIMIZERS) {
      registerClass(optimizer);
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const DEFAULT_FILE_NAME_PREFIX = "model";
  const DEFAULT_JSON_EXTENSION_NAME = ".json";
  const DEFAULT_WEIGHT_DATA_EXTENSION_NAME = ".weights.bin";
  function defer(f) {
    return new Promise((resolve) => setTimeout(resolve)).then(f);
  }
  class BrowserDownloads {
    constructor(fileNamePrefix) {
      if (!env().getBool("IS_BROWSER")) {
        throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
      }
      if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {
        fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);
      }
      if (fileNamePrefix == null || fileNamePrefix.length === 0) {
        fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;
      }
      this.modelJsonFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;
      this.weightDataFileName = fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;
    }
    async save(modelArtifacts) {
      if (typeof document === "undefined") {
        throw new Error("Browser downloads are not supported in this environment since `document` is not present");
      }
      const weightBuffer = CompositeArrayBuffer.join(modelArtifacts.weightData);
      const weightsURL = window.URL.createObjectURL(new Blob([weightBuffer], { type: "application/octet-stream" }));
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
      } else {
        const weightsManifest = [{
          paths: ["./" + this.weightDataFileName],
          weights: modelArtifacts.weightSpecs
        }];
        const modelJSON = getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);
        const modelJsonURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelJSON)], { type: "application/json" }));
        const jsonAnchor = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor;
        jsonAnchor.download = this.modelJsonFileName;
        jsonAnchor.href = modelJsonURL;
        await defer(() => jsonAnchor.dispatchEvent(new MouseEvent("click")));
        if (modelArtifacts.weightData != null) {
          const weightDataAnchor = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
          weightDataAnchor.download = this.weightDataFileName;
          weightDataAnchor.href = weightsURL;
          await defer(() => weightDataAnchor.dispatchEvent(new MouseEvent("click")));
        }
        return { modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts) };
      }
    }
  }
  BrowserDownloads.URL_SCHEME = "downloads://";
  class BrowserFiles {
    constructor(files) {
      if (files == null || files.length < 1) {
        throw new Error(`When calling browserFiles, at least 1 file is required, but received ${files}`);
      }
      this.jsonFile = files[0];
      this.weightsFiles = files.slice(1);
    }
    async load() {
      return new Promise((resolve, reject) => {
        const jsonReader = new FileReader();
        jsonReader.onload = (event) => {
          const modelJSON = JSON.parse(event.target.result);
          const modelTopology = modelJSON.modelTopology;
          if (modelTopology == null) {
            reject(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
            return;
          }
          const weightsManifest = modelJSON.weightsManifest;
          if (weightsManifest == null) {
            reject(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
            return;
          }
          if (this.weightsFiles.length === 0) {
            resolve({ modelTopology });
            return;
          }
          const modelArtifactsPromise = getModelArtifactsForJSON(modelJSON, (weightsManifest2) => this.loadWeights(weightsManifest2));
          resolve(modelArtifactsPromise);
        };
        jsonReader.onerror = (error) => reject(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`);
        jsonReader.readAsText(this.jsonFile);
      });
    }
    loadWeights(weightsManifest) {
      const weightSpecs = [];
      const paths = [];
      for (const entry of weightsManifest) {
        weightSpecs.push(...entry.weights);
        paths.push(...entry.paths);
      }
      const pathToFile = this.checkManifestAndWeightFiles(weightsManifest);
      const promises = paths.map((path) => this.loadWeightsFile(path, pathToFile[path]));
      return Promise.all(promises).then((buffers) => [weightSpecs, buffers]);
    }
    loadWeightsFile(path, file) {
      return new Promise((resolve, reject) => {
        const weightFileReader = new FileReader();
        weightFileReader.onload = (event) => {
          const weightData = event.target.result;
          resolve(weightData);
        };
        weightFileReader.onerror = (error) => reject(`Failed to weights data from file of path '${path}'.`);
        weightFileReader.readAsArrayBuffer(file);
      });
    }
    /**
     * Check the compatibility between weights manifest and weight files.
     */
    checkManifestAndWeightFiles(manifest) {
      const basenames = [];
      const fileNames = this.weightsFiles.map((file) => basename(file.name));
      const pathToFile = {};
      for (const group of manifest) {
        group.paths.forEach((path) => {
          const pathBasename = basename(path);
          if (basenames.indexOf(pathBasename) !== -1) {
            throw new Error(`Duplicate file basename found in weights manifest: '${pathBasename}'`);
          }
          basenames.push(pathBasename);
          if (fileNames.indexOf(pathBasename) === -1) {
            throw new Error(`Weight file with basename '${pathBasename}' is not provided.`);
          } else {
            pathToFile[path] = this.weightsFiles[fileNames.indexOf(pathBasename)];
          }
        });
      }
      if (basenames.length !== this.weightsFiles.length) {
        throw new Error(`Mismatch in the number of files in weights manifest (${basenames.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
      }
      return pathToFile;
    }
  }
  const browserDownloadsRouter = (url) => {
    if (!env().getBool("IS_BROWSER")) {
      return null;
    } else {
      if (!Array.isArray(url) && url.startsWith(BrowserDownloads.URL_SCHEME)) {
        return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));
      } else {
        return null;
      }
    }
  };
  IORouterRegistry.registerSaveRouter(browserDownloadsRouter);
  function browserDownloads(fileNamePrefix = "model") {
    return new BrowserDownloads(fileNamePrefix);
  }
  function browserFiles(files) {
    return new BrowserFiles(files);
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function monitorPromisesProgress(promises, onProgress, startFraction, endFraction) {
    checkPromises(promises);
    startFraction = startFraction == null ? 0 : startFraction;
    endFraction = endFraction == null ? 1 : endFraction;
    checkFraction(startFraction, endFraction);
    let resolvedPromise = 0;
    const registerMonitor = (promise) => {
      promise.then((value) => {
        const fraction = startFraction + ++resolvedPromise / promises.length * (endFraction - startFraction);
        onProgress(fraction);
        return value;
      });
      return promise;
    };
    function checkPromises(promises2) {
      assert(promises2 != null && Array.isArray(promises2) && promises2.length > 0, () => "promises must be a none empty array");
    }
    function checkFraction(startFraction2, endFraction2) {
      assert(startFraction2 >= 0 && startFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${startFraction2}`);
      assert(endFraction2 >= 0 && endFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${endFraction2}`);
      assert(endFraction2 >= startFraction2, () => `startFraction must be no more than endFraction, but got startFraction ${startFraction2} and endFraction ${endFraction2}`);
    }
    return Promise.all(promises.map(registerMonitor));
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  async function loadWeightsAsArrayBuffer(fetchURLs, loadOptions) {
    if (loadOptions == null) {
      loadOptions = {};
    }
    const fetchFunc = loadOptions.fetchFunc == null ? env().platform.fetch : loadOptions.fetchFunc;
    const requests = fetchURLs.map((fetchURL) => fetchFunc(fetchURL, loadOptions.requestInit, { isBinary: true }));
    const fetchStartFraction = 0;
    const fetchEndFraction = 0.5;
    const responses = loadOptions.onProgress == null ? await Promise.all(requests) : await monitorPromisesProgress(requests, loadOptions.onProgress, fetchStartFraction, fetchEndFraction);
    const bufferPromises = responses.map((response) => response.arrayBuffer());
    const bufferStartFraction = 0.5;
    const bufferEndFraction = 1;
    const buffers = loadOptions.onProgress == null ? await Promise.all(bufferPromises) : await monitorPromisesProgress(bufferPromises, loadOptions.onProgress, bufferStartFraction, bufferEndFraction);
    return buffers;
  }
  function streamWeights(fetchURLs, loadOptions) {
    var _a;
    const fetchFunc = loadOptions.fetchFunc == null ? env().platform.fetch : loadOptions.fetchFunc;
    let fetchIndex = 0;
    let chunkReader;
    (_a = loadOptions.onProgress) === null || _a === void 0 ? void 0 : _a.call(loadOptions, 0);
    return new ReadableStream({
      pull: async (controller) => {
        var _a2;
        while (fetchIndex < fetchURLs.length) {
          if (!chunkReader) {
            const body = (await fetchFunc(fetchURLs[fetchIndex], loadOptions.requestInit, { isBinary: true })).body;
            chunkReader = body.getReader();
          }
          const { done, value } = await chunkReader.read();
          if (done) {
            fetchIndex++;
            chunkReader = void 0;
            (_a2 = loadOptions.onProgress) === null || _a2 === void 0 ? void 0 : _a2.call(loadOptions, fetchIndex / fetchURLs.length);
            continue;
          }
          controller.enqueue(value);
          return;
        }
        controller.close();
      }
    });
  }
  async function loadWeights(manifest, filePathPrefix = "", weightNames, requestInit) {
    const fetchWeights = (fetchUrls) => loadWeightsAsArrayBuffer(fetchUrls, { requestInit });
    const loadWeights2 = weightsLoaderFactory(fetchWeights);
    return loadWeights2(manifest, filePathPrefix, weightNames);
  }
  function weightsLoaderFactory(fetchWeightsFunction) {
    return async (manifest, filePathPrefix = "", weightNames) => {
      const groupIndicesToFetchMap = manifest.map(() => false);
      const groupWeightsToFetch = {};
      const weightsFound = weightNames != null ? weightNames.map(() => false) : [];
      const allManifestWeightNames = [];
      manifest.forEach((manifestGroupConfig, groupIndex) => {
        let groupOffset = 0;
        manifestGroupConfig.weights.forEach((weightsEntry) => {
          const rawDtype = "quantization" in weightsEntry ? weightsEntry.quantization.dtype : weightsEntry.dtype;
          const weightsBytes = DTYPE_VALUE_SIZE_MAP[rawDtype] * sizeFromShape(weightsEntry.shape);
          const enqueueWeightsForFetchingFn = () => {
            groupIndicesToFetchMap[groupIndex] = true;
            if (groupWeightsToFetch[groupIndex] == null) {
              groupWeightsToFetch[groupIndex] = [];
            }
            groupWeightsToFetch[groupIndex].push({
              manifestEntry: weightsEntry,
              groupOffset,
              sizeBytes: weightsBytes
            });
          };
          if (weightNames != null) {
            weightNames.forEach((weightName, weightIndex) => {
              if (weightName === weightsEntry.name) {
                enqueueWeightsForFetchingFn();
                weightsFound[weightIndex] = true;
              }
            });
          } else {
            enqueueWeightsForFetchingFn();
          }
          allManifestWeightNames.push(weightsEntry.name);
          groupOffset += weightsBytes;
        });
      });
      if (!weightsFound.every((found) => found)) {
        const weightsNotFound = weightNames.filter((_, i) => !weightsFound[i]);
        throw new Error(`Could not find weights in manifest with names: ${weightsNotFound.join(", ")}. 
Manifest JSON has weights with names: ${allManifestWeightNames.join(", ")}.`);
      }
      const groupIndicesToFetch = groupIndicesToFetchMap.reduce((accumulator, shouldFetch, i) => {
        if (shouldFetch) {
          accumulator.push(i);
        }
        return accumulator;
      }, []);
      const fetchUrls = [];
      groupIndicesToFetch.forEach((i) => {
        manifest[i].paths.forEach((filepath) => {
          const fetchUrl = filePathPrefix + (!filePathPrefix.endsWith("/") ? "/" : "") + filepath;
          fetchUrls.push(fetchUrl);
        });
      });
      const buffers = await fetchWeightsFunction(fetchUrls);
      const weightsTensorMap = {};
      let bufferIndexOffset = 0;
      groupIndicesToFetch.forEach((i) => {
        const numBuffers = manifest[i].paths.length;
        const weightsBuffer = new CompositeArrayBuffer(buffers.slice(bufferIndexOffset, bufferIndexOffset + numBuffers));
        const weightsEntries = groupWeightsToFetch[i];
        weightsEntries.forEach((weightsEntry) => {
          const byteBuffer = weightsBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
          const nameToTensorMap = decodeWeights(byteBuffer, [weightsEntry.manifestEntry]);
          for (const name in nameToTensorMap) {
            weightsTensorMap[name] = nameToTensorMap[name];
          }
        });
        bufferIndexOffset += numBuffers;
      });
      return weightsTensorMap;
    };
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const OCTET_STREAM_MIME_TYPE = "application/octet-stream";
  const JSON_TYPE = "application/json";
  class HTTPRequest {
    constructor(path, loadOptions) {
      this.DEFAULT_METHOD = "POST";
      if (loadOptions == null) {
        loadOptions = {};
      }
      this.weightPathPrefix = loadOptions.weightPathPrefix;
      this.weightUrlConverter = loadOptions.weightUrlConverter;
      if (loadOptions.fetchFunc != null) {
        assert(typeof loadOptions.fetchFunc === "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)");
        this.fetch = loadOptions.fetchFunc;
      } else {
        this.fetch = env().platform.fetch;
      }
      assert(path != null && path.length > 0, () => "URL path for http must not be null, undefined or empty.");
      if (Array.isArray(path)) {
        assert(path.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${path.length}).`);
      }
      this.path = path;
      if (loadOptions.requestInit != null && loadOptions.requestInit.body != null) {
        throw new Error("requestInit is expected to have no pre-existing body, but has one.");
      }
      this.requestInit = loadOptions.requestInit || {};
      this.loadOptions = loadOptions;
    }
    async save(modelArtifacts) {
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
      }
      const init2 = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
      init2.body = new FormData();
      const weightsManifest = [{
        paths: ["./model.weights.bin"],
        weights: modelArtifacts.weightSpecs
      }];
      const modelTopologyAndWeightManifest = getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);
      init2.body.append("model.json", new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: JSON_TYPE }), "model.json");
      if (modelArtifacts.weightData != null) {
        const weightBuffer = CompositeArrayBuffer.join(modelArtifacts.weightData);
        init2.body.append("model.weights.bin", new Blob([weightBuffer], { type: OCTET_STREAM_MIME_TYPE }), "model.weights.bin");
      }
      const response = await this.fetch(this.path, init2);
      if (response.ok) {
        return {
          modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts),
          responses: [response]
        };
      } else {
        throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${response.status}.`);
      }
    }
    async loadModelJSON() {
      const modelConfigRequest = await this.fetch(this.path, this.requestInit);
      if (!modelConfigRequest.ok) {
        throw new Error(`Request to ${this.path} failed with status code ${modelConfigRequest.status}. Please verify this URL points to the model JSON of the model to load.`);
      }
      let modelJSON;
      try {
        modelJSON = await modelConfigRequest.json();
      } catch (e) {
        let message = `Failed to parse model JSON of response from ${this.path}.`;
        if (this.path.endsWith(".pb")) {
          message += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.";
        } else {
          message += " Please make sure the server is serving valid JSON for this request.";
        }
        throw new Error(message);
      }
      const modelTopology = modelJSON.modelTopology;
      const weightsManifest = modelJSON.weightsManifest;
      if (modelTopology == null && weightsManifest == null) {
        throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
      }
      return modelJSON;
    }
    /**
     * Load model artifacts via HTTP request(s).
     *
     * See the documentation to `tf.io.http` for details on the saved
     * artifacts.
     *
     * @returns The loaded model artifacts (if loading succeeds).
     */
    async load() {
      if (this.loadOptions.streamWeights) {
        return this.loadStream();
      }
      const modelJSON = await this.loadModelJSON();
      return getModelArtifactsForJSON(modelJSON, (weightsManifest) => this.loadWeights(weightsManifest));
    }
    async loadStream() {
      const modelJSON = await this.loadModelJSON();
      const fetchURLs = await this.getWeightUrls(modelJSON.weightsManifest);
      const weightSpecs = getWeightSpecs(modelJSON.weightsManifest);
      const stream = () => streamWeights(fetchURLs, this.loadOptions);
      return Object.assign(Object.assign({}, modelJSON), { weightSpecs, getWeightStream: stream });
    }
    async getWeightUrls(weightsManifest) {
      const weightPath = Array.isArray(this.path) ? this.path[1] : this.path;
      const [prefix, suffix] = parseUrl(weightPath);
      const pathPrefix = this.weightPathPrefix || prefix;
      const fetchURLs = [];
      const urlPromises = [];
      for (const weightsGroup of weightsManifest) {
        for (const path of weightsGroup.paths) {
          if (this.weightUrlConverter != null) {
            urlPromises.push(this.weightUrlConverter(path));
          } else {
            fetchURLs.push(pathPrefix + path + suffix);
          }
        }
      }
      if (this.weightUrlConverter) {
        fetchURLs.push(...await Promise.all(urlPromises));
      }
      return fetchURLs;
    }
    async loadWeights(weightsManifest) {
      const fetchURLs = await this.getWeightUrls(weightsManifest);
      const weightSpecs = getWeightSpecs(weightsManifest);
      const buffers = await loadWeightsAsArrayBuffer(fetchURLs, this.loadOptions);
      return [weightSpecs, buffers];
    }
  }
  HTTPRequest.URL_SCHEME_REGEX = /^https?:\/\//;
  function parseUrl(url) {
    const lastSlash = url.lastIndexOf("/");
    const lastSearchParam = url.lastIndexOf("?");
    const prefix = url.substring(0, lastSlash);
    const suffix = lastSearchParam > lastSlash ? url.substring(lastSearchParam) : "";
    return [prefix + "/", suffix];
  }
  function isHTTPScheme(url) {
    return url.match(HTTPRequest.URL_SCHEME_REGEX) != null;
  }
  const httpRouter = (url, loadOptions) => {
    if (typeof fetch === "undefined" && (loadOptions == null || loadOptions.fetchFunc == null)) {
      return null;
    } else {
      let isHTTP = true;
      if (Array.isArray(url)) {
        isHTTP = url.every((urlItem) => isHTTPScheme(urlItem));
      } else {
        isHTTP = isHTTPScheme(url);
      }
      if (isHTTP) {
        return http(url, loadOptions);
      }
    }
    return null;
  };
  IORouterRegistry.registerSaveRouter(httpRouter);
  IORouterRegistry.registerLoadRouter(httpRouter);
  function http(path, loadOptions) {
    return new HTTPRequest(path, loadOptions);
  }
  function browserHTTPRequest(path, loadOptions) {
    return http(path, loadOptions);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class PassthroughLoader {
    constructor(modelArtifacts) {
      this.modelArtifacts = modelArtifacts;
    }
    load() {
      return this.modelArtifacts;
    }
  }
  class PassthroughSaver {
    constructor(saveHandler) {
      this.saveHandler = saveHandler;
    }
    save(modelArtifacts) {
      return this.saveHandler(modelArtifacts);
    }
  }
  class PassthroughAsync {
    constructor(handler) {
      if (handler.load) {
        this.load = () => Promise.resolve(handler.load());
      }
      if (handler.save) {
        this.save = (modelArtifacts) => Promise.resolve(handler.save(modelArtifacts));
      }
    }
  }
  function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {
    const args = arguments;
    return new PassthroughAsync(fromMemorySync(...args));
  }
  function fromMemorySync(modelArtifacts, weightSpecs, weightData, trainingConfig) {
    if (arguments.length === 1) {
      const isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;
      if (isModelArtifacts) {
        return new PassthroughLoader(modelArtifacts);
      } else {
        console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
        return new PassthroughLoader({ modelTopology: modelArtifacts });
      }
    } else {
      console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
      return new PassthroughLoader({
        modelTopology: modelArtifacts,
        weightSpecs,
        weightData,
        trainingConfig
      });
    }
  }
  function withSaveHandler(saveHandler) {
    return new PassthroughSaver(saveHandler);
  }
  function withSaveHandlerSync(saveHandler) {
    return new PassthroughSaver(saveHandler);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const io = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    CompositeArrayBuffer,
    browserFiles,
    browserHTTPRequest,
    concatenateArrayBuffers,
    copyModel,
    decodeWeights,
    decodeWeightsStream,
    encodeWeights,
    fromMemory,
    fromMemorySync,
    getLoadHandlers,
    getModelArtifactsForJSON,
    getModelArtifactsForJSONSync,
    getModelArtifactsInfoForJSON,
    getSaveHandlers,
    getWeightSpecs,
    http,
    isHTTPScheme,
    listModels,
    loadWeights,
    moveModel,
    registerLoadRouter,
    registerSaveRouter,
    removeModel,
    weightsLoaderFactory,
    withSaveHandler,
    withSaveHandlerSync
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function confusionMatrix_(labels, predictions, numClasses) {
    const $labels = convertToTensor(labels, "labels", "confusionMatrix");
    const $predictions = convertToTensor(predictions, "predictions", "confusionMatrix");
    assert(numClasses == null || numClasses > 0 && Number.isInteger(numClasses), () => `If provided, numClasses must be a positive integer, but got ${numClasses}`);
    assert($labels.rank === 1, () => `Expected the rank of labels to be 1, but got ${$labels.rank}`);
    assert($predictions.rank === 1, () => `Expected the rank of predictions to be 1, but got ${$predictions.rank}`);
    assert($labels.shape[0] === $predictions.shape[0], () => `Mismatch in the number of examples: ${$labels.shape[0]} vs. ${$predictions.shape[0]}. Labels and predictions should have the same number of elements.`);
    assert(numClasses > 0 && Number.isInteger(numClasses), () => `numClasses is required to be a positive integer, but got ${numClasses}`);
    const oneHotLabels = oneHot$1(cast$1($labels, "int32"), numClasses);
    const oneHotPredictions = oneHot$1(cast$1($predictions, "int32"), numClasses);
    const oneHotLabelsT = transpose$1(oneHotLabels);
    const product = matMul$1(oneHotLabelsT, oneHotPredictions);
    return cast$1(product, "int32");
  }
  const confusionMatrix = /* @__PURE__ */ op({ confusionMatrix_ });
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const math = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    confusionMatrix
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  let fromPixels2DContext$1;
  let hasToPixelsWarned = false;
  function fromPixels_(pixels, numChannels = 3) {
    if (numChannels > 4) {
      throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
    }
    if (pixels == null) {
      throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    }
    let isPixelData2 = false;
    let isImageData = false;
    let isVideo = false;
    let isImage = false;
    let isCanvasLike = false;
    let isImageBitmap = false;
    if (pixels.data instanceof Uint8Array) {
      isPixelData2 = true;
    } else if (typeof ImageData !== "undefined" && pixels instanceof ImageData) {
      isImageData = true;
    } else if (typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement) {
      isVideo = true;
    } else if (typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement) {
      isImage = true;
    } else if (pixels.getContext != null) {
      isCanvasLike = true;
    } else if (typeof ImageBitmap !== "undefined" && pixels instanceof ImageBitmap) {
      isImageBitmap = true;
    } else {
      throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${pixels.constructor.name}`);
    }
    const kernel = getKernel(FromPixels, ENGINE.backendName);
    if (kernel != null) {
      const inputs = { pixels };
      const attrs = { numChannels };
      return ENGINE.runKernel(FromPixels, inputs, attrs);
    }
    const [width, height] = isVideo ? [
      pixels.videoWidth,
      pixels.videoHeight
    ] : [pixels.width, pixels.height];
    let vals;
    if (isCanvasLike) {
      vals = // tslint:disable-next-line:no-any
      pixels.getContext("2d").getImageData(0, 0, width, height).data;
    } else if (isImageData || isPixelData2) {
      vals = pixels.data;
    } else if (isImage || isVideo || isImageBitmap) {
      if (fromPixels2DContext$1 == null) {
        if (typeof document === "undefined") {
          if (typeof OffscreenCanvas !== "undefined" && typeof OffscreenCanvasRenderingContext2D !== "undefined") {
            fromPixels2DContext$1 = new OffscreenCanvas(1, 1).getContext("2d");
          } else {
            throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
          }
        } else {
          fromPixels2DContext$1 = document.createElement("canvas").getContext("2d", { willReadFrequently: true });
        }
      }
      fromPixels2DContext$1.canvas.width = width;
      fromPixels2DContext$1.canvas.height = height;
      fromPixels2DContext$1.drawImage(pixels, 0, 0, width, height);
      vals = fromPixels2DContext$1.getImageData(0, 0, width, height).data;
    }
    let values;
    if (numChannels === 4) {
      values = new Int32Array(vals);
    } else {
      const numPixels = width * height;
      values = new Int32Array(numPixels * numChannels);
      for (let i = 0; i < numPixels; i++) {
        for (let channel = 0; channel < numChannels; ++channel) {
          values[i * numChannels + channel] = vals[i * 4 + channel];
        }
      }
    }
    const outShape = [height, width, numChannels];
    return tensor3d(values, outShape, "int32");
  }
  function isPixelData(pixels) {
    return pixels != null && pixels.data instanceof Uint8Array;
  }
  function isImageBitmapFullySupported() {
    return typeof window !== "undefined" && typeof ImageBitmap !== "undefined" && window.hasOwnProperty("createImageBitmap");
  }
  function isNonEmptyPixels(pixels) {
    return pixels != null && pixels.width !== 0 && pixels.height !== 0;
  }
  function canWrapPixelsToImageBitmap(pixels) {
    return isImageBitmapFullySupported() && !(pixels instanceof ImageBitmap) && isNonEmptyPixels(pixels) && !isPixelData(pixels);
  }
  async function fromPixelsAsync(pixels, numChannels = 3) {
    let inputs = null;
    if (env().getBool("WRAP_TO_IMAGEBITMAP") && canWrapPixelsToImageBitmap(pixels)) {
      let imageBitmap;
      try {
        imageBitmap = await createImageBitmap(pixels, { premultiplyAlpha: "none" });
      } catch (e) {
        imageBitmap = null;
      }
      if (imageBitmap != null && imageBitmap.width === pixels.width && imageBitmap.height === pixels.height) {
        inputs = imageBitmap;
      } else {
        inputs = pixels;
      }
    } else {
      inputs = pixels;
    }
    return fromPixels_(inputs, numChannels);
  }
  function validateImgTensor(img) {
    if (img.rank !== 2 && img.rank !== 3) {
      throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${img.rank}.`);
    }
    const depth = img.rank === 2 ? 1 : img.shape[2];
    if (depth > 4 || depth === 2) {
      throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${depth}`);
    }
    if (img.dtype !== "float32" && img.dtype !== "int32") {
      throw new Error(`Unsupported type for toPixels: ${img.dtype}. Please use float32 or int32 tensors.`);
    }
  }
  function validateImageOptions(imageOptions) {
    const alpha = (imageOptions === null || imageOptions === void 0 ? void 0 : imageOptions.alpha) || 1;
    if (alpha > 1 || alpha < 0) {
      throw new Error(`Alpha value ${alpha} is suppoed to be in range [0 - 1].`);
    }
  }
  async function toPixels(img, canvas) {
    let $img = convertToTensor(img, "img", "toPixels");
    if (!(img instanceof Tensor)) {
      const originalImgTensor = $img;
      $img = cast$1(originalImgTensor, "int32");
      originalImgTensor.dispose();
    }
    validateImgTensor($img);
    const [height, width] = $img.shape.slice(0, 2);
    const depth = $img.rank === 2 ? 1 : $img.shape[2];
    const data = await $img.data();
    const multiplier = $img.dtype === "float32" ? 255 : 1;
    const bytes = new Uint8ClampedArray(width * height * 4);
    for (let i = 0; i < height * width; ++i) {
      const rgba = [0, 0, 0, 255];
      for (let d = 0; d < depth; d++) {
        const value = data[i * depth + d];
        if ($img.dtype === "float32") {
          if (value < 0 || value > 1) {
            throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${value}.`);
          }
        } else if ($img.dtype === "int32") {
          if (value < 0 || value > 255) {
            throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${value}.`);
          }
        }
        if (depth === 1) {
          rgba[0] = value * multiplier;
          rgba[1] = value * multiplier;
          rgba[2] = value * multiplier;
        } else {
          rgba[d] = value * multiplier;
        }
      }
      const j2 = i * 4;
      bytes[j2 + 0] = Math.round(rgba[0]);
      bytes[j2 + 1] = Math.round(rgba[1]);
      bytes[j2 + 2] = Math.round(rgba[2]);
      bytes[j2 + 3] = Math.round(rgba[3]);
    }
    if (canvas != null) {
      if (!hasToPixelsWarned) {
        const kernel = getKernel(Draw, ENGINE.backendName);
        if (kernel != null) {
          console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead.");
          hasToPixelsWarned = true;
        }
      }
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      const imageData = new ImageData(bytes, width, height);
      ctx.putImageData(imageData, 0, 0);
    }
    if ($img !== img) {
      $img.dispose();
    }
    return bytes;
  }
  function draw(image2, canvas, options) {
    let $img = convertToTensor(image2, "img", "draw");
    if (!(image2 instanceof Tensor)) {
      const originalImgTensor = $img;
      $img = cast$1(originalImgTensor, "int32");
      originalImgTensor.dispose();
    }
    validateImgTensor($img);
    validateImageOptions(options === null || options === void 0 ? void 0 : options.imageOptions);
    const inputs = { image: $img };
    const attrs = { canvas, options };
    ENGINE.runKernel(Draw, inputs, attrs);
  }
  const fromPixels$1 = /* @__PURE__ */ op({ fromPixels_ });
  const browser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    draw,
    fromPixels: fromPixels$1,
    fromPixelsAsync,
    toPixels
  }, Symbol.toStringTag, { value: "Module" }));
  function prepareAndValidate(tensor2, indices) {
    const tensorRank = tensor2.shape.length;
    const indicesRank = indices.shape.length;
    if (tensorRank < 1) {
      throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${tensorRank}.`);
    }
    if (indicesRank < 1) {
      throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${indicesRank}.`);
    }
    if (indices.dtype !== "int32") {
      throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${indices.dtype}.`);
    }
    if (indices.shape[indicesRank - 1] > tensorRank) {
      throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);
    }
    if (sizeFromShape(tensor2.shape) === 0) {
      throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${tensor2.shape}.`);
    }
    const indicesShape = indices.shape;
    const sliceRank = indicesShape[indicesShape.length - 1];
    let nResult = 1;
    for (let i = 0; i < indicesShape.length - 1; ++i) {
      nResult *= indicesShape[i];
    }
    const inputShape = tensor2.shape;
    const resultShape = indicesShape.slice();
    resultShape.pop();
    let sliceSize = 1;
    for (let i = sliceRank; i < tensorRank; ++i) {
      sliceSize *= inputShape[i];
      resultShape.push(inputShape[i]);
    }
    const strides = [
      ...computeStrides(tensor2.shape).map((stride) => stride / sliceSize),
      1
    ].slice(0, sliceRank);
    return [resultShape, nResult, sliceSize, strides];
  }
  const gather_nd_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    prepareAndValidate
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const NEW_AXIS = -2;
  const SHRINK_AXIS = -1;
  function assertParamsValid(input, begin, size) {
    const inputRank = input.shape.length;
    assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must match the rank of the array (${inputRank}).`);
    assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must match the rank of the array (${inputRank}).`);
    for (let i = 0; i < inputRank; ++i) {
      assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] (${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);
    }
  }
  function maskToAxes(mask) {
    const axes = [];
    let axis = 0;
    while (mask > 0) {
      if (mask & 1) {
        axes.push(axis);
      }
      mask /= 2;
      axis++;
    }
    return axes;
  }
  function computeOutShape$2(begin, end, strides) {
    const size = [];
    for (let axis = 0; axis < begin.length; axis++) {
      size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);
    }
    return size;
  }
  function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {
    const newStrides = [...strides];
    for (let i = newStrides.length; i < inputShape.length; i++) {
      newStrides.push(1);
    }
    for (let i = 0; i < numElidedAxes; i++) {
      if (i === 0) {
        newStrides[ellipsisInsertionIndex] = 1;
      } else {
        newStrides.splice(
          ellipsisInsertionIndex,
          0,
          1
          /* element to add */
        );
        newStrides.pop();
      }
    }
    return newStrides;
  }
  function unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {
    if (normalizedAxis <= ellipsisInsertionIndex) {
      return normalizedAxis;
    }
    return normalizedAxis - (numElidedAxes - 1);
  }
  function getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {
    const elidedAxes = [];
    for (let i = 0; i < numElidedAxes; i++) {
      elidedAxes.push(ellipsisInsertionIndex + i);
    }
    return elidedAxes;
  }
  function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {
    const inputRank = inputShape.length;
    let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);
    if (ellipsisAxes.length && numInterpolatedAxes > 0) {
      const fullIndex = ellipsisAxes[0];
      const numElidedAxes = numInterpolatedAxes + 1;
      normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);
      normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);
      normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);
    } else {
      for (let axis = 0; axis < inputRank; axis++) {
        normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);
        normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);
        normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);
      }
    }
    return {
      begin: normalizedBegin,
      end: normalizedEnd,
      strides: normalizedStrides
    };
  }
  function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {
    const newIndices = [...inputShape];
    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
    for (let axis = 0; axis < newIndices.length; axis++) {
      if (elidedAxes.indexOf(axis) > -1) {
        newIndices[axis] = 0;
      } else {
        const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
        let originalValue = originalBegin[originalAxis];
        if (beginMask & 1 << originalAxis) {
          originalValue = 0;
        }
        newIndices[axis] = originalValue;
      }
    }
    return newIndices;
  }
  function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {
    const newIndices = [...inputShape];
    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
    for (let axis = 0; axis < newIndices.length; axis++) {
      if (elidedAxes.indexOf(axis) > -1) {
        newIndices[axis] = Number.MAX_SAFE_INTEGER;
      } else {
        const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
        let originalValue = originalEnd[originalAxis];
        if (endMask & 1 << originalAxis) {
          originalValue = Number.MAX_SAFE_INTEGER;
        }
        newIndices[axis] = originalValue;
      }
    }
    for (let i = 0; i < newIndices.length; i++) {
      const axisSize = inputShape[i];
      if (newIndices[i] < 0) {
        newIndices[i] += axisSize;
      }
      newIndices[i] = clamp(0, newIndices[i], inputShape[i]);
    }
    return newIndices;
  }
  function stridesForAxis(strides, axis, ellipsisMask) {
    let stride = strides[axis];
    if (ellipsisMask & 1 << axis || stride == null) {
      stride = 1;
    }
    return stride;
  }
  function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {
    let start = startIndices[axis];
    const stride = strides[axis] || 1;
    if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {
      if (stride > 0) {
        start = Number.MIN_SAFE_INTEGER;
      } else {
        start = Number.MAX_SAFE_INTEGER;
      }
    }
    const axisSize = inputShape[axis];
    if (start < 0) {
      start += axisSize;
    }
    start = clamp(0, start, axisSize - 1);
    return start;
  }
  function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {
    let stop = stopIndices[axis];
    const stride = strides[axis] || 1;
    if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {
      if (stride > 0) {
        stop = Number.MAX_SAFE_INTEGER;
      } else {
        stop = Number.MIN_SAFE_INTEGER;
      }
    }
    const axisSize = inputShape[axis];
    if (stop < 0) {
      stop += axisSize;
    }
    if (stride > 0) {
      stop = clamp(0, stop, axisSize);
    } else {
      stop = clamp(-1, stop, axisSize - 1);
    }
    return stop;
  }
  function isSliceContinous(shape, begin, size) {
    let firstNonOneAxis = size.length;
    for (let i = 0; i < size.length; i++) {
      if (size[i] > 1) {
        firstNonOneAxis = i;
        break;
      }
    }
    for (let i = firstNonOneAxis + 1; i < size.length; i++) {
      if (begin[i] > 0 || size[i] !== shape[i]) {
        return false;
      }
    }
    return true;
  }
  function computeFlatOffset(begin, strides) {
    let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;
    for (let i = 0; i < begin.length - 1; i++) {
      flatOffset += begin[i] * strides[i];
    }
    return flatOffset;
  }
  function parseSliceParams(x, begin, size) {
    let begin_;
    const xRank = x.shape.length;
    if (typeof begin === "number") {
      begin_ = [begin, ...new Array(xRank - 1).fill(0)];
    } else if (begin.length < xRank) {
      begin_ = begin.concat(new Array(xRank - begin.length).fill(0));
    } else {
      begin_ = begin.slice();
    }
    begin_.forEach((d) => {
      assert(d !== -1, () => "slice() does not support negative begin indexing.");
    });
    let size_;
    if (size == null) {
      size_ = new Array(xRank).fill(-1);
    } else if (typeof size === "number") {
      size_ = [size, ...new Array(xRank - 1).fill(-1)];
    } else if (size.length < xRank) {
      size_ = size.concat(new Array(xRank - size.length).fill(-1));
    } else {
      size_ = size;
    }
    size_ = size_.map((d, i) => {
      if (d >= 0) {
        return d;
      } else {
        assert(d === -1, () => `Negative size values should be exactly -1 but got ${d} for the slice() size at index ${i}.`);
        return x.shape[i] - begin_[i];
      }
    });
    return [begin_, size_];
  }
  function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
    let stridesNonNull;
    if (strides == null) {
      stridesNonNull = new Array(begin.length);
      stridesNonNull.fill(1);
    } else {
      stridesNonNull = strides;
    }
    if (ellipsisMask != null && (ellipsisMask & ellipsisMask - 1) !== 0) {
      throw new Error("Multiple ellipses in slice is not allowed.");
    }
    let ellipsisSeen = false;
    const sparseSpec = {
      dims: stridesNonNull.length,
      numAddAxisAfterEllipsis: 0,
      begin: begin.slice(),
      end: end.slice(),
      strides: stridesNonNull.slice(),
      beginMask,
      endMask,
      ellipsisMask,
      newAxisMask,
      shrinkAxisMask
    };
    for (let i = 0; i < sparseSpec.dims; i++) {
      if (ellipsisSeen && (1 << i & newAxisMask) !== 0) {
        sparseSpec.numAddAxisAfterEllipsis++;
      }
      if (1 << i & ellipsisMask) {
        ellipsisSeen = true;
      }
    }
    if (!ellipsisSeen) {
      sparseSpec.ellipsisMask |= 1 << sparseSpec.dims;
      sparseSpec.dims++;
    }
    const denseSpec = {
      dims: xShape.length,
      beginMask: 0,
      endMask: 0,
      beginValid: false,
      endValid: false
    };
    buildDenseSpec(sparseSpec, denseSpec);
    let isIdentity = true;
    let sliceDim0 = true;
    let isSimpleSlice = true;
    const processingShape = [];
    const finalShape = [];
    for (let i = 0; i < xShape.length; ++i) {
      if (denseSpec.strides[i] === 0) {
        throw Error(`strides[${i}] must be non-zero`);
      }
      const shrinkI = !!(denseSpec.shrinkAxisMask & 1 << i);
      const dimI = xShape[i];
      if (dimI === -1) {
        processingShape.push(shrinkI ? 1 : -1);
        continue;
      }
      const masks = [denseSpec.beginMask & 1 << i, denseSpec.endMask & 1 << i];
      const validRange = [
        denseSpec.strides[i] > 0 ? 0 : -1,
        denseSpec.strides[i] > 0 ? dimI : dimI - 1
      ];
      if (shrinkI && denseSpec.strides[i] <= 0) {
        throw Error("only stride 1 allowed on non-range indexing.");
      }
      isSimpleSlice = isSimpleSlice && denseSpec.strides[i] === 1;
      const beginAndEndMasked = !!(denseSpec.beginMask & 1 << i && denseSpec.endMask & 1 << i);
      if (denseSpec.beginValid && denseSpec.endValid) {
        if (shrinkI) {
          const xFwd = denseSpec.begin[i] < 0 ? dimI + denseSpec.begin[i] : denseSpec.begin[i];
          denseSpec.begin[i] = xFwd;
          denseSpec.end[i] = denseSpec.begin[i] + 1;
          if (xFwd < 0 || xFwd >= dimI) {
            throw Error(`slice index ${denseSpec.begin[i]} of dimension ${i} out of bounds.`);
          }
        } else {
          denseSpec.begin[i] = canonical(denseSpec.begin[i], 0, denseSpec.strides[i], dimI, masks, validRange);
          denseSpec.end[i] = canonical(denseSpec.end[i], 1, denseSpec.strides[i], dimI, masks, validRange);
        }
        const takeAllInDimension = denseSpec.strides[i] === 1 && denseSpec.begin[i] === 0 && denseSpec.end[i] === dimI;
        isIdentity = isIdentity && takeAllInDimension;
        sliceDim0 = sliceDim0 && (i === 0 && denseSpec.strides[i] === 1 || takeAllInDimension);
      } else {
        isIdentity = isIdentity && (denseSpec.strides[i] === 1 && beginAndEndMasked);
        sliceDim0 = sliceDim0 && (i === 0 && denseSpec.strides[i] === 1 || beginAndEndMasked);
      }
      let intervalLength;
      let knownInterval = false;
      if (denseSpec.beginValid && denseSpec.endValid) {
        intervalLength = denseSpec.end[i] - denseSpec.begin[i];
        knownInterval = true;
      } else if (shrinkI) {
        intervalLength = 1;
        knownInterval = true;
      } else if (beginAndEndMasked) {
        if (dimI >= 0) {
          if (denseSpec.strides[i] < 0) {
            intervalLength = -dimI;
          } else {
            intervalLength = dimI;
          }
          knownInterval = true;
        }
      }
      if (knownInterval) {
        let sizeI;
        if (intervalLength === 0 || intervalLength < 0 !== denseSpec.strides[i] < 0) {
          sizeI = 0;
        } else {
          sizeI = Math.trunc(intervalLength / denseSpec.strides[i]) + (intervalLength % denseSpec.strides[i] !== 0 ? 1 : 0);
        }
        processingShape.push(sizeI);
      } else {
        processingShape.push(-1);
      }
    }
    for (let denseDim = 0; denseDim < denseSpec.finalShapeGatherIndices.length; ++denseDim) {
      const gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];
      if (gatherIndex >= 0) {
        finalShape.push(processingShape[gatherIndex]);
      } else if (gatherIndex === NEW_AXIS) {
        finalShape.push(1);
      }
    }
    const finalShapeSparse = finalShape.filter((dim, i) => denseSpec.finalShapeGatherIndices[i] !== NEW_AXIS);
    return {
      finalShapeSparse,
      finalShape,
      isIdentity,
      sliceDim0,
      isSimpleSlice,
      begin: denseSpec.begin,
      end: denseSpec.end,
      strides: denseSpec.strides
    };
  }
  function buildDenseSpec(sparse2, dense) {
    dense.beginMask = 0;
    dense.endMask = 0;
    dense.shrinkAxisMask = 0;
    let fullIndex = 0;
    dense.beginValid = sparse2.begin != null;
    dense.endValid = sparse2.end != null;
    dense.begin = new Array(dense.dims);
    dense.end = new Array(dense.dims);
    dense.strides = new Array(dense.dims);
    dense.finalShapeGatherIndices = [];
    dense.finalShapeGatherIndicesSparse = [];
    dense.inputShapeGatherIndicesSparse = new Array(dense.dims);
    for (let i = 0; i < sparse2.dims; i++) {
      if (1 << i & sparse2.ellipsisMask) {
        const nextIndex = Math.min(dense.dims - (sparse2.dims - i) + 1 + sparse2.numAddAxisAfterEllipsis, dense.dims);
        for (; fullIndex < nextIndex; fullIndex++) {
          dense.begin[fullIndex] = 0;
          dense.end[fullIndex] = 0;
          dense.strides[fullIndex] = 1;
          dense.beginMask |= 1 << fullIndex;
          dense.endMask |= 1 << fullIndex;
          dense.finalShapeGatherIndices.push(fullIndex);
          dense.finalShapeGatherIndicesSparse.push(-1);
          dense.inputShapeGatherIndicesSparse[fullIndex] = i;
        }
      } else if (1 << i & sparse2.newAxisMask) {
        dense.finalShapeGatherIndices.push(NEW_AXIS);
        dense.finalShapeGatherIndicesSparse.push(-1);
      } else {
        if (fullIndex === dense.begin.length) {
          throw Error(`Index out of range using input dim ${fullIndex}; input has only ${dense.dims} dims, ${dense.begin.length}.`);
        }
        if (sparse2.begin != null) {
          dense.begin[fullIndex] = sparse2.begin[i];
        }
        if (sparse2.end != null) {
          dense.end[fullIndex] = sparse2.end[i];
        }
        dense.strides[fullIndex] = sparse2.strides[i];
        if (sparse2.beginMask & 1 << i) {
          dense.beginMask |= 1 << fullIndex;
        }
        if (sparse2.endMask & 1 << i) {
          dense.endMask |= 1 << fullIndex;
        }
        if (sparse2.shrinkAxisMask & 1 << i) {
          dense.finalShapeGatherIndices.push(SHRINK_AXIS);
          dense.finalShapeGatherIndicesSparse.push(-1);
          dense.shrinkAxisMask |= 1 << fullIndex;
        } else {
          dense.finalShapeGatherIndices.push(fullIndex);
          dense.finalShapeGatherIndicesSparse.push(i);
        }
        dense.inputShapeGatherIndicesSparse[fullIndex] = i;
        fullIndex++;
      }
    }
  }
  function canonical(x, c, strideI, dimI, masks, validRange) {
    if (masks[c]) {
      return strideI > 0 ? validRange[c] : validRange[c + 1 & 1];
    } else {
      const xFwd = x < 0 ? dimI + x : x;
      return xFwd < validRange[0] ? validRange[0] : xFwd > validRange[1] ? validRange[1] : xFwd;
    }
  }
  const slice_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    assertParamsValid,
    computeFlatOffset,
    computeOutShape: computeOutShape$2,
    getNormalizedAxes,
    isSliceContinous,
    maskToAxes,
    parseSliceParams,
    sliceInfo,
    startForAxis,
    startIndicesWithElidedDims,
    stopForAxis,
    stopIndicesWithElidedDims,
    stridesForAxis,
    stridesWithElidedDims
  }, Symbol.toStringTag, { value: "Module" }));
  /** @license See the LICENSE file. */
  const version$1 = "4.22.0";
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class OptimizerConstructors {
    /**
     * Constructs a `tf.SGDOptimizer` that uses stochastic gradient descent.
     *
     * ```js
     * // Fit a quadratic function by learning the coefficients a, b, c.
     * const xs = tf.tensor1d([0, 1, 2, 3]);
     * const ys = tf.tensor1d([1.1, 5.9, 16.8, 33.9]);
     *
     * const a = tf.scalar(Math.random()).variable();
     * const b = tf.scalar(Math.random()).variable();
     * const c = tf.scalar(Math.random()).variable();
     *
     * // y = a * x^2 + b * x + c.
     * const f = x => a.mul(x.square()).add(b.mul(x)).add(c);
     * const loss = (pred, label) => pred.sub(label).square().mean();
     *
     * const learningRate = 0.01;
     * const optimizer = tf.train.sgd(learningRate);
     *
     * // Train the model.
     * for (let i = 0; i < 10; i++) {
     *   optimizer.minimize(() => loss(f(xs), ys));
     * }
     *
     * // Make predictions.
     * console.log(
     *     `a: ${a.dataSync()}, b: ${b.dataSync()}, c: ${c.dataSync()}`);
     * const preds = f(xs).dataSync();
     * preds.forEach((pred, i) => {
     *   console.log(`x: ${i}, pred: ${pred}`);
     * });
     * ```
     *
     * @param learningRate The learning rate to use for the SGD algorithm.
     *
     * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
     */
    static sgd(learningRate) {
      return new SGDOptimizer(learningRate);
    }
    /**
     * Constructs a `tf.MomentumOptimizer` that uses momentum gradient
     * descent.
     *
     * See
     * [http://proceedings.mlr.press/v28/sutskever13.pdf](
     * http://proceedings.mlr.press/v28/sutskever13.pdf)
     *
     * @param learningRate The learning rate to use for the Momentum gradient
     * descent algorithm.
     * @param momentum The momentum to use for the momentum gradient descent
     * algorithm.
     *
     * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
     */
    static momentum(learningRate, momentum, useNesterov = false) {
      return new MomentumOptimizer(learningRate, momentum, useNesterov);
    }
    /**
     * Constructs a `tf.RMSPropOptimizer` that uses RMSProp gradient
     * descent. This implementation uses plain momentum and is not centered
     * version of RMSProp.
     *
     * See
     * [http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf](
     * http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf)
     *
     * @param learningRate The learning rate to use for the RMSProp gradient
     * descent algorithm.
     * @param decay The discounting factor for the history/coming gradient.
     * @param momentum The momentum to use for the RMSProp gradient descent
     * algorithm.
     * @param epsilon Small value to avoid zero denominator.
     * @param centered If true, gradients are normalized by the estimated
     * variance of the gradient.
     *
     * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
     */
    static rmsprop(learningRate, decay = 0.9, momentum = 0, epsilon = null, centered = false) {
      return new RMSPropOptimizer(learningRate, decay, momentum, epsilon, centered);
    }
    /**
     * Constructs a `tf.AdamOptimizer` that uses the Adam algorithm.
     * See [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)
     *
     * @param learningRate The learning rate to use for the Adam gradient
     * descent algorithm.
     * @param beta1 The exponential decay rate for the 1st moment estimates.
     * @param beta2 The exponential decay rate for the 2nd moment estimates.
     * @param epsilon A small constant for numerical stability.
     *
     * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
     */
    static adam(learningRate = 1e-3, beta1 = 0.9, beta2 = 0.999, epsilon = null) {
      return new AdamOptimizer(learningRate, beta1, beta2, epsilon);
    }
    /**
     * Constructs a `tf.AdadeltaOptimizer` that uses the Adadelta algorithm.
     * See [https://arxiv.org/abs/1212.5701](https://arxiv.org/abs/1212.5701)
     *
     * @param learningRate The learning rate to use for the Adadelta gradient
     * descent algorithm.
     * @param rho The learning rate decay over each update.
     * @param epsilon A constant epsilon used to better condition the grad
     * update.
     *
     * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
     */
    static adadelta(learningRate = 1e-3, rho = 0.95, epsilon = null) {
      return new AdadeltaOptimizer(learningRate, rho, epsilon);
    }
    /**
     * Constructs a `tf.AdamaxOptimizer` that uses the Adamax algorithm.
     * See [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)
     *
     * @param learningRate The learning rate to use for the Adamax gradient
     * descent algorithm.
     * @param beta1 The exponential decay rate for the 1st moment estimates.
     * @param beta2 The exponential decay rate for the 2nd moment estimates.
     * @param epsilon A small constant for numerical stability.
     * @param decay The learning rate decay over each update.
     *
     * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
     */
    static adamax(learningRate = 2e-3, beta1 = 0.9, beta2 = 0.999, epsilon = null, decay = 0) {
      return new AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay);
    }
    /**
     * Constructs a `tf.AdagradOptimizer` that uses the Adagrad algorithm.
     * See
     * [http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf](
     * http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf)
     * or
     * [http://ruder.io/optimizing-gradient-descent/index.html#adagrad](
     * http://ruder.io/optimizing-gradient-descent/index.html#adagrad)
     *
     * @param learningRate The learning rate to use for the Adagrad gradient
     * descent algorithm.
     * @param initialAccumulatorValue Starting value for the accumulators, must be
     * positive.
     *
     * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
     */
    static adagrad(learningRate, initialAccumulatorValue = 0.1) {
      return new AdagradOptimizer(learningRate, initialAccumulatorValue);
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const train = OptimizerConstructors;
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const delayCallback = (() => {
    if (typeof requestAnimationFrame !== "undefined") {
      return requestAnimationFrame;
    } else if (typeof setImmediate !== "undefined") {
      return setImmediate;
    }
    return (f) => f();
  })();
  function nextFrame() {
    return new Promise((resolve) => delayCallback(() => resolve()));
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function assertParamsConsistent(shapes, axis) {
    const rank = shapes[0].length;
    shapes.forEach((shape, i) => {
      assert(shape.length === rank, () => `Error in concat${rank}D: rank of tensors[${i}] must be the same as the rank of the rest (${rank})`);
    });
    assert(axis >= 0 && axis < rank, () => `Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`);
    const firstShape = shapes[0];
    shapes.forEach((shape, i) => {
      for (let r = 0; r < rank; r++) {
        assert(r === axis || shape[r] === firstShape[r], () => `Error in concat${rank}D: Shape of tensors[${i}] (${shape}) does not match the shape of the rest (${firstShape}) along the non-concatenated axis ${i}.`);
      }
    });
  }
  function computeOutShape$1(shapes, axis) {
    const outputShape = shapes[0].slice();
    for (let i = 1; i < shapes.length; i++) {
      outputShape[axis] += shapes[i][axis];
    }
    return outputShape;
  }
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  var RowPartitionType$1;
  (function(RowPartitionType2) {
    RowPartitionType2[RowPartitionType2["FIRST_DIM_SIZE"] = 0] = "FIRST_DIM_SIZE";
    RowPartitionType2[RowPartitionType2["VALUE_ROWIDS"] = 1] = "VALUE_ROWIDS";
    RowPartitionType2[RowPartitionType2["ROW_LENGTHS"] = 2] = "ROW_LENGTHS";
    RowPartitionType2[RowPartitionType2["ROW_SPLITS"] = 3] = "ROW_SPLITS";
    RowPartitionType2[RowPartitionType2["ROW_LIMITS"] = 4] = "ROW_LIMITS";
    RowPartitionType2[RowPartitionType2["ROW_STARTS"] = 5] = "ROW_STARTS";
  })(RowPartitionType$1 || (RowPartitionType$1 = {}));
  function combineRaggedTensorToTensorShapes(raggedRank, shape, valueShape) {
    let outputShape = new Array();
    if (valueShape == null && shape == null) {
      return outputShape;
    }
    if (shape == null) {
      while (outputShape.length < raggedRank + valueShape.length) {
        outputShape.push(-1);
      }
    } else {
      outputShape = shape.slice();
    }
    if (valueShape == null) {
      return outputShape;
    }
    if (raggedRank + valueShape.length !== outputShape.length) {
      throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.rank = ${raggedRank + valueShape.length}, but shape.rank = ${outputShape.length}`);
    }
    for (let i = 1; i < valueShape.length; ++i) {
      const valueDim = valueShape[i];
      const outputShapeDimIndex = outputShape[outputShape.length - valueShape.length + i];
      const outputShapeDim = outputShape[outputShapeDimIndex];
      if (valueDim >= 0) {
        if (outputShapeDim >= 0) {
          if (outputShapeDim !== valueDim) {
            throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.shape[${i + raggedRank}] = ${valueDim} but shape[${i + raggedRank}] = ${outputShapeDim}`);
          }
        } else {
          outputShape[outputShapeDimIndex] = valueDim;
        }
      }
    }
    return outputShape;
  }
  function getRowPartitionTypesHelper(rowPartitionTypeStrings) {
    const stringToType = {
      "FIRST_DIM_SIZE": RowPartitionType$1.FIRST_DIM_SIZE,
      "VALUE_ROWIDS": RowPartitionType$1.VALUE_ROWIDS,
      "ROW_LENGTHS": RowPartitionType$1.ROW_LENGTHS,
      "ROW_SPLITS": RowPartitionType$1.ROW_SPLITS,
      "ROW_LIMITS": RowPartitionType$1.ROW_LIMITS,
      "ROW_STARTS": RowPartitionType$1.ROW_STARTS
    };
    const result = [];
    for (const typeStr of rowPartitionTypeStrings) {
      if (typeStr in stringToType) {
        result.push(stringToType[typeStr]);
      } else {
        break;
      }
    }
    return result;
  }
  function getRaggedRank(rowPartitionTypes) {
    if (rowPartitionTypes.length === 0) {
      return 0;
    }
    if (rowPartitionTypes[0] === RowPartitionType$1.FIRST_DIM_SIZE) {
      return rowPartitionTypes.length - 1;
    }
    return rowPartitionTypes.length;
  }
  function validateDefaultValueShape(defaultValueShape, valueShape) {
    if (defaultValueShape == null || valueShape == null) {
      return;
    }
    const defaultNDims = defaultValueShape.length;
    const valuesNDims = valueShape.length;
    if (defaultNDims >= valuesNDims) {
      throw new Error(`defaultValue.shape=${defaultValueShape} and ragged tensor flatValues.shape=${valueShape}, are incompatible: defaultValue.rank = ${defaultNDims} must be less than ragged tensor input flatValues.rank = ${valuesNDims})`);
    }
    for (let i = 0; i < Math.min(defaultNDims, valuesNDims - 1); ++i) {
      const defaultDim = defaultValueShape[i];
      const valueDim = valueShape[i + 1];
      if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 && defaultDim !== valueDim) {
        throw new Error(`defaultValue.shape=${defaultValueShape}, and ragged tensor input flatValues.shape=${valueShape} are incompatible: defaultValue.shape[${i - defaultValueShape.length}] = ${defaultDim} but ragged tensor input.flatValues.shape[${i - defaultValueShape.length}] = ${valueDim}`);
      }
    }
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const PARALLELIZE_THRESHOLD = 30;
  function computeOptimalWindowSize(inSize) {
    if (inSize <= PARALLELIZE_THRESHOLD) {
      return inSize;
    }
    return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getImageCenter(center, imageHeight, imageWidth) {
    const centerX = imageWidth * (typeof center === "number" ? center : center[0]);
    const centerY = imageHeight * (typeof center === "number" ? center : center[1]);
    return [centerX, centerY];
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getReshaped(inputShape, blockShape, prod2, batchToSpace = true) {
    let reshaped = [];
    if (batchToSpace) {
      reshaped = reshaped.concat(blockShape.slice(0));
      reshaped.push(inputShape[0] / prod2);
      reshaped = reshaped.concat(inputShape.slice(1));
    } else {
      reshaped = reshaped.concat(inputShape[0]);
      const spatialLength = blockShape.length;
      for (let i = 0; i < spatialLength; ++i) {
        reshaped = reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);
      }
      reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));
    }
    return reshaped;
  }
  function getPermuted(reshapedRank, blockShapeRank, batchToSpace = true) {
    const permuted = [];
    if (batchToSpace) {
      permuted.push(blockShapeRank);
      for (let i = blockShapeRank + 1; i < reshapedRank; ++i) {
        if (i <= 2 * blockShapeRank) {
          permuted.push(i);
          permuted.push(i - (blockShapeRank + 1));
        } else {
          permuted.push(i);
        }
      }
    } else {
      const permutedBeforeBatch = [];
      const permutedAfterBatch = [];
      for (let i = 1; i < reshapedRank; ++i) {
        if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {
          permutedAfterBatch.push(i);
        } else {
          permutedBeforeBatch.push(i);
        }
      }
      permuted.push(...permutedBeforeBatch);
      permuted.push(0);
      permuted.push(...permutedAfterBatch);
    }
    return permuted;
  }
  function getReshapedPermuted(inputShape, blockShape, prod2, batchToSpace = true) {
    const reshapedPermuted = [];
    if (batchToSpace) {
      reshapedPermuted.push(inputShape[0] / prod2);
    } else {
      reshapedPermuted.push(inputShape[0] * prod2);
    }
    for (let i = 1; i < inputShape.length; ++i) {
      if (i <= blockShape.length) {
        if (batchToSpace) {
          reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);
        } else {
          reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);
        }
      } else {
        reshapedPermuted.push(inputShape[i]);
      }
    }
    return reshapedPermuted;
  }
  function getSliceBeginCoords(crops, blockShape) {
    const sliceBeginCoords = [0];
    for (let i = 0; i < blockShape; ++i) {
      sliceBeginCoords.push(crops[i][0]);
    }
    return sliceBeginCoords;
  }
  function getSliceSize(uncroppedShape, crops, blockShape) {
    const sliceSize = uncroppedShape.slice(0, 1);
    for (let i = 0; i < blockShape; ++i) {
      sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);
    }
    return sliceSize;
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const SELU_SCALEALPHA = 1.7580993408473768;
  const SELU_SCALE = 1.0507009873554805;
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ERF_P = 0.3275911;
  const ERF_A1 = 0.254829592;
  const ERF_A2 = -0.284496736;
  const ERF_A3 = 1.421413741;
  const ERF_A4 = -1.453152027;
  const ERF_A5 = 1.061405429;
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function mergeRealAndImagArrays(real2, imag2) {
    if (real2.length !== imag2.length) {
      throw new Error(`Cannot merge real and imag arrays of different lengths. real:${real2.length}, imag: ${imag2.length}.`);
    }
    const result = new Float32Array(real2.length * 2);
    for (let i = 0; i < result.length; i += 2) {
      result[i] = real2[i / 2];
      result[i + 1] = imag2[i / 2];
    }
    return result;
  }
  function splitRealAndImagArrays(complex2) {
    const real2 = new Float32Array(complex2.length / 2);
    const imag2 = new Float32Array(complex2.length / 2);
    for (let i = 0; i < complex2.length; i += 2) {
      real2[i / 2] = complex2[i];
      imag2[i / 2] = complex2[i + 1];
    }
    return { real: real2, imag: imag2 };
  }
  function complexWithEvenIndex(complex2) {
    const len = Math.ceil(complex2.length / 4);
    const real2 = new Float32Array(len);
    const imag2 = new Float32Array(len);
    for (let i = 0; i < complex2.length; i += 4) {
      real2[Math.floor(i / 4)] = complex2[i];
      imag2[Math.floor(i / 4)] = complex2[i + 1];
    }
    return { real: real2, imag: imag2 };
  }
  function complexWithOddIndex(complex2) {
    const len = Math.floor(complex2.length / 4);
    const real2 = new Float32Array(len);
    const imag2 = new Float32Array(len);
    for (let i = 2; i < complex2.length; i += 4) {
      real2[Math.floor(i / 4)] = complex2[i];
      imag2[Math.floor(i / 4)] = complex2[i + 1];
    }
    return { real: real2, imag: imag2 };
  }
  function getComplexWithIndex(complex2, index2) {
    const real2 = complex2[index2 * 2];
    const imag2 = complex2[index2 * 2 + 1];
    return { real: real2, imag: imag2 };
  }
  function assignToTypedArray(data, real2, imag2, index2) {
    data[index2 * 2] = real2;
    data[index2 * 2 + 1] = imag2;
  }
  function exponents(n, inverse) {
    const real2 = new Float32Array(n / 2);
    const imag2 = new Float32Array(n / 2);
    for (let i = 0; i < Math.ceil(n / 2); i++) {
      const x = (inverse ? 2 : -2) * Math.PI * (i / n);
      real2[i] = Math.cos(x);
      imag2[i] = Math.sin(x);
    }
    return { real: real2, imag: imag2 };
  }
  function exponent(k3, n, inverse) {
    const x = (inverse ? 2 : -2) * Math.PI * (k3 / n);
    const real2 = Math.cos(x);
    const imag2 = Math.sin(x);
    return { real: real2, imag: imag2 };
  }
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ARROW = "->";
  const ARROW_REGEX = /->/g;
  const COMMA = ",";
  const ELLIPSIS = "...";
  function decodeEinsumEquation(equation, numTensors) {
    equation = equation.replace(/\s/g, "");
    const numArrows = (equation.length - equation.replace(ARROW_REGEX, "").length) / ARROW.length;
    if (numArrows < 1) {
      throw new Error("Equations without an arrow are not supported.");
    } else if (numArrows > 1) {
      throw new Error(`Equation must contain exactly one arrow ("${ARROW}").`);
    }
    const [inputString, outputString] = equation.split(ARROW);
    assert(inputString.indexOf(ELLIPSIS) === -1, () => `The ellipsis notation ("${ELLIPSIS}") is not supported yet.`);
    const inputTerms = inputString.split(COMMA);
    const numInputs = inputTerms.length;
    if (numTensors !== numInputs) {
      throw new Error(`Expected ${numInputs} input tensors, received ${numTensors}`);
    }
    if (numInputs > 2) {
      throw new Error("Support for more than 2 input tensors is not implemented yet.");
    }
    const allDims = [];
    for (let i = 0; i < outputString.length; ++i) {
      const dimName = outputString[i];
      if (!inputTerms.some((inputTerm) => inputTerm.indexOf(dimName) !== -1)) {
        throw new Error(`Output subscripts contain the label ${dimName} not present in the input subscripts.`);
      }
      if (allDims.indexOf(dimName) === -1) {
        allDims.push(dimName);
      }
    }
    for (let i = 0; i < inputString.length; ++i) {
      const dimName = inputString[i];
      if (allDims.indexOf(dimName) === -1 && dimName !== COMMA) {
        allDims.push(dimName);
      }
    }
    const idDims = new Array(inputTerms.length);
    for (let i = 0; i < numInputs; ++i) {
      if (new Set(inputTerms[i].split("")).size !== inputTerms[i].length) {
        throw new Error(`Found duplicate axes in input component ${inputTerms[i]}. Support for duplicate axes in input is not implemented yet.`);
      }
      idDims[i] = [];
      for (let j2 = 0; j2 < inputTerms[i].length; ++j2) {
        idDims[i].push(allDims.indexOf(inputTerms[i][j2]));
      }
    }
    const numDims = allDims.length;
    const numOutDims = outputString.length;
    const summedDims = [];
    for (let i = numOutDims; i < numDims; ++i) {
      summedDims.push(i);
    }
    return { allDims, summedDims, idDims };
  }
  function getEinsumPermutation(nDims, idDims) {
    let permutationIndices = new Array(nDims);
    permutationIndices.fill(-1);
    for (let i = 0; i < idDims.length; ++i) {
      permutationIndices[idDims[i]] = i;
    }
    const expandDims2 = [];
    for (let i = 0; i < nDims; ++i) {
      if (permutationIndices[i] === -1) {
        expandDims2.push(i);
      }
    }
    permutationIndices = permutationIndices.filter((d) => d !== -1);
    return { permutationIndices, expandDims: expandDims2 };
  }
  function checkEinsumDimSizes(nDims, idDims, tensors) {
    const dimSizes = new Array(nDims);
    for (let i = 0; i < tensors.length; ++i) {
      const shape = tensors[i].shape;
      for (let j2 = 0; j2 < idDims[i].length; ++j2) {
        if (dimSizes[idDims[i][j2]] === void 0) {
          dimSizes[idDims[i][j2]] = shape[j2];
        } else {
          assert(dimSizes[idDims[i][j2]] === shape[j2], () => `Expected dimension ${dimSizes[idDims[i][j2]]} at axis ${j2} of input shaped ${JSON.stringify(shape)}, but got dimension ${shape[j2]}`);
        }
      }
    }
  }
  function getEinsumComputePath(summedDims, idDims) {
    const path = summedDims;
    const steps = [];
    let nSteps = 0;
    if (summedDims.length === 0) {
      path.push(-1);
    }
    nSteps = summedDims.length + 1;
    for (let i = 0; i < nSteps; ++i) {
      steps.push([]);
    }
    const computedTermIndices = [];
    for (let i = 0; i < path.length; ++i) {
      const summedDim = path[i];
      const termIndices = findTermsWithDim(idDims, summedDim);
      for (const termIndex of termIndices) {
        if (computedTermIndices.indexOf(termIndex) === -1) {
          steps[i].push(termIndex);
          computedTermIndices.push(termIndex);
        }
      }
    }
    return { path, steps };
  }
  function isIdentityPermutation(perm) {
    return perm.every((dim, index2) => dim === index2);
  }
  function findTermsWithDim(idDims, dim) {
    const termIndices = [];
    for (let i = 0; i < idDims.length; ++i) {
      if (idDims[i].length === 0 || idDims[i].indexOf(dim) !== -1 || dim === -1) {
        termIndices.push(i);
      }
    }
    return termIndices;
  }
  function prepareSplitSize(x, numOrSizeSplits, axis = 0) {
    let splitSizes = [];
    if (typeof numOrSizeSplits === "number") {
      assert(x.shape[axis] % numOrSizeSplits === 0, () => "Number of splits must evenly divide the axis.");
      splitSizes = new Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);
    } else {
      const numOfNegs = numOrSizeSplits.reduce((count, value) => {
        if (value === -1) {
          count += 1;
        }
        return count;
      }, 0);
      assert(numOfNegs <= 1, () => "There should be only one negative value in split array.");
      const negIndex = numOrSizeSplits.indexOf(-1);
      if (negIndex !== -1) {
        const total = numOrSizeSplits.reduce((a, b) => b > 0 ? a + b : a);
        numOrSizeSplits[negIndex] = x.shape[axis] - total;
      }
      assert(x.shape[axis] === numOrSizeSplits.reduce((a, b) => a + b), () => "The sum of sizes must match the size of the axis dimension.");
      splitSizes = numOrSizeSplits;
    }
    return splitSizes;
  }
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getSparseFillEmptyRowsIndicesDenseShapeMismatch(indicesLength) {
    return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${indicesLength}`;
  }
  function getSparseFillEmptyRowsNegativeIndexErrorMessage(index2, value) {
    return `indices(${index2}, 0) is invalid: ${value} < 0`;
  }
  function getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(index2, value, limit) {
    return `indices(${index2}, 0) is invalid: ${value} >= ${limit}`;
  }
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(dim1, dim2) {
    return `only one output dimension may be -1, not both ${dim1} and ${dim2}`;
  }
  function getSparseReshapeNegativeOutputDimErrorMessage(dim, value) {
    return `size ${dim} must be non-negative, not ${value}`;
  }
  function getSparseReshapeEmptyTensorZeroOutputDimErrorMessage() {
    return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
  }
  function getSparseReshapeInputOutputMultipleErrorMessage(inputShape, outputShape) {
    const inputSize = sizeFromShape(inputShape);
    const outputSize = sizeFromShape(outputShape);
    return `Input to reshape is a SparseTensor with ${inputSize}
  dense values, but the requested shape requires a multiple of ${outputSize}. inputShape=${inputShape} outputShape= ${outputShape}`;
  }
  function getSparseReshapeInputOutputMismatchErrorMessage(inputShape, outputShape) {
    const inputSize = sizeFromShape(inputShape);
    const outputSize = sizeFromShape(outputShape);
    return `Input to reshape is a tensor with ${inputSize} dense values, but the requested shape has ${outputSize}. inputShape=${inputShape} outputShape=${outputShape}`;
  }
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getSparseSegmentReductionNegativeSegmentIdsErrorMessage() {
    return `segment ids must be >= 0`;
  }
  function getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage() {
    return `segment ids are not increasing`;
  }
  function getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(segmentId, outputRows) {
    return `Segment id ${segmentId} out of range [0, ${outputRows}), possibly because segmentIds input is not sorted.`;
  }
  function getSparseSegmentReductionIndicesOutOfRangeErrorMessage(index2, indexValue, inputRows) {
    return `Bad: indices[${index2}] == ${indexValue} out of range [0, ${inputRows})`;
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function segOpComputeOptimalWindowSize(inSize, numSegments) {
    let done = false;
    let res;
    if (inSize <= PARALLELIZE_THRESHOLD) {
      res = inSize;
      done = true;
    } else {
      res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
    }
    while (!done) {
      if (res > numSegments || res === inSize) {
        done = true;
      } else {
        res = nearestDivisor(inSize, res + 1);
      }
    }
    return res;
  }
  function computeOutShape(aShape, axis, numSegments) {
    const outShape = [];
    const rank = aShape.length;
    for (let dim = 0; dim < rank; dim++) {
      if (dim !== axis) {
        outShape.push(aShape[dim]);
      } else {
        outShape.push(numSegments);
      }
    }
    return outShape;
  }
  function collectGatherOpShapeInfo(x, indices, axis, batchDims) {
    const indicesRank = indices.shape.length;
    const xRank = x.shape.length;
    if (batchDims !== 0) {
      if (batchDims < -indicesRank || batchDims > indicesRank) {
        throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${indicesRank}], but got ${batchDims}`);
      }
    }
    if (batchDims < 0) {
      batchDims += indicesRank;
    }
    if (batchDims > xRank) {
      throw new Error(`batchDims (${batchDims}) must be less than rank(x) (
    ${xRank}).`);
    }
    if (axis < batchDims) {
      throw new Error(`batchDims (${batchDims}) must be less than or equal to axis (${axis}).`);
    }
    for (let i = 0; i < batchDims; ++i) {
      if (x.shape[i] !== indices.shape[i]) {
        throw new Error(`x.shape[${i}]: ${x.shape[i]} should be equal to indices.shape[${i}]: ${indices.shape[i]}.`);
      }
    }
    const dimSize = x.shape[axis];
    const outputShape = [];
    let batchSize = 1;
    let outerSize = 1;
    let sliceSize = 1;
    for (let i = 0; i < batchDims; ++i) {
      outputShape.push(x.shape[i]);
      batchSize *= x.shape[i];
    }
    for (let i = batchDims; i < axis; i++) {
      outputShape.push(x.shape[i]);
      outerSize *= x.shape[i];
    }
    for (let i = batchDims; i < indicesRank; i++) {
      outputShape.push(indices.shape[i]);
    }
    for (let i = axis + 1; i < xRank; i++) {
      outputShape.push(x.shape[i]);
      sliceSize *= x.shape[i];
    }
    return { batchSize, sliceSize, outerSize, dimSize, outputShape };
  }
  const segment_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    collectGatherOpShapeInfo,
    computeOutShape,
    segOpComputeOptimalWindowSize
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function fromUint8ToStringArray(vals) {
    try {
      return vals.map((val) => decodeString(val));
    } catch (err) {
      throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);
    }
  }
  function fromStringArrayToUint8(strings) {
    return strings.map((s) => encodeString(s));
  }
  const backend_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    ERF_A1,
    ERF_A2,
    ERF_A3,
    ERF_A4,
    ERF_A5,
    ERF_P,
    PARALLELIZE_THRESHOLD,
    get RowPartitionType() {
      return RowPartitionType$1;
    },
    SELU_SCALE,
    SELU_SCALEALPHA,
    applyActivation,
    assertAndGetBroadcastShape,
    assertAxesAreInnerMostDims,
    assertParamsConsistent,
    assignToTypedArray,
    axesAreInnerMostDims,
    calculateShapes,
    checkEinsumDimSizes,
    checkPadOnDimRoundingMode,
    combineLocations,
    combineRaggedTensorToTensorShapes,
    complexWithEvenIndex,
    complexWithOddIndex,
    computeConv2DInfo,
    computeConv3DInfo,
    computeDefaultPad,
    computeDilation2DInfo,
    computeOptimalWindowSize,
    computeOutAndReduceShapes,
    computeOutShape: computeOutShape$1,
    computePool2DInfo,
    computePool3DInfo,
    convertConv2DDataFormat,
    decodeEinsumEquation,
    eitherStridesOrDilationsAreOne,
    expandShapeToKeepDim,
    exponent,
    exponents,
    fromStringArrayToUint8,
    fromUint8ToStringArray,
    getAxesPermutation,
    getBroadcastDims: getBroadcastDims$1,
    getComplexWithIndex,
    getEinsumComputePath,
    getEinsumPermutation,
    getFusedBiasGradient,
    getFusedDyActivation,
    getImageCenter,
    getInnerMostAxes,
    getPermuted,
    getRaggedRank,
    getReductionAxes,
    getReshaped,
    getReshapedPermuted,
    getRowPartitionTypesHelper,
    getSliceBeginCoords,
    getSliceSize,
    getSparseFillEmptyRowsIndicesDenseShapeMismatch,
    getSparseFillEmptyRowsNegativeIndexErrorMessage,
    getSparseFillEmptyRowsOutOfRangeIndexErrorMessage,
    getSparseReshapeEmptyTensorZeroOutputDimErrorMessage,
    getSparseReshapeInputOutputMismatchErrorMessage,
    getSparseReshapeInputOutputMultipleErrorMessage,
    getSparseReshapeMultipleNegativeOneOutputDimErrorMessage,
    getSparseReshapeNegativeOutputDimErrorMessage,
    getSparseSegmentReductionIndicesOutOfRangeErrorMessage,
    getSparseSegmentReductionNegativeSegmentIdsErrorMessage,
    getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage,
    getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage,
    getUndoAxesPermutation,
    isIdentityPermutation,
    log: log$2,
    mergeRealAndImagArrays,
    prepareAndValidate,
    prepareSplitSize,
    segment_util,
    shouldFuse,
    slice_util,
    splitRealAndImagArrays,
    stridesOrDilationsArePositive,
    tupleValuesAreOne,
    upcastType,
    validateDefaultValueShape,
    validateInput: validateInput$1,
    validateUpdateShape,
    warn
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const kernel_impls = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    nonMaxSuppressionV3Impl: nonMaxSuppressionV3Impl$1,
    nonMaxSuppressionV4Impl: nonMaxSuppressionV4Impl$1,
    nonMaxSuppressionV5Impl: nonMaxSuppressionV5Impl$1,
    whereImpl: whereImpl$1
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  registerOptimizers();
  const tf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Abs,
    Acos,
    Acosh,
    AdadeltaOptimizer,
    AdagradOptimizer,
    AdamOptimizer,
    AdamaxOptimizer,
    Add,
    AddN,
    All,
    Any,
    ArgMax,
    ArgMin,
    Asin,
    Asinh,
    Atan,
    Atan2,
    Atanh,
    AvgPool,
    AvgPool3D,
    AvgPool3DGrad,
    AvgPoolGrad,
    BatchMatMul,
    BatchToSpaceND,
    Bincount,
    BitwiseAnd,
    BroadcastArgs,
    BroadcastTo,
    Cast,
    Ceil,
    ClipByValue,
    Complex,
    ComplexAbs,
    Concat,
    Conv2D,
    Conv2DBackpropFilter,
    Conv2DBackpropInput,
    Conv3D,
    Conv3DBackpropFilterV2,
    Conv3DBackpropInputV2,
    Cos,
    Cosh,
    CropAndResize,
    Cumprod,
    Cumsum,
    DataStorage,
    DenseBincount,
    DepthToSpace,
    DepthwiseConv2dNative,
    DepthwiseConv2dNativeBackpropFilter,
    DepthwiseConv2dNativeBackpropInput,
    Diag,
    Dilation2D,
    Dilation2DBackpropFilter,
    Dilation2DBackpropInput,
    Draw,
    get ENV() {
      return ENV$3;
    },
    Einsum,
    Elu,
    EluGrad,
    Environment,
    Equal,
    Erf,
    Exp,
    ExpandDims,
    Expm1,
    FFT,
    Fill,
    FlipLeftRight,
    Floor,
    FloorDiv,
    FromPixels,
    FusedBatchNorm,
    FusedConv2D,
    FusedDepthwiseConv2D,
    GatherNd,
    GatherV2,
    Greater,
    GreaterEqual,
    IFFT,
    Identity,
    Imag,
    IsFinite,
    IsInf,
    IsNan,
    KernelBackend,
    LRN,
    LRNGrad,
    LeakyRelu,
    Less,
    LessEqual,
    LinSpace,
    Log,
    Log1p,
    LogSoftmax,
    LogicalAnd,
    LogicalNot,
    LogicalOr,
    LogicalXor,
    LowerBound,
    MatrixBandPart,
    Max,
    MaxPool,
    MaxPool3D,
    MaxPool3DGrad,
    MaxPoolGrad,
    MaxPoolWithArgmax,
    Maximum,
    Mean,
    Min,
    Minimum,
    MirrorPad,
    Mod,
    MomentumOptimizer,
    Multinomial,
    Multiply,
    Neg,
    NonMaxSuppressionV3,
    NonMaxSuppressionV4,
    NonMaxSuppressionV5,
    NotEqual,
    OP_SCOPE_SUFFIX,
    OneHot,
    OnesLike,
    Optimizer,
    OptimizerConstructors,
    Pack,
    PadV2,
    Pool,
    Pow,
    Prelu,
    Prod,
    RMSPropOptimizer,
    RaggedGather,
    RaggedRange,
    RaggedTensorToTensor,
    Range,
    get Rank() {
      return Rank;
    },
    Real,
    RealDiv,
    Reciprocal,
    get Reduction() {
      return Reduction;
    },
    Relu,
    Relu6,
    Reshape,
    ResizeBilinear,
    ResizeBilinearGrad,
    ResizeNearestNeighbor,
    ResizeNearestNeighborGrad,
    Reverse,
    RotateWithOffset,
    Round,
    Rsqrt,
    SGDOptimizer,
    ScatterNd,
    SearchSorted,
    Select,
    Selu,
    Sigmoid,
    Sign,
    Sin,
    Sinh,
    Slice,
    Softmax,
    Softplus,
    SpaceToBatchND,
    SparseFillEmptyRows,
    SparseReshape,
    SparseSegmentMean,
    SparseSegmentSum,
    SparseToDense,
    SplitV,
    Sqrt,
    Square,
    SquaredDifference,
    StaticRegexReplace,
    Step,
    StridedSlice,
    StringNGrams,
    StringSplit,
    StringToHashBucketFast,
    Sub,
    Sum,
    Tan,
    Tanh,
    Tensor,
    TensorBuffer,
    TensorScatterUpdate,
    Tile,
    TopK,
    Transform,
    Transpose,
    Unique,
    Unpack,
    UnsortedSegmentSum,
    UpperBound,
    Variable,
    ZerosLike,
    _FusedMatMul,
    abs: abs$1,
    acos: acos$1,
    acosh: acosh$1,
    add,
    addN: addN$1,
    all: all$1,
    any: any$1,
    argMax: argMax$1,
    argMin: argMin$1,
    asin: asin$1,
    asinh: asinh$1,
    atan: atan$1,
    atan2: atan2$1,
    atanh: atanh$1,
    avgPool: avgPool$1,
    avgPool3d,
    backend,
    backend_util,
    basicLSTMCell,
    batchNorm: batchNorm$1,
    batchNorm2d,
    batchNorm3d,
    batchNorm4d,
    batchToSpaceND: batchToSpaceND$1,
    bincount: bincount$1,
    bitwiseAnd: bitwiseAnd$1,
    booleanMaskAsync,
    broadcastArgs: broadcastArgs$1,
    broadcastTo,
    broadcast_util,
    browser,
    buffer,
    cast: cast$1,
    ceil: ceil$1,
    clipByValue: clipByValue$1,
    clone,
    complex: complex$1,
    concat: concat$1,
    concat1d,
    concat2d,
    concat3d,
    concat4d,
    conv1d,
    conv2d: conv2d$2,
    conv2dTranspose,
    conv3d,
    conv3dTranspose,
    copyRegisteredKernels,
    cos: cos$1,
    cosh: cosh$1,
    cosineWindow,
    cumprod: cumprod$1,
    cumsum: cumsum$1,
    customGrad,
    denseBincount: denseBincount$1,
    deprecationWarn,
    depthToSpace: depthToSpace$1,
    depthwiseConv2d: depthwiseConv2d$1,
    device_util,
    diag: diag$1,
    dilation2d,
    disableDeprecationWarnings,
    dispose,
    disposeVariables,
    div,
    divNoNan,
    dot,
    dropout,
    einsum: einsum$1,
    elu: elu$1,
    enableDebugMode,
    enableProdMode,
    enclosingPowerOfTwo,
    engine,
    ensureShape,
    env,
    equal: equal$1,
    erf: erf$1,
    euclideanNorm,
    exp: exp$1,
    expandDims: expandDims$1,
    expm1: expm1$1,
    eye,
    fft: fft$1,
    fill: fill$1,
    findBackend,
    findBackendFactory,
    floor: floor$1,
    floorDiv: floorDiv$1,
    fused: fused_ops,
    gather,
    gatherND,
    gather_util: gather_nd_util,
    getBackend,
    getGradient,
    getKernel,
    getKernelsForBackend,
    grad,
    grads,
    greater: greater$1,
    greaterEqual: greaterEqual$1,
    ifft: ifft$1,
    imag: imag$1,
    image: image$1,
    inTopKAsync,
    io,
    irfft,
    isFinite: isFinite$2,
    isInf: isInf$1,
    isNaN: isNaN$2,
    keep,
    kernel_impls,
    leakyRelu: leakyRelu$1,
    less: less$1,
    lessEqual: lessEqual$1,
    linalg,
    linspace,
    localResponseNormalization,
    log: log$1,
    log1p: log1p$1,
    logSigmoid,
    logSoftmax,
    logSumExp,
    logicalAnd: logicalAnd$1,
    logicalNot: logicalNot$1,
    logicalOr: logicalOr$1,
    logicalXor,
    losses,
    lowerBound,
    matMul: matMul$1,
    math,
    max: max$1,
    maxPool: maxPool$1,
    maxPool3d: maxPool3d$1,
    maxPoolWithArgmax,
    maximum: maximum$1,
    mean,
    memory,
    meshgrid,
    min: min$1,
    minimum: minimum$1,
    mirrorPad,
    mod: mod$1,
    moments,
    movingAverage,
    mul,
    multiRNNCell,
    multinomial: multinomial$1,
    neg: neg$1,
    nextFrame,
    norm,
    notEqual: notEqual$1,
    oneHot: oneHot$1,
    ones,
    onesLike: onesLike$1,
    op,
    outerProduct,
    pad,
    pad1d,
    pad2d,
    pad3d,
    pad4d,
    pool,
    pow: pow$1,
    prelu: prelu$1,
    print,
    prod: prod$1,
    profile,
    raggedGather: raggedGather$1,
    raggedRange: raggedRange$1,
    raggedTensorToTensor: raggedTensorToTensor$1,
    rand,
    randomGamma,
    randomNormal,
    randomStandardNormal,
    randomUniform,
    randomUniformInt,
    range: range$1,
    ready,
    real: real$1,
    reciprocal: reciprocal$1,
    registerBackend,
    registerGradient,
    registerKernel,
    relu: relu$1,
    relu6: relu6$1,
    removeBackend,
    reshape: reshape$1,
    reverse: reverse$1,
    reverse1d,
    reverse2d,
    reverse3d,
    reverse4d,
    rfft,
    round: round$1,
    rsqrt: rsqrt$1,
    scalar,
    scatterND,
    scatter_util: scatter_nd_util,
    searchSorted: searchSorted$1,
    selu: selu$1,
    separableConv2d,
    serialization,
    setBackend,
    setPlatform,
    setdiff1dAsync,
    sigmoid: sigmoid$1,
    sign: sign$1,
    signal,
    sin: sin$1,
    sinh: sinh$1,
    slice: slice$1,
    slice1d,
    slice2d,
    slice3d,
    slice4d,
    slice_util,
    softmax: softmax$1,
    softplus: softplus$1,
    spaceToBatchND: spaceToBatchND$1,
    sparse: sparse$1,
    sparseToDense: sparseToDense$1,
    spectral: spectral$1,
    split: split$2,
    sqrt: sqrt$1,
    square: square$1,
    squaredDifference: squaredDifference$1,
    squeeze,
    stack,
    step: step$1,
    stridedSlice: stridedSlice$1,
    string: string$1,
    sub: sub$1,
    sum: sum$1,
    sumOutType,
    tan: tan$1,
    tanh: tanh$1,
    tensor,
    tensor1d,
    tensor2d,
    tensor3d,
    tensor4d,
    tensor5d,
    tensor6d,
    tensorScatterUpdate: tensorScatterUpdate$1,
    tensor_util,
    test_util,
    tidy,
    tile: tile$1,
    time,
    topk,
    train,
    transpose: transpose$1,
    truncatedNormal,
    unique: unique$1,
    unregisterGradient,
    unregisterKernel,
    unsortedSegmentSum: unsortedSegmentSum$1,
    unstack,
    upcastType,
    upperBound,
    util,
    valueAndGrad,
    valueAndGrads,
    variable,
    variableGrads,
    version_core: version$1,
    where,
    whereAsync,
    zeros,
    zerosLike: zerosLike$1
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const contexts = {};
  const WEBGL_ATTRIBUTES = {
    alpha: false,
    antialias: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    depth: false,
    stencil: false,
    failIfMajorPerformanceCaveat: true
  };
  function setWebGLContext(webGLVersion, gl) {
    contexts[webGLVersion] = gl;
  }
  function getWebGLContext(webGLVersion, customCanvas) {
    if (!(webGLVersion in contexts) || customCanvas != null) {
      const newCtx = getWebGLRenderingContext(webGLVersion, customCanvas);
      if (newCtx !== null) {
        contexts[webGLVersion] = newCtx;
      } else {
        console.log("Could not get context for WebGL version", webGLVersion);
        return null;
      }
    }
    const gl = contexts[webGLVersion];
    if (gl == null || gl.isContextLost()) {
      delete contexts[webGLVersion];
      return getWebGLContext(webGLVersion);
    }
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.BLEND);
    gl.disable(gl.DITHER);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SAMPLE_COVERAGE);
    gl.enable(gl.SCISSOR_TEST);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    return contexts[webGLVersion];
  }
  function createCanvas(webGLVersion) {
    if (!env().getBool("IS_SAFARI") && typeof OffscreenCanvas !== "undefined" && webGLVersion === 2) {
      return new OffscreenCanvas(300, 150);
    } else if (typeof document !== "undefined") {
      return document.createElement("canvas");
    } else {
      throw new Error("Cannot create a canvas in this context");
    }
  }
  function getWebGLRenderingContext(webGLVersion, customCanvas) {
    if (webGLVersion !== 1 && webGLVersion !== 2) {
      throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
    }
    const canvas = customCanvas == null ? createCanvas(webGLVersion) : customCanvas;
    canvas.addEventListener("webglcontextlost", (ev) => {
      ev.preventDefault();
      delete contexts[webGLVersion];
    }, false);
    if (env().getBool("SOFTWARE_WEBGL_ENABLED")) {
      WEBGL_ATTRIBUTES.failIfMajorPerformanceCaveat = false;
    }
    if (webGLVersion === 1) {
      return (
        // tslint:disable-next-line
        canvas.getContext("webgl", WEBGL_ATTRIBUTES) || canvas.getContext("experimental-webgl", WEBGL_ATTRIBUTES)
      );
    }
    return canvas.getContext("webgl2", WEBGL_ATTRIBUTES);
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  var PackingScheme;
  (function(PackingScheme2) {
    PackingScheme2[PackingScheme2["DENSE"] = 0] = "DENSE";
    PackingScheme2[PackingScheme2["SHARED_BATCH"] = 1] = "SHARED_BATCH";
  })(PackingScheme || (PackingScheme = {}));
  var TextureUsage;
  (function(TextureUsage2) {
    TextureUsage2[TextureUsage2["RENDER"] = 0] = "RENDER";
    TextureUsage2[TextureUsage2["UPLOAD"] = 1] = "UPLOAD";
    TextureUsage2[TextureUsage2["PIXELS"] = 2] = "PIXELS";
    TextureUsage2[TextureUsage2["DOWNLOAD"] = 3] = "DOWNLOAD";
  })(TextureUsage || (TextureUsage = {}));
  var PhysicalTextureType;
  (function(PhysicalTextureType2) {
    PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT16"] = 0] = "UNPACKED_FLOAT16";
    PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT32"] = 1] = "UNPACKED_FLOAT32";
    PhysicalTextureType2[PhysicalTextureType2["PACKED_4X1_UNSIGNED_BYTE"] = 2] = "PACKED_4X1_UNSIGNED_BYTE";
    PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT32"] = 3] = "PACKED_2X2_FLOAT32";
    PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT16"] = 4] = "PACKED_2X2_FLOAT16";
  })(PhysicalTextureType || (PhysicalTextureType = {}));
  function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
  }
  function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
  }
  function getDenseTexShape(shape) {
    const size = sizeFromShape(shape);
    const texelsNeeded = Math.ceil(size / 4);
    return sizeToSquarishShape(texelsNeeded);
  }
  function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [
      Math.max(1, Math.ceil(columns / 2)),
      Math.max(1, Math.ceil(rows / 2))
    ];
  }
  function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    const [w, h] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
    return w * h * 4;
  }
  function getTextureConfig(gl, textureHalfFloatExtension) {
    const glany = gl;
    let internalFormatFloat;
    let internalFormatHalfFloat;
    let internalFormatPackedHalfFloat;
    let internalFormatPackedFloat;
    let textureFormatFloat;
    let downloadTextureFormat;
    let downloadUnpackNumChannels;
    let defaultNumChannels;
    let textureTypeHalfFloat;
    let textureTypeFloat;
    if (env().getNumber("WEBGL_VERSION") === 2) {
      internalFormatFloat = glany.R32F;
      internalFormatHalfFloat = glany.R16F;
      internalFormatPackedHalfFloat = glany.RGBA16F;
      internalFormatPackedFloat = glany.RGBA32F;
      textureFormatFloat = glany.RED;
      downloadUnpackNumChannels = 4;
      defaultNumChannels = 1;
      textureTypeHalfFloat = glany.HALF_FLOAT;
      textureTypeFloat = glany.FLOAT;
      downloadTextureFormat = glany.RGBA8;
    } else {
      internalFormatFloat = gl.RGBA;
      internalFormatHalfFloat = gl.RGBA;
      internalFormatPackedHalfFloat = gl.RGBA;
      internalFormatPackedFloat = glany.RGBA;
      textureFormatFloat = gl.RGBA;
      downloadUnpackNumChannels = 4;
      defaultNumChannels = 4;
      textureTypeHalfFloat = textureHalfFloatExtension != null ? textureHalfFloatExtension.HALF_FLOAT_OES : null;
      textureTypeFloat = gl.FLOAT;
      downloadTextureFormat = gl.RGBA;
    }
    return {
      internalFormatFloat,
      internalFormatHalfFloat,
      internalFormatPackedHalfFloat,
      internalFormatPackedFloat,
      textureFormatFloat,
      downloadTextureFormat,
      downloadUnpackNumChannels,
      defaultNumChannels,
      textureTypeHalfFloat,
      textureTypeFloat
    };
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function callAndCheck(gl, func) {
    const returnValue = func();
    if (env().getBool("DEBUG")) {
      checkWebGLError(gl);
    }
    return returnValue;
  }
  function checkWebGLError(gl) {
    const error = gl.getError();
    if (error !== gl.NO_ERROR) {
      throw new Error("WebGL Error: " + getWebGLErrorMessage(gl, error));
    }
  }
  const MIN_FLOAT16 = 596e-10;
  const MAX_FLOAT16 = 65504;
  function canBeRepresented(num) {
    if (env().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || num === 0 || MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16) {
      return true;
    }
    return false;
  }
  function getWebGLErrorMessage(gl, status) {
    switch (status) {
      case gl.NO_ERROR:
        return "NO_ERROR";
      case gl.INVALID_ENUM:
        return "INVALID_ENUM";
      case gl.INVALID_VALUE:
        return "INVALID_VALUE";
      case gl.INVALID_OPERATION:
        return "INVALID_OPERATION";
      case gl.INVALID_FRAMEBUFFER_OPERATION:
        return "INVALID_FRAMEBUFFER_OPERATION";
      case gl.OUT_OF_MEMORY:
        return "OUT_OF_MEMORY";
      case gl.CONTEXT_LOST_WEBGL:
        return "CONTEXT_LOST_WEBGL";
      default:
        return `Unknown error code ${status}`;
    }
  }
  function getExtensionOrThrow(gl, extensionName) {
    return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension "' + extensionName + '" not supported on this browser.');
  }
  function createVertexShader$1(gl, vertexShaderSource) {
    const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
    callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));
    callAndCheck(gl, () => gl.compileShader(vertexShader));
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
      console.log(gl.getShaderInfoLog(vertexShader));
      throw new Error("Failed to compile vertex shader.");
    }
    return vertexShader;
  }
  function createFragmentShader(gl, fragmentShaderSource) {
    const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
    callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));
    callAndCheck(gl, () => gl.compileShader(fragmentShader));
    if (env().get("ENGINE_COMPILE_ONLY")) {
      return fragmentShader;
    }
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
      logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
      throw new Error("Failed to compile fragment shader.");
    }
    return fragmentShader;
  }
  const lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
  function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
    const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
    if (lineNumberRegexResult == null) {
      console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);
      console.log(shaderSource);
      return;
    }
    const lineNumber = +lineNumberRegexResult[1];
    const shaderLines = shaderSource.split("\n");
    const pad2 = shaderLines.length.toString().length + 2;
    const linesWithLineNumbers = shaderLines.map((line, lineNumber2) => rightPad((lineNumber2 + 1).toString(), pad2) + line);
    let maxLineLength = 0;
    for (let i = 0; i < linesWithLineNumbers.length; i++) {
      maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
    }
    const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
    const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
    const afterErrorLines = linesWithLineNumbers.slice(lineNumber);
    console.log(beforeErrorLines.join("\n"));
    console.log(shaderInfoLog.split("\n")[0]);
    console.log(`%c ${rightPad(errorLine[0], maxLineLength)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717");
    console.log(afterErrorLines.join("\n"));
  }
  function createProgram(gl) {
    return throwIfNull(gl, () => gl.createProgram(), "Unable to create WebGLProgram.");
  }
  function linkProgram(gl, program) {
    callAndCheck(gl, () => gl.linkProgram(program));
    if (env().get("ENGINE_COMPILE_ONLY")) {
      return;
    }
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
      console.log(gl.getProgramInfoLog(program));
      throw new Error("Failed to link vertex and fragment shaders.");
    }
  }
  function validateProgram(gl, program) {
    callAndCheck(gl, () => gl.validateProgram(program));
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
      console.log(gl.getProgramInfoLog(program));
      throw new Error("Shader program validation failed.");
    }
  }
  function createStaticVertexBuffer(gl, data) {
    const buffer2 = throwIfNull(gl, () => gl.createBuffer(), "Unable to create WebGLBuffer");
    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer2));
    callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));
    return buffer2;
  }
  function createStaticIndexBuffer(gl, data) {
    const buffer2 = throwIfNull(gl, () => gl.createBuffer(), "Unable to create WebGLBuffer");
    callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer2));
    callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));
    return buffer2;
  }
  function getNumChannels() {
    if (env().getNumber("WEBGL_VERSION") === 2) {
      return 1;
    }
    return 4;
  }
  function createTexture(gl) {
    return throwIfNull(gl, () => gl.createTexture(), "Unable to create WebGLTexture.");
  }
  function validateTextureSize(width, height) {
    const maxTextureSize = env().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (width <= 0 || height <= 0) {
      const requested = `[${width}x${height}]`;
      throw new Error("Requested texture size " + requested + " is invalid.");
    }
    if (width > maxTextureSize || height > maxTextureSize) {
      const requested = `[${width}x${height}]`;
      const max2 = `[${maxTextureSize}x${maxTextureSize}]`;
      throw new Error("Requested texture size " + requested + " greater than WebGL maximum on this browser / GPU " + max2 + ".");
    }
  }
  function createFramebuffer(gl) {
    return throwIfNull(gl, () => gl.createFramebuffer(), "Unable to create WebGLFramebuffer.");
  }
  function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer2, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
    const loc = gl.getAttribLocation(program, attribute);
    if (loc === -1) {
      return false;
    }
    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer2));
    callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));
    callAndCheck(gl, () => gl.enableVertexAttribArray(loc));
    return true;
  }
  function bindTextureUnit(gl, texture, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
  }
  function unbindTextureUnit(gl, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
  }
  function getProgramUniformLocationOrThrow(gl, program, uniformName) {
    return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform "' + uniformName + '" not present in program.');
  }
  function getProgramUniformLocation(gl, program, uniformName) {
    return gl.getUniformLocation(program, uniformName);
  }
  function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {
    callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));
    callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));
  }
  function bindCanvasToFramebuffer(gl) {
    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));
    callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));
    callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));
  }
  function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));
  }
  function unbindColorTextureFromFramebuffer(gl, framebuffer) {
    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));
  }
  function validateFramebuffer(gl) {
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
      throw new Error("Error binding framebuffer: " + getFramebufferErrorMessage(gl, status));
    }
  }
  function getFramebufferErrorMessage(gl, status) {
    switch (status) {
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      case gl.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";
      default:
        return `unknown error ${status}`;
    }
  }
  function throwIfNull(gl, returnTOrNull, failureMessage) {
    const tOrNull = callAndCheck(gl, () => returnTOrNull());
    if (tOrNull == null) {
      throw new Error(failureMessage);
    }
    return tOrNull;
  }
  function validateTextureUnit(gl, textureUnit) {
    const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    const glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
      const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;
      throw new Error(`textureUnit must be in ${textureUnitRange}.`);
    }
  }
  function getBatchDim(shape, dimsToSkip = 2) {
    return sizeFromShape(shape.slice(0, shape.length - dimsToSkip));
  }
  function getRowsCols(shape) {
    if (shape.length === 0) {
      throw Error("Cannot get rows and columns of an empty shape array.");
    }
    return [
      shape.length > 1 ? shape[shape.length - 2] : 1,
      shape[shape.length - 1]
    ];
  }
  function getShapeAs3D(shape) {
    let shapeAs3D = [1, 1, 1];
    const isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;
    if (!isScalar) {
      shapeAs3D = [getBatchDim(shape), ...getRowsCols(shape)];
    }
    return shapeAs3D;
  }
  function getTextureShapeFromLogicalShape(logShape, isPacked = false) {
    let maxTexSize = env().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    let maxSizeForNarrowTex = env().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
    if (maxSizeForNarrowTex === Infinity && env().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")) {
      maxSizeForNarrowTex = maxTexSize / 2;
    }
    if (isPacked) {
      maxTexSize = maxTexSize * 2;
      maxSizeForNarrowTex = maxSizeForNarrowTex * 2;
      logShape = logShape.map((d, i) => i >= logShape.length - 2 ? nearestLargerEven(logShape[i]) : logShape[i]);
      if (logShape.length === 1) {
        logShape = [2, logShape[0]];
      }
    }
    if (logShape.length !== 2) {
      const squeezeResult = squeezeShape(logShape);
      logShape = squeezeResult.newShape;
    }
    let size = sizeFromShape(logShape);
    let textureShape = null;
    if (logShape.length <= 1 && size <= maxTexSize) {
      textureShape = [1, size];
    } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {
      textureShape = logShape;
    } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) {
      textureShape = [logShape[0] * logShape[1], logShape[2]];
    } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {
      textureShape = [logShape[0], logShape[1] * logShape[2]];
    } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) {
      textureShape = [logShape[0] * logShape[1] * logShape[2], logShape[3]];
    } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
      textureShape = [logShape[0], logShape[1] * logShape[2] * logShape[3]];
    }
    const isLongNarrowTex = textureShape != null && Math.max(...textureShape) > maxSizeForNarrowTex && Math.min(...textureShape) <= (isPacked ? 2 : 1) && Math.min(...textureShape) > 0;
    if (textureShape == null || isLongNarrowTex) {
      if (isPacked) {
        const batchDim = getBatchDim(logShape);
        let rows = 2, cols = 2;
        if (logShape.length) {
          [rows, cols] = getRowsCols(logShape);
        }
        size = batchDim * (rows / 2) * (cols / 2);
        textureShape = sizeToSquarishShape(size).map((d) => d * 2);
      } else {
        textureShape = sizeToSquarishShape(size);
      }
    }
    return textureShape;
  }
  function isEven(n) {
    return n % 2 === 0;
  }
  function isReshapeFree(shape1, shape2) {
    shape1 = shape1.slice(-2);
    shape2 = shape2.slice(-2);
    if (arraysEqual(shape1, shape2)) {
      return true;
    }
    if (!shape1.length || !shape2.length) {
      return true;
    }
    if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) {
      return true;
    }
    if (shape1.length !== shape2.length) {
      const shape1Cols = shape1[shape1.length - 1];
      const shape2Cols = shape2[shape2.length - 1];
      if (shape1Cols === shape2Cols) {
        return true;
      }
      if (isEven(shape1Cols) && isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) {
        return true;
      }
    }
    return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);
  }
  let MAX_TEXTURE_SIZE;
  let MAX_TEXTURES_IN_SHADER;
  function getWebGLMaxTextureSize(webGLVersion) {
    if (MAX_TEXTURE_SIZE == null) {
      const gl = getWebGLContext(webGLVersion);
      MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    }
    return MAX_TEXTURE_SIZE;
  }
  function resetMaxTextureSize() {
    MAX_TEXTURE_SIZE = null;
  }
  function resetMaxTexturesInShader() {
    MAX_TEXTURES_IN_SHADER = null;
  }
  function getMaxTexturesInShader(webGLVersion) {
    if (MAX_TEXTURES_IN_SHADER == null) {
      const gl = getWebGLContext(webGLVersion);
      MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    }
    return Math.min(16, MAX_TEXTURES_IN_SHADER);
  }
  function getWebGLDisjointQueryTimerVersion(webGLVersion) {
    if (webGLVersion === 0) {
      return 0;
    }
    let queryTimerVersion;
    const gl = getWebGLContext(webGLVersion);
    if (hasExtension(gl, "EXT_disjoint_timer_query_webgl2") && webGLVersion === 2) {
      queryTimerVersion = 2;
    } else if (hasExtension(gl, "EXT_disjoint_timer_query")) {
      queryTimerVersion = 1;
    } else {
      queryTimerVersion = 0;
    }
    return queryTimerVersion;
  }
  function hasExtension(gl, extensionName) {
    const ext = gl.getExtension(extensionName);
    return ext != null;
  }
  function isWebGLVersionEnabled(webGLVersion) {
    try {
      const gl = getWebGLContext(webGLVersion);
      if (gl != null) {
        return true;
      }
    } catch (e) {
      console.log("Error when getting WebGL context: ", e);
      return false;
    }
    return false;
  }
  function isCapableOfRenderingToFloatTexture(webGLVersion) {
    if (webGLVersion === 0) {
      return false;
    }
    const gl = getWebGLContext(webGLVersion);
    if (webGLVersion === 1) {
      if (!hasExtension(gl, "OES_texture_float")) {
        return false;
      }
    } else {
      if (!hasExtension(gl, "EXT_color_buffer_float")) {
        return false;
      }
    }
    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
    return isFrameBufferComplete;
  }
  function isDownloadFloatTextureEnabled(webGLVersion) {
    if (webGLVersion === 0) {
      return false;
    }
    const gl = getWebGLContext(webGLVersion);
    if (webGLVersion === 1) {
      if (!hasExtension(gl, "OES_texture_float")) {
        return false;
      }
      if (!hasExtension(gl, "WEBGL_color_buffer_float")) {
        return false;
      }
    } else {
      if (hasExtension(gl, "EXT_color_buffer_float")) {
        return createFloatTextureAndBindToFramebuffer(gl);
      }
      const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
      if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {
        const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
        return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);
      }
      return false;
    }
    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
    return isFrameBufferComplete;
  }
  function createFloatTextureAndBindToFramebuffer(gl) {
    const texConfig = getTextureConfig(gl);
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const width = 1;
    const height = 1;
    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);
    const frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(frameBuffer);
    return isFrameBufferComplete;
  }
  function createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension) {
    const texConfig = getTextureConfig(gl, textureHalfFloatExtension);
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const width = 1;
    const height = 1;
    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);
    const frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(frameBuffer);
    return isFrameBufferComplete;
  }
  function isWebGLFenceEnabled(webGLVersion) {
    if (webGLVersion !== 2) {
      return false;
    }
    const gl = getWebGLContext(webGLVersion);
    const isEnabled = gl.fenceSync != null;
    return isEnabled;
  }
  function assertNotComplex(tensor2, opName) {
    if (!Array.isArray(tensor2)) {
      tensor2 = [tensor2];
    }
    tensor2.forEach((t) => {
      if (t != null) {
        assert(t.dtype !== "complex64", () => `${opName} does not support complex64 tensors in the WebGL backend.`);
      }
    });
  }
  const webgl_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    assertNotComplex,
    bindCanvasToFramebuffer,
    bindColorTextureToFramebuffer,
    bindTextureToProgramUniformSampler,
    bindTextureUnit,
    bindVertexBufferToProgramAttribute,
    callAndCheck,
    canBeRepresented,
    createFragmentShader,
    createFramebuffer,
    createProgram,
    createStaticIndexBuffer,
    createStaticVertexBuffer,
    createTexture,
    createVertexShader: createVertexShader$1,
    getBatchDim,
    getExtensionOrThrow,
    getFramebufferErrorMessage,
    getMaxTexturesInShader,
    getNumChannels,
    getProgramUniformLocation,
    getProgramUniformLocationOrThrow,
    getRowsCols,
    getShapeAs3D,
    getTextureShapeFromLogicalShape,
    getWebGLDisjointQueryTimerVersion,
    getWebGLErrorMessage,
    getWebGLMaxTextureSize,
    hasExtension,
    isCapableOfRenderingToFloatTexture,
    isDownloadFloatTextureEnabled,
    isReshapeFree,
    isWebGLFenceEnabled,
    isWebGLVersionEnabled,
    linkProgram,
    logShaderSourceAndInfoLog,
    resetMaxTextureSize,
    resetMaxTexturesInShader,
    unbindColorTextureFromFramebuffer,
    unbindTextureUnit,
    validateFramebuffer,
    validateProgram,
    validateTextureSize
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ENV$1 = env();
  ENV$1.registerFlag("HAS_WEBGL", () => ENV$1.getNumber("WEBGL_VERSION") > 0);
  ENV$1.registerFlag("WEBGL_VERSION", () => {
    if (isWebGLVersionEnabled(2)) {
      return 2;
    } else if (isWebGLVersionEnabled(1)) {
      return 1;
    }
    return 0;
  });
  ENV$1.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false);
  ENV$1.registerFlag("WEBGL_BUFFER_SUPPORTED", () => ENV$1.get("WEBGL_VERSION") === 2);
  ENV$1.registerFlag("WEBGL_CPU_FORWARD", () => true);
  ENV$1.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false);
  ENV$1.registerFlag("WEBGL_PACK", () => ENV$1.getBool("HAS_WEBGL"));
  ENV$1.registerFlag("WEBGL_PACK_NORMALIZATION", () => ENV$1.getBool("WEBGL_PACK"));
  ENV$1.registerFlag("WEBGL_PACK_CLIP", () => ENV$1.getBool("WEBGL_PACK"));
  ENV$1.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => ENV$1.getBool("WEBGL_PACK"));
  ENV$1.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => ENV$1.getBool("WEBGL_PACK"));
  ENV$1.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => ENV$1.getBool("WEBGL_PACK"));
  ENV$1.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => ENV$1.getBool("WEBGL_PACK"));
  ENV$1.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => ENV$1.getBool("WEBGL_PACK"));
  ENV$1.registerFlag("WEBGL_PACK_REDUCE", () => ENV$1.getBool("WEBGL_PACK"));
  ENV$1.registerFlag("WEBGL_LAZILY_UNPACK", () => ENV$1.getBool("WEBGL_PACK"));
  ENV$1.registerFlag("WEBGL_CONV_IM2COL", () => ENV$1.getBool("WEBGL_PACK"));
  ENV$1.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE", () => ENV$1.getBool("WEBGL_PACK"));
  ENV$1.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => getWebGLMaxTextureSize(ENV$1.getNumber("WEBGL_VERSION")));
  ENV$1.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => getMaxTexturesInShader(ENV$1.getNumber("WEBGL_VERSION")));
  ENV$1.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
    const webGLVersion = ENV$1.getNumber("WEBGL_VERSION");
    if (webGLVersion === 0) {
      return 0;
    }
    return getWebGLDisjointQueryTimerVersion(webGLVersion);
  });
  ENV$1.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => ENV$1.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !isMobile());
  ENV$1.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => isCapableOfRenderingToFloatTexture(ENV$1.getNumber("WEBGL_VERSION")));
  ENV$1.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => {
    return ENV$1.getBool("WEBGL_FORCE_F16_TEXTURES") ? false : ENV$1.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
  });
  ENV$1.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => isDownloadFloatTextureEnabled(ENV$1.getNumber("WEBGL_VERSION")));
  ENV$1.registerFlag("WEBGL_FENCE_API_ENABLED", () => isWebGLFenceEnabled(ENV$1.getNumber("WEBGL_VERSION")));
  ENV$1.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => {
    const useUniforms = ENV$1.getBool("WEBGL_RENDER_FLOAT32_ENABLED");
    return useUniforms ? 4 : 0;
  });
  ENV$1.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => {
    return -1;
  }, (threshold2) => {
    if (!(typeof threshold2 === "number")) {
      throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${threshold2}.`);
    }
    if (threshold2 < 0 && threshold2 !== -1) {
      throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${threshold2}.`);
    }
  });
  ENV$1.registerFlag("WEBGL_FLUSH_THRESHOLD", () => {
    return isMobile() ? 1 : -1;
  }, (threshold2) => {
    if (!(typeof threshold2 === "number")) {
      throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${threshold2}.`);
    }
    if (threshold2 < 0 && threshold2 !== -1) {
      throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${threshold2}.`);
    }
  });
  ENV$1.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128);
  ENV$1.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => false);
  ENV$1.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5);
  ENV$1.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);
  ENV$1.registerFlag("WEBGL_EXP_CONV", () => false);
  ENV$1.registerFlag("SOFTWARE_WEBGL_ENABLED", () => ENV$1.getBool("IS_TEST"));
  ENV$1.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", () => Infinity);
  ENV$1.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", () => false);
  ENV$1.registerFlag("WEBGL2_ISNAN_CUSTOM", () => false);
  ENV$1.registerFlag("ENGINE_COMPILE_ONLY", () => false);
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getGlslDifferences() {
    let version2;
    let attribute;
    let varyingVs;
    let varyingFs;
    let texture2D;
    let output;
    let defineOutput;
    let defineSpecialNaN;
    let defineSpecialInf;
    let defineRound;
    if (env().getNumber("WEBGL_VERSION") === 2) {
      version2 = "#version 300 es";
      attribute = "in";
      varyingVs = "out";
      varyingFs = "in";
      texture2D = "texture";
      output = "outputColor";
      defineOutput = "out vec4 outputColor;";
      defineSpecialNaN = env().getBool("WEBGL2_ISNAN_CUSTOM") ? `
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    ` : "";
      defineSpecialInf = ``;
      defineRound = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
    } else {
      version2 = "";
      attribute = "attribute";
      varyingVs = "varying";
      varyingFs = "varying";
      texture2D = "texture2D";
      output = "gl_FragColor";
      defineOutput = "";
      defineSpecialNaN = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `;
      defineSpecialInf = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `;
      defineRound = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
    }
    return {
      version: version2,
      attribute,
      varyingVs,
      varyingFs,
      texture2D,
      output,
      defineOutput,
      defineSpecialNaN,
      defineSpecialInf,
      defineRound
    };
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getLogicalCoordinatesFromFlatIndex(coords2, shape, index2 = "index") {
    const strides = computeStrides(shape);
    return strides.map((stride, i) => {
      const line1 = `int ${coords2[i]} = ${index2} / ${stride}`;
      const line2 = i === strides.length - 1 ? `int ${coords2[i + 1]} = ${index2} - ${coords2[i]} * ${stride}` : `index -= ${coords2[i]} * ${stride}`;
      return `${line1}; ${line2};`;
    }).join("");
  }
  function getOutputLogicalCoordinatesFromFlatIndexByUniform(coords2, shape, index2 = "index") {
    const strides = computeStrides(shape);
    return strides.map((_, i) => {
      const line1 = `int ${coords2[i]} = ${index2} / outShapeStrides[${i}]`;
      const line2 = i === strides.length - 1 ? `int ${coords2[i + 1]} = ${index2} - ${coords2[i]} * outShapeStrides[${i}]` : `index -= ${coords2[i]} * outShapeStrides[${i}]`;
      return `${line1}; ${line2};`;
    }).join("");
  }
  function symbolicallyComputeStrides(indicesArr, variableName) {
    const numCoords = indicesArr.length;
    const shape = indicesArr.map((d) => `${variableName}[${d}]`);
    const strides = new Array(numCoords - 1);
    strides[numCoords - 2] = shape[numCoords - 1];
    for (let i = numCoords - 3; i >= 0; --i) {
      strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;
    }
    return strides;
  }
  function getLogicalCoordinatesFromFlatIndexByUniform(coords2, variableName, index2 = "index") {
    const indicesArray = coords2.map((_, i) => i);
    const strides = symbolicallyComputeStrides(indicesArray, variableName);
    return strides.map((_, i) => {
      const line1 = `int ${coords2[i]} = ${index2} / ${strides[i]}`;
      const line2 = i === strides.length - 1 ? `int ${coords2[i + 1]} = ${index2} - ${coords2[i]} * ${strides[i]}` : `index -= ${coords2[i]} * ${strides[i]}`;
      return `${line1}; ${line2};`;
    }).join("");
  }
  function getFlatIndexFrom3D(shape) {
    const strides = computeStrides(shape).map((d) => d.toString());
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;
  }
`;
  }
  function getFlatIndexFrom3DOutput() {
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`;
  }
  const ENCODE_FLOAT_SNIPPET = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const { getBroadcastDims } = backend_util;
  function makeShader(inputsInfo, outputShape, program) {
    const prefixSnippets = [];
    inputsInfo.forEach((x) => {
      const size = sizeFromShape(x.shapeInfo.logicalShape);
      if (x.shapeInfo.isUniform) {
        prefixSnippets.push(`uniform float ${x.name}${size > 1 ? `[${size}]` : ""};`);
      } else {
        prefixSnippets.push(`uniform sampler2D ${x.name};`);
        prefixSnippets.push(`uniform int offset${x.name};`);
      }
      if (program.enableShapeUniforms) {
        const { uniformShape } = getUniformInfoFromShape(program.packedInputs, x.shapeInfo.logicalShape, x.shapeInfo.texShape);
        switch (uniformShape.length) {
          case 1:
            prefixSnippets.push(`uniform int ${x.name}Shape;`);
            break;
          case 2:
            prefixSnippets.push(`uniform ivec2 ${x.name}Shape;`);
            break;
          case 3:
            prefixSnippets.push(`uniform ivec3 ${x.name}Shape;`);
            break;
          case 4:
            prefixSnippets.push(`uniform ivec4 ${x.name}Shape;`);
            break;
        }
        prefixSnippets.push(`uniform ivec2 ${x.name}TexShape;`);
      }
    });
    if (program.enableShapeUniforms) {
      switch (outputShape.logicalShape.length) {
        case 1:
          prefixSnippets.push(`uniform int outShape;`);
          break;
        case 2:
          prefixSnippets.push(`uniform ivec2 outShape;`);
          prefixSnippets.push(`uniform int outShapeStrides;`);
          break;
        case 3:
          prefixSnippets.push(`uniform ivec3 outShape;`);
          prefixSnippets.push(`uniform ivec2 outShapeStrides;`);
          break;
        case 4:
          prefixSnippets.push(`uniform ivec4 outShape;`);
          prefixSnippets.push(`uniform ivec3 outShapeStrides;`);
          break;
      }
      prefixSnippets.push(`uniform ivec2 outTexShape;`);
    }
    if (program.customUniforms) {
      program.customUniforms.forEach((d) => {
        prefixSnippets.push(`uniform ${d.type} ${d.name}${d.arrayIndex ? `[${d.arrayIndex}]` : ""};`);
      });
    }
    const inputPrefixSnippet = prefixSnippets.join("\n");
    const inputSamplingSnippet = inputsInfo.map((x) => getInputSamplingSnippet(x, outputShape, program.packedInputs, program.enableShapeUniforms)).join("\n");
    const outTexShape = outputShape.texShape;
    const glsl = getGlslDifferences();
    const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);
    let outputSamplingSnippet;
    let floatTextureSetOutputSnippet;
    let shaderPrefix = getShaderPrefix(glsl);
    if (outputShape.isPacked) {
      outputSamplingSnippet = getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape, program.enableShapeUniforms);
      floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);
    } else {
      outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape, program.enableShapeUniforms);
      floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);
    }
    if (program.packedInputs) {
      shaderPrefix += SHADER_PACKED_PREFIX;
    }
    const source = [
      shaderPrefix,
      floatTextureSampleSnippet,
      floatTextureSetOutputSnippet,
      inputPrefixSnippet,
      outputSamplingSnippet,
      inputSamplingSnippet,
      program.userCode
    ].join("\n");
    return source;
  }
  function getSamplerFromInInfo(inInfo, enableShapeUniforms = false) {
    const shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
      case 0:
        return getSamplerScalar(inInfo, enableShapeUniforms);
      case 1:
        return getSampler1D(inInfo, enableShapeUniforms);
      case 2:
        return getSampler2D(inInfo, enableShapeUniforms);
      case 3:
        return getSampler3D(inInfo, enableShapeUniforms);
      case 4:
        return getSampler4D(inInfo, enableShapeUniforms);
      case 5:
        return getSampler5D(inInfo);
      case 6:
        return getSampler6D(inInfo);
      default:
        throw new Error(`${shape.length}-D input sampling is not yet supported`);
    }
  }
  function getPackedSamplerFromInInfo(inInfo, enableShapeUniforms) {
    const shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
      case 0:
        return getPackedSamplerScalar(inInfo);
      case 1:
        return getPackedSampler1D(inInfo, enableShapeUniforms);
      case 2:
        return getPackedSampler2D(inInfo, enableShapeUniforms);
      case 3:
        return getPackedSampler3D(inInfo, enableShapeUniforms);
      default:
        return getPackedSamplerND(inInfo, enableShapeUniforms);
    }
  }
  function getInputSamplingSnippet(inInfo, outShapeInfo, usesPackedTextures = false, enableShapeUniforms) {
    let res = "";
    if (usesPackedTextures) {
      res += getPackedSamplerFromInInfo(inInfo, enableShapeUniforms);
    } else {
      res += getSamplerFromInInfo(inInfo, enableShapeUniforms);
    }
    const inShape = inInfo.shapeInfo.logicalShape;
    const outShape = outShapeInfo.logicalShape;
    if (inShape.length <= outShape.length) {
      if (usesPackedTextures) {
        res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);
      } else {
        res += getSamplerAtOutputCoords(inInfo, outShapeInfo);
      }
    }
    return res;
  }
  function getPackedOutputSamplingSnippet(outShape, outTexShape, enableShapeUniforms) {
    switch (outShape.length) {
      case 0:
        return getOutputScalarCoords();
      case 1:
        return getOutputPacked1DCoords(outShape, outTexShape, enableShapeUniforms);
      case 2:
        return getOutputPacked2DCoords(outShape, outTexShape, enableShapeUniforms);
      case 3:
        return getOutputPacked3DCoords(outShape, outTexShape, enableShapeUniforms);
      default:
        return getOutputPackedNDCoords(outShape, outTexShape, enableShapeUniforms);
    }
  }
  function getOutputSamplingSnippet(outShape, outTexShape, enableShapeUniforms) {
    switch (outShape.length) {
      case 0:
        return getOutputScalarCoords();
      case 1:
        return getOutput1DCoords(outShape, outTexShape, enableShapeUniforms);
      case 2:
        return getOutput2DCoords(outShape, outTexShape, enableShapeUniforms);
      case 3:
        return getOutput3DCoords(outShape, outTexShape, enableShapeUniforms);
      case 4:
        return getOutput4DCoords(outShape, outTexShape, enableShapeUniforms);
      case 5:
        return getOutput5DCoords(outShape, outTexShape);
      case 6:
        return getOutput6DCoords(outShape, outTexShape);
      default:
        throw new Error(`${outShape.length}-D output sampling is not yet supported`);
    }
  }
  function getFloatTextureSampleSnippet(glsl) {
    return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${glsl.texture2D}(textureSampler, uv).r;
    }
  `;
  }
  function getFloatTextureSetRSnippet(glsl) {
    return `
    void setOutput(float val) {
      ${glsl.output} = vec4(val, 0, 0, 0);
    }
  `;
  }
  function getFloatTextureSetRGBASnippet(glsl) {
    return `
    void setOutput(vec4 val) {
      ${glsl.output} = val;
    }
  `;
  }
  function getShaderPrefix(glsl) {
    const SHADER_PREFIX = `${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFs} vec2 resultUV;
    ${glsl.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${glsl.defineSpecialNaN}
    ${glsl.defineSpecialInf}
    ${glsl.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${SAMPLE_1D_SNIPPET}
    ${SAMPLE_2D_SNIPPET}
    ${SAMPLE_3D_SNIPPET}
  `;
    return SHADER_PREFIX;
  }
  const SAMPLE_1D_SNIPPET = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  const SAMPLE_2D_SNIPPET = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  const SAMPLE_3D_SNIPPET = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  const SHADER_PACKED_PREFIX = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
  function getOutputScalarCoords() {
    return `
    int getOutputCoords() {
      return 0;
    }
  `;
  }
  function getOutputPacked1DCoords(shape, texShape, enableShapeUniforms) {
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    if (packedTexShape[0] === 1) {
      if (enableShapeUniforms) {
        return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `;
      }
      return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);
      }
    `;
    }
    if (packedTexShape[1] === 1) {
      if (enableShapeUniforms) {
        return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `;
      }
      return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `;
    }
    return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);
    }
  `;
  }
  function getOutput1DCoords(shape, texShape, enableShapeUniforms) {
    if (texShape[0] === 1) {
      if (enableShapeUniforms) {
        return `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `;
      }
      return `
      int getOutputCoords() {
        return int(resultUV.x * ${texShape[1]}.0);
      }
    `;
    }
    if (texShape[1] === 1) {
      if (enableShapeUniforms) {
        return `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `;
      }
      return `
      int getOutputCoords() {
        return int(resultUV.y * ${texShape[0]}.0);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `;
    }
    return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      return resTexRC.x * ${texShape[1]} + resTexRC.y;
    }
  `;
  }
  function getOutputPacked3DCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
      return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
    }
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const texelsInLogicalRow = Math.ceil(shape[2] / 2);
    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec3(b, r, c);
    }
  `;
  }
  function getOutput3DCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
      const coordsFromIndexSnippet2 = getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], shape);
      return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${coordsFromIndexSnippet2}
    return ivec3(r, c, d);
  }
`;
    }
    const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
  }
  function getOutputPackedNDCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
      return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
    }
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);
    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);
    let texelsInBatchN = texelsInBatch;
    let batches = ``;
    let coords2 = "b, r, c";
    for (let b = 2; b < shape.length - 1; b++) {
      texelsInBatchN *= shape[shape.length - b - 1];
      batches = `
      int b${b} = index / ${texelsInBatchN};
      index -= b${b} * ${texelsInBatchN};
    ` + batches;
      coords2 = `b${b}, ` + coords2;
    }
    return `
    ivec${shape.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      ${batches}

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec${shape.length}(${coords2});
    }
  `;
  }
  function getOutput4DCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
      const coordsFromIndexSnippet2 = getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d", "d2"], shape);
      return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${coordsFromIndexSnippet2}
      return ivec4(r, c, d, d2);
    }
  `;
    }
    const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2"], shape);
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec4(r, c, d, d2);
    }
  `;
  }
  function getOutput5DCoords(shape, texShape) {
    const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3"], shape);
    return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},
                             ${texShape[1]}));

      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
  }
  function getOutput6DCoords(shape, texShape) {
    const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3", "d4"], shape);
    return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
  }
  function getOutputPacked2DCoords(shape, texShape, enableShapeUniforms) {
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    if (arraysEqual(shape, texShape)) {
      if (enableShapeUniforms) {
        return `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `;
      }
      return `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      }
    `;
    }
    const texelsInLogicalRow = Math.ceil(shape[1] / 2);
    if (enableShapeUniforms) {
      return `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `;
    }
    return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;
      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec2(r, c);
    }
  `;
  }
  function getOutput2DCoords(shape, texShape, enableShapeUniforms) {
    if (arraysEqual(shape, texShape)) {
      if (enableShapeUniforms) {
        return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `;
      }
      return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));
      }
    `;
    }
    if (shape[1] === 1) {
      if (enableShapeUniforms) {
        return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
      }
      return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
    }
    if (shape[0] === 1) {
      if (enableShapeUniforms) {
        return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `;
      }
      return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `;
    }
    return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      int r = index / ${shape[1]};
      int c = index - r * ${shape[1]};
      return ivec2(r, c);
    }
  `;
  }
  function getFlatOffsetUniformName(texName) {
    return `offset${texName}`;
  }
  function getPackedSamplerScalar(inputInfo) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const glsl = getGlslDifferences();
    return `
    vec4 ${funcName}() {
      return ${glsl.texture2D}(${texName}, halfCR);
    }
  `;
  }
  function getSamplerScalar(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    if (inputInfo.shapeInfo.isUniform) {
      return `float ${funcName}() {return ${texName};}`;
    }
    const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;
    if (texNumR === 1 && texNumC === 1) {
      return `
      float ${funcName}() {
        return sampleTexture(${texName}, halfCR);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    if (enableShapeUniforms) {
      return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;
    return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getPackedSampler1D(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const glsl = getGlslDifferences();
    if (enableShapeUniforms) {
      return `
    vec4 ${funcName}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    return `
    vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
        ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  function getSampler1D(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int index) {
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const texShape = inputInfo.shapeInfo.texShape;
    const tNumR = texShape[0];
    const tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
      return `
      float ${funcName}(int index) {
        return sampleTexture(${texName}, halfCR);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    if (tNumC === 1) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / float(${texName}TexShape[0]));
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (tNumR === 1) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / float(${texName}TexShape[1]), 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getPackedSampler2D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const glsl = getGlslDifferences();
    if (texShape != null && arraysEqual(shape, texShape)) {
      if (enableShapeUniforms) {
        return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
      }
      return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    vec4 ${funcName}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${texName}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const valuesPerRow = Math.ceil(shape[1] / 2);
    return `
    vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${packedTexShape[1]}, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  function getSampler2D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    if (texShape != null && arraysEqual(shape, texShape)) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      const texNumR2 = texShape[0];
      const texNumC2 = texShape[1];
      return `
    float ${funcName}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC2}.0, ${texNumR2}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    const { newShape, keptDims } = squeezeShape(shape);
    const squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
      const params = ["row", "col"];
      return `
      ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
      float ${funcName}(int row, int col) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const offset = getFlatOffsetUniformName(texName);
    if (texNumC === 1) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${texName}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${texName}TexShape[0]));
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    if (texNumR === 1) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${texName}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${texName}TexShape[1]), 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${texName}Shape[1] + col + ${offset};
        vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
  float ${funcName}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${shape[1]} + col + ${offset};
    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
    return sampleTexture(${texName}, uv);
  }
`;
  }
  function getPackedSampler3D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    if (shape[0] === 1) {
      const squeezedShape = shape.slice(1);
      const keptDims = [1, 2];
      const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
      const params = ["b", "row", "col"];
      return `
        ${getPackedSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
        vec4 ${funcName}(int b, int row, int col) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
    }
    const glsl = getGlslDifferences();
    if (enableShapeUniforms) {
      return `
    vec4 ${funcName}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${texName}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${texName}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    const texNumR = packedTexShape[0];
    const texNumC = packedTexShape[1];
    const valuesPerRow = Math.ceil(shape[2] / 2);
    const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);
    return `
    vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  function getSampler3D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride0 = shape[1] * shape[2];
    const stride1 = shape[2];
    const { newShape, keptDims } = squeezeShape(shape);
    const squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
      const params = ["row", "col", "depth"];
      return `
        ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
        float ${funcName}(int row, int col, int depth) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
    }
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${stride0}, ${stride1}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    if (texNumC === stride0 && flatOffset == null) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col, int depth) {
        int stride1 = ${texName}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
        float ${funcName}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
    }
    if (texNumC === stride1 && flatOffset == null) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${texName}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
    float ${funcName}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    const offset = getFlatOffsetUniformName(texName);
    if (enableShapeUniforms) {
      return `
    float ${funcName}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${texName}Shape[1] * ${texName}Shape[2];
      int stride1 = ${texName}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${offset};
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index);
      return sampleTexture(${texName}, uv);
    }
    `;
    }
    return `
      float ${funcName}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};
        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
        return sampleTexture(${texName}, uv);
      }
  `;
  }
  function getPackedSamplerND(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const glsl = getGlslDifferences();
    if (enableShapeUniforms) {
      return `
    vec4 ${funcName}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${texName}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${texName}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${texName}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    const shape = inputInfo.shapeInfo.logicalShape;
    const rank = shape.length;
    const texShape = inputInfo.shapeInfo.texShape;
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const texNumR = packedTexShape[0];
    const texNumC = packedTexShape[1];
    const valuesPerRow = Math.ceil(shape[rank - 1] / 2);
    let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);
    let params = `int b, int row, int col`;
    let index2 = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
    for (let b = 2; b < rank - 1; b++) {
      params = `int b${b}, ` + params;
      texelsInBatch *= shape[rank - b - 1];
      index2 = `b${b} * ${texelsInBatch} + ` + index2;
    }
    return `
    vec4 ${funcName}(${params}) {
      int index = ${index2};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  function getSampler4D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride2 = shape[3];
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    const { newShape, keptDims } = squeezeShape(shape);
    if (newShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, newShape);
      const params = ["row", "col", "depth", "depth2"];
      return `
      ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
      float ${funcName}(int row, int col, int depth, int depth2) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const stride2Str = `int stride2 = ${texName}Shape[3];`;
    const stride1Str = `int stride1 = ${texName}Shape[2] * stride2;`;
    const stride0Str = `int stride0 = ${texName}Shape[1] * stride1;`;
    if (texNumC === stride0 && flatOffset == null) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        ${stride2Str}
        ${stride1Str}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${stride1}, ${stride2}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (texNumC === stride2 && flatOffset == null) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${texName}Shape[1] * ${texName}Shape[2], ${texName}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    if (enableShapeUniforms) {
      return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${stride2Str}
      ${stride1Str}
      ${stride0Str}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} +
          depth * ${stride2} + depth2;
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getSampler5D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride3 = shape[4];
    const stride2 = shape[3] * stride3;
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    const { newShape, keptDims } = squeezeShape(shape);
    if (newShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, newShape);
      const params = ["row", "col", "depth", "depth2", "depth3"];
      return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          depth3;
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    if (texNumC === stride0 && flatOffset == null) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${stride1}, ${stride2}, ${stride3}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (texNumC === stride3 && flatOffset == null) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3]},
               ${shape[2] * shape[3]}, ${shape[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    return `
    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getSampler6D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const { newShape, keptDims } = squeezeShape(shape);
    if (newShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, newShape);
      const params = ["row", "col", "depth", "depth2", "depth3", "depth4"];
      return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    const stride4 = shape[5];
    const stride3 = shape[4] * stride4;
    const stride2 = shape[3] * stride3;
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          dot(
            vec2(depth3, depth4),
            vec2(${stride4}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    if (texNumC === stride0 && flatOffset == null) {
      return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (texNumC === stride4 && flatOffset == null) {
      return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},
               ${shape[2] * shape[3] * shape[4]},
               ${shape[3] * shape[4]},
               ${shape[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    return `
    float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getUniformSampler(inputInfo) {
    const texName = inputInfo.name;
    const inSize = sizeFromShape(inputInfo.shapeInfo.logicalShape);
    if (inSize < 2) {
      return `return ${texName};`;
    }
    return `
    for (int i = 0; i < ${inSize}; i++) {
      if (i == index) {
        return ${texName}[i];
      }
    }
  `;
  }
  function getPackedSamplerAtOutputCoords(inputInfo, outShapeInfo) {
    const texName = inputInfo.name;
    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    const funcName = "get" + texFuncSnippet + "AtOutCoords";
    const inRank = inputInfo.shapeInfo.logicalShape.length;
    const outRank = outShapeInfo.logicalShape.length;
    const broadcastDims = getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    const type = getCoordsDataType(outRank);
    const rankDiff = outRank - inRank;
    let coordsSnippet;
    const fields = ["x", "y", "z", "w", "u", "v"];
    if (inRank === 0) {
      coordsSnippet = "";
    } else if (outRank < 2 && broadcastDims.length >= 1) {
      coordsSnippet = "coords = 0;";
    } else {
      coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
    }
    let unpackedCoordsSnippet = "";
    if (outRank < 2 && inRank > 0) {
      unpackedCoordsSnippet = "coords";
    } else {
      unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
    }
    let output = `return outputValue;`;
    const inSize = sizeFromShape(inputInfo.shapeInfo.logicalShape);
    const isInputScalar = inSize === 1;
    const outSize = sizeFromShape(outShapeInfo.logicalShape);
    const isOutputScalar = outSize === 1;
    if (inRank === 1 && !isInputScalar && !isOutputScalar) {
      output = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
    } else if (isInputScalar && !isOutputScalar) {
      if (outRank === 1) {
        output = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `;
      } else {
        output = `
        return vec4(outputValue.x);
      `;
      }
    } else if (broadcastDims.length) {
      const rows = inRank - 2;
      const cols = inRank - 1;
      if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
        output = `return vec4(outputValue.x);`;
      } else if (broadcastDims.indexOf(rows) > -1) {
        output = `return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);`;
      } else if (broadcastDims.indexOf(cols) > -1) {
        output = `return vec4(outputValue.xx, outputValue.zz);`;
      }
    }
    return `
    vec4 ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});
      ${output}
    }
  `;
  }
  function getSamplerAtOutputCoords(inputInfo, outShapeInfo) {
    const texName = inputInfo.name;
    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    const funcName = "get" + texFuncSnippet + "AtOutCoords";
    const outTexShape = outShapeInfo.texShape;
    const inTexShape = inputInfo.shapeInfo.texShape;
    const inRank = inputInfo.shapeInfo.logicalShape.length;
    const outRank = outShapeInfo.logicalShape.length;
    if (!inputInfo.shapeInfo.isUniform && inRank === outRank && inputInfo.shapeInfo.flatOffset == null && arraysEqual(inTexShape, outTexShape)) {
      return `
      float ${funcName}() {
        return sampleTexture(${texName}, resultUV);
      }
    `;
    }
    const type = getCoordsDataType(outRank);
    const broadcastDims = getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    const rankDiff = outRank - inRank;
    let coordsSnippet;
    const fields = ["x", "y", "z", "w", "u", "v"];
    if (inRank === 0) {
      coordsSnippet = "";
    } else if (outRank < 2 && broadcastDims.length >= 1) {
      coordsSnippet = "coords = 0;";
    } else {
      coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
    }
    let unpackedCoordsSnippet = "";
    if (outRank < 2 && inRank > 0) {
      unpackedCoordsSnippet = "coords";
    } else {
      unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
    }
    return `
    float ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      return get${texFuncSnippet}(${unpackedCoordsSnippet});
    }
  `;
  }
  function getCoordsDataType(rank) {
    if (rank <= 1) {
      return "int";
    } else if (rank === 2) {
      return "ivec2";
    } else if (rank === 3) {
      return "ivec3";
    } else if (rank === 4) {
      return "ivec4";
    } else if (rank === 5) {
      return "ivec5";
    } else if (rank === 6) {
      return "ivec6";
    } else {
      throw Error(`GPU for rank ${rank} is not yet supported`);
    }
  }
  function getUniformInfoFromShape(isPacked, shape, texShape) {
    const { newShape, keptDims } = squeezeShape(shape);
    const rank = shape.length;
    const useSqueezePackedShape = isPacked && rank === 3 && shape[0] === 1;
    const squeezeShape$1 = useSqueezePackedShape ? shape.slice(1) : newShape;
    const useSqueezeShape = !isPacked && rank > 1 && !arraysEqual(shape, texShape) && newShape.length < rank || useSqueezePackedShape;
    const uniformShape = useSqueezeShape ? squeezeShape$1 : shape;
    return { useSqueezeShape, uniformShape, keptDims };
  }
  function squeezeInputInfo(inInfo, squeezedShape) {
    const newInputInfo = JSON.parse(JSON.stringify(inInfo));
    newInputInfo.shapeInfo.logicalShape = squeezedShape;
    return newInputInfo;
  }
  function getSqueezedParams(params, keptDims) {
    return keptDims.map((d) => params[d]).join(", ");
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function compileProgram(gpgpu, program, inputs, output) {
    const inputInfos = inputs.map((input, i) => {
      const shapeInfo = {
        logicalShape: input.shape,
        texShape: input.isUniform ? null : input.texData.texShape,
        isUniform: input.isUniform,
        isPacked: input.isUniform ? false : input.texData.isPacked,
        flatOffset: null
      };
      if (input.texData != null && input.texData.slice != null && input.texData.slice.flatOffset > 0) {
        shapeInfo.flatOffset = input.texData.slice.flatOffset;
      }
      return { name: program.variableNames[i], shapeInfo };
    });
    const inShapeInfos = inputInfos.map((x) => x.shapeInfo);
    const outShapeInfo = {
      logicalShape: output.shape,
      texShape: output.texData.texShape,
      isUniform: false,
      isPacked: output.texData.isPacked,
      flatOffset: null
    };
    const source = makeShader(inputInfos, outShapeInfo, program);
    const fragmentShader = createFragmentShader(gpgpu.gl, source);
    const webGLProgram = gpgpu.createProgram(fragmentShader);
    if (!env().get("ENGINE_COMPILE_ONLY")) {
      gpgpu.buildVao(webGLProgram);
      return Object.assign({
        program,
        fragmentShader,
        source,
        webGLProgram,
        inShapeInfos,
        outShapeInfo
      }, getUniformLocations(gpgpu, program, webGLProgram));
    } else {
      return {
        program,
        fragmentShader,
        source,
        webGLProgram,
        inShapeInfos,
        outShapeInfo,
        variablesLocations: null,
        customUniformLocations: null,
        infLoc: null,
        nanLoc: null,
        outShapeLocation: null,
        outShapeStridesLocation: null,
        outTexShapeLocation: null
      };
    }
  }
  function getUniformLocations(gpgpu, program, webGLProgram) {
    const variablesLocations = [];
    const customUniformLocations = [];
    let outShapeLocation;
    let outTexShapeLocation;
    let outShapeStridesLocation;
    let infLoc = null;
    let nanLoc = null;
    nanLoc = gpgpu.getUniformLocation(webGLProgram, "NAN", false);
    if (env().getNumber("WEBGL_VERSION") === 1) {
      infLoc = gpgpu.getUniformLocation(webGLProgram, "INFINITY", false);
    }
    const shouldThrow = false;
    for (const varName of program.variableNames) {
      const varLocs = {
        name: varName,
        uniform: gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow),
        offset: gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow)
      };
      if (program.enableShapeUniforms) {
        varLocs.shape = gpgpu.getUniformLocation(webGLProgram, `${varName}Shape`, shouldThrow);
        varLocs.texShape = gpgpu.getUniformLocation(webGLProgram, `${varName}TexShape`, shouldThrow);
      }
      variablesLocations.push(varLocs);
    }
    if (program.enableShapeUniforms) {
      outShapeLocation = gpgpu.getUniformLocation(webGLProgram, "outShape", shouldThrow);
      outShapeStridesLocation = gpgpu.getUniformLocation(webGLProgram, "outShapeStrides", shouldThrow);
      outTexShapeLocation = gpgpu.getUniformLocation(webGLProgram, "outTexShape", shouldThrow);
    }
    if (program.customUniforms) {
      for (const d of program.customUniforms) {
        customUniformLocations.push(gpgpu.getUniformLocation(webGLProgram, d.name, shouldThrow));
      }
    }
    return {
      variablesLocations,
      customUniformLocations,
      infLoc,
      nanLoc,
      outShapeLocation,
      outShapeStridesLocation,
      outTexShapeLocation
    };
  }
  function validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) {
      throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but was executed with ${inputs.length} inputs`);
    }
    shapeInfos.forEach((s, i) => {
      const shapeA = s.logicalShape;
      const input = inputs[i];
      const shapeB = input.shape;
      if (!arraysEqual(shapeA, shapeB)) {
        throw Error(`Binary was compiled with different shapes than the current args. Shapes ${shapeA} and ${shapeB} must match`);
      }
      if (s.isUniform && input.isUniform) {
        return;
      }
      const texShapeA = s.texShape;
      const texShapeB = input.isUniform ? null : input.texData.texShape;
      if (!arraysEqual(texShapeA, texShapeB)) {
        throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${texShapeA} and ${texShapeB} must match`);
      }
    });
  }
  function runProgram(gpgpu, binary, inputs, output, customUniformValues) {
    if (!binary.program.enableShapeUniforms) {
      validateBinaryAndProgram(binary.inShapeInfos, inputs);
      validateBinaryAndProgram([binary.outShapeInfo], [output]);
    }
    const outTex = output.texData.texture;
    const outTexShape = output.texData.texShape;
    if (output.texData.isPacked) {
      gpgpu.setOutputPackedMatrixTexture(outTex.texture, outTexShape[0], outTexShape[1]);
    } else {
      gpgpu.setOutputMatrixTexture(outTex.texture, outTexShape[0], outTexShape[1]);
    }
    gpgpu.setProgram(binary.webGLProgram);
    gpgpu.bindVertexArray(binary.webGLProgram.vao);
    if (env().getNumber("WEBGL_VERSION") === 1) {
      if (binary.infLoc !== null) {
        gpgpu.gl.uniform1f(binary.infLoc, Infinity);
      }
    }
    if (binary.nanLoc !== null) {
      gpgpu.gl.uniform1f(binary.nanLoc, NaN);
    }
    for (let i = 0; i < inputs.length; ++i) {
      const input = inputs[i];
      const { uniform: varLoc, offset: varOffsetLoc, shape: varShapeLoc, texShape: varTexShapeLoc } = binary.variablesLocations[i];
      if (varShapeLoc) {
        const { uniformShape } = getUniformInfoFromShape(binary.program.packedInputs, input.shape, input.texData.texShape);
        switch (uniformShape.length) {
          case 1:
            gpgpu.gl.uniform1iv(varShapeLoc, new Int32Array(uniformShape));
            break;
          case 2:
            gpgpu.gl.uniform2iv(varShapeLoc, new Int32Array(uniformShape));
            break;
          case 3:
            gpgpu.gl.uniform3iv(varShapeLoc, new Int32Array(uniformShape));
            break;
          case 4:
            gpgpu.gl.uniform4iv(varShapeLoc, new Int32Array(uniformShape));
            break;
        }
      }
      if (varTexShapeLoc) {
        gpgpu.gl.uniform2i(varTexShapeLoc, input.texData.texShape[0], input.texData.texShape[1]);
      }
      if (varLoc == null) {
        continue;
      }
      if (input.isUniform) {
        if (sizeFromShape(input.shape) < 2) {
          gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);
        } else {
          let vals = input.uniformValues;
          if (!(vals instanceof Float32Array)) {
            vals = new Float32Array(vals);
          }
          gpgpu.gl.uniform1fv(varLoc, vals);
        }
        continue;
      }
      if (input.texData.slice != null && varOffsetLoc != null) {
        gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);
      }
      gpgpu.setInputMatrixTexture(input.texData.texture.texture, varLoc, i);
    }
    const outShapeLoc = binary.outShapeLocation;
    if (outShapeLoc) {
      switch (output.shape.length) {
        case 1:
          gpgpu.gl.uniform1iv(outShapeLoc, new Int32Array(output.shape));
          break;
        case 2:
          gpgpu.gl.uniform2iv(outShapeLoc, new Int32Array(output.shape));
          break;
        case 3:
          gpgpu.gl.uniform3iv(outShapeLoc, new Int32Array(output.shape));
          break;
        case 4:
          gpgpu.gl.uniform4iv(outShapeLoc, new Int32Array(output.shape));
          break;
      }
    }
    if (binary.outShapeStridesLocation) {
      const strides = computeStrides(output.shape);
      switch (output.shape.length) {
        case 2:
          gpgpu.gl.uniform1iv(binary.outShapeStridesLocation, new Int32Array(strides));
          break;
        case 3:
          gpgpu.gl.uniform2iv(binary.outShapeStridesLocation, new Int32Array(strides));
          break;
        case 4:
          gpgpu.gl.uniform3iv(binary.outShapeStridesLocation, new Int32Array(strides));
          break;
      }
    }
    if (binary.outTexShapeLocation) {
      gpgpu.gl.uniform2i(binary.outTexShapeLocation, output.texData.texShape[0], output.texData.texShape[1]);
    }
    if (binary.program.customUniforms && customUniformValues) {
      for (let i = 0; i < binary.program.customUniforms.length; ++i) {
        const d = binary.program.customUniforms[i];
        const customLoc = binary.customUniformLocations[i];
        const customValue = customUniformValues[i];
        if (d.type === "float") {
          gpgpu.gl.uniform1fv(customLoc, customValue);
        } else if (d.type === "vec2") {
          gpgpu.gl.uniform2fv(customLoc, customValue);
        } else if (d.type === "vec3") {
          gpgpu.gl.uniform3fv(customLoc, customValue);
        } else if (d.type === "vec4") {
          gpgpu.gl.uniform4fv(customLoc, customValue);
        } else if (d.type === "int") {
          gpgpu.gl.uniform1iv(customLoc, customValue);
        } else if (d.type === "ivec2") {
          gpgpu.gl.uniform2iv(customLoc, customValue);
        } else if (d.type === "ivec3") {
          gpgpu.gl.uniform3iv(customLoc, customValue);
        } else if (d.type === "ivec4") {
          gpgpu.gl.uniform4iv(customLoc, customValue);
        } else {
          throw Error(`uniform type ${d.type} is not supported yet.`);
        }
      }
    }
    gpgpu.executeProgram();
  }
  function makeShaderKey(program, inputs, output) {
    let keyInputs = "";
    inputs.concat(output).forEach((x) => {
      const hasOffset = x.texData != null && x.texData.slice != null && x.texData.slice.flatOffset > 0;
      if (program.enableShapeUniforms && !x.isUniform) {
        const xTexShape = x.texData.texShape;
        const { useSqueezeShape, uniformShape, keptDims } = getUniformInfoFromShape(program.packedInputs, x.shape, xTexShape);
        let rank1 = "", rank2 = "", rank34 = "";
        if (uniformShape.length === 1 && program.packedInputs) {
          const packedTexShape = [Math.ceil(xTexShape[0] / 2), Math.ceil(xTexShape[1] / 2)];
          rank1 = `${packedTexShape[0] > 1}_${packedTexShape[1] > 1}`;
        } else if (uniformShape.length === 2 && !program.packedInputs) {
          rank2 = `${uniformShape[0] > 1}_${uniformShape[1] > 1}`;
        } else if (uniformShape.length > 2 && !program.packedInputs) {
          const strides = computeStrides(uniformShape);
          rank34 = `${strides[0] === xTexShape[1]}_${strides[strides.length - 1] === xTexShape[1]}`;
        }
        const xRank = x.shape.length;
        const isLogicalShapTexShapeEqual = uniformShape.length === 2 && arraysEqual(x.shape, xTexShape);
        const isScalar = sizeFromShape(x.shape) === 1;
        const broadcastDims = getBroadcastDims$1(x.shape, output.shape);
        const isInOutTexShapeEqual = !program.packedInputs && xRank === output.shape.length && arraysEqual(xTexShape, output.texData.texShape);
        const isTexShapeGreaterThanOne = program.packedInputs || uniformShape.length > 2 ? "" : `${xTexShape[0] > 1}_${xTexShape[1] > 1}`;
        keyInputs += `${xRank}_${isInOutTexShapeEqual}_${useSqueezeShape ? keptDims : ""}_${uniformShape.length}_${isScalar}_${broadcastDims}_${isLogicalShapTexShapeEqual}_${rank1}_${rank2}_${rank34}_${isTexShapeGreaterThanOne}_${hasOffset}`;
      } else {
        const texShape = x.isUniform ? "uniform" : x.texData.texShape;
        keyInputs += `${x.shape}_${texShape}_${hasOffset}`;
      }
    });
    const keyUserCode = program.userCode;
    let key = program.constructor.name;
    key += "_" + keyInputs + "_" + keyUserCode + `${env().getNumber("WEBGL_VERSION")}`;
    return key;
  }
  function useShapeUniforms(rank) {
    return env().getBool("WEBGL_USE_SHAPES_UNIFORMS") && rank <= 4;
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class DecodeMatrixProgram {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = false;
      this.packedOutput = true;
      this.outPackingScheme = PackingScheme.DENSE;
      this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], outputShape) : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${glsl.output} = result;
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class DecodeMatrixPackedProgram {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outPackingScheme = PackingScheme.DENSE;
      this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], outputShape) : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${glsl.output} = result;
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class EncodeFloatProgram {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.outTexUsage = TextureUsage.DOWNLOAD;
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.userCode = `
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        float x = getAAtOutCoords();
        ${glsl.output} = encode_float(x);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class EncodeFloatPackedProgram {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = false;
      this.outTexUsage = TextureUsage.DOWNLOAD;
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.userCode = `
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${glsl.output} = encode_float(x);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const CHANNEL_CHAR_TO_INDEX_MAP = {
    "R": 0,
    "G": 1,
    "B": 2,
    "A": 3
  };
  class EncodeMatrixProgram {
    constructor(outputShape, inputIsUnsignedByte = false, usedChannels = "RGBA") {
      this.variableNames = ["A"];
      this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      let output = `result`;
      if (inputIsUnsignedByte) {
        output = `floor(result * 255. + 0.5)`;
      }
      let mainLoop = "";
      for (let usedChannelIndex = 0; usedChannelIndex < usedChannels.length; usedChannelIndex++) {
        const curChannel = usedChannels[usedChannelIndex];
        mainLoop += `
          if(offset == ${usedChannelIndex}) {
            result = values[${CHANNEL_CHAR_TO_INDEX_MAP[curChannel]}];
          }`;
      }
      this.userCode = `
      ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${usedChannels.length});

        flatIndex = idiv(flatIndex, ${usedChannels.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${glsl.texture2D}(A, uv);
          ${mainLoop}
        }
        ${glsl.output} = vec4(${output}, 0., 0., 0.);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class EncodeMatrixPackedProgram {
    constructor(outputShape, inputIsUnsignedByte = false) {
      this.variableNames = ["A"];
      this.packedInputs = false;
      this.packedOutput = true;
      this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      let mainLoop = "";
      let output = "result";
      if (inputIsUnsignedByte) {
        output = "floor(result * 255. + 0.5)";
      }
      for (let row = 0; row <= 1; row++) {
        for (let col = 0; col <= 1; col++) {
          const channel = row * 2 + col;
          mainLoop += `
          localCoords = coords;
          if(localCoords[2] + ${col} < ${this.enableShapeUniforms ? "outShape[2]" : `${outputShape[2]}`}) {
          localCoords[2] += ${col};
          if (localCoords[1] + ${row} < ${this.enableShapeUniforms ? "outShape[1]" : `${outputShape[1]}`}) {
            localCoords[1] += ${row};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${glsl.texture2D}(A, uv);

            if (offset == 0) {
              result[${channel}] = values[0];
            } else if (offset == 1) {
              result[${channel}] = values[1];
            } else if (offset == 2) {
              result[${channel}] = values[2];
            } else {
              result[${channel}] = values[3];
            }
          }
        }
        `;
        }
      }
      this.userCode = `
        ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${mainLoop}

          ${glsl.output} = ${output};
        }
    `;
    }
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function createVertexShader(gl) {
    const glsl = getGlslDifferences();
    const vertexShaderSource = `${glsl.version}
    precision highp float;
    ${glsl.attribute} vec3 clipSpacePos;
    ${glsl.attribute} vec2 uv;
    ${glsl.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
    return createVertexShader$1(gl, vertexShaderSource);
  }
  function createVertexBuffer(gl) {
    const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return createStaticVertexBuffer(gl, vertexArray);
  }
  function createIndexBuffer(gl) {
    const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return createStaticIndexBuffer(gl, triangleVertexIndices);
  }
  function createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {
    validateTextureSize(width, height);
    const texture = createTexture(gl);
    const tex2d = gl.TEXTURE_2D;
    callAndCheck(gl, () => gl.bindTexture(tex2d, texture));
    callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));
    callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));
    callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));
    callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));
    if (env().getNumber("WEBGL_VERSION") === 1) {
      callAndCheck(gl, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));
    } else {
      callAndCheck(gl, () => gl.texStorage2D(tex2d, 1, internalFormat, width, height));
    }
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
    return { texture, texShape: [height, width] };
  }
  function getInternalFormatForFloat32MatrixTexture(textureConfig) {
    return textureConfig.internalFormatFloat;
  }
  function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);
  }
  function getInternalFormatForFloat16MatrixTexture(textureConfig) {
    return textureConfig.internalFormatHalfFloat;
  }
  function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);
  }
  function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {
    return textureConfig.downloadTextureFormat;
  }
  function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);
  }
  function getInternalFormatForPackedMatrixTexture(textureConfig) {
    return textureConfig.internalFormatPackedFloat;
  }
  function createPackedMatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);
  }
  function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {
    return textureConfig.internalFormatPackedHalfFloat;
  }
  function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);
  }
  function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
    const posOffset = 0;
    const uvOffset = 3 * 4;
    const stride = 3 * 4 + 2 * 4;
    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));
    const success = bindVertexBufferToProgramAttribute(gl, program, "clipSpacePos", vertexBuffer, 3, stride, posOffset);
    return success && bindVertexBufferToProgramAttribute(gl, program, "uv", vertexBuffer, 2, stride, uvOffset);
  }
  function uploadDenseMatrixToTexture(gl, texture, width, height, data, textureConfig) {
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
    let dataForUpload, texelDataType, internalFormat;
    if (data instanceof Uint8Array) {
      dataForUpload = new Uint8Array(width * height * 4);
      texelDataType = gl.UNSIGNED_BYTE;
      internalFormat = gl.RGBA;
    } else {
      dataForUpload = new Float32Array(width * height * 4);
      texelDataType = gl.FLOAT;
      internalFormat = textureConfig.internalFormatPackedFloat;
    }
    dataForUpload.set(data);
    if (env().getNumber("WEBGL_VERSION") === 2) {
      callAndCheck(gl, () => gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, texelDataType, dataForUpload));
    } else {
      callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));
    }
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
  }
  function uploadPixelDataToTexture(gl, texture, pixels) {
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
    if (pixels.data instanceof Uint8Array) {
      if (env().getNumber("WEBGL_VERSION") === 2) {
        callAndCheck(gl, () => gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, pixels.width, pixels.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));
      } else {
        callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));
      }
    } else {
      if (env().getNumber("WEBGL_VERSION") === 2) {
        callAndCheck(gl, () => gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels));
      } else {
        callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));
      }
    }
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
  }
  function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {
    const buffer2 = gl2.createBuffer();
    callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer2));
    const bytesPerFloat = 4;
    const valuesPerTexel = 4;
    const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;
    callAndCheck(gl2, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));
    callAndCheck(gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));
    callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));
    return buffer2;
  }
  function downloadFloat32MatrixFromBuffer(gl, buffer2, size) {
    const gl2 = gl;
    const downloadTarget = new Float32Array(size);
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer2);
    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
    return downloadTarget;
  }
  function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {
    const [w, h] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    const numChannels = 4;
    const downloadTarget = new Uint8Array(getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));
    callAndCheck(gl, () => gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget));
    return new Float32Array(downloadTarget.buffer);
  }
  function downloadPackedMatrixFromBuffer(gl, buffer2, batch, rows, cols, physicalRows, physicalCols, textureConfig) {
    const gl2 = gl;
    const downloadTarget = new Float32Array(getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer2);
    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
    return downloadTarget;
  }
  function downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {
    const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);
    callAndCheck(gl, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));
    return packedRGBA;
  }
  const gpgpu_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    bindVertexProgramAttributeStreams,
    createBufferFromOutputTexture,
    createFloat16MatrixTexture,
    createFloat16PackedMatrixTexture,
    createFloat32MatrixTexture,
    createIndexBuffer,
    createPackedMatrixTexture,
    createUnsignedBytesMatrixTexture,
    createVertexBuffer,
    createVertexShader,
    downloadByteEncodedFloatMatrixFromOutputTexture,
    downloadFloat32MatrixFromBuffer,
    downloadMatrixFromPackedOutputTexture,
    downloadPackedMatrixFromBuffer,
    getInternalFormatForFloat16MatrixTexture,
    getInternalFormatForFloat16PackedMatrixTexture,
    getInternalFormatForFloat32MatrixTexture,
    getInternalFormatForPackedMatrixTexture,
    getInternalFormatForUnsignedBytesMatrixTexture,
    uploadDenseMatrixToTexture,
    uploadPixelDataToTexture
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class GPGPUContext {
    constructor(gl) {
      this.outputTexture = null;
      this.program = null;
      this.disposed = false;
      this.itemsToPoll = [];
      const glVersion = env().getNumber("WEBGL_VERSION");
      if (gl != null) {
        this.gl = gl;
        setWebGLContext(glVersion, gl);
      } else {
        this.gl = getWebGLContext(glVersion);
      }
      gl = this.gl;
      if (env().getNumber("WEBGL_VERSION") === 2) {
        const gl2 = gl;
        this.createVertexArray = () => {
          return callAndCheck(gl2, () => gl2.createVertexArray());
        };
        this.bindVertexArray = (vao) => {
          return callAndCheck(gl2, () => gl2.bindVertexArray(vao));
        };
        this.deleteVertexArray = (vao) => {
          return callAndCheck(gl2, () => gl2.deleteVertexArray(vao));
        };
        this.getVertexArray = () => {
          return callAndCheck(gl2, () => gl2.getParameter(gl2.VERTEX_ARRAY_BINDING));
        };
      } else if (gl != null) {
        const ext = gl.getExtension("OES_vertex_array_object");
        if (ext == null) {
          throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
        }
        this.createVertexArray = () => {
          return callAndCheck(gl, () => ext.createVertexArrayOES());
        };
        this.bindVertexArray = (vao) => {
          return callAndCheck(gl, () => ext.bindVertexArrayOES(vao));
        };
        this.deleteVertexArray = (vao) => {
          return callAndCheck(gl, () => ext.deleteVertexArrayOES(vao));
        };
        this.getVertexArray = () => {
          return callAndCheck(gl, () => gl.getParameter(ext.VERTEX_ARRAY_BINDING_OES));
        };
      }
      let COLOR_BUFFER_FLOAT = "WEBGL_color_buffer_float";
      const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
      this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile");
      if (env().getNumber("WEBGL_VERSION") === 1) {
        const TEXTURE_FLOAT = "OES_texture_float";
        const TEXTURE_HALF_FLOAT = "OES_texture_half_float";
        this.textureFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_FLOAT);
        if (hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {
          this.textureHalfFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);
        } else if (env().get("WEBGL_FORCE_F16_TEXTURES")) {
          throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        }
        this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
        if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
          this.colorBufferHalfFloatExtension = getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);
        } else if (env().get("WEBGL_FORCE_F16_TEXTURES")) {
          throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        }
      } else {
        COLOR_BUFFER_FLOAT = "EXT_color_buffer_float";
        if (hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {
          this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
        } else if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
          this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
        } else {
          throw new Error("GL context does not support color renderable floats");
        }
      }
      this.vertexBuffer = createVertexBuffer(this.gl);
      this.indexBuffer = createIndexBuffer(this.gl);
      this.framebuffer = createFramebuffer(this.gl);
      this.textureConfig = getTextureConfig(this.gl, this.textureHalfFloatExtension);
    }
    get debug() {
      return env().getBool("DEBUG");
    }
    dispose() {
      if (this.disposed) {
        return;
      }
      if (this.program != null) {
        console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.");
      }
      if (this.outputTexture != null) {
        console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      }
      const gl = this.gl;
      callAndCheck(gl, () => gl.finish());
      callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));
      callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));
      callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));
      callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));
      callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));
      this.disposed = true;
    }
    createFloat32MatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    createFloat16MatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    createUnsignedBytesMatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    uploadPixelDataToTexture(texture, pixels) {
      this.throwIfDisposed();
      uploadPixelDataToTexture(this.gl, texture, pixels);
    }
    uploadDenseMatrixToTexture(texture, width, height, data) {
      this.throwIfDisposed();
      uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);
    }
    createFloat16PackedMatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    createPackedMatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    deleteMatrixTexture(texture) {
      this.throwIfDisposed();
      if (this.outputTexture === texture) {
        unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        this.outputTexture = null;
      }
      callAndCheck(this.gl, () => this.gl.deleteTexture(texture));
    }
    downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {
      return this.downloadMatrixDriver(texture, () => downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));
    }
    downloadPackedMatrixFromBuffer(buffer2, batch, rows, columns, physicalRows, physicalCols) {
      return downloadPackedMatrixFromBuffer(this.gl, buffer2, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);
    }
    downloadFloat32MatrixFromBuffer(buffer2, size) {
      return downloadFloat32MatrixFromBuffer(this.gl, buffer2, size);
    }
    createBufferFromTexture(texture, rows, columns) {
      this.bindTextureToFrameBuffer(texture);
      const result = createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);
      this.unbindTextureToFrameBuffer();
      return result;
    }
    createAndWaitForFence() {
      const fenceContext = this.createFence(this.gl);
      return this.pollFence(fenceContext);
    }
    createFence(gl) {
      let query;
      let isFencePassed;
      if (env().getBool("WEBGL_FENCE_API_ENABLED")) {
        const gl2 = gl;
        const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);
        gl.flush();
        isFencePassed = () => {
          const status = gl2.clientWaitSync(sync, 0, 0);
          return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;
        };
        query = sync;
      } else if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0) {
        query = this.beginQuery();
        this.endQuery();
        isFencePassed = () => this.isQueryAvailable(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
      } else {
        isFencePassed = () => true;
      }
      return { query, isFencePassed };
    }
    downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {
      return this.downloadMatrixDriver(texture, () => downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));
    }
    createProgram(fragmentShader) {
      this.throwIfDisposed();
      const gl = this.gl;
      if (this.vertexShader == null) {
        this.vertexShader = createVertexShader(gl);
      }
      const program = createProgram(gl);
      callAndCheck(gl, () => gl.attachShader(program, this.vertexShader));
      callAndCheck(gl, () => gl.attachShader(program, fragmentShader));
      linkProgram(gl, program);
      const program2 = Object.assign(program, { vao: this.createVertexArray() });
      if (this.debug) {
        validateProgram(gl, program2);
      }
      return program2;
    }
    buildVao(program) {
      this.setProgram(program);
      this.bindVertexArray(program.vao);
      const gl = this.gl;
      callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer));
      bindVertexProgramAttributeStreams(gl, program, this.vertexBuffer);
    }
    deleteProgram(program) {
      this.throwIfDisposed();
      if (program === this.program) {
        this.program = null;
      }
      if (program != null) {
        callAndCheck(this.gl, () => this.gl.deleteProgram(program));
        this.deleteVertexArray(program.vao);
      }
    }
    setProgram(program) {
      this.throwIfDisposed();
      this.program = program;
      if (this.program != null) {
        if (this.debug) {
          validateProgram(this.gl, this.program);
        }
      }
      callAndCheck(this.gl, () => this.gl.useProgram(program));
    }
    getUniformLocation(program, uniformName, shouldThrow = true) {
      this.throwIfDisposed();
      if (shouldThrow) {
        return getProgramUniformLocationOrThrow(this.gl, program, uniformName);
      } else {
        return getProgramUniformLocation(this.gl, program, uniformName);
      }
    }
    getAttributeLocation(program, attribute) {
      this.throwIfDisposed();
      return callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));
    }
    getUniformLocationNoThrow(program, uniformName) {
      this.throwIfDisposed();
      return this.gl.getUniformLocation(program, uniformName);
    }
    setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {
      this.throwIfDisposed();
      this.throwIfNoProgram();
      bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);
    }
    setOutputMatrixTexture(outputMatrixTexture, rows, columns) {
      this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    }
    setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {
      this.throwIfDisposed();
      const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
      this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    }
    setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
      this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    }
    setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
      throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
    }
    debugValidate() {
      if (this.program != null) {
        validateProgram(this.gl, this.program);
      }
      validateFramebuffer(this.gl);
    }
    executeProgram() {
      this.throwIfDisposed();
      this.throwIfNoProgram();
      const gl = this.gl;
      if (this.debug) {
        const boundVao = this.getVertexArray();
        console.assert(boundVao === this.program.vao, "VAO changed between setProgram and executeProgram!");
        this.debugValidate();
      }
      callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));
    }
    blockUntilAllProgramsCompleted() {
      this.throwIfDisposed();
      callAndCheck(this.gl, () => this.gl.finish());
    }
    getQueryTimerExtension() {
      if (this.disjointQueryTimerExtension == null) {
        this.disjointQueryTimerExtension = getExtensionOrThrow(this.gl, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query");
      }
      return this.disjointQueryTimerExtension;
    }
    getQueryTimerExtensionWebGL2() {
      return this.getQueryTimerExtension();
    }
    getQueryTimerExtensionWebGL1() {
      return this.getQueryTimerExtension();
    }
    beginQuery() {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        const gl2 = this.gl;
        const ext2 = this.getQueryTimerExtensionWebGL2();
        const query2 = gl2.createQuery();
        gl2.beginQuery(ext2.TIME_ELAPSED_EXT, query2);
        return query2;
      }
      const ext = this.getQueryTimerExtensionWebGL1();
      const query = ext.createQueryEXT();
      ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
      return query;
    }
    endQuery() {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        const gl2 = this.gl;
        const ext2 = this.getQueryTimerExtensionWebGL2();
        gl2.endQuery(ext2.TIME_ELAPSED_EXT);
        return;
      }
      const ext = this.getQueryTimerExtensionWebGL1();
      ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
    }
    async waitForQueryAndGetTime(query) {
      await repeatedTry(() => this.disposed || // while testing contexts are created / disposed
      // in rapid succession, so without this check we
      // may poll for the query timer indefinitely
      this.isQueryAvailable(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")));
      return this.getQueryTime(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    }
    getQueryTime(query, queryTimerVersion) {
      if (queryTimerVersion === 0) {
        return null;
      }
      if (queryTimerVersion === 2) {
        const gl2 = this.gl;
        const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
        return timeElapsedNanos / 1e6;
      } else {
        const ext = this.getQueryTimerExtensionWebGL1();
        const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
        return timeElapsedNanos / 1e6;
      }
    }
    isQueryAvailable(query, queryTimerVersion) {
      if (queryTimerVersion === 0) {
        return true;
      }
      if (queryTimerVersion === 2) {
        const gl2 = this.gl;
        const ext = this.getQueryTimerExtensionWebGL2();
        const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
        if (this.disjoint == null) {
          this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
        }
        return available && !this.disjoint;
      } else {
        const ext = this.getQueryTimerExtensionWebGL1();
        const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
        if (this.disjoint == null) {
          this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
        }
        return available && !this.disjoint;
      }
    }
    pollFence(fenceContext) {
      return new Promise((resolve) => {
        this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());
      });
    }
    pollItems() {
      const index2 = linearSearchLastTrue(this.itemsToPoll.map((x) => x.isDoneFn));
      for (let i = 0; i <= index2; ++i) {
        const { resolveFn } = this.itemsToPoll[i];
        resolveFn();
      }
      this.itemsToPoll = this.itemsToPoll.slice(index2 + 1);
    }
    addItemToPoll(isDoneFn, resolveFn) {
      this.itemsToPoll.push({ isDoneFn, resolveFn });
      if (this.itemsToPoll.length > 1) {
        return;
      }
      let scheduleFn = void 0;
      if ("setTimeoutCustom" in env().platform) {
        scheduleFn = env().platform.setTimeoutCustom.bind(env().platform);
      }
      repeatedTry(() => {
        this.pollItems();
        return this.itemsToPoll.length === 0;
      }, () => 0, null, scheduleFn);
    }
    bindTextureToFrameBuffer(texture) {
      this.throwIfDisposed();
      bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
      if (this.debug) {
        validateFramebuffer(this.gl);
      }
    }
    unbindTextureToFrameBuffer() {
      if (this.outputTexture != null) {
        bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
        if (this.debug) {
          validateFramebuffer(this.gl);
        }
      } else {
        unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
      }
    }
    downloadMatrixDriver(texture, downloadAndDecode) {
      this.bindTextureToFrameBuffer(texture);
      const result = downloadAndDecode();
      this.unbindTextureToFrameBuffer();
      return result;
    }
    setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {
      this.throwIfDisposed();
      const gl = this.gl;
      bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
      if (this.debug) {
        validateFramebuffer(gl);
      }
      this.outputTexture = outputMatrixTextureMaybePacked;
      callAndCheck(gl, () => gl.viewport(0, 0, width, height));
      callAndCheck(gl, () => gl.scissor(0, 0, width, height));
    }
    setOutputMatrixWriteRegionDriver(x, y, width, height) {
      this.throwIfDisposed();
      callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));
    }
    throwIfDisposed() {
      if (this.disposed) {
        throw new Error("Attempted to use disposed GPGPUContext.");
      }
    }
    throwIfNoProgram() {
      if (this.program == null) {
        throw new Error("No GPU program is currently set.");
      }
    }
  }
  function linearSearchLastTrue(arr) {
    let i = 0;
    for (; i < arr.length; ++i) {
      const isDone = arr[i]();
      if (!isDone) {
        break;
      }
    }
    return i - 1;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function simpleAbsImpl(vals) {
    const resultValues = new Float32Array(vals.length);
    for (let i = 0; i < vals.length; ++i) {
      resultValues[i] = Math.abs(vals[i]);
    }
    return resultValues;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function createSimpleBinaryKernelImpl(op2) {
    return (aShape, bShape, aVals, bVals, dtype) => {
      const newShape = assertAndGetBroadcastShape(aShape, bShape);
      const resultRank = newShape.length;
      const resultStrides = computeStrides(newShape);
      const resultSize = sizeFromShape(newShape);
      const result = getTypedArrayFromDType(dtype, resultSize);
      const aRank = aShape.length;
      const bRank = bShape.length;
      const aStrides = computeStrides(aShape);
      const bStrides = computeStrides(bShape);
      const aBroadcastDims = getBroadcastDims$1(aShape, newShape);
      const bBroadcastDims = getBroadcastDims$1(bShape, newShape);
      if (aBroadcastDims.length + bBroadcastDims.length === 0) {
        for (let i = 0; i < result.length; ++i) {
          result[i] = op2(aVals[i % aVals.length], bVals[i % bVals.length]);
        }
      } else {
        for (let i = 0; i < result.length; ++i) {
          const loc = indexToLoc(i, resultRank, resultStrides);
          const aLoc = loc.slice(-aRank);
          aBroadcastDims.forEach((d) => aLoc[d] = 0);
          const aIndex = locToIndex(aLoc, aRank, aStrides);
          const bLoc = loc.slice(-bRank);
          bBroadcastDims.forEach((d) => bLoc[d] = 0);
          const bIndex = locToIndex(bLoc, bRank, bStrides);
          result[i] = op2(aVals[aIndex], bVals[bIndex]);
        }
      }
      return [result, newShape];
    };
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function castImpl(values, shape, inputType, dtype) {
    if (dtype === "int32") {
      const resultValues = Int32Array.from(values);
      return [shape, "int32", resultValues];
    }
    if (dtype === "bool") {
      const zero = toTypedArray([0], inputType);
      const [resultData, resultShape] = createSimpleBinaryKernelImpl((a, b) => a !== b ? 1 : 0)(shape, [], values, zero, "bool");
      return [resultShape, "bool", resultData];
    }
    throw new Error(`Error in Cast: failed to cast ${inputType} to ${dtype}`);
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const addImpl = createSimpleBinaryKernelImpl((a, b) => a + b);
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function bincountImpl(xVals, weightsVals, weightsDtype, weightsShape, size) {
    const weightsSize = sizeFromShape(weightsShape);
    const outVals = makeZerosTypedArray(size, weightsDtype);
    for (let i = 0; i < xVals.length; i++) {
      const value = xVals[i];
      if (value < 0) {
        throw new Error("Input x must be non-negative!");
      }
      if (value >= size) {
        continue;
      }
      if (weightsSize > 0) {
        outVals[value] += weightsVals[i];
      } else {
        outVals[value] += 1;
      }
    }
    return outVals;
  }
  function bincountReduceImpl(xBuf, weightsBuf, size, binaryOutput = false) {
    const numRows = xBuf.shape[0];
    const numCols = xBuf.shape[1];
    const outBuf = buffer([numRows, size], weightsBuf.dtype);
    for (let i = 0; i < numRows; i++) {
      for (let j2 = 0; j2 < numCols; j2++) {
        const value = xBuf.get(i, j2);
        if (value < 0) {
          throw new Error("Input x must be non-negative!");
        }
        if (value >= size) {
          continue;
        }
        if (binaryOutput) {
          outBuf.set(1, i, value);
        } else {
          if (weightsBuf.size > 0) {
            outBuf.set(outBuf.get(i, value) + weightsBuf.get(i, j2), i, value);
          } else {
            outBuf.set(outBuf.get(i, value) + 1, i, value);
          }
        }
      }
    }
    return outBuf;
  }
  /**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const bitwiseAndImpl = createSimpleBinaryKernelImpl((a, b) => a & b);
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function createSimpleUnaryImpl(op2) {
    return (values, dtype, attrs) => {
      const newValues = getArrayFromDType(dtype, values.length);
      for (let i = 0; i < values.length; ++i) {
        newValues[i] = op2(values[i], attrs);
      }
      return newValues;
    };
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ceilImpl = createSimpleUnaryImpl((xi) => Math.ceil(xi));
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function concatImpl$1(inputs, outShape, dtype, simplyConcat) {
    const outVals = getArrayFromDType(dtype, sizeFromShape(outShape));
    if (simplyConcat && dtype !== "string") {
      let offset = 0;
      inputs.forEach((input) => {
        const size = sizeFromShape(input.shape);
        outVals.set(input.vals, offset);
        offset += size;
      });
    } else {
      let colOffset = 0;
      inputs.forEach((input) => {
        const decodedData = dtype === "string" ? fromUint8ToStringArray(input.vals) : input.vals;
        let tIdx = 0;
        for (let row = 0; row < input.shape[0]; ++row) {
          const resIdx = row * outShape[1] + colOffset;
          for (let col = 0; col < input.shape[1]; ++col) {
            outVals[resIdx + col] = decodedData[tIdx++];
          }
        }
        colOffset += input.shape[1];
      });
    }
    return outVals;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const equalImpl = createSimpleBinaryKernelImpl((a, b) => a === b ? 1 : 0);
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const expImpl = createSimpleUnaryImpl((xi) => Math.exp(xi));
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const expm1Impl = createSimpleUnaryImpl((xi) => Math.expm1(xi));
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const floorImpl = createSimpleUnaryImpl((xi) => Math.floor(xi));
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const floorDivImpl = createSimpleBinaryKernelImpl((a, b) => Math.floor(a / b));
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function gatherNdImpl(indicesData, paramsBuf, dtype, numSlices, sliceRank, sliceSize, strides, paramsShape, paramsSize) {
    const outBuf = buffer([numSlices, sliceSize], dtype);
    for (let i = 0; i < numSlices; i++) {
      const index2 = [];
      let flattenIndex = 0;
      for (let j2 = 0; j2 < sliceRank; j2++) {
        const dim = indicesData[i * sliceRank + j2];
        flattenIndex += dim * strides[j2];
        index2.push(dim);
      }
      if (flattenIndex < 0 || flattenIndex >= paramsSize / sliceSize) {
        throw new Error(`Invalid indices: ${index2} does not index into ${paramsShape}`);
      }
      for (let k3 = 0; k3 < sliceSize; k3++) {
        outBuf.values[i * sliceSize + k3] = paramsBuf.get(...paramsBuf.indexToLoc(flattenIndex * sliceSize + k3));
      }
    }
    return outBuf;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function gatherV2Impl(xBuf, indicesBuf, flattenOutputShape) {
    const outBuf = buffer(flattenOutputShape, xBuf.dtype);
    for (let i = 0; i < outBuf.size; ++i) {
      const newLoc = outBuf.indexToLoc(i);
      const originalLoc = newLoc.slice();
      const batchIdx = originalLoc[0];
      const indicesIdx = originalLoc[2];
      const indicesIndex = indicesBuf.locToIndex([batchIdx, indicesIdx]);
      originalLoc[2] = indicesBuf.values[indicesIndex];
      const originalIndex = xBuf.locToIndex(originalLoc);
      if (0 <= originalIndex && originalIndex < xBuf.values.length) {
        outBuf.values[i] = xBuf.values[originalIndex];
      }
    }
    return outBuf;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const greaterImpl = createSimpleBinaryKernelImpl((a, b) => a > b ? 1 : 0);
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const greaterEqualImpl = createSimpleBinaryKernelImpl((a, b) => a >= b ? 1 : 0);
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const lessImpl = createSimpleBinaryKernelImpl((a, b) => a < b ? 1 : 0);
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const lessEqualImpl = createSimpleBinaryKernelImpl((a, b) => a <= b ? 1 : 0);
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function linSpaceImpl(start, stop, num) {
    const step2 = (stop - start) / (num - 1);
    const values = makeZerosTypedArray(num, "float32");
    values[0] = start;
    for (let i = 1; i < values.length; i++) {
      values[i] = values[i - 1] + step2;
    }
    return values;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const logImpl = createSimpleUnaryImpl((xi) => Math.log(xi));
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function maxImpl$1(aVals, reduceSize, outShape, dtype) {
    const vals = getTypedArrayFromDType(dtype, sizeFromShape(outShape));
    for (let i = 0; i < vals.length; ++i) {
      const offset = i * reduceSize;
      let max2 = aVals[offset];
      for (let j2 = 0; j2 < reduceSize; ++j2) {
        const value = aVals[offset + j2];
        if (Number.isNaN(value) || value > max2) {
          max2 = value;
        }
      }
      vals[i] = max2;
    }
    return vals;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const maximumImpl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.max(aValue, bValue));
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const minimumImpl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.min(aValue, bValue));
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const multiplyImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue * bValue);
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function negImpl(xVals, xShape, xDtype) {
    const minusOne = createScalarValue(-1, xDtype);
    return multiplyImpl([], xShape, minusOne, xVals, xDtype);
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const notEqualImpl = createSimpleBinaryKernelImpl((a, b) => a !== b ? 1 : 0);
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function transposeImpl$1(xVals, xShape, dtype, perm, newShape) {
    const xRank = xShape.length;
    const xSize = sizeFromShape(xShape);
    const xStrides = computeStrides(xShape);
    const newStrides = computeStrides(newShape);
    const result = getTypedArrayFromDType(dtype, sizeFromShape(newShape));
    for (let i = 0; i < xSize; ++i) {
      const loc = indexToLoc(i, xRank, xStrides);
      const newLoc = new Array(loc.length);
      for (let i2 = 0; i2 < newLoc.length; i2++) {
        newLoc[i2] = loc[perm[i2]];
      }
      const newIndex = locToIndex(newLoc, xRank, newStrides);
      result[newIndex] = xVals[i];
    }
    return result;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function prodImpl(xShape, xDtype, xVals, reductionAxes) {
    const [outShape, reduceShape] = computeOutAndReduceShapes(xShape, reductionAxes);
    const outDtype = upcastType(xDtype, "int32");
    const outVals = makeZerosTypedArray(sizeFromShape(outShape), outDtype);
    const reduceSize = sizeFromShape(reduceShape);
    for (let i = 0; i < outVals.length; ++i) {
      const offset = i * reduceSize;
      let prod2 = 1;
      for (let j2 = 0; j2 < reduceSize; ++j2) {
        prod2 *= xVals[offset + j2];
      }
      outVals[i] = prod2;
    }
    return { outVals, outShape, outDtype };
  }
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function validateIndices(indices, indicesShape, numParams) {
    indices.forEach((index2, i) => {
      if (index2 < 0 || index2 >= numParams) {
        const locString = indexToLoc(i, indicesShape.length, computeStrides(indicesShape)).join(",");
        throw new Error(`indices[${locString}] = ${index2} is not in [0, ${numParams})`);
      }
    });
  }
  function validateSplits(paramsNestedSplits, numParamsDenseValues) {
    for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {
      const splits = paramsNestedSplits[dim];
      const lastSplit = dim === paramsNestedSplits.length - 1 ? numParamsDenseValues : paramsNestedSplits[dim + 1].length;
      if (splits.length === 0) {
        throw new Error("Ragged splits may not be empty");
      }
      if (splits[0] < 0) {
        throw new Error("Ragged splits must be non-negative");
      }
      if (splits[splits.length - 1] > lastSplit) {
        throw new Error("Ragged splits must not point past values");
      }
      for (let i = 1; i < splits.length; ++i) {
        if (splits[i - 1] > splits[i]) {
          throw new Error("Ragged splits must be sorted in ascending order");
        }
      }
    }
  }
  function makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues) {
    const valueSlices = [];
    let numValues = 0;
    const numSplits = indicesShape.length - 1 + paramsNestedSplits.length;
    const outSplits = new Array(numSplits).fill(null).map(() => [0]);
    validateSplits(paramsNestedSplits, numParamsDenseValues);
    let nrows = 1;
    for (let dim = 0; dim < indicesShape.length - 1; ++dim) {
      nrows *= indicesShape[dim];
      const rowLength = indicesShape[dim + 1];
      for (let i = 1; i < nrows + 1; ++i) {
        outSplits[dim].push(i * rowLength);
      }
    }
    for (let i = 0; i < indices.length; ++i) {
      let start = indices[i];
      let limit = indices[i] + 1;
      for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {
        const splits = paramsNestedSplits[dim];
        const outDim = dim + indicesShape.length - 1;
        if (outDim >= 0) {
          const outSplitsOutDim = outSplits[outDim];
          const delta = outSplitsOutDim[outSplitsOutDim.length - 1] - splits[start];
          for (let j2 = start; j2 < limit; ++j2) {
            outSplits[outDim].push(splits[j2 + 1] + delta);
          }
        }
        start = splits[start];
        limit = splits[limit];
      }
      if (limit !== start) {
        valueSlices.push([start, limit]);
        numValues += limit - start;
      }
    }
    return { outSplits, valueSlices, numValues };
  }
  function getSplits(outSplits) {
    const splitsOut = [];
    for (let i = 0; i < outSplits.length; ++i) {
      const numSplits = outSplits[i].length;
      const splits = getArrayFromDType("int32", numSplits);
      splitsOut.push(splits);
      outSplits[i].forEach((value, j2) => splits[j2] = value);
    }
    return splitsOut;
  }
  function computeFlatOuterDims(orig, numOutDims) {
    const outDims = orig.slice(0, numOutDims);
    while (outDims.length < numOutDims) {
      outDims.push(1);
    }
    for (let inDim = numOutDims; inDim < orig.length; inDim++) {
      outDims[numOutDims - 1] *= orig[inDim];
    }
    return outDims;
  }
  function writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, values, valuesShape) {
    const denseM = computeFlatOuterDims(paramsDenseValuesShape, 2)[1];
    const valuesM = computeFlatOuterDims(valuesShape, 2)[1];
    let outPos = 0;
    for (const slice2 of valueSlices) {
      for (let i = slice2[0]; i < slice2[1]; ++i) {
        for (let j2 = 0; j2 < valueSize; ++j2) {
          values[outPos * valuesM + j2] = paramsDenseValues[i * denseM + j2];
        }
        ++outPos;
      }
    }
  }
  function getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues) {
    const valuesShape = paramsDenseValuesShape.slice();
    valuesShape[0] = numValues;
    const valuesOut = getArrayFromDType(paramsDenseValuesDType, sizeFromShape(valuesShape));
    const numElements = paramsDenseValues.length;
    const valueSize = numElements === 0 ? 0 : numElements / paramsDenseValuesShape[0];
    writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, valuesOut, valuesShape);
    return [valuesOut, valuesShape];
  }
  function raggedGatherImpl(paramsNestedSplits, paramsNestedSplitsShapes, paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, indices, indicesShape, outputRaggedRank) {
    if (paramsNestedSplits.length === 0) {
      throw new Error("paramsNestedSplits must be non empty");
    }
    if (paramsNestedSplitsShapes[0].length === 0) {
      throw new Error("Split tensors must not be scalars");
    }
    const numParams = paramsNestedSplitsShapes[0][0] - 1;
    validateIndices(indices, indicesShape, numParams);
    if (paramsDenseValuesShape.length === 0) {
      throw new Error("params.rank must be nonzero");
    }
    const numParamsDenseValues = paramsDenseValuesShape[0];
    const { outSplits, valueSlices, numValues } = makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues);
    const outputNestedSplits = getSplits(outSplits);
    const outputDenseValues = getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues);
    return [outputNestedSplits, outputDenseValues[0], outputDenseValues[1]];
  }
  /**
   * @license
   * Copyright 2022 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const INT32_MAX = 2147483647;
  function raggedRangeImpl(starts, startsShape, startsDType, limits, limitsShape, deltas, deltasShape) {
    if (startsShape.length > 1) {
      throw new Error("starts must be a scalar or vector");
    }
    if (limitsShape.length > 1) {
      throw new Error("limits must be a scalar or vector");
    }
    if (deltasShape.length > 1) {
      throw new Error("deltas must be a scalar or vector");
    }
    const broadcastStarts = startsShape.length === 0;
    const broadcastLimits = limitsShape.length === 0;
    const broadcastDeltas = deltasShape.length === 0;
    const inSizes = [];
    if (!broadcastStarts) {
      inSizes.push(startsShape[0]);
    }
    if (!broadcastLimits) {
      inSizes.push(limitsShape[0]);
    }
    if (!broadcastDeltas) {
      inSizes.push(deltasShape[0]);
    }
    for (let i = 1; i < inSizes.length; ++i) {
      if (inSizes[i] !== inSizes[i - 1]) {
        throw new Error("starts, limits, and deltas must have the same shape");
      }
    }
    const nRows = inSizes.length === 0 ? 1 : inSizes[0];
    const rtNestedSplits = getArrayFromDType("int32", nRows + 1);
    rtNestedSplits[0] = 0;
    for (let row = 0; row < nRows; ++row) {
      const start = broadcastStarts ? starts[0] : starts[row];
      const limit = broadcastLimits ? limits[0] : limits[row];
      const delta = broadcastDeltas ? deltas[0] : deltas[row];
      if (delta === 0) {
        throw new Error("Requires delta != 0");
      }
      let size;
      if (delta > 0 && limit < start || delta < 0 && limit > start) {
        size = 0;
      } else {
        size = Math.ceil(Math.abs((limit - start) / delta));
        if (size > INT32_MAX) {
          throw new Error(`Requires ((limit - start) / delta) <= ${INT32_MAX}`);
        }
      }
      rtNestedSplits[row + 1] = rtNestedSplits[row] + size;
    }
    const nVals = rtNestedSplits[nRows];
    const rtDenseValues = getArrayFromDType(startsDType, nVals);
    let valueIndex = 0;
    for (let row = 0; row < nRows; ++row) {
      const rowSize = rtNestedSplits[row + 1] - rtNestedSplits[row];
      let value = broadcastStarts ? starts[0] : starts[row];
      const delta = broadcastDeltas ? deltas[0] : deltas[row];
      for (let i = 0; i < rowSize; ++i) {
        rtDenseValues[valueIndex++] = value;
        value += delta;
      }
    }
    return [rtNestedSplits, rtDenseValues];
  }
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  var RowPartitionType = RowPartitionType$1;
  class RaggedTensorToTensorOp {
    constructor(shape, shapeShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypeStrings) {
      this.shape = shape;
      this.shapeShape = shapeShape;
      this.values = values;
      this.valuesShape = valuesShape;
      this.valuesDType = valuesDType;
      this.defaultValue = defaultValue;
      this.defaultValueShape = defaultValueShape;
      this.rowPartitionValues = rowPartitionValues;
      this.rowPartitionValuesShapes = rowPartitionValuesShapes;
      this.rowPartitionTypes = getRowPartitionTypesHelper(rowPartitionTypeStrings);
      this.raggedRank = getRaggedRank(this.rowPartitionTypes);
    }
    getRowPartitionTypeByDimension(dimension) {
      if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {
        return this.rowPartitionTypes[dimension + 1];
      } else {
        return this.rowPartitionTypes[dimension];
      }
    }
    // Returns the relationship between dimension and dimension + 1.
    getRowPartitionTensor(dimension) {
      if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {
        return this.rowPartitionValues[dimension + 1];
      } else {
        return this.rowPartitionValues[dimension];
      }
    }
    getMaxWidth(dimension) {
      const rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);
      switch (this.getRowPartitionTypeByDimension(dimension - 1)) {
        case RowPartitionType.VALUE_ROWIDS:
          return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);
        case RowPartitionType.ROW_SPLITS:
          return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);
        default:
          throw new Error(`Cannot handle partition type ${RowPartitionType[this.getRowPartitionTypeByDimension(dimension - 1)]}`);
      }
    }
    static getMaxWidthRowSplit(rowSplit) {
      const tensorLength = rowSplit.length;
      if (tensorLength === 0 || tensorLength === 1) {
        return 0;
      }
      let maxWidth = 0;
      for (let i = 0; i < tensorLength - 1; ++i) {
        const currentWidth = rowSplit[i + 1] - rowSplit[i];
        if (currentWidth > maxWidth) {
          maxWidth = currentWidth;
        }
      }
      return maxWidth;
    }
    static getMaxWidthValueRowID(valueRowIds) {
      const indexLength = valueRowIds.length;
      if (indexLength === 0) {
        return 0;
      }
      let firstEqualIndex = 0;
      let firstEqualIndexValue = valueRowIds[0];
      let maxWidth = 0;
      for (let i = 1; i < indexLength; ++i) {
        const value = valueRowIds[i];
        if (value !== firstEqualIndexValue) {
          firstEqualIndexValue = value;
          maxWidth = Math.max(i - firstEqualIndex, maxWidth);
          firstEqualIndex = i;
        }
      }
      return Math.max(indexLength - firstEqualIndex, maxWidth);
    }
    tensorShapeFromTensor(t, tShape, isPartial = true) {
      if (tShape.length === 0) {
        if (t[0] === -1) {
          return [];
        }
        throw new Error(`The only valid scalar shape tensor is the fully unknown shape specified as -1.`);
      }
      return makeShape(t, isPartial);
    }
    calculateOutputSize(firstDim) {
      const valueShape = this.valuesShape;
      const defaultValueShape = this.defaultValueShape;
      validateDefaultValueShape(defaultValueShape, valueShape);
      const shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);
      const outputShape = combineRaggedTensorToTensorShapes(this.raggedRank, shape, valueShape);
      const result = outputShape;
      if (result[0] < 0) {
        result[0] = firstDim;
      }
      for (let i = 1; i <= this.raggedRank; ++i) {
        if (result[i] < 0) {
          result[i] = this.getMaxWidth(i);
        }
      }
      return result;
    }
    /**
     * The outputIndex represents the index in the output tensor
     * where the first element of a particular dimension would be written.
     * If it is -1, it indicates that the index is out of scope.
     * Example, given firstDimension = 10, firstDimensionOutput = 6,
     * and outputIndexMultiplier = 100:
     * result = [0 100 200 300 400 500 -1 -1 -1 -1]
     * If firstDimensionOutput = 11 instead, then:
     * result = [0 100 200 300 400 500 600 700 800 900]
     */
    calculateFirstParentOutputIndex(firstDimension, outputIndexMultiplier, firstDimensionOutput) {
      const minDimension = Math.min(firstDimension, firstDimensionOutput);
      const result = [];
      let currentOutputIndex = 0;
      for (let i = 0; i < minDimension; ++i, currentOutputIndex += outputIndexMultiplier) {
        result.push(currentOutputIndex);
      }
      for (let i = minDimension; i < firstDimension; ++i) {
        result.push(-1);
      }
      assert(result.length === firstDimension, () => "Final length of result must be equal to firstDimension.");
      return result;
    }
    calculateOutputIndexRowSplit(rowSplit, parentOutputIndex, outputIndexMultiplier, outputSize) {
      const rowSplitSize = rowSplit.length;
      const result = [];
      for (let i = 0; i < rowSplitSize - 1; ++i) {
        const rowLength = rowSplit[i + 1] - rowSplit[i];
        let realLength = Math.min(outputSize, rowLength);
        let parentOutputIndexCurrent = parentOutputIndex[i];
        if (parentOutputIndexCurrent === -1) {
          realLength = 0;
        }
        for (let j2 = 0; j2 < realLength; ++j2) {
          result.push(parentOutputIndexCurrent);
          parentOutputIndexCurrent += outputIndexMultiplier;
        }
        for (let j2 = 0; j2 < rowLength - realLength; ++j2) {
          result.push(-1);
        }
      }
      if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {
        throw new Error("Invalid row split size.");
      }
      return result;
    }
    // Calculate the output index of the first element of a list.
    // The parentOutputIndex is the same computation for the previous list.
    // -1 indicates an element or list that is out of range.
    // The outputIndexMultiplier is the number of output indices one moves
    // forward for each column.
    // E.g., given:
    // valueRowIds:[0 1 2 2 2 3 5 5 6]
    // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]
    // outputIndexMultiplier: 10
    // outputSize: 2
    // You get:
    // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]
    // result[0] = parentOutputIndex[valueRowIds[0]]
    // result[1] = parentOutputIndex[valueRowIds[1]]
    // result[2] = parentOutputIndex[valueRowIds[2]]
    // result[3] = parentOutputIndex[valueRowIds[2] + 10]
    // result[4] = -1 because it is the third element the size is 2.
    // result[5] = parentOutputIndex[valueRowIds[3]]
    // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1
    // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1
    // result[8] = parentOutputIndex[valueRowIds[7]]
    calculateOutputIndexValueRowID(valueRowIds, parentOutputIndex, outputIndexMultiplier, outputSize) {
      const indexSize = valueRowIds.length;
      const result = [];
      if (indexSize === 0) {
        return [];
      }
      let currentOutputColumn = 0;
      let currentValueRowId = valueRowIds[0];
      if (currentValueRowId >= parentOutputIndex.length) {
        throw new Error(`Got currentValueRowId=${currentValueRowId}, which is not less than ${parentOutputIndex.length}`);
      }
      let currentOutputIndex = parentOutputIndex[currentValueRowId];
      result.push(currentOutputIndex);
      for (let i = 1; i < indexSize; ++i) {
        const nextValueRowId = valueRowIds[i];
        if (nextValueRowId === currentValueRowId) {
          if (currentOutputIndex >= 0) {
            ++currentOutputColumn;
            if (currentOutputColumn < outputSize) {
              currentOutputIndex += outputIndexMultiplier;
            } else {
              currentOutputIndex = -1;
            }
          }
        } else {
          currentOutputColumn = 0;
          currentValueRowId = nextValueRowId;
          if (nextValueRowId >= parentOutputIndex.length) {
            throw new Error(`Got nextValueRowId=${nextValueRowId} which is not less than ${parentOutputIndex.length}`);
          }
          currentOutputIndex = parentOutputIndex[nextValueRowId];
        }
        result.push(currentOutputIndex);
      }
      if (result.length !== valueRowIds.length) {
        throw new Error("Invalid row ids.");
      }
      return result;
    }
    calculateOutputIndex(dimension, parentOutputIndex, outputIndexMultiplier, outputSize) {
      const rowPartitionTensor = this.getRowPartitionTensor(dimension);
      const partitionType = this.getRowPartitionTypeByDimension(dimension);
      switch (partitionType) {
        case RowPartitionType.VALUE_ROWIDS:
          return this.calculateOutputIndexValueRowID(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);
        case RowPartitionType.ROW_SPLITS:
          if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {
            throw new Error(`Row partition size is greater than output size: ${rowPartitionTensor.length - 1} > ${parentOutputIndex.length}`);
          }
          return this.calculateOutputIndexRowSplit(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);
        default:
          throw new Error(`Unsupported partition type: ${RowPartitionType[partitionType]}`);
      }
    }
    getFirstDimensionSize() {
      const firstPartitionTensor = this.rowPartitionValues[0];
      if (this.rowPartitionTypes.length === 0) {
        throw new Error("No row_partition_types given.");
      }
      const firstPartitionType = this.rowPartitionTypes[0];
      switch (firstPartitionType) {
        case RowPartitionType.FIRST_DIM_SIZE:
          return firstPartitionTensor[0];
        case RowPartitionType.VALUE_ROWIDS:
          throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
        case RowPartitionType.ROW_SPLITS:
          return this.rowPartitionValuesShapes[0][0] - 1;
        default:
          throw new Error(`Cannot handle type ${RowPartitionType[firstPartitionType]}`);
      }
    }
    compute() {
      const firstPartitionTensor = this.rowPartitionValues[0];
      if (firstPartitionTensor.length <= 0) {
        throw new Error("Invalid first partition input. Tensor requires at least one element.");
      }
      const firstDimension = this.getFirstDimensionSize();
      const outputSize = this.calculateOutputSize(firstDimension);
      const multiplier = new Array(this.raggedRank + 1);
      multiplier[multiplier.length - 1] = 1;
      for (let i = multiplier.length - 2; i >= 0; --i) {
        multiplier[i] = multiplier[i + 1] * outputSize[i + 1];
      }
      const outputShape = makeShape(outputSize, false);
      const outputTensor = getArrayFromDType(this.valuesDType, sizeFromShape(outputShape));
      const fullSize = multiplier[0] * outputSize[0];
      if (fullSize > 0) {
        let outputIndex = this.calculateFirstParentOutputIndex(firstDimension, multiplier[0], outputSize[0]);
        for (let i = 1; i <= this.raggedRank; ++i) {
          const newOutputIndex = this.calculateOutputIndex(i - 1, outputIndex, multiplier[i], outputSize[i]);
          outputIndex = newOutputIndex;
        }
        this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);
      }
      return [outputShape, outputTensor];
    }
    setOutput(raggedRank, outputIndex, outputTensor, outputShape) {
      if (outputTensor.length === 0) {
        return;
      }
      const valuesBase = this.values;
      const outputBase = outputTensor;
      let elementShape = outputShape.slice();
      elementShape = elementShape.slice(raggedRank + 1);
      const valueElementSize = sizeFromShape(elementShape);
      const outputIndexSize = outputIndex.length;
      let defaultValue = this.defaultValue;
      if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {
        const srcShape = this.defaultValueShape;
        tidy(() => {
          const defaultValueTensor = reshape$1(defaultValue, srcShape);
          const bCastDefault = broadcastTo(defaultValueTensor, elementShape);
          defaultValue = bCastDefault.dataSync();
        });
      }
      let srcStart = 0;
      let dstStart = 0;
      let dstEnd = 0;
      for (let srcI = 0; srcI <= outputIndexSize; ++srcI) {
        let dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;
        if (dstI === dstEnd) {
          ++dstEnd;
          continue;
        }
        if (dstStart < dstEnd) {
          const src = valuesBase.subarray(srcStart * valueElementSize);
          const dst = outputBase.subarray(dstStart * valueElementSize);
          const nVals = (dstEnd - dstStart) * valueElementSize;
          copyArray(dst, src, nVals);
        }
        if (srcI >= outputIndexSize) {
          const outputSize = outputTensor.length;
          dstI = Math.floor(outputSize / valueElementSize);
        }
        if (dstI > dstEnd) {
          if (this.defaultValue.length === 1) {
            outputBase.subarray(dstEnd * valueElementSize, dstI * valueElementSize).fill(this.defaultValue[0]);
            dstEnd = dstI;
          } else {
            while (dstI > dstEnd) {
              const dst = outputBase.slice(dstEnd * valueElementSize);
              copyArray(dst, defaultValue, valueElementSize);
              ++dstEnd;
            }
          }
        }
        if (dstI < 0) {
          srcStart = srcI + 1;
          dstStart = dstEnd;
        } else {
          srcStart = srcI;
          dstStart = dstEnd;
          dstEnd = dstStart + 1;
        }
      }
    }
  }
  function copyArray(dst, src, size) {
    for (let i = 0; i < size; i++) {
      dst[i] = src[i];
    }
  }
  function makeShape(shape, isPartial) {
    const out = [];
    for (let dim of shape) {
      if (dim < 0) {
        if (!isPartial) {
          throw new Error(`Dimension ${dim} must be >= 0`);
        }
        if (dim < -1) {
          throw new Error(`Dimension ${dim} must be >= -1`);
        }
        dim = -1;
      }
      out.push(dim);
    }
    return out;
  }
  function raggedTensorToTensorImpl(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes) {
    return new RaggedTensorToTensorOp(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes).compute();
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function rangeImpl(start, stop, step2, dtype) {
    const sameStartStop = start === stop;
    const increasingRangeNegativeStep = start < stop && step2 < 0;
    const decreasingRangePositiveStep = stop < start && step2 > 1;
    if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) {
      return makeZerosTypedArray(0, dtype);
    }
    const numElements = Math.abs(Math.ceil((stop - start) / step2));
    const values = makeZerosTypedArray(numElements, dtype);
    if (stop < start && step2 === 1) {
      step2 = -1;
    }
    values[0] = start;
    for (let i = 1; i < values.length; i++) {
      values[i] = values[i - 1] + step2;
    }
    return values;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const rsqrtImpl = createSimpleUnaryImpl((xi) => 1 / Math.sqrt(xi));
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function scatterImpl(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {
    const flattenShape = [outputSize / sliceSize, sliceSize];
    const indicesData = indices.values;
    const updatesData = updates.values;
    if (outputSize === 0) {
      return buffer(shape, updates.dtype);
    }
    const outBuf = defaultValue instanceof TensorBuffer ? defaultValue : buffer(flattenShape, updates.dtype);
    if (typeof defaultValue === "string") {
      outBuf.values.fill(defaultValue);
    } else if (typeof defaultValue === "number") {
      outBuf.values.fill(defaultValue);
    } else if (typeof defaultValue === "boolean") {
      outBuf.values.fill(+defaultValue);
    }
    for (let i = 0; i < numUpdates; i++) {
      const index2 = [];
      let flattenIndex = 0;
      for (let j2 = 0; j2 < sliceRank; j2++) {
        const dim = indicesData[i * sliceRank + j2];
        index2.push(dim);
        flattenIndex += dim * strides[j2];
      }
      if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {
        throw new Error(`Invalid indices: ${index2} does not index into ${shape}`);
      }
      for (let k3 = 0; k3 < sliceSize; k3++) {
        if (sumDupeIndices) {
          outBuf.values[flattenIndex * sliceSize + k3] += updatesData[i * sliceSize + k3];
        } else {
          outBuf.values[flattenIndex * sliceSize + k3] = updates.rank === 0 ? updatesData[0] : updatesData[i * sliceSize + k3];
        }
      }
    }
    return outBuf;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const sigmoidImpl = createSimpleUnaryImpl((xi) => 1 / (1 + Math.exp(-xi)));
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sliceImpl(vals, begin, size, shape, dtype) {
    const isContinous = isSliceContinous(shape, begin, size);
    const length = sizeFromShape(size);
    const xStrides = computeStrides(shape);
    if (isContinous) {
      const flatOffset = computeFlatOffset(begin, xStrides);
      if (dtype === "string") {
        return vals.slice(flatOffset, flatOffset + length);
      }
      return vals.subarray(flatOffset, flatOffset + length);
    }
    const decodedData = dtype === "string" ? fromUint8ToStringArray(vals) : vals;
    const inBuf = buffer(shape, dtype, decodedData);
    const outBuf = buffer(size, dtype);
    for (let i = 0; i < outBuf.size; ++i) {
      const outLoc = outBuf.indexToLoc(i);
      const inLoc = outLoc.map((idx, j2) => idx + begin[j2]);
      outBuf.set(inBuf.get(...inLoc), ...outLoc);
    }
    if (dtype === "string") {
      return fromStringArrayToUint8(outBuf.values);
    }
    return outBuf.values;
  }
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sparseFillEmptyRowsImpl(indices, indicesShape, indicesDType, values, valuesDType, denseShape, defaultValue) {
    const indicesCount = indicesShape[0];
    const denseRows = denseShape[0];
    const emptyRowIndicator = new Array(denseRows);
    const reverseIndexMap = new Array(indicesCount);
    const rank = indicesShape[1];
    if (denseRows === 0) {
      if (indicesCount !== 0) {
        throw new Error(getSparseFillEmptyRowsIndicesDenseShapeMismatch(indicesCount));
      }
      const outputIndices = getArrayFromDType(indicesDType, 0);
      const outputValues = getArrayFromDType(valuesDType, 0);
      return [
        outputIndices,
        [0, rank],
        outputValues,
        emptyRowIndicator,
        reverseIndexMap
      ];
    }
    let rowsAreOrdered = true;
    let lastIndicesRow = 0;
    const csrOffset = new Array(denseRows).fill(0);
    for (let i = 0; i < indicesCount; ++i) {
      const row = indices[i * rank];
      if (row < 0) {
        throw new Error(getSparseFillEmptyRowsNegativeIndexErrorMessage(i, row));
      }
      if (row >= denseRows) {
        throw new Error(getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(i, row, denseRows));
      }
      ++csrOffset[row];
      rowsAreOrdered = rowsAreOrdered && row >= lastIndicesRow;
      lastIndicesRow = row;
    }
    let allRowsFull = true;
    for (let row = 0; row < denseRows; ++row) {
      const rowEmpty = csrOffset[row] === 0;
      emptyRowIndicator[row] = rowEmpty;
      allRowsFull = allRowsFull && !rowEmpty;
      csrOffset[row] = Math.max(csrOffset[row], 1);
      if (row > 0) {
        csrOffset[row] += csrOffset[row - 1];
      }
    }
    if (allRowsFull && rowsAreOrdered) {
      const outputIndices = indices;
      const outputValues = values;
      for (let i = 0; i < indicesCount; ++i) {
        reverseIndexMap[i] = i;
      }
      return [
        outputIndices,
        [indicesCount, rank],
        outputValues,
        emptyRowIndicator,
        reverseIndexMap
      ];
    } else {
      const fullIndicesCount = csrOffset[denseRows - 1];
      const outputIndices = getArrayFromDType(indicesDType, fullIndicesCount * rank);
      const outputValues = getArrayFromDType(valuesDType, fullIndicesCount);
      const filledCount = new Array(denseRows).fill(0);
      for (let i = 0; i < indicesCount; ++i) {
        const row = indices[i * rank];
        const offset = filledCount[row];
        const outputI = (row === 0 ? 0 : csrOffset[row - 1]) + offset;
        filledCount[row]++;
        for (let j2 = 0; j2 < rank; ++j2) {
          outputIndices[outputI * rank + j2] = indices[i * rank + j2];
        }
        outputValues[outputI] = values[i];
        reverseIndexMap[i] = outputI;
      }
      for (let row = 0; row < denseRows; ++row) {
        const rowCount = filledCount[row];
        if (rowCount === 0) {
          const startingIndex = row === 0 ? 0 : csrOffset[row - 1];
          outputIndices[startingIndex * rank + 0] = row;
          for (let col = 1; col < rank; ++col) {
            outputIndices[startingIndex * rank + col] = 0;
          }
          outputValues[startingIndex] = defaultValue;
        }
      }
      return [
        outputIndices,
        [fullIndicesCount, rank],
        outputValues,
        emptyRowIndicator,
        reverseIndexMap
      ];
    }
  }
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sparseReshapeImpl(inputIndices, inputIndicesShape, inputDType, inputShape, targetShape) {
    const denseSize = sizeFromShape(inputShape);
    const nnz = inputIndicesShape[0];
    const outputRank = targetShape.length;
    const outputShape = [];
    let product = 1;
    let unknownIndex = -1;
    for (let d = 0; d < outputRank; ++d) {
      const size = targetShape[d];
      if (size === -1) {
        if (unknownIndex !== -1) {
          throw new Error(getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(unknownIndex, d));
        }
        unknownIndex = d;
        outputShape.push(1);
      } else {
        if (size < 0) {
          throw new Error(getSparseReshapeNegativeOutputDimErrorMessage(d, size));
        }
        product *= size;
        outputShape.push(size);
      }
    }
    if (unknownIndex !== -1) {
      if (product <= 0) {
        throw new Error(getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());
      }
      const missing = Math.trunc(denseSize / product);
      if (product * missing !== denseSize) {
        throw new Error(getSparseReshapeInputOutputMultipleErrorMessage(inputShape, outputShape));
      }
      outputShape[unknownIndex] = missing;
    }
    const outputSize = sizeFromShape(outputShape);
    if (outputSize !== denseSize) {
      throw new Error(getSparseReshapeInputOutputMismatchErrorMessage(inputShape, outputShape));
    }
    const inputRank = inputShape.length;
    const inputStrides = [];
    if (inputRank > 0) {
      inputStrides[inputRank - 1] = 1;
      for (let d = inputRank - 2; d >= 0; --d) {
        inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];
      }
    }
    const outputStrides = [];
    if (outputRank > 0) {
      outputStrides[outputRank - 1] = 1;
      for (let d = outputRank - 2; d >= 0; --d) {
        outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];
      }
    }
    const newIndices = getArrayFromDType(inputDType, nnz * outputRank);
    for (let i = 0; i < nnz; ++i) {
      let id = 0;
      for (let j2 = 0; j2 < inputRank; ++j2) {
        id += inputIndices[i * inputRank + j2] * inputStrides[j2];
      }
      for (let j2 = 0; j2 < outputRank; ++j2) {
        newIndices[i * outputRank + j2] = Math.trunc(id / outputStrides[j2]);
        id %= outputStrides[j2];
      }
    }
    return [newIndices, [nnz, outputRank], outputShape];
  }
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sparseSegmentReductionImpl(input, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {
    const numIndices = indices.length;
    const inputFlat = [inputShape[0], input.length / inputShape[0]];
    const numCol = inputFlat[1];
    const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;
    const outputRows = lastSegmentIdPlusOne;
    if (outputRows < 0) {
      throw new Error(getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    }
    const outputShape = inputShape.slice();
    outputShape[0] = outputRows;
    const outputLength = outputShape.reduce((product, value) => product * value, 1);
    const output = getArrayFromDType(inputDType, outputLength);
    if (numIndices === 0) {
      if (outputRows > 0) {
        output.fill(defaultValue);
      }
      return [output, outputShape];
    }
    if (outputRows <= 0) {
      throw new Error(getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    }
    let start = 0, end = 1;
    let uninitializedIndex = 0;
    let outIndex = segmentIds[start];
    while (true) {
      let nextIndex = 0;
      if (end < numIndices) {
        nextIndex = segmentIds[end];
        if (outIndex === nextIndex) {
          ++end;
          continue;
        }
        if (outIndex >= nextIndex) {
          throw new Error(getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());
        }
      }
      if (outIndex < 0 || outIndex >= outputRows) {
        throw new Error(getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(outIndex, outputRows));
      }
      if (outIndex > uninitializedIndex) {
        output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);
      }
      for (let i = start; i < end; ++i) {
        const index2 = indices[i];
        if (index2 < 0 || index2 >= inputFlat[0]) {
          throw new Error(getSparseSegmentReductionIndicesOutOfRangeErrorMessage(i, indices[i], inputFlat[0]));
        }
        for (let j2 = 0; j2 < numCol; j2++) {
          output[outIndex * numCol + j2] += input[index2 * numCol + j2];
        }
      }
      if (isMean) {
        for (let j2 = 0; j2 < numCol; j2++) {
          output[outIndex * numCol + j2] /= end - start;
        }
      }
      start = end;
      ++end;
      uninitializedIndex = outIndex + 1;
      outIndex = nextIndex;
      if (end > numIndices) {
        break;
      }
    }
    if (uninitializedIndex < outputRows) {
      output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);
    }
    return [output, outputShape];
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const sqrtImpl = createSimpleUnaryImpl((xi) => Math.sqrt(xi));
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const squaredDifferenceImpl = createSimpleBinaryKernelImpl((a, b) => {
    const diff = a - b;
    return diff * diff;
  });
  /**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const staticRegexReplaceImpl = createSimpleUnaryImpl((x, attrs) => {
    const { pattern, replaceGlobal, rewrite } = attrs;
    return x.replace(new RegExp(pattern, replaceGlobal ? "g" : ""), rewrite);
  });
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function stridedSliceImpl(outShape, xBuf, strides, begin) {
    const outBuf = buffer(outShape, xBuf.dtype);
    for (let i = 0; i < outBuf.size; i++) {
      const loc = outBuf.indexToLoc(i);
      const newLoc = new Array(loc.length);
      for (let j2 = 0; j2 < newLoc.length; j2++) {
        newLoc[j2] = loc[j2] * strides[j2] + begin[j2];
      }
      outBuf.set(xBuf.get(...newLoc), ...loc);
    }
    return outBuf;
  }
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class StringNGramsOp {
    constructor(separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
      this.separator = encodeString(separator);
      this.nGramWidths = nGramWidths;
      this.leftPad = encodeString(leftPad);
      this.rightPad = encodeString(rightPad2);
      this.padWidth = padWidth;
      this.preserveShort = preserveShortSequences;
    }
    getPadWidth(nGramWidth) {
      return Math.min(this.padWidth < 0 ? nGramWidth - 1 : this.padWidth, nGramWidth - 1);
    }
    getNumNGrams(length, nGramWidth) {
      const padWidth = this.getPadWidth(nGramWidth);
      return Math.max(0, length + 2 * padWidth - nGramWidth + 1);
    }
    createNGrams(data, splitIndex, output, outputStartIndex, numNGrams, nGramWidth) {
      for (let nGramIndex = 0; nGramIndex < numNGrams; ++nGramIndex) {
        const padWidth = this.getPadWidth(nGramWidth);
        const leftPadding = Math.max(0, padWidth - nGramIndex);
        const rightPadding = Math.max(0, padWidth - (numNGrams - (nGramIndex + 1)));
        const numTokens = nGramWidth - (leftPadding + rightPadding);
        const dataStartIndex = splitIndex + (leftPadding > 0 ? 0 : nGramIndex - padWidth);
        let nGramSize = 0;
        nGramSize += leftPadding * this.leftPad.length;
        for (let n = 0; n < numTokens; ++n) {
          nGramSize += data[dataStartIndex + n].length;
        }
        nGramSize += rightPadding * this.rightPad.length;
        const numSeparators = leftPadding + rightPadding + numTokens - 1;
        nGramSize += numSeparators * this.separator.length;
        output[outputStartIndex + nGramIndex] = new Uint8Array(nGramSize);
        const nGram = output[outputStartIndex + nGramIndex];
        let nextNGramIndex = 0;
        const appendToNGram = (str) => str.forEach((value) => nGram[nextNGramIndex++] = value);
        for (let n = 0; n < leftPadding; ++n) {
          appendToNGram(this.leftPad);
          appendToNGram(this.separator);
        }
        for (let n = 0; n < numTokens - 1; ++n) {
          appendToNGram(data[dataStartIndex + n]);
          appendToNGram(this.separator);
        }
        if (numTokens > 0) {
          appendToNGram(data[dataStartIndex + numTokens - 1]);
          for (let n = 0; n < rightPadding; ++n) {
            appendToNGram(this.separator);
            appendToNGram(this.rightPad);
          }
        } else {
          for (let n = 0; n < rightPadding - 1; ++n) {
            appendToNGram(this.rightPad);
            appendToNGram(this.separator);
          }
          appendToNGram(this.rightPad);
        }
      }
    }
    // Data and splits together form the definition of the ragged tensor,
    // where data is 1 dimensional and contains the values of the tensor
    // and splits denotes the indices at which each row starts.
    compute(data, splits) {
      const inputDataSize = data.length;
      const splitsSize = splits.length;
      if (splitsSize > 0) {
        let prevSplit = splits[0];
        if (prevSplit !== 0) {
          throw new Error(`First split value must be 0, got ${prevSplit}`);
        }
        for (let i = 1; i < splitsSize; ++i) {
          let validSplits = splits[i] >= prevSplit;
          validSplits = validSplits && splits[i] <= inputDataSize;
          if (!validSplits) {
            throw new Error(`Invalid split value ${splits[i]}, must be in [${prevSplit}, ${inputDataSize}]`);
          }
          prevSplit = splits[i];
        }
        if (prevSplit !== inputDataSize) {
          throw new Error(`Last split value must be data size. Expected ${inputDataSize}, got ${prevSplit}`);
        }
      }
      const numBatchItems = splitsSize - 1;
      const nGramsSplits = getArrayFromDType("int32", splitsSize);
      if (inputDataSize === 0 || splitsSize === 0) {
        const empty = new Array(inputDataSize);
        for (let i = 0; i <= numBatchItems; ++i) {
          nGramsSplits[i] = 0;
        }
        return [empty, nGramsSplits];
      }
      nGramsSplits[0] = 0;
      for (let i = 1; i <= numBatchItems; ++i) {
        const length = splits[i] - splits[i - 1];
        let numNGrams = 0;
        this.nGramWidths.forEach((nGramWidth) => {
          numNGrams += this.getNumNGrams(length, nGramWidth);
        });
        if (this.preserveShort && length > 0 && numNGrams === 0) {
          numNGrams = 1;
        }
        nGramsSplits[i] = nGramsSplits[i - 1] + numNGrams;
      }
      const nGrams = new Array(nGramsSplits[numBatchItems]);
      for (let i = 0; i < numBatchItems; ++i) {
        const splitIndex = splits[i];
        let outputStartIdx = nGramsSplits[i];
        this.nGramWidths.forEach((nGramWidth) => {
          const length = splits[i + 1] - splits[i];
          const numNGrams = this.getNumNGrams(length, nGramWidth);
          this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
          outputStartIdx += numNGrams;
        });
        if (this.preserveShort && outputStartIdx === nGramsSplits[i]) {
          const dataLength = splits[i + 1] - splits[i];
          if (dataLength === 0) {
            continue;
          }
          const nGramWidth = dataLength + 2 * this.padWidth;
          const numNGrams = 1;
          this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
        }
      }
      return [nGrams, nGramsSplits];
    }
  }
  function stringNGramsImpl(data, dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
    return new StringNGramsOp(separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences).compute(data, dataSplits);
  }
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function split$1(str, delimiters, skipEmpty, result) {
    if (!str.length) {
      return;
    }
    if (delimiters.length === 0) {
      for (let i = 0; i < str.length; ++i) {
        result.push(str.subarray(i, i + 1));
      }
      return;
    }
    if (delimiters.length === 1) {
      const delimiter = delimiters[0];
      let f = str.indexOf(delimiter);
      while (f !== -1) {
        const token = str.subarray(0, f);
        if (!skipEmpty || token.length !== 0) {
          result.push(token);
        }
        str = str.subarray(f + 1);
        f = str.indexOf(delimiter);
      }
      if (!skipEmpty || str.length !== 0) {
        result.push(str);
      }
      return;
    }
    let tokenStart = 0;
    for (let i = 0; i < str.length + 1; i++) {
      if (i === str.length || delimiters.indexOf(str[i]) !== -1) {
        const token = str.subarray(tokenStart, i);
        if (!skipEmpty || token.length !== 0) {
          result.push(token);
        }
        tokenStart = i + 1;
      }
    }
  }
  function stringSplitImpl(input, delimiter, skipEmpty) {
    const batchSize = input.length;
    const tokens = [];
    let outputSize = 0;
    let maxNumEntries = 0;
    const numIndices = new Array(batchSize);
    for (let i = 0; i < batchSize; ++i) {
      const prevTokensLength = tokens.length;
      split$1(input[i], delimiter, skipEmpty, tokens);
      const nEntries = tokens.length - prevTokensLength;
      numIndices[i] = nEntries;
      outputSize += nEntries;
      maxNumEntries = Math.max(maxNumEntries, nEntries);
    }
    const indices = getArrayFromDType("int32", outputSize * 2);
    const values = new Array(outputSize);
    const shape = [batchSize, maxNumEntries];
    let c = 0;
    for (let i = 0; i < batchSize; ++i) {
      for (let j2 = 0; j2 < numIndices[i]; ++j2) {
        indices[c * 2] = i;
        indices[c * 2 + 1] = j2;
        values[c] = tokens[c];
        ++c;
      }
    }
    return [indices, values, shape];
  }
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function stringToHashBucketFastImpl(input, numBuckets) {
    const output = getArrayFromDType("int32", input.length);
    for (let i = 0; i < input.length; ++i) {
      output[i] = fingerPrint64(input[i]).modulo(numBuckets).getLowBitsUnsigned();
    }
    return output;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const subImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue - bValue);
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tileImpl(xBuf, reps) {
    const newShape = new Array(xBuf.rank);
    for (let i = 0; i < newShape.length; i++) {
      newShape[i] = xBuf.shape[i] * reps[i];
    }
    const result = buffer(newShape, xBuf.dtype);
    for (let i = 0; i < result.values.length; ++i) {
      const newLoc = result.indexToLoc(i);
      const originalLoc = new Array(xBuf.rank);
      for (let j2 = 0; j2 < originalLoc.length; j2++) {
        originalLoc[j2] = newLoc[j2] % xBuf.shape[j2];
      }
      const originalIndex = xBuf.locToIndex(originalLoc);
      result.values[i] = xBuf.values[originalIndex];
    }
    return result;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const comparePair = (a, b) => {
    const valueDiff = b.value - a.value;
    return valueDiff === 0 ? a.index - b.index : valueDiff;
  };
  function select$1(array, k3, left = 0, right = array.length - 1) {
    while (right > left) {
      if (right - left > 600) {
        const n = right - left + 1;
        const i2 = k3 - left + 1;
        const z2 = Math.log(n);
        const s = 0.5 * Math.exp(2 * z2 / 3);
        const sd = 0.5 * Math.sqrt(z2 * s * (n - s) / n) * Math.sign(i2 - n / 2);
        const newLeft = Math.max(left, Math.floor(k3 - i2 * s / n + sd));
        const newRight = Math.min(right, Math.floor(k3 + (n - i2) * s / n + sd));
        select$1(array, k3, newLeft, newRight);
      }
      const t = array[k3];
      let i = left;
      let j2 = right;
      swap(array, left, k3);
      if (comparePair(array[right], t) > 0) {
        swap(array, left, right);
      }
      while (i < j2) {
        swap(array, i, j2);
        i++;
        j2--;
        while (comparePair(array[i], t) < 0) {
          i = i + 1;
        }
        while (comparePair(array[j2], t) > 0) {
          j2 = j2 - 1;
        }
      }
      if (comparePair(array[left], t) === 0) {
        swap(array, left, j2);
      } else {
        j2 = j2 + 1;
        swap(array, j2, right);
      }
      if (j2 <= k3) {
        left = j2 + 1;
      }
      if (k3 <= j2) {
        right = j2 - 1;
      }
    }
  }
  function topKImpl(x, xShape, xDtype, k3, sorted) {
    const lastDim = xShape[xShape.length - 1];
    const [batch, size] = [x.length / lastDim, lastDim];
    const allTopKVals = getTypedArrayFromDType(xDtype, batch * k3);
    const allTopKIndices = getTypedArrayFromDType("int32", batch * k3);
    for (let b = 0; b < batch; b++) {
      const offset = b * size;
      const vals = x.subarray(offset, offset + size);
      let valAndInd = new Array(vals.length);
      vals.forEach((value, index2) => valAndInd[index2] = { value, index: index2 });
      if (k3 < valAndInd.length) {
        select$1(valAndInd, k3);
        valAndInd = valAndInd.slice(0, k3);
      }
      if (sorted) {
        valAndInd.sort(comparePair);
      }
      const outOffset = b * k3;
      const topKVals = allTopKVals.subarray(outOffset, outOffset + k3);
      const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k3);
      for (let i = 0; i < k3; i++) {
        topKVals[i] = valAndInd[i].value;
        topKIndices[i] = valAndInd[i].index;
      }
    }
    const outputShape = xShape.slice();
    outputShape[outputShape.length - 1] = k3;
    return [
      buffer(outputShape, xDtype, allTopKVals),
      buffer(outputShape, "int32", allTopKIndices)
    ];
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function uniqueImpl(values, axis, shape, dtype) {
    const $axis = parseAxisParam(axis, shape)[0];
    const newShape = [1, shape[0], 1];
    for (let i = 0; i < $axis; i++) {
      newShape[0] *= shape[i];
    }
    newShape[1] = shape[$axis];
    for (let i = $axis + 1; i < shape.length; i++) {
      newShape[2] *= shape[i];
    }
    const uniqueElements = /* @__PURE__ */ new Map();
    const indices = new Int32Array(shape[$axis]);
    const inputBuffer = new TensorBuffer(newShape, dtype, values);
    const uniqueIndices = [];
    const is1DTensor = newShape[0] === 1 && newShape[2] === 1;
    for (let i = 0; i < shape[$axis]; i++) {
      let element;
      if (is1DTensor) {
        element = values[i].toString();
      } else {
        const axisValues = [];
        for (let m = 0; m < newShape[0]; m++) {
          for (let n = 0; n < newShape[2]; n++) {
            axisValues.push(inputBuffer.get(m, i, n));
          }
        }
        element = axisValues.join(",");
      }
      const existingIndex = uniqueElements.get(element);
      if (existingIndex != null) {
        indices[i] = existingIndex;
      } else {
        const uniqueIndex = uniqueElements.size;
        uniqueElements.set(element, uniqueIndex);
        indices[i] = uniqueIndex;
        uniqueIndices.push(i);
      }
    }
    const outputTmpShape = newShape.slice();
    outputTmpShape[1] = uniqueElements.size;
    const outputBuffer = new TensorBuffer(outputTmpShape, dtype);
    uniqueIndices.forEach((uniqueElementIndex, i) => {
      for (let m = 0; m < newShape[0]; m++) {
        for (let n = 0; n < newShape[2]; n++) {
          outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);
        }
      }
    });
    const outputShape = shape.slice();
    outputShape[$axis] = outputTmpShape[1];
    return {
      outputValues: outputBuffer.values,
      outputShape,
      indices
    };
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const shared = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    addImpl,
    bincountImpl,
    bincountReduceImpl,
    bitwiseAndImpl,
    castImpl,
    ceilImpl,
    concatImpl: concatImpl$1,
    equalImpl,
    expImpl,
    expm1Impl,
    floorDivImpl,
    floorImpl,
    gatherNdImpl,
    gatherV2Impl,
    greaterEqualImpl,
    greaterImpl,
    lessEqualImpl,
    lessImpl,
    linSpaceImpl,
    logImpl,
    maxImpl: maxImpl$1,
    maximumImpl,
    minimumImpl,
    multiplyImpl,
    negImpl,
    notEqualImpl,
    prodImpl,
    raggedGatherImpl,
    raggedRangeImpl,
    raggedTensorToTensorImpl,
    rangeImpl,
    rsqrtImpl,
    scatterImpl,
    sigmoidImpl,
    simpleAbsImpl,
    sliceImpl,
    sparseFillEmptyRowsImpl,
    sparseReshapeImpl,
    sparseSegmentReductionImpl,
    sqrtImpl,
    squaredDifferenceImpl,
    staticRegexReplaceImpl,
    stridedSliceImpl,
    stringNGramsImpl,
    stringSplitImpl,
    stringToHashBucketFastImpl,
    subImpl,
    tileImpl,
    topKImpl,
    transposeImpl: transposeImpl$1,
    uniqueImpl
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const { addImpl: addImplCPU, bincountImpl: bincountImplCPU, bincountReduceImpl: bincountReduceImplCPU, bitwiseAndImpl: bitwiseAndImplCPU, castImpl: castImplCPU, ceilImpl: ceilImplCPU, concatImpl: concatImplCPU, equalImpl: equalImplCPU, expImpl: expImplCPU, expm1Impl: expm1ImplCPU, floorImpl: floorImplCPU, gatherNdImpl: gatherNdImplCPU, gatherV2Impl: gatherV2ImplCPU, greaterImpl: greaterImplCPU, greaterEqualImpl: greaterEqualImplCPU, lessImpl: lessImplCPU, lessEqualImpl: lessEqualImplCPU, linSpaceImpl: linSpaceImplCPU, logImpl: logImplCPU, maxImpl: maxImplCPU, maximumImpl: maximumImplCPU, minimumImpl: minimumImplCPU, multiplyImpl: multiplyImplCPU, negImpl: negImplCPU, notEqualImpl: notEqualImplCPU, prodImpl: prodImplCPU, raggedGatherImpl: raggedGatherImplCPU, raggedRangeImpl: raggedRangeImplCPU, raggedTensorToTensorImpl: raggedTensorToTensorImplCPU, rangeImpl: rangeImplCPU, rsqrtImpl: rsqrtImplCPU, scatterImpl: scatterImplCPU, sigmoidImpl: sigmoidImplCPU, simpleAbsImpl: simpleAbsImplCPU, sliceImpl: sliceImplCPU, sparseFillEmptyRowsImpl: sparseFillEmptyRowsImplCPU, sparseReshapeImpl: sparseReshapeImplCPU, sparseSegmentReductionImpl: sparseSegmentReductionImplCPU, sqrtImpl: sqrtImplCPU, staticRegexReplaceImpl: staticRegexReplaceImplCPU, stridedSliceImpl: stridedSliceImplCPU, stringNGramsImpl: stringNGramsImplCPU, stringSplitImpl: stringSplitImplCPU, stringToHashBucketFastImpl: stringToHashBucketFastImplCPU, subImpl: subImplCPU, tileImpl: tileImplCPU, topKImpl: topKImplCPU, transposeImpl: transposeImplCPU, uniqueImpl: uniqueImplCPU } = shared;
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getVecChannels(name, rank) {
    return ["x", "y", "z", "w", "u", "v"].slice(0, rank).map((d) => `${name}.${d}`);
  }
  function getChannels(name, rank) {
    if (rank === 1) {
      return [name];
    }
    return getVecChannels(name, rank);
  }
  function getSourceCoords$2(rank, dims) {
    if (rank === 1) {
      return "rc";
    }
    let coords2 = "";
    for (let i = 0; i < rank; i++) {
      coords2 += dims[i];
      if (i < rank - 1) {
        coords2 += ",";
      }
    }
    return coords2;
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class PackProgram {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = false;
      this.packedOutput = true;
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      if (this.rank === 0) {
        this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
      } else {
        const channels = getChannels("rc", this.rank);
        const dtype = getCoordsDataType(this.rank);
        const outOfBoundsCondition = this.getOutOfBoundsCondition(channels);
        const setup = this.getSetup(channels);
        const output = this.getOutput(channels);
        this.userCode = `
        void main() {
          ${dtype} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            setOutput(vec4(0));
          } else {
            ${setup}

            setOutput(vec4(${output}));
          }
        }
      `;
      }
    }
    getSourceCoordsArr(dims) {
      const coords2 = [];
      for (let row = 0; row <= 1; row++) {
        for (let col = 0; col <= 1; col++) {
          let coord = `${row === 0 ? "r" : "rp1"}, ${col === 0 ? "c" : "cp1"}`;
          for (let d = 2; d < this.rank; d++) {
            coord = `${dims[dims.length - 1 - d]},` + coord;
          }
          coords2.push(coord);
        }
      }
      return coords2;
    }
    getOutOfBoundsCondition(dims) {
      if (this.rank === 1) {
        return `rc > ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]}`;
      }
      let cond = "";
      for (let i = this.rank - 2; i < this.rank; i++) {
        cond += `${dims[i]} >= ${this.enableShapeUniforms ? `outShape[${i}]` : this.outputShape[i]}`;
        if (i < this.rank - 1) {
          cond += "||";
        }
      }
      return cond;
    }
    getSetup(dims) {
      if (this.rank === 1) {
        return "";
      }
      const innerDims = dims.slice(-2);
      const col = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1];
      const row = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
      return `
      int r = ${innerDims[0]};
      int c = ${innerDims[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${col};
      bool rEdge = rp1 >= ${row};
    `;
    }
    getOutput(dims) {
      const sourceCoords = this.getSourceCoordsArr(dims);
      if (this.rank === 1) {
        const outShape = this.enableShapeUniforms ? "outShape" : this.outputShape[0];
        return `getA(rc), (rc + 1 >= ${outShape} ? 0. : getA(rc + 1)), 0, 0`;
      }
      return `getA(${sourceCoords[0]}),
            cEdge ? 0. : getA(${sourceCoords[1]}),
            rEdge ? 0. : getA(${sourceCoords[2]}),
            rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ReshapePackedProgram {
    constructor(outputShape, inputShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [{ name: "inputShape", type: "ivec3" }];
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      let mainLoop = ``;
      for (let i = 0; i < 4; i++) {
        let thisRC = `thisRC = rc;`;
        if (i % 2 === 1) {
          thisRC += `thisRC.z += 1;`;
        }
        if (i > 1) {
          thisRC += `thisRC.y += 1;`;
        }
        mainLoop += `
        ${thisRC}
        ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i > 0 ? "}" : ""}
      `;
      }
      this.userCode = `
      ${getReshapedInputCoords(inputShape, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : outputShape[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : outputShape[2]};

        ${mainLoop}

        setOutput(result);
      }
    `;
    }
  }
  function getReshapedInputCoords(shape, enableShapeUniforms) {
    const coordsFromIndexSnippet = enableShapeUniforms ? getLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], "inputShape") : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
    return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class TextureManager {
    constructor(gpgpu) {
      this.gpgpu = gpgpu;
      this.numUsedTextures = 0;
      this.numFreeTextures = 0;
      this._numBytesAllocated = 0;
      this._numBytesFree = 0;
      this.freeTextures = {};
      this.usedTextures = {};
      this.logEnabled = false;
    }
    acquireTexture(shapeRC, usage, isPacked) {
      const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);
      const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);
      if (!(shapeKey in this.freeTextures)) {
        this.freeTextures[shapeKey] = [];
      }
      if (!(shapeKey in this.usedTextures)) {
        this.usedTextures[shapeKey] = [];
      }
      const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
      if (this.freeTextures[shapeKey].length > 0) {
        this.numFreeTextures--;
        this.numUsedTextures++;
        this._numBytesFree -= texBytes;
        this.log();
        const newTexture2 = this.freeTextures[shapeKey].pop();
        this.usedTextures[shapeKey].push(newTexture2);
        return newTexture2;
      }
      let newTexture;
      if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {
        newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);
      } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {
        newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);
      } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {
        newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);
      } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {
        newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);
      } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {
        newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);
      }
      this.usedTextures[shapeKey].push(newTexture);
      this.numUsedTextures++;
      this._numBytesAllocated += texBytes;
      this.log();
      return newTexture;
    }
    releaseTexture(texture, shape, logicalTexType, isPacked) {
      if (this.freeTextures == null) {
        return;
      }
      const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);
      const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);
      if (!(shapeKey in this.freeTextures)) {
        this.freeTextures[shapeKey] = [];
      }
      const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
      const deleteTexThreshold = env().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");
      if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {
        this.gpgpu.deleteMatrixTexture(texture.texture);
        this._numBytesAllocated -= texBytes;
      } else {
        this.freeTextures[shapeKey].push(texture);
        this.numFreeTextures++;
        this._numBytesFree += texBytes;
      }
      this.numUsedTextures--;
      const texList = this.usedTextures[shapeKey];
      const texIndex = texList && texList.indexOf(texture);
      if (texIndex == null || texIndex < 0) {
        throw new Error("Cannot release a texture that was never provided by this texture manager");
      }
      texList[texIndex] = texList[texList.length - 1];
      texList.pop();
      this.log();
    }
    log() {
      if (!this.logEnabled) {
        return;
      }
      const total = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);
      const freeRatio = this._numBytesFree / this._numBytesAllocated;
      console.log(`Bytes allocated: ${this._numBytesAllocated}`);
      console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);
    }
    get numBytesAllocated() {
      return this._numBytesAllocated;
    }
    get numBytesFree() {
      return this._numBytesFree;
    }
    getNumUsedTextures() {
      return this.numUsedTextures;
    }
    getNumFreeTextures() {
      return this.numFreeTextures;
    }
    dispose() {
      if (this.freeTextures == null) {
        return;
      }
      for (const texShape in this.freeTextures) {
        this.freeTextures[texShape].forEach((tex) => {
          this.gpgpu.deleteMatrixTexture(tex.texture);
        });
      }
      for (const texShape in this.usedTextures) {
        this.usedTextures[texShape].forEach((tex) => {
          this.gpgpu.deleteMatrixTexture(tex.texture);
        });
      }
      this.freeTextures = null;
      this.usedTextures = null;
      this.numUsedTextures = 0;
      this.numFreeTextures = 0;
      this._numBytesAllocated = 0;
      this._numBytesFree = 0;
    }
  }
  function numBytesForInternalFormat(gl, internalFormat) {
    const glany = gl;
    if (internalFormat === glany.R32F) {
      return 4;
    } else if (internalFormat === glany.R16F) {
      return 2;
    } else if (internalFormat === glany.RGBA32F) {
      return 16;
    } else if (internalFormat === gl.RGBA) {
      return 16;
    } else if (internalFormat === glany.RGBA16F) {
      return 8;
    } else if (internalFormat === glany.RGBA8) {
      return 4;
    }
    throw new Error(`Unknown internal format ${internalFormat}`);
  }
  function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {
    const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);
    let numElements;
    if (isPacked) {
      const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
      numElements = packedWidth * packedHeight;
    } else {
      const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
      numElements = width * height;
    }
    const bytesPerElement2 = numBytesForInternalFormat(gl, internalFormat);
    return numElements * bytesPerElement2;
  }
  function internalFormatForPhysicalTexType(physicalTexType, textureConfig) {
    switch (physicalTexType) {
      case PhysicalTextureType.PACKED_2X2_FLOAT32:
        return getInternalFormatForPackedMatrixTexture(textureConfig);
      case PhysicalTextureType.PACKED_2X2_FLOAT16:
        return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);
      case PhysicalTextureType.UNPACKED_FLOAT32:
        return getInternalFormatForFloat32MatrixTexture(textureConfig);
      case PhysicalTextureType.UNPACKED_FLOAT16:
        return getInternalFormatForFloat16MatrixTexture(textureConfig);
      case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:
        return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);
      default:
        throw new Error(`Unknown physical texture type ${physicalTexType}`);
    }
  }
  function getPhysicalTextureForRendering(isPacked) {
    if (env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")) {
      if (isPacked) {
        return PhysicalTextureType.PACKED_2X2_FLOAT32;
      }
      return PhysicalTextureType.UNPACKED_FLOAT32;
    }
    if (isPacked) {
      return PhysicalTextureType.PACKED_2X2_FLOAT16;
    }
    return PhysicalTextureType.UNPACKED_FLOAT16;
  }
  function getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {
    if (logicalTexType === TextureUsage.UPLOAD) {
      return PhysicalTextureType.PACKED_2X2_FLOAT32;
    } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {
      return getPhysicalTextureForRendering(isPacked);
    } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {
      return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;
    }
    throw new Error(`Unknown logical texture type ${logicalTexType}`);
  }
  function getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {
    return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class UnaryOpProgram {
    constructor(aShape, opSnippet) {
      this.variableNames = ["A"];
      this.outputShape = aShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      float unaryOperation(float x) {
        ${opSnippet}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  }
  const CHECK_NAN_SNIPPET$1 = `if (isnan(x)) return x;`;
  const LINEAR$1 = `return x;`;
  const ABS$1 = `return abs(x);`;
  const ELU$2 = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
  const RELU$2 = CHECK_NAN_SNIPPET$1 + `
  return (x < 0.0) ? 0.0 : x;
`;
  const RELU6$2 = CHECK_NAN_SNIPPET$1 + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
  const CLONE = "return x;";
  const SIGMOID$2 = `return 1.0 / (1.0 + exp(-1.0 * x));`;
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const LINEAR = `return x;`;
  const ELU$1 = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
  const RELU$1 = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  const RELU6$1 = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  const SIGMOID$1 = `return 1.0 / (1.0 + exp(-1.0 * x));`;
  class UnaryOpPackedProgram {
    constructor(aShape, opSnippet) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = aShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${opSnippet}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class UnpackProgram {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = false;
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const rank = outputShape.length;
      const channels = getChannels("rc", rank);
      const dtype = getCoordsDataType(rank);
      const sourceCoords = getSourceCoords$2(rank, channels);
      const innerDims = channels.slice(-2);
      const coords2 = rank <= 1 ? "rc" : `vec2(${innerDims.join(",")})`;
      this.userCode = `
      void main() {
        ${dtype} rc = getOutputCoords();
        vec4 packedInput = getA(${sourceCoords});

        setOutput(getChannel(packedInput, ${coords2}));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const whereImpl = whereImpl$1;
  const EPSILON_FLOAT32 = 1e-7;
  const EPSILON_FLOAT16 = 1e-4;
  const binaryCaches = {};
  function getBinaryCache(webGLVersion) {
    if (webGLVersion in binaryCaches) {
      return binaryCaches[webGLVersion];
    }
    binaryCaches[webGLVersion] = {};
    return binaryCaches[webGLVersion];
  }
  const CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
  const BEFORE_PAGING_CONSTANT = 600;
  function numMBBeforeWarning() {
    if (env().global.screen == null) {
      return 1024;
    }
    return env().global.screen.height * env().global.screen.width * window.devicePixelRatio * BEFORE_PAGING_CONSTANT / 1024 / 1024;
  }
  class MathBackendWebGL extends KernelBackend {
    nextDataId() {
      return MathBackendWebGL.nextDataId++;
    }
    constructor(gpuResource) {
      super();
      this.pendingRead = /* @__PURE__ */ new WeakMap();
      this.pendingDisposal = /* @__PURE__ */ new WeakSet();
      this.dataRefCount = /* @__PURE__ */ new WeakMap();
      this.numBytesInGPU = 0;
      this.uploadWaitMs = 0;
      this.downloadWaitMs = 0;
      this.lastGlFlushTime = 0;
      this.warnedAboutMemory = false;
      this.pendingDeletes = 0;
      this.disposed = false;
      if (!env().getBool("HAS_WEBGL")) {
        throw new Error("WebGL is not supported on this device");
      }
      let newGPGPU;
      if (gpuResource != null) {
        if (gpuResource instanceof GPGPUContext) {
          newGPGPU = gpuResource;
        } else {
          const gl = getWebGLContext(env().getNumber("WEBGL_VERSION"), gpuResource);
          newGPGPU = new GPGPUContext(gl);
        }
        this.binaryCache = {};
        this.gpgpuCreatedLocally = false;
      } else {
        const gl = getWebGLContext(env().getNumber("WEBGL_VERSION"));
        newGPGPU = new GPGPUContext(gl);
        this.binaryCache = getBinaryCache(env().getNumber("WEBGL_VERSION"));
        this.gpgpuCreatedLocally = true;
      }
      this.gpgpu = newGPGPU;
      this.canvas = this.gpgpu.gl.canvas;
      this.textureManager = new TextureManager(this.gpgpu);
      this.numMBBeforeWarning = numMBBeforeWarning();
      this.texData = new DataStorage(this, engine());
    }
    numDataIds() {
      return this.texData.numDataIds() - this.pendingDeletes;
    }
    // Writes a new entry to the data store with a WebGL texture, and registers it
    // to the texture manager.
    writeTexture(texture, shape, dtype, texHeight, texWidth, channels) {
      const input = this.makeTensorInfo(shape, dtype);
      const inData = this.texData.get(input.dataId);
      inData.isPacked = false;
      inData.texture = { texture, texShape: [texHeight, texWidth] };
      inData.texShape = [texHeight, texWidth];
      const shapeAs3D = getShapeAs3D(shape);
      const program = new EncodeMatrixProgram(shapeAs3D, false, channels);
      const output = this.runWebGLProgram(program, [input], dtype, [[texHeight, texWidth]]);
      output.shape = shape;
      inData.texture = null;
      this.disposeIntermediateTensorInfo(input);
      return output.dataId;
    }
    write(values, shape, dtype) {
      if (env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || env().getBool("DEBUG")) {
        this.checkNumericalProblems(values);
      }
      if (dtype === "complex64" && values != null) {
        throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
      }
      const dataId = { id: this.nextDataId() };
      this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount: 1 });
      return dataId;
    }
    /** Return refCount of a `TensorData`. */
    refCount(dataId) {
      if (this.texData.has(dataId)) {
        const tensorData = this.texData.get(dataId);
        return tensorData.refCount;
      }
      return 0;
    }
    /** Increase refCount of a `TextureData`. */
    incRef(dataId) {
      const texData = this.texData.get(dataId);
      texData.refCount++;
    }
    /** Decrease refCount of a `TextureData`. */
    decRef(dataId) {
      if (this.texData.has(dataId)) {
        const texData = this.texData.get(dataId);
        texData.refCount--;
      }
    }
    move(dataId, values, shape, dtype, refCount) {
      if (env().getBool("DEBUG")) {
        this.checkNumericalProblems(values);
      }
      if (dtype === "complex64") {
        throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
      }
      this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount });
    }
    disposeIntermediateTensorInfo(tensorInfo) {
      this.disposeData(tensorInfo.dataId);
    }
    readSync(dataId) {
      const texData = this.texData.get(dataId);
      const { values, dtype, complexTensorInfos, slice: slice2, shape, isPacked } = texData;
      if (slice2 != null) {
        let program;
        if (isPacked) {
          program = new UnaryOpPackedProgram(shape, CLONE);
        } else {
          program = new UnaryOpProgram(shape, CLONE);
        }
        const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
        const data = this.readSync(res.dataId);
        this.disposeIntermediateTensorInfo(res);
        return data;
      }
      if (values != null) {
        return this.convertAndCacheOnCPU(dataId);
      }
      if (dtype === "string") {
        return values;
      }
      const shouldTimeProgram = this.activeTimers != null;
      let start;
      if (shouldTimeProgram) {
        start = now();
      }
      let result;
      if (dtype === "complex64") {
        const realValues = this.readSync(complexTensorInfos.real.dataId);
        const imagValues = this.readSync(complexTensorInfos.imag.dataId);
        result = mergeRealAndImagArrays(realValues, imagValues);
      } else {
        result = this.getValuesFromTexture(dataId);
      }
      if (shouldTimeProgram) {
        this.downloadWaitMs += now() - start;
      }
      return this.convertAndCacheOnCPU(dataId, result);
    }
    async read(dataId) {
      if (this.pendingRead.has(dataId)) {
        const subscribers2 = this.pendingRead.get(dataId);
        return new Promise((resolve) => subscribers2.push(resolve));
      }
      const texData = this.texData.get(dataId);
      const { values, shape, slice: slice2, dtype, complexTensorInfos, isPacked } = texData;
      if (slice2 != null) {
        let program;
        if (isPacked) {
          program = new UnaryOpPackedProgram(shape, CLONE);
        } else {
          program = new UnaryOpProgram(shape, CLONE);
        }
        const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
        const data = this.read(res.dataId);
        this.disposeIntermediateTensorInfo(res);
        return data;
      }
      if (values != null) {
        return this.convertAndCacheOnCPU(dataId);
      }
      if (env().getBool("DEBUG")) {
        if (!env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && env().getNumber("WEBGL_VERSION") === 2) {
          throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.`);
        }
      }
      let buffer2 = null;
      let tmpDownloadTarget;
      if (dtype !== "complex64" && env().get("WEBGL_BUFFER_SUPPORTED")) {
        tmpDownloadTarget = this.decode(dataId);
        const tmpData = this.texData.get(tmpDownloadTarget.dataId);
        buffer2 = this.gpgpu.createBufferFromTexture(tmpData.texture.texture, ...getDenseTexShape(shape));
      }
      this.pendingRead.set(dataId, []);
      if (dtype !== "complex64") {
        await this.gpgpu.createAndWaitForFence();
      }
      let vals;
      if (dtype === "complex64") {
        const ps = await Promise.all([
          this.read(complexTensorInfos.real.dataId),
          this.read(complexTensorInfos.imag.dataId)
        ]);
        const realValues = ps[0];
        const imagValues = ps[1];
        vals = mergeRealAndImagArrays(realValues, imagValues);
      } else if (buffer2 == null) {
        vals = this.getValuesFromTexture(dataId);
      } else {
        const size = sizeFromShape(shape);
        vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer2, size);
      }
      if (tmpDownloadTarget != null) {
        this.disposeIntermediateTensorInfo(tmpDownloadTarget);
      }
      if (buffer2 != null) {
        const gl = this.gpgpu.gl;
        callAndCheck(gl, () => gl.deleteBuffer(buffer2));
      }
      const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);
      const subscribers = this.pendingRead.get(dataId);
      this.pendingRead.delete(dataId);
      subscribers.forEach((resolve) => resolve(dTypeVals));
      if (this.pendingDisposal.has(dataId)) {
        this.pendingDisposal.delete(dataId);
        if (this.disposeData(dataId)) {
          engine().removeDataId(dataId, this);
        }
        this.pendingDeletes--;
      }
      return dTypeVals;
    }
    /**
     * Read tensor to a new texture that is densely packed for ease of use.
     * @param dataId The source tensor.
     * @param options
     *     customTexShape: Optional. If set, will use the user defined texture
     *     shape to create the texture.
     */
    readToGPU(dataId, options = {}) {
      const texData = this.texData.get(dataId);
      const { values, shape, slice: slice2, dtype, isPacked, texture } = texData;
      if (dtype === "complex64") {
        throw new Error("Does not support reading texture for complex64 dtype.");
      }
      if (slice2 != null) {
        let program;
        if (isPacked) {
          program = new UnaryOpPackedProgram(shape, CLONE);
        } else {
          program = new UnaryOpProgram(shape, CLONE);
        }
        const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
        const gpuResouorce = this.readToGPU(res, options);
        this.disposeIntermediateTensorInfo(res);
        return gpuResouorce;
      }
      if (texture == null) {
        if (values != null) {
          throw new Error("Data is not on GPU but on CPU.");
        } else {
          throw new Error("There is no data on GPU or CPU.");
        }
      }
      const tmpTarget = this.decode(dataId, options.customTexShape);
      const tensorRef = engine().makeTensorFromTensorInfo(tmpTarget);
      const tmpData = this.texData.get(tmpTarget.dataId);
      return Object.assign({ tensorRef }, tmpData.texture);
    }
    bufferSync(t) {
      const data = this.readSync(t.dataId);
      if (t.dtype === "string") {
        try {
          const strings = data.map((d) => decodeString(d));
          return buffer(t.shape, t.dtype, strings);
        } catch (_a) {
          throw new Error("Failed to decode encoded string bytes into utf-8");
        }
      }
      return buffer(t.shape, t.dtype, data);
    }
    checkNumericalProblems(values) {
      if (values == null) {
        return;
      }
      for (let i = 0; i < values.length; i++) {
        const num = values[i];
        if (!canBeRepresented(num)) {
          if (env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) {
            throw Error(`The value ${num} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);
          }
          throw Error(`The value ${num} cannot be represented on this device.`);
        }
      }
    }
    getValuesFromTexture(dataId) {
      const { shape, dtype, isPacked } = this.texData.get(dataId);
      const size = sizeFromShape(shape);
      if (env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
        const tmpTarget = this.decode(dataId);
        const tmpData2 = this.texData.get(tmpTarget.dataId);
        const vals2 = this.gpgpu.downloadMatrixFromPackedTexture(tmpData2.texture.texture, ...getDenseTexShape(shape)).subarray(0, size);
        this.disposeIntermediateTensorInfo(tmpTarget);
        return vals2;
      }
      const shouldUsePackedProgram = env().getBool("WEBGL_PACK") && isPacked === true;
      const outputShape = shouldUsePackedProgram ? getShapeAs3D(shape) : shape;
      const program = shouldUsePackedProgram ? new EncodeFloatPackedProgram(outputShape) : new EncodeFloatProgram(outputShape);
      const output = this.runWebGLProgram(program, [{ shape: outputShape, dtype, dataId }], "float32");
      const tmpData = this.texData.get(output.dataId);
      const vals = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture.texture, tmpData.texShape[0], tmpData.texShape[1]).subarray(0, size);
      this.disposeIntermediateTensorInfo(output);
      return vals;
    }
    timerAvailable() {
      return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
    }
    time(f) {
      const oldActiveTimers = this.activeTimers;
      const newActiveTimers = [];
      let outerMostTime = false;
      if (this.programTimersStack == null) {
        this.programTimersStack = newActiveTimers;
        outerMostTime = true;
      } else {
        this.activeTimers.push(newActiveTimers);
      }
      this.activeTimers = newActiveTimers;
      f();
      const flattenedActiveTimerQueries = flatten(this.activeTimers.map((d) => d.query)).filter((d) => d != null);
      const flattenedActiveTimerNames = flatten(this.activeTimers.map((d) => d.name)).filter((d) => d != null);
      this.activeTimers = oldActiveTimers;
      if (outerMostTime) {
        this.programTimersStack = null;
      }
      const res = {
        uploadWaitMs: this.uploadWaitMs,
        downloadWaitMs: this.downloadWaitMs,
        kernelMs: null,
        wallMs: null
        // will be filled by the engine
      };
      return (async () => {
        if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          const kernelMs = await Promise.all(flattenedActiveTimerQueries);
          res["kernelMs"] = sum$2(kernelMs);
          res["getExtraProfileInfo"] = () => kernelMs.map((d, i) => ({ name: flattenedActiveTimerNames[i], ms: d })).map((d) => `${d.name}: ${d.ms}`).join(", ");
        } else {
          res["kernelMs"] = {
            error: "WebGL query timers are not supported in this environment."
          };
        }
        this.uploadWaitMs = 0;
        this.downloadWaitMs = 0;
        return res;
      })();
    }
    memory() {
      return {
        unreliable: false,
        numBytesInGPU: this.numBytesInGPU,
        numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
        numBytesInGPUFree: this.textureManager.numBytesFree
      };
    }
    startTimer() {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        return this.gpgpu.beginQuery();
      }
      return { startMs: now(), endMs: null };
    }
    endTimer(query) {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        this.gpgpu.endQuery();
        return query;
      }
      query.endMs = now();
      return query;
    }
    async getQueryTime(query) {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        return this.gpgpu.waitForQueryAndGetTime(query);
      }
      const timerQuery = query;
      return timerQuery.endMs - timerQuery.startMs;
    }
    /**
     * Decrease the RefCount on the dataId and dispose the memory if the dataId
     * has 0 refCount. If there are pending read on the data, the disposal would
     * added to the pending delete queue. Return true if the dataId is removed
     * from backend or the backend does not contain the dataId, false if the
     * dataId is not removed. Memory may or may not be released even when dataId
     * is removed, which also depends on dataRefCount, see `releaseGPU`.
     * @param dataId
     * @oaram force Optional, remove the data regardless of refCount
     */
    disposeData(dataId, force = false) {
      if (this.pendingDisposal.has(dataId)) {
        return false;
      }
      if (!this.texData.has(dataId)) {
        return true;
      }
      if (force) {
        this.texData.get(dataId).refCount = 0;
      } else {
        this.texData.get(dataId).refCount--;
      }
      if (!force && this.texData.get(dataId).refCount > 0) {
        return false;
      }
      if (this.pendingRead.has(dataId)) {
        this.pendingDisposal.add(dataId);
        this.pendingDeletes++;
        return false;
      }
      this.releaseGPUData(dataId);
      const { complexTensorInfos } = this.texData.get(dataId);
      if (complexTensorInfos != null) {
        this.disposeData(complexTensorInfos.real.dataId, force);
        this.disposeData(complexTensorInfos.imag.dataId, force);
      }
      this.texData.delete(dataId);
      return true;
    }
    releaseGPUData(dataId) {
      const { texture, dtype, texShape, usage, isPacked, slice: slice2 } = this.texData.get(dataId);
      const key = slice2 && slice2.origDataId || dataId;
      const refCount = this.dataRefCount.get(key);
      if (refCount > 1) {
        this.dataRefCount.set(key, refCount - 1);
      } else {
        this.dataRefCount.delete(key);
        if (texture != null) {
          this.numBytesInGPU -= this.computeBytes(texShape, dtype);
          this.textureManager.releaseTexture(texture, texShape, usage, isPacked);
        }
      }
      const texData = this.texData.get(dataId);
      texData.texture = null;
      texData.texShape = null;
      texData.isPacked = false;
      texData.slice = null;
    }
    getTexture(dataId) {
      this.uploadToGPU(dataId);
      return this.texData.get(dataId).texture.texture;
    }
    /**
     * Returns internal information for the specific data bucket. Used in unit
     * tests.
     */
    getDataInfo(dataId) {
      return this.texData.get(dataId);
    }
    /*
    Tests whether all the inputs to an op are small and on the CPU. This heuristic
    determines when it would be faster to execute a kernel on the CPU. WebGL
    kernels opt into running this check and forwarding when appropriate.
    TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more
    sustainable strategy for optimizing backend execution of ops.
     */
    shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD) {
      return env().getBool("WEBGL_CPU_FORWARD") && inputs.every((input) => this.texData.get(input.dataId).texture == null && sizeFromShape(input.shape) < sizeThreshold);
    }
    getGPGPUContext() {
      return this.gpgpu;
    }
    where(condition) {
      warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
      const condVals = condition.dataSync();
      return whereImpl(condition.shape, condVals);
    }
    packedUnaryOp(x, op2, dtype) {
      const program = new UnaryOpPackedProgram(x.shape, op2);
      const outInfo = this.compileAndRun(program, [x], dtype);
      return engine().makeTensorFromTensorInfo(outInfo);
    }
    // TODO(msoulanille) remove this once the backend has been modularized
    // a copy is needed here to break a circular dependency.
    // Also remove the op from unary_op.
    abs(x) {
      if (this.shouldExecuteOnCPU([x]) && x.dtype !== "complex64") {
        const outValues = simpleAbsImplCPU(this.texData.get(x.dataId).values);
        return this.makeOutput(x.shape, x.dtype, outValues);
      }
      if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
        return this.packedUnaryOp(x, ABS$1, x.dtype);
      }
      const program = new UnaryOpProgram(x.shape, ABS$1);
      const outInfo = this.compileAndRun(program, [x]);
      return engine().makeTensorFromTensorInfo(outInfo);
    }
    makeTensorInfo(shape, dtype, values) {
      let dataId;
      if (dtype === "string" && values != null && values.length > 0 && isString(values[0])) {
        const encodedValues = values.map((d) => encodeString(d));
        dataId = this.write(encodedValues, shape, dtype);
      } else {
        dataId = this.write(values, shape, dtype);
      }
      this.texData.get(dataId).usage = null;
      return { dataId, shape, dtype };
    }
    makeOutput(shape, dtype, values) {
      return engine().makeTensorFromTensorInfo(this.makeTensorInfo(shape, dtype, values), this);
    }
    unpackTensor(input) {
      const program = new UnpackProgram(input.shape);
      return this.runWebGLProgram(program, [input], input.dtype);
    }
    packTensor(input) {
      const program = new PackProgram(input.shape);
      const preventEagerUnpackingOutput = true;
      return this.runWebGLProgram(program, [input], input.dtype, null, preventEagerUnpackingOutput);
    }
    packedReshape(input, afterShape) {
      const input3DShape = [
        getBatchDim(input.shape),
        ...getRowsCols(input.shape)
      ];
      const input3D = {
        dtype: input.dtype,
        shape: input3DShape,
        dataId: input.dataId
      };
      const afterShapeAs3D = [
        getBatchDim(afterShape),
        ...getRowsCols(afterShape)
      ];
      const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
      const preventEagerUnpackingOfOutput = true;
      const customValues = [input3DShape];
      const output = this.runWebGLProgram(program, [input3D], input.dtype, customValues, preventEagerUnpackingOfOutput);
      return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
    }
    decode(dataId, customTexShape) {
      const texData = this.texData.get(dataId);
      const { isPacked, shape, dtype } = texData;
      if (customTexShape != null) {
        const size = sizeFromShape(shape);
        const texSize = customTexShape[0] * customTexShape[1] * 4;
        assert(size <= texSize, () => "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");
      }
      const shapeAs3D = getShapeAs3D(shape);
      let program;
      if (isPacked) {
        program = new DecodeMatrixPackedProgram(shapeAs3D);
      } else {
        program = new DecodeMatrixProgram(shapeAs3D);
      }
      const preventEagerUnpackingOfOutput = true;
      const customValues = [customTexShape != null ? customTexShape : getDenseTexShape(shapeAs3D)];
      const out = this.runWebGLProgram(program, [{ shape: shapeAs3D, dtype, dataId }], dtype, customValues, preventEagerUnpackingOfOutput, customTexShape);
      return { dtype, shape, dataId: out.dataId };
    }
    runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false, customTexShape) {
      const output = this.makeTensorInfo(program.outputShape, outputDtype);
      const outData = this.texData.get(output.dataId);
      if (program.packedOutput) {
        outData.isPacked = true;
      }
      if (program.outPackingScheme === PackingScheme.DENSE) {
        const texelShape = customTexShape != null ? customTexShape : getDenseTexShape(program.outputShape);
        outData.texShape = texelShape.map((d) => d * 2);
      }
      if (program.outTexUsage != null) {
        outData.usage = program.outTexUsage;
      }
      if (sizeFromShape(output.shape) === 0) {
        outData.values = getTypedArrayFromDType(output.dtype, 0);
        return output;
      }
      const dataToDispose = [];
      const inputsData = inputs.map((input) => {
        if (input.dtype === "complex64") {
          throw new Error(`GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.`);
        }
        let texData = this.texData.get(input.dataId);
        if (texData.texture == null) {
          if (!program.packedInputs && sizeFromShape(input.shape) <= env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) {
            return {
              shape: input.shape,
              texData: null,
              isUniform: true,
              uniformValues: texData.values
            };
          }
          if (program.packedInputs) {
            texData.isPacked = true;
            texData.shape = input.shape;
          }
        }
        this.uploadToGPU(input.dataId);
        if (!!texData.isPacked !== !!program.packedInputs) {
          input = texData.isPacked ? this.unpackTensor(input) : this.packTensor(input);
          dataToDispose.push(input);
          texData = this.texData.get(input.dataId);
        } else if (texData.isPacked && !isReshapeFree(texData.shape, input.shape)) {
          const savedInput = input;
          const targetShape = input.shape;
          input.shape = texData.shape;
          input = this.packedReshape(input, targetShape);
          dataToDispose.push(input);
          texData = this.texData.get(input.dataId);
          savedInput.shape = targetShape;
        }
        return { shape: input.shape, texData, isUniform: false };
      });
      this.uploadToGPU(output.dataId);
      const outputData = { shape: output.shape, texData: outData, isUniform: false };
      const key = makeShaderKey(program, inputsData, outputData);
      const binary = this.getAndSaveBinary(key, () => {
        return compileProgram(this.gpgpu, program, inputsData, outputData);
      });
      const shouldTimeProgram = this.activeTimers != null;
      let query;
      if (shouldTimeProgram) {
        query = this.startTimer();
      }
      if (!env().get("ENGINE_COMPILE_ONLY")) {
        runProgram(this.gpgpu, binary, inputsData, outputData, customUniformValues);
      }
      dataToDispose.forEach((info) => this.disposeIntermediateTensorInfo(info));
      if (shouldTimeProgram) {
        query = this.endTimer(query);
        this.activeTimers.push({ name: program.constructor.name, query: this.getQueryTime(query) });
      }
      const glFlushThreshold = env().getNumber("WEBGL_FLUSH_THRESHOLD");
      if (glFlushThreshold > 0) {
        const time2 = now();
        if (time2 - this.lastGlFlushTime > glFlushThreshold) {
          this.gpgpu.gl.flush();
          this.lastGlFlushTime = time2;
        }
      }
      if (!env().getBool("WEBGL_LAZILY_UNPACK") && outData.isPacked && preventEagerUnpackingOfOutput === false) {
        const unpacked = this.unpackTensor(output);
        this.disposeIntermediateTensorInfo(output);
        return unpacked;
      }
      return output;
    }
    compileAndRun(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false) {
      outputDtype = outputDtype || inputs[0].dtype;
      const outInfo = this.runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput);
      return outInfo;
    }
    getAndSaveBinary(key, getBinary) {
      if (!(key in this.binaryCache)) {
        this.binaryCache[key] = getBinary();
      }
      return this.binaryCache[key];
    }
    getTextureManager() {
      return this.textureManager;
    }
    dispose() {
      if (this.disposed) {
        return;
      }
      if (!env().getBool("IS_TEST")) {
        const allKeys = Object.keys(this.binaryCache);
        allKeys.forEach((key) => {
          this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
          delete this.binaryCache[key];
        });
      }
      this.textureManager.dispose();
      if (this.canvas != null && (typeof HTMLCanvasElement !== "undefined" && this.canvas instanceof HTMLCanvasElement)) {
        this.canvas.remove();
      } else {
        this.canvas = null;
      }
      if (this.gpgpuCreatedLocally) {
        this.gpgpu.program = null;
        this.gpgpu.dispose();
      }
      this.disposed = true;
    }
    floatPrecision() {
      if (this.floatPrecisionValue == null) {
        this.floatPrecisionValue = tidy(() => {
          if (!env().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
            const debugFlag = env().getBool("DEBUG");
            env().set("DEBUG", false);
            const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];
            env().set("DEBUG", debugFlag);
            if (underflowCheckValue > 0) {
              return 32;
            }
          }
          return 16;
        });
      }
      return this.floatPrecisionValue;
    }
    /** Returns the smallest representable number.  */
    epsilon() {
      return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;
    }
    uploadToGPU(dataId) {
      const texData = this.texData.get(dataId);
      const { shape, dtype, values, texture, usage, isPacked } = texData;
      if (texture != null) {
        return;
      }
      const shouldTimeProgram = this.activeTimers != null;
      let start;
      if (shouldTimeProgram) {
        start = now();
      }
      let texShape = texData.texShape;
      if (texShape == null) {
        texShape = getTextureShapeFromLogicalShape(shape, isPacked);
        texData.texShape = texShape;
      }
      if (values != null) {
        const shapeAs3D = getShapeAs3D(shape);
        let program;
        let width = texShape[1], height = texShape[0];
        const isByteArray = values instanceof Uint8Array || values instanceof Uint8ClampedArray;
        if (isPacked || !isByteArray) {
          [width, height] = getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);
        }
        if (isPacked) {
          program = new EncodeMatrixPackedProgram(shapeAs3D, isByteArray);
        } else {
          program = new EncodeMatrixProgram(shapeAs3D, isByteArray);
        }
        const tempDenseInputTexShape = isByteArray ? [height, width] : texShape;
        const tempDenseInputHandle = this.makeTensorInfo(tempDenseInputTexShape, dtype);
        const tempDenseInputTexData = this.texData.get(tempDenseInputHandle.dataId);
        if (isByteArray) {
          tempDenseInputTexData.usage = TextureUsage.PIXELS;
        } else {
          tempDenseInputTexData.usage = TextureUsage.UPLOAD;
        }
        tempDenseInputTexData.texShape = tempDenseInputTexShape;
        this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);
        const customValues = [[height, width]];
        const preventEagerUnpacking = true;
        const encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, customValues, preventEagerUnpacking);
        const outputTexData = this.texData.get(encodedOutputTarget.dataId);
        texData.texShape = outputTexData.texShape;
        texData.isPacked = outputTexData.isPacked;
        texData.usage = outputTexData.usage;
        if (!env().get("ENGINE_COMPILE_ONLY")) {
          texData.texture = outputTexData.texture;
          texData.values = null;
          this.texData.delete(encodedOutputTarget.dataId);
        } else {
          this.disposeData(encodedOutputTarget.dataId);
        }
        this.disposeIntermediateTensorInfo(tempDenseInputHandle);
        if (shouldTimeProgram) {
          this.uploadWaitMs += now() - start;
        }
      } else {
        const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);
        texData.texture = newTexture;
      }
    }
    convertAndCacheOnCPU(dataId, float32Values) {
      const texData = this.texData.get(dataId);
      const { dtype } = texData;
      if (float32Values != null) {
        texData.values = float32ToTypedArray(float32Values, dtype);
      }
      return texData.values;
    }
    acquireTexture(texShape, texType, dtype, isPacked) {
      this.numBytesInGPU += this.computeBytes(texShape, dtype);
      if (!this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
        const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
        this.warnedAboutMemory = true;
        console.warn(`High memory usage in GPU: ${mb} MB, most likely due to a memory leak`);
      }
      return this.textureManager.acquireTexture(texShape, texType, isPacked);
    }
    computeBytes(shape, dtype) {
      return shape[0] * shape[1] * bytesPerElement(dtype);
    }
    checkCompileCompletion() {
      for (const [, binary] of Object.entries(this.binaryCache)) {
        this.checkCompletion_(binary);
      }
    }
    async checkCompileCompletionAsync() {
      const ps = [];
      if (this.gpgpu.parallelCompilationExtension) {
        for (const [, binary] of Object.entries(this.binaryCache)) {
          ps.push(this.checkCompletionAsync_(binary));
        }
        return Promise.all(ps);
      } else {
        for (const [, binary] of Object.entries(this.binaryCache)) {
          const p = new Promise((resolve) => {
            try {
              this.checkCompletion_(binary);
              resolve(true);
            } catch (error) {
              throw error;
            }
          });
          ps.push(p);
        }
        return Promise.all(ps);
      }
    }
    async checkCompletionAsync_(binary) {
      if (this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)) {
        return this.checkCompletion_(binary);
      } else {
        await nextFrame();
        return this.checkCompletionAsync_(binary);
      }
    }
    checkCompletion_(binary) {
      if (this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) {
        console.log(this.gpgpu.gl.getProgramInfoLog(binary.webGLProgram));
        if (this.gpgpu.gl.getShaderParameter(binary.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false) {
          logShaderSourceAndInfoLog(binary.source, this.gpgpu.gl.getShaderInfoLog(binary.fragmentShader));
          throw new Error("Failed to compile fragment shader.");
        }
        throw new Error("Failed to link vertex and fragment shaders.");
      }
      return true;
    }
    getUniformLocations() {
      for (const binary of Object.values(this.binaryCache)) {
        this.gpgpu.buildVao(binary.webGLProgram);
        const { variablesLocations, customUniformLocations, infLoc, nanLoc, outShapeLocation, outShapeStridesLocation, outTexShapeLocation } = getUniformLocations(this.gpgpu, binary.program, binary.webGLProgram);
        binary.variablesLocations = variablesLocations;
        binary.customUniformLocations = customUniformLocations;
        binary.infLoc = infLoc;
        binary.nanLoc = nanLoc;
        binary.outShapeLocation = outShapeLocation;
        binary.outShapeStridesLocation = outShapeStridesLocation;
        binary.outTexShapeLocation = outTexShapeLocation;
      }
    }
    /**
     * Create a TF.js tensor out of an existing WebGL texture. A new texture will
     * be created.
     */
    createTensorFromGPUData(values, shape, dtype) {
      values.channels = values.channels || "RGBA";
      const { texture, height, width, channels } = values;
      const backend2 = engine().backend;
      if (!backend2.gpgpu.gl.isTexture(texture)) {
        throw new Error(`The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.`);
      }
      const dataId = backend2.writeTexture(texture, shape, dtype, height, width, channels);
      return engine().makeTensorFromDataId(dataId, shape, dtype, backend2);
    }
  }
  MathBackendWebGL.nextDataId = 0;
  function float32ToTypedArray(a, dtype) {
    if (dtype === "float32" || dtype === "complex64") {
      return a;
    } else if (dtype === "int32" || dtype === "bool") {
      const result = dtype === "int32" ? new Int32Array(a.length) : new Uint8Array(a.length);
      for (let i = 0; i < result.length; ++i) {
        result[i] = Math.round(a[i]);
      }
      return result;
    } else {
      throw new Error(`Unknown dtype ${dtype}`);
    }
  }
  /** @license See the LICENSE file. */
  const version = "4.22.0";
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function forceHalfFloat() {
    env().set("WEBGL_FORCE_F16_TEXTURES", true);
  }
  /**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  if (isBrowser()) {
    registerBackend(
      "webgl",
      () => new MathBackendWebGL(),
      2
      /* priority */
    );
  }
  const webgl = { forceHalfFloat };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const CHECK_NAN_SNIPPET = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
  class BinaryOpProgram {
    constructor(op2, aShape, bShape) {
      this.variableNames = ["A", "B"];
      this.outputShape = assertAndGetBroadcastShape(aShape, bShape);
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      float binaryOperation(float a, float b) {
        ${op2}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const CHECK_NAN_SNIPPET_PACKED = `
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;
  class BinaryOpPackedProgram {
    constructor(op2, aShape, bShape, checkOutOfBounds = false) {
      this.variableNames = ["A", "B"];
      this.supportsBroadcasting = true;
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = assertAndGetBroadcastShape(aShape, bShape);
      const rank = this.outputShape.length;
      this.enableShapeUniforms = useShapeUniforms(rank);
      let checkOutOfBoundsString = "";
      if (checkOutOfBounds) {
        if (rank === 0 || sizeFromShape(this.outputShape) === 1) {
          checkOutOfBoundsString = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
        } else {
          const dtype = getCoordsDataType(rank);
          checkOutOfBoundsString = `
          ${dtype} coords = getOutputCoords();
        `;
          if (rank === 1) {
            if (this.enableShapeUniforms) {
              checkOutOfBoundsString += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
            } else {
              checkOutOfBoundsString += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
            }
          } else {
            const channels = getChannels("coords", rank);
            if (this.enableShapeUniforms) {
              checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= outShape[${rank} - 2];
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= outShape[${rank} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
            } else {
              checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
            }
          }
        }
      }
      this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${op2}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${checkOutOfBoundsString}

        setOutput(result);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function identity(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    backend2.incRef(x.dataId);
    return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };
  }
  const identityConfig = {
    kernelName: Identity,
    backendName: "webgl",
    kernelFunc: identity
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function complex(args) {
    const { inputs, backend: backend2 } = args;
    const { real: real2, imag: imag2 } = inputs;
    const complexInfo = backend2.makeTensorInfo(real2.shape, "complex64");
    const complex2 = backend2.texData.get(complexInfo.dataId);
    const realTensorInfo = identity({ inputs: { x: real2 }, backend: backend2 });
    const imagTensorInfo = identity({ inputs: { x: imag2 }, backend: backend2 });
    complex2.complexTensorInfos = { real: realTensorInfo, imag: imagTensorInfo };
    return complexInfo;
  }
  const complexConfig = {
    kernelName: Complex,
    backendName: "webgl",
    kernelFunc: complex
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const LEAKYRELU = `return (a < 0.) ? b * a : a;`;
  const LEAKYRELU_PACKED = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function leakyRelu(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { alpha } = attrs;
    const $alpha = backend2.makeTensorInfo([], "float32", createScalarValue(alpha, "float32"));
    const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(LEAKYRELU_PACKED, x.shape, $alpha.shape) : new BinaryOpProgram(LEAKYRELU, x.shape, $alpha.shape);
    const result = backend2.runWebGLProgram(program, [x, $alpha], "float32");
    backend2.disposeIntermediateTensorInfo($alpha);
    return result;
  }
  const leakyReluConfig = {
    kernelName: LeakyRelu,
    backendName: "webgl",
    kernelFunc: leakyRelu
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const PRELU = `return (a < 0.) ? b * a : a;`;
  const PRELU_PACKED = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function prelu(args) {
    const { inputs, backend: backend2 } = args;
    const { x, alpha } = inputs;
    const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(PRELU_PACKED, x.shape, alpha.shape) : new BinaryOpProgram(PRELU, x.shape, alpha.shape);
    return backend2.runWebGLProgram(program, [x, alpha], "float32");
  }
  const preluConfig = {
    kernelName: Prelu,
    backendName: "webgl",
    kernelFunc: prelu
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;
  function unaryKernelFunc({ opSnippet, packedOpSnippet, cpuKernelImpl, dtype }) {
    return ({ inputs, backend: backend2 }) => {
      const { x } = inputs;
      const webglBackend = backend2;
      const $dtype = dtype || x.dtype;
      if (webglBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {
        const xData = webglBackend.texData.get(x.dataId);
        const outValues = cpuKernelImpl(xData.values, $dtype);
        return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);
      }
      const shouldUsePackedProgram = env().getBool("WEBGL_PACK_UNARY_OPERATIONS") && packedOpSnippet != null;
      let program;
      if (shouldUsePackedProgram) {
        program = new UnaryOpPackedProgram(x.shape, packedOpSnippet);
      } else {
        program = new UnaryOpProgram(x.shape, opSnippet);
      }
      return webglBackend.runWebGLProgram(program, [x], $dtype);
    };
  }
  function binaryKernelFunc({ opSnippet, packedOpSnippet, checkOutOfBounds = false, supportsComplex = false, cpuKernelImpl, dtype }) {
    return ({ inputs, backend: backend2 }) => {
      const { a, b } = inputs;
      const webglBackend = backend2;
      if (supportsComplex && a.dtype === "complex64") {
        const aData = webglBackend.texData.get(a.dataId);
        const bData = webglBackend.texData.get(b.dataId);
        const [real2, imag2] = [
          [aData.complexTensorInfos.real, bData.complexTensorInfos.real],
          [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]
        ].map((complexParts) => {
          const [aPart, bPart] = complexParts;
          const aHandle = {
            dataId: aPart.dataId,
            dtype: aPart.dtype,
            shape: a.shape
          };
          const bHandle = {
            dataId: bPart.dataId,
            dtype: bPart.dtype,
            shape: b.shape
          };
          const program2 = new BinaryOpProgram(opSnippet, a.shape, b.shape);
          return webglBackend.runWebGLProgram(program2, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));
        });
        const complexOutput = complex({ inputs: { real: real2, imag: imag2 }, backend: webglBackend });
        webglBackend.disposeIntermediateTensorInfo(real2);
        webglBackend.disposeIntermediateTensorInfo(imag2);
        return complexOutput;
      }
      const $dtype = dtype || upcastType(a.dtype, b.dtype);
      if ((a.dtype === "string" || b.dtype === "string" || webglBackend.shouldExecuteOnCPU([a, b])) && cpuKernelImpl != null) {
        const aVals = webglBackend.texData.get(a.dataId).values;
        const bVals = webglBackend.texData.get(b.dataId).values;
        const decodedAVals = a.dtype === "string" ? (
          // tslint:disable-next-line: no-any
          fromUint8ToStringArray(aVals)
        ) : aVals;
        const decodedBVals = a.dtype === "string" ? (
          // tslint:disable-next-line: no-any
          fromUint8ToStringArray(bVals)
        ) : bVals;
        const [outValues, outShape] = cpuKernelImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);
        const out = webglBackend.makeTensorInfo(outShape, $dtype);
        const outData = webglBackend.texData.get(out.dataId);
        outData.values = outValues;
        return out;
      }
      const shouldUsePackedProgram = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") && packedOpSnippet != null;
      let program;
      if (shouldUsePackedProgram) {
        program = new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, checkOutOfBounds);
      } else {
        program = new BinaryOpProgram(opSnippet, a.shape, b.shape);
      }
      return webglBackend.runWebGLProgram(program, [a, b], $dtype);
    };
  }
  function mapActivationToShaderProgram(activation, packed = false) {
    if (activation === "linear") {
      if (packed) {
        return LINEAR;
      }
      return LINEAR$1;
    } else if (activation === "relu") {
      if (packed) {
        return RELU$1;
      }
      return RELU$2;
    } else if (activation === "elu") {
      if (packed) {
        return ELU$1;
      }
      return ELU$2;
    } else if (activation === "relu6") {
      if (packed) {
        return RELU6$1;
      }
      return RELU6$2;
    } else if (activation === "prelu") {
      if (packed) {
        return PRELU_PACKED;
      }
      return PRELU;
    } else if (activation === "leakyrelu") {
      if (packed) {
        return LEAKYRELU_PACKED;
      }
      return LEAKYRELU;
    } else if (activation === "sigmoid") {
      if (packed) {
        return SIGMOID$1;
      }
      return SIGMOID$2;
    }
    throw new Error(`Activation ${activation} has not been implemented for the WebGL backend.`);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class MatMulPackedProgram {
    constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, addBias = false, activation = null, hasPreluActivation = false, hasLeakyreluActivation = false) {
      this.variableNames = ["matrixA", "matrixB"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const sharedDim = transposeA ? aShape[1] : aShape[2];
      const sharedDimensionPacked = Math.ceil(sharedDim / 2);
      const aSample = transposeA ? "i * 2, rc.y" : "rc.y, i * 2";
      const bSample = transposeB ? "rc.z, i * 2" : "i * 2, rc.z";
      const aSwizzle = transposeA ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"];
      const bSwizzle = transposeB ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation) {
        if (hasPreluActivation) {
          activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
        } else if (hasLeakyreluActivation) {
          activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
        } else {
          activationSnippet = `vec4 activation(vec4 x) {
          ${activation}
        }`;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivation) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyreluActivation) {
        this.variableNames.push("leakyreluAlpha");
      }
      let batchASnippet = "rc.x";
      let batchBSnippet = "rc.x";
      if (aShape[0] < bShape[0]) {
        batchASnippet = `imod(rc.x, ${aShape[0]})`;
      } else if (bShape[0] < aShape[0]) {
        batchBSnippet = `imod(rc.x, ${bShape[0]})`;
      }
      this.userCode = `
      ${activationSnippet}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${sharedDimensionPacked}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${batchASnippet};
        int batchB = ${batchBSnippet};
        for (int i = 0; i < ${sharedDimensionPacked}; i++) {
          vec4 a = getMatrixA(batchA, ${aSample});
          vec4 b = getMatrixB(batchB, ${bSample});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${aSwizzle[0]} * ${bSwizzle[0]});
          result += (${aSwizzle[1]} * ${bSwizzle[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${addBiasSnippet}

        ${applyActivationSnippet}

        setOutput(result);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const COMPLEX_MULTIPLY = {
    REAL: "return areal * breal - aimag * bimag;",
    IMAG: "return areal * bimag + aimag * breal;"
  };
  class BinaryOpComplexProgram {
    constructor(op2, aShape, bShape) {
      this.variableNames = ["AReal", "AImag", "BReal", "BImag"];
      this.outputShape = assertAndGetBroadcastShape(aShape, bShape);
      this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${op2}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const MUL = "return a * b;";
  function multiply(args) {
    const { inputs, backend: backend2 } = args;
    const { a, b } = inputs;
    const dtype = upcastType(a.dtype, b.dtype);
    if (a.dtype === "complex64") {
      const aData = backend2.texData.get(a.dataId);
      const bData = backend2.texData.get(b.dataId);
      const realProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL, a.shape, b.shape);
      const imagProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);
      const inputs2 = [
        {
          dataId: aData.complexTensorInfos.real.dataId,
          dtype: aData.complexTensorInfos.real.dtype,
          shape: a.shape
        },
        {
          dataId: aData.complexTensorInfos.imag.dataId,
          dtype: aData.complexTensorInfos.imag.dtype,
          shape: a.shape
        },
        {
          dataId: bData.complexTensorInfos.real.dataId,
          dtype: bData.complexTensorInfos.real.dtype,
          shape: b.shape
        },
        {
          dataId: bData.complexTensorInfos.imag.dataId,
          dtype: bData.complexTensorInfos.imag.dtype,
          shape: b.shape
        }
      ];
      const realPart = backend2.runWebGLProgram(realProgram, inputs2, "float32");
      const imagPart = backend2.runWebGLProgram(imagProgram, inputs2, "float32");
      const complexOutput = complex({ inputs: { real: realPart, imag: imagPart }, backend: backend2 });
      backend2.disposeIntermediateTensorInfo(realPart);
      backend2.disposeIntermediateTensorInfo(imagPart);
      return complexOutput;
    }
    if (backend2.shouldExecuteOnCPU([a, b])) {
      const aData = backend2.texData.get(a.dataId);
      const bData = backend2.texData.get(b.dataId);
      const [outValues, outShape] = multiplyImplCPU(a.shape, b.shape, aData.values, bData.values, dtype);
      const out = backend2.makeTensorInfo(outShape, dtype);
      const outData = backend2.texData.get(out.dataId);
      outData.values = outValues;
      return out;
    }
    let program;
    if (env().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
      program = new BinaryOpPackedProgram(MUL, a.shape, b.shape);
    } else {
      program = new BinaryOpProgram(MUL, a.shape, b.shape);
    }
    return backend2.runWebGLProgram(program, [a, b], dtype);
  }
  const multiplyConfig = {
    kernelName: Multiply,
    backendName: "webgl",
    kernelFunc: multiply
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function packedReshape(input, afterShape, backend2) {
    const input3DShape = [
      getBatchDim(input.shape),
      ...getRowsCols(input.shape)
    ];
    const input3D = {
      dtype: input.dtype,
      shape: input3DShape,
      dataId: input.dataId
    };
    const afterShapeAs3D = [
      getBatchDim(afterShape),
      ...getRowsCols(afterShape)
    ];
    const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
    const preventEagerUnpackingOfOutput = true;
    const customValues = [input3DShape];
    const output = backend2.runWebGLProgram(program, [input3D], input.dtype, customValues, preventEagerUnpackingOfOutput);
    return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function reshape(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { shape } = attrs;
    const webglBackend = backend2;
    const xSize = sizeFromShape(x.shape);
    const $shape = inferFromImplicitShape(shape, xSize);
    const $xSize = sizeFromShape($shape);
    assert(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old shape (${x.shape}) has ${xSize} elements. The new shape and old shape must have the same number of elements.`);
    const xTexData = webglBackend.texData.get(x.dataId);
    if (xTexData.isPacked && !isReshapeFree(x.shape, $shape) && !(xTexData.texture !== null && isReshapeFree(xTexData.shape, $shape))) {
      return packedReshape(x, $shape, webglBackend);
    }
    webglBackend.incRef(x.dataId);
    return { dataId: x.dataId, shape: $shape, dtype: x.dtype };
  }
  const reshapeConfig = {
    kernelName: Reshape,
    backendName: "webgl",
    kernelFunc: reshape
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class MeanProgram {
    constructor(reduceInfo, divisor) {
      this.variableNames = ["x"];
      const { windowSize, batchSize, inSize, outSize } = reduceInfo;
      this.outputShape = [batchSize, outSize];
      const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
      const windowSizeVec4Remainder = windowSize % 4;
      let updateSnippet = `sumValue += dot(values, ones);`;
      if (divisor != null) {
        const denominator = 1 / divisor;
        updateSnippet = `sumValue += dot(values * ${isInt(denominator) ? denominator.toPrecision(2) : denominator}, ones);`;
      }
      let checkOutOfBounds = "";
      if (inSize % windowSize > 0) {
        checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return 0.0;
        }
      `;
      }
      this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${updateSnippet}
        }
        setOutput(sumValue);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ReduceProgram {
    constructor(reduceInfo, reduceType) {
      this.variableNames = ["x"];
      const { windowSize, batchSize, inSize, outSize } = reduceInfo;
      this.outputShape = [batchSize, outSize];
      let initializationValue = "0.0";
      let compareOp = ``;
      if (reduceType === "prod") {
        initializationValue = "1.0";
      } else if (reduceType === "min") {
        initializationValue = "1.0 / 1e-20";
        compareOp = `min`;
      } else if (reduceType === "max") {
        initializationValue = "-1.0 / 1e-20";
        compareOp = `max`;
      }
      let returnValue = `${reduceType}(${reduceType}(${reduceType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      if (reduceType === "sum") {
        returnValue = `sumValue`;
      } else if (reduceType === "prod") {
        returnValue = `prodValue`;
      } else if (reduceType === "all") {
        returnValue = `allValue`;
      } else if (reduceType === "any") {
        returnValue = `anyValue`;
      }
      const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
      const windowSizeVec4Remainder = windowSize % 4;
      let updateSnippet = `
      if (${reduceType === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${reduceType === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
        if (${reduceType === "min"} || ${reduceType === "max"}) {
          minMaxValue = ${compareOp}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `;
      let vecType = `vec4`;
      if (reduceType === "all") {
        initializationValue = "1.0";
        updateSnippet = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `;
        vecType = `bvec4`;
      } else if (reduceType === "any") {
        initializationValue = "0.0";
        updateSnippet = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `;
        vecType = `bvec4`;
      }
      let checkOutOfBounds = "";
      if (inSize % windowSize > 0) {
        checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
      }
      this.userCode = `
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        vec4 minMaxValue = vec4(${initializationValue});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getReductionStages(inShape) {
    const stages = [];
    while (stages.length === 0 || stages[stages.length - 1].outSize !== 1) {
      const outSize = stages.length ? stages[stages.length - 1].outSize : inShape[1];
      const windowSize = computeOptimalWindowSize(outSize);
      stages.push({
        inSize: outSize,
        windowSize,
        outSize: Math.ceil(outSize / windowSize)
      });
    }
    return stages;
  }
  function reduce(x, dtype, reductionType, backend2) {
    const reductionStages = getReductionStages(x.shape);
    let result = x;
    for (let i = 0; i < reductionStages.length; i++) {
      const { inSize, windowSize, outSize } = reductionStages[i];
      let program;
      let previousResult;
      if (reductionType === "mean") {
        program = i === 0 ? new MeanProgram({ windowSize, inSize, batchSize: x.shape[0], outSize }, inSize) : new MeanProgram({ windowSize, inSize, batchSize: x.shape[0], outSize });
      } else {
        program = new ReduceProgram({ windowSize, inSize, batchSize: x.shape[0], outSize }, reductionType);
      }
      previousResult = result;
      result = backend2.runWebGLProgram(program, [result], dtype);
      if (previousResult.dataId !== x.dataId) {
        backend2.disposeIntermediateTensorInfo(previousResult);
      }
    }
    return result;
  }
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class TransposeProgram {
    constructor(aShape, newDim) {
      this.variableNames = ["A"];
      const outputShape = new Array(aShape.length);
      for (let i = 0; i < outputShape.length; i++) {
        outputShape[i] = aShape[newDim[i]];
      }
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      const dtype = getCoordsDataType(this.rank);
      const switched = getSwitchedCoords(newDim);
      this.userCode = `
    void main() {
      ${dtype} resRC = getOutputCoords();
      setOutput(getA(${switched}));
    }
    `;
    }
  }
  function getSwitchedCoords(newDim) {
    const rank = newDim.length;
    if (rank > 6) {
      throw Error(`Transpose for rank ${rank} is not yet supported`);
    }
    const originalOrder = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"];
    const switchedCoords = new Array(rank);
    for (let i = 0; i < newDim.length; i++) {
      switchedCoords[newDim[i]] = originalOrder[i];
    }
    return switchedCoords.join();
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class TransposePackedProgram {
    constructor(aShape, newDim) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      const outputShape = new Array(aShape.length);
      for (let i = 0; i < outputShape.length; i++) {
        outputShape[i] = aShape[newDim[i]];
      }
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      if (this.rank > 6) {
        throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
      }
      const dtype = getCoordsDataType(this.rank);
      const outputOrder = getVecChannels("rc", this.rank);
      const switchedOrder = new Array(this.rank);
      for (let i = 0; i < newDim.length; i++) {
        switchedOrder[newDim[i]] = outputOrder[i];
      }
      const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;
      const nextColumn = `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;
      const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;
      this.userCode = `
    void main() {
      ${dtype} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${getc};
      if(${nextColumn}) {
        result[1] = ${getc};
      }
      --${outputOrder[this.rank - 1]};
      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {
        result[2] = ${getc};
        if(${nextColumn}) {
          result[3] = ${getc};
        }
      }
      setOutput(result);
    }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function transposeImpl(x, perm, backend2) {
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new TransposePackedProgram(x.shape, perm) : new TransposeProgram(x.shape, perm);
    return backend2.runWebGLProgram(program, [x], x.dtype);
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sumImpl(x, axis, keepDims, backend2) {
    const reductionIndices = axis;
    const xRank = x.shape.length;
    const origAxes = parseAxisParam(reductionIndices, x.shape);
    let axes = origAxes;
    const permutedAxes = getAxesPermutation(axes, xRank);
    const sumInputIsTransposed = permutedAxes != null;
    let sumInput = x;
    if (sumInputIsTransposed) {
      sumInput = transposeImpl(x, permutedAxes, backend2);
      axes = getInnerMostAxes(axes.length, xRank);
    }
    assertAxesAreInnerMostDims("sum", axes, xRank);
    const [sumOutShape, reduceShape] = computeOutAndReduceShapes(sumInput.shape, axes);
    let outShape = sumOutShape;
    if (keepDims) {
      outShape = expandShapeToKeepDim(sumOutShape, origAxes);
    }
    const inSize = sizeFromShape(reduceShape);
    const xSize = sizeFromShape(x.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = reshape({ inputs: { x: sumInput }, attrs: { shape: [batchSize, inSize] }, backend: backend2 });
    const outType = sumOutType(x.dtype);
    const reduced = reduce(reshapedInput, outType, "sum", backend2);
    const out = reshape({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend2 });
    backend2.disposeIntermediateTensorInfo(reshapedInput);
    backend2.disposeIntermediateTensorInfo(reduced);
    if (sumInputIsTransposed) {
      backend2.disposeIntermediateTensorInfo(sumInput);
    }
    return out;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sum(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    return sumImpl(x, axis, keepDims, backend2);
  }
  const sumConfig = {
    kernelName: Sum,
    backendName: "webgl",
    kernelFunc: sum
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function transpose(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { perm } = attrs;
    const webglBackend = backend2;
    const xRank = x.shape.length;
    const newShape = new Array(xRank);
    for (let i = 0; i < newShape.length; i++) {
      newShape[i] = x.shape[perm[i]];
    }
    let out;
    if (webglBackend.shouldExecuteOnCPU([x])) {
      const xTexData = webglBackend.texData.get(x.dataId);
      const values = xTexData.values;
      const outValues = transposeImplCPU(values, x.shape, x.dtype, perm, newShape);
      out = webglBackend.makeTensorInfo(newShape, x.dtype);
      const outData = webglBackend.texData.get(out.dataId);
      outData.values = outValues;
    } else {
      out = transposeImpl(x, perm, webglBackend);
    }
    return out;
  }
  const transposeConfig = {
    kernelName: Transpose,
    backendName: "webgl",
    kernelFunc: transpose
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const MATMUL_SHARED_DIM_THRESHOLD = 1e3;
  function batchMatMulImpl({ a, b, transposeA, transposeB, backend: backend2, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    const aRank = a.shape.length;
    const bRank = b.shape.length;
    const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
    const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
    const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
    const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
    const outerDimsA = a.shape.slice(0, -2);
    const outerDimsB = b.shape.slice(0, -2);
    const batchDimA = sizeFromShape(outerDimsA);
    const batchDimB = sizeFromShape(outerDimsB);
    const outShapeOuterDims = assertAndGetBroadcastShape(a.shape.slice(0, -2), b.shape.slice(0, -2));
    const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
    assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${a.shape} and ${b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
    const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
    const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
    const a3d = reshape({ inputs: { x: a }, backend: backend2, attrs: { shape: a3dShape } });
    const b3d = reshape({ inputs: { x: b }, backend: backend2, attrs: { shape: b3dShape } });
    const intermediates = [a3d, b3d];
    const batchDim = Math.max(batchDimA, batchDimB);
    const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === "leakyrelu";
    const fusedActivation = activation != null ? mapActivationToShaderProgram(activation, true) : null;
    const containsFusedOps = hasBias || hasPreluActivationWeights || hasLeakyreluAlpha || fusedActivation != null;
    let out;
    if ((outerShapeA === 1 || outerShapeB === 1) && sharedDim > MATMUL_SHARED_DIM_THRESHOLD && containsFusedOps === false) {
      let aVec = a3d;
      let bVec = b3d;
      if (transposeA) {
        aVec = transpose({ inputs: { x: a3d }, backend: backend2, attrs: { perm: [0, 2, 1] } });
        intermediates.push(aVec);
      }
      if (transposeB) {
        bVec = transpose({ inputs: { x: b3d }, backend: backend2, attrs: { perm: [0, 2, 1] } });
        intermediates.push(bVec);
      }
      const shouldReshapeA = outerShapeB !== 1;
      const shouldReshapeB = outerShapeB === 1;
      let aVec3d = aVec;
      if (shouldReshapeA) {
        aVec3d = reshape({
          inputs: { x: aVec },
          backend: backend2,
          attrs: { shape: [batchDim, sharedDim, 1] }
        });
        intermediates.push(aVec3d);
      }
      const axis = outerShapeB === 1 ? 2 : 1;
      let bVec3d = bVec;
      if (shouldReshapeB) {
        bVec3d = reshape({
          inputs: { x: bVec },
          backend: backend2,
          attrs: { shape: [batchDim, 1, sharedDim] }
        });
        intermediates.push(bVec3d);
      }
      const product = multiply({ inputs: { a: aVec3d, b: bVec3d }, backend: backend2 });
      out = sum({ inputs: { x: product }, backend: backend2, attrs: { axis, keepDims: true } });
      intermediates.push(product);
    } else {
      const dtype = upcastType(a.dtype, b.dtype);
      const program = new MatMulPackedProgram(a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
      const inputs = [a3d, b3d];
      if (bias != null) {
        inputs.push(bias);
      }
      if (hasPreluActivationWeights) {
        inputs.push(preluActivationWeights);
      }
      if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend2.makeTensorInfo([], "float32", createScalarValue(leakyreluAlpha, "float32"));
        inputs.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
      }
      out = backend2.runWebGLProgram(program, inputs, dtype);
    }
    const outReshaped = reshape({ inputs: { x: out }, backend: backend2, attrs: { shape: outShape } });
    intermediates.push(out);
    for (const i of intermediates) {
      backend2.disposeIntermediateTensorInfo(i);
    }
    return outReshaped;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function _fusedMatMul(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { a, b, bias, preluActivationWeights } = inputs;
    const { transposeA, transposeB, activation, leakyreluAlpha } = attrs;
    return batchMatMulImpl({
      a,
      b,
      transposeA,
      transposeB,
      backend: backend2,
      bias,
      preluActivationWeights,
      leakyreluAlpha,
      activation
    });
  }
  const _fusedMatMulConfig = {
    kernelName: _FusedMatMul,
    backendName: "webgl",
    kernelFunc: _fusedMatMul
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ABS = `return abs(x);`;
  function abs(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    if (backend2.shouldExecuteOnCPU([x]) && x.dtype !== "complex64") {
      const xData = backend2.texData.get(x.dataId);
      const outValues = simpleAbsImplCPU(xData.values);
      return backend2.makeTensorInfo(x.shape, x.dtype, outValues);
    }
    let program;
    if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
      program = new UnaryOpPackedProgram(x.shape, ABS);
    } else {
      program = new UnaryOpProgram(x.shape, ABS);
    }
    return backend2.runWebGLProgram(program, [x], x.dtype);
  }
  const absConfig = {
    kernelName: Abs,
    backendName: "webgl",
    kernelFunc: abs
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ACOS = CHECK_NAN_SNIPPET$1 + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`;
  const acos = unaryKernelFunc({ opSnippet: ACOS });
  const acosConfig = {
    kernelName: Acos,
    backendName: "webgl",
    kernelFunc: acos
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ACOSH = CHECK_NAN_SNIPPET$1 + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`;
  const acosh = unaryKernelFunc({ opSnippet: ACOSH });
  const acoshConfig = {
    kernelName: Acosh,
    backendName: "webgl",
    kernelFunc: acosh
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ADD = "return a + b;";
  const addKernelFunc = binaryKernelFunc({
    opSnippet: ADD,
    packedOpSnippet: ADD,
    supportsComplex: true,
    cpuKernelImpl: addImplCPU
  });
  const addConfig = {
    kernelName: Add,
    backendName: "webgl",
    kernelFunc: addKernelFunc
  };
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class AddNProgram {
    constructor(outputShape, shapes) {
      this.outputShape = [];
      this.outputShape = outputShape;
      this.variableNames = shapes.map((_, i) => `T${i}`);
      const snippets = [];
      this.variableNames.forEach((variable2) => {
        snippets.push(`float v${variable2} = get${variable2}AtOutCoords();`);
      });
      const operation = this.variableNames.map((variable2) => {
        return `v${variable2}`;
      }).join(" + ");
      this.userCode = `
      void main() {
        ${snippets.join("\n        ")}

        float result = ${operation};
        setOutput(result);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class AddNPackedProgram {
    constructor(outputShape, shapes) {
      this.outputShape = [];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = outputShape;
      this.variableNames = shapes.map((_, i) => `T${i}`);
      const snippets = [];
      this.variableNames.forEach((variable2) => {
        snippets.push(`vec4 v${variable2} = get${variable2}AtOutCoords();`);
      });
      const operation = this.variableNames.map((variable2) => {
        return `v${variable2}`;
      }).join(" + ");
      this.userCode = `
      void main() {
        ${snippets.join("\n        ")}

        vec4 result = ${operation};
        setOutput(result);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function addN(args) {
    const { inputs, backend: backend2 } = args;
    const tensors = inputs;
    if (tensors.length === 1) {
      return identity({ inputs: { x: tensors[0] }, backend: backend2 });
    }
    if (tensors.length > env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      const midIndex = Math.floor(tensors.length / 2);
      const leftSide = addN({ inputs: tensors.slice(0, midIndex), backend: backend2 });
      const rightSide = addN({ inputs: tensors.slice(midIndex), backend: backend2 });
      return addN({ inputs: [leftSide, rightSide], backend: backend2 });
    }
    const dtype = tensors.map((t) => t.dtype).reduce((d1, d2) => upcastType(d1, d2));
    const shapes = tensors.map((t) => t.shape);
    const usePackedOp = env().getBool("WEBGL_PACK");
    const program = usePackedOp ? new AddNPackedProgram(tensors[0].shape, shapes) : new AddNProgram(tensors[0].shape, shapes);
    return backend2.runWebGLProgram(program, tensors, dtype);
  }
  const addNConfig = {
    kernelName: AddN,
    backendName: "webgl",
    kernelFunc: addN
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function all(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x.shape.length;
    const origAxes = parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
      permutedX = transpose({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      axes = getInnerMostAxes(axes.length, xRank);
    }
    assertAxesAreInnerMostDims("all", axes, xRank);
    const [outShape, reduceShape] = computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = sizeFromShape(reduceShape);
    const a2D = reshape({ inputs: { x: permutedX }, backend: backend2, attrs: { shape: [-1, inSize] } });
    const reduced = reduce(a2D, a2D.dtype, "all", backend2);
    let res;
    if (keepDims) {
      const newShape = expandShapeToKeepDim(outShape, origAxes);
      res = reshape({ inputs: { x: reduced }, backend: backend2, attrs: { shape: newShape } });
    } else {
      res = reshape({ inputs: { x: reduced }, backend: backend2, attrs: { shape: outShape } });
    }
    backend2.disposeIntermediateTensorInfo(a2D);
    backend2.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) {
      backend2.disposeIntermediateTensorInfo(permutedX);
    }
    return res;
  }
  const allConfig = {
    kernelName: All,
    backendName: "webgl",
    kernelFunc: all
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function any(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x.shape.length;
    const origAxes = parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
      permutedX = transpose({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      axes = getInnerMostAxes(axes.length, xRank);
    }
    assertAxesAreInnerMostDims("any", axes, xRank);
    const [outShape, reduceShape] = computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = sizeFromShape(reduceShape);
    const a2D = reshape({ inputs: { x: permutedX }, backend: backend2, attrs: { shape: [-1, inSize] } });
    const reduced = reduce(a2D, a2D.dtype, "any", backend2);
    let res;
    if (keepDims) {
      const newShape = expandShapeToKeepDim(outShape, origAxes);
      res = reshape({ inputs: { x: reduced }, backend: backend2, attrs: { shape: newShape } });
    } else {
      res = reshape({ inputs: { x: reduced }, backend: backend2, attrs: { shape: outShape } });
    }
    backend2.disposeIntermediateTensorInfo(a2D);
    backend2.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) {
      backend2.disposeIntermediateTensorInfo(permutedX);
    }
    return res;
  }
  const anyConfig = {
    kernelName: Any,
    backendName: "webgl",
    kernelFunc: any
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ArgMinMaxProgram {
    constructor(reduceInfo, op2, firstPass) {
      this.variableNames = ["A"];
      const { windowSize, batchSize, outSize } = reduceInfo;
      if (!firstPass) {
        this.variableNames.push("bestIndicesA");
      }
      this.outputShape = [batchSize, outSize];
      const compOp = op2 === "max" ? ">" : "<";
      const indexSnippet = firstPass ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${windowSize}; i++) {
          int inIdx = ${indexSnippet};
          float candidate = getA(batch, inIdx);
          if (candidate ${compOp} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ArgMinMaxPackedProgram {
    constructor(shape, windowSize, op2, firstPass) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      assert(shape.length > 2, () => `Packed arg${op2.charAt(0).toUpperCase() + op2.slice(1)} supports only inputs with rank above 2.`);
      const inSize = shape[shape.length - 1];
      const outSize = Math.ceil(inSize / windowSize);
      this.outputShape = shape.slice(0, -1);
      if (outSize > 1) {
        this.outputShape.push(outSize);
      }
      if (!firstPass) {
        this.variableNames.push("bestIndicesA");
      }
      const outShape = this.outputShape;
      const rank = outShape.length;
      const dtype = getCoordsDataType(rank);
      const coords2 = getChannels("coords", rank);
      let sourceLocSetup;
      let sourceRank;
      if (outSize === 1) {
        sourceRank = rank + 1;
        const sourceLocDType = getCoordsDataType(sourceRank);
        sourceLocSetup = `
        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords2.join()}, 0);
        ++${coords2[rank - 1]};
        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords2.join()}, 0);
        ++${coords2[rank - 2]};
        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords2.join()}, 0);
        --${coords2[rank - 1]};
        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords2.join()}, 0);
        --${coords2[rank - 2]};`;
      } else {
        sourceRank = rank;
        sourceLocSetup = `
        ${dtype} sourceLocR = coords;
        ++${coords2[rank - 1]};
        ${dtype} sourceLocG = coords;
        ++${coords2[rank - 2]};
        ${dtype} sourceLocA = coords;
        --${coords2[rank - 1]};
        ${dtype} sourceLocB = coords;
        --${coords2[rank - 2]};`;
      }
      const channels = ["x", "y", "z", "w", "u", "v"].slice(0, sourceRank);
      const inChannel = "." + channels[sourceRank - 1];
      const intChannels = channels.map((x) => "int " + x);
      const srcRCoords = getChannels("sourceLocR", sourceRank - 1).concat("inIdx.r");
      const srcGCoords = getChannels("sourceLocG", sourceRank - 1).concat("inIdx.g");
      const srcBCoords = getChannels("sourceLocB", sourceRank - 1).concat("inIdx.b");
      const srcACoords = getChannels("sourceLocA", sourceRank - 1).concat("inIdx.a");
      const compOp = op2 === "max" ? "greaterThan" : "lessThan";
      const fetchCandidateIdx = firstPass ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),
                             getBestIndicesAChannel(${srcGCoords.join()}),
                             getBestIndicesAChannel(${srcBCoords.join()}),
                             getBestIndicesAChannel(${srcACoords.join()})));`;
      const fetchValue = `vec4(
            getAChannel(${srcRCoords.join()}),
            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,
            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;
      const getBestIndicesAChannelSnippet = firstPass ? "" : `
      float getBestIndicesAChannel(${intChannels.join()}) {
        return getChannel(getBestIndicesA(${channels.join()}),
                                          vec2(${channels.slice(-2).join()}));
      }`;
      this.userCode = `
      float getAChannel(${intChannels.join()}) {
        return getChannel(getA(${channels.join()}),
                               vec2(${channels.slice(-2).join()}));
      }
      ${getBestIndicesAChannelSnippet}
      void main() {
        ${dtype} coords = getOutputCoords();
        bool hasNextCol = ${coords2[rank - 1]} < ${outShape[rank - 1] - 1};
        bool hasNextRow = ${coords2[rank - 2]} < ${outShape[rank - 2] - 1};
        ${sourceLocSetup}
        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},
          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${fetchValue};

        for (int i = 0; i < ${windowSize}; i++) {
          inIdx = srcIdx;
          ${fetchCandidateIdx}
          vec4 candidate = ${fetchValue};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function argReduce(backend2, x, reduceType, bestIndicesA = null) {
    let batchSize = x.shape[0];
    let inSize = x.shape[1];
    if (bestIndicesA != null) {
      batchSize = bestIndicesA.shape[0];
      inSize = bestIndicesA.shape[1];
    }
    const windowSize = computeOptimalWindowSize(inSize);
    const reduceInfo = { windowSize, inSize, batchSize, outSize: Math.ceil(inSize / windowSize) };
    const program = new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
    const inputs = [x];
    if (bestIndicesA != null) {
      inputs.push(bestIndicesA);
    }
    const output = backend2.runWebGLProgram(program, inputs, "int32");
    if (output.shape[1] === 1) {
      return output;
    }
    const result = argReduce(backend2, x, reduceType, output);
    backend2.disposeIntermediateTensorInfo(output);
    return result;
  }
  function argReducePacked(backend2, x, reduceType, bestIndicesA = null) {
    const inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;
    const inSize = inShape[inShape.length - 1];
    const windowSize = computeOptimalWindowSize(inSize);
    const program = new ArgMinMaxPackedProgram(inShape, windowSize, reduceType, bestIndicesA == null);
    const inputs = bestIndicesA == null ? [x] : [x, bestIndicesA];
    const output = backend2.runWebGLProgram(program, inputs, "int32");
    if (output.shape.length === x.shape.length) {
      const result = argReducePacked(backend2, x, reduceType, output);
      backend2.disposeIntermediateTensorInfo(output);
      return result;
    }
    return output;
  }
  function argMinMaxReduce(backend2, x, axis, reduceType) {
    const axes = [axis];
    assertAxesAreInnerMostDims("arg" + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes, x.shape.length);
    if (!env().getBool("WEBGL_PACK_REDUCE") || x.shape.length <= 2) {
      const intermediateTensorInfos = [];
      const xtexData = backend2.texData.get(x.dataId);
      const xIsPacked = xtexData !== null && xtexData.isPacked;
      let xUnPacked = x;
      if (xIsPacked) {
        xUnPacked = backend2.unpackTensor(x);
        intermediateTensorInfos.push(xUnPacked);
      }
      const [outShape, reduceShape] = computeOutAndReduceShapes(xUnPacked.shape, axes);
      const inSize = sizeFromShape(reduceShape);
      const a2D = reshape({ inputs: { x: xUnPacked }, backend: backend2, attrs: { shape: [-1, inSize] } });
      intermediateTensorInfos.push(a2D);
      const reduced = argReduce(backend2, a2D, reduceType);
      intermediateTensorInfos.push(reduced);
      const reshaped = reshape({ inputs: { x: reduced }, backend: backend2, attrs: { shape: outShape } });
      intermediateTensorInfos.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
      return reshaped;
    }
    return argReducePacked(backend2, x, reduceType);
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function argMax(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis } = attrs;
    let axes = parseAxisParam(axis, x.shape);
    const permutedAxes = getAxesPermutation(axes, x.shape.length);
    let $x = x;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
      $x = transpose({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      intermediateTensorInfos.push($x);
      axes = getInnerMostAxes(axes.length, $x.shape.length);
    }
    assertAxesAreInnerMostDims("argMax", [axes[0]], $x.shape.length);
    const out = argMinMaxReduce(backend2, $x, axes[0], "max");
    intermediateTensorInfos.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return out;
  }
  const argMaxConfig = {
    kernelName: ArgMax,
    backendName: "webgl",
    kernelFunc: argMax
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function argMin(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis } = attrs;
    let axes = parseAxisParam(axis, x.shape);
    const permutedAxes = getAxesPermutation(axes, x.shape.length);
    let $x = x;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
      $x = transpose({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      intermediateTensorInfos.push($x);
      axes = getInnerMostAxes(axes.length, $x.shape.length);
    }
    assertAxesAreInnerMostDims("argMin", [axes[0]], $x.shape.length);
    const out = argMinMaxReduce(backend2, $x, axes[0], "min");
    intermediateTensorInfos.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return out;
  }
  const argMinConfig = {
    kernelName: ArgMin,
    backendName: "webgl",
    kernelFunc: argMin
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ASIN = CHECK_NAN_SNIPPET$1 + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`;
  const asin = unaryKernelFunc({ opSnippet: ASIN });
  const asinConfig = {
    kernelName: Asin,
    backendName: "webgl",
    kernelFunc: asin
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ASINH = CHECK_NAN_SNIPPET$1 + `return log(x + sqrt(x * x + 1.0));`;
  const asinh = unaryKernelFunc({ opSnippet: ASINH });
  const asinhConfig = {
    kernelName: Asinh,
    backendName: "webgl",
    kernelFunc: asinh
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ATAN = CHECK_NAN_SNIPPET$1 + `
  return atan(x);
`;
  const atan = unaryKernelFunc({ opSnippet: ATAN });
  const atanConfig = {
    kernelName: Atan,
    backendName: "webgl",
    kernelFunc: atan
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ATAN2 = CHECK_NAN_SNIPPET + `
  return atan(a, b);
`;
  const ATAN2_PACKED = `
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  const atan2 = binaryKernelFunc({ opSnippet: ATAN2, packedOpSnippet: ATAN2_PACKED });
  const atan2Config = {
    kernelName: Atan2,
    backendName: "webgl",
    kernelFunc: atan2
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ATANH = CHECK_NAN_SNIPPET$1 + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;
  const atanh = unaryKernelFunc({ opSnippet: ATANH });
  const atanhConfig = {
    kernelName: Atanh,
    backendName: "webgl",
    kernelFunc: atanh
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class Pool2DProgram {
    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
      this.variableNames = ["x"];
      if (poolType === "avg" && computePositions) {
        throw new Error("Cannot compute positions for average pool.");
      }
      const filterWidth = convInfo.filterWidth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      this.outputShape = convInfo.outShape;
      const isAvgPool = poolType === "avg";
      const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
      const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
      let initializationValue = "0.0";
      if (!isAvgPool) {
        initializationValue = "-1.0 / 1e-20";
      }
      if (computePositions) {
        const compareOp2 = ">=";
        this.userCode = `
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${compareOp2} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${flattenPositions ? includeBatchInIndex ? batchFlattenPositionStr : flattenPositionStr : `wR * ${effectiveFilterWidth} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      const compareOp = "max";
      let returnValue = `${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      if (poolType === "avg") {
        returnValue = `avgValue / max(count, 1.0)`;
      }
      const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
      const filterWidthVec4Remainder = filterWidth % 4;
      const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
            int xC = xCCorner + wC * ${dilationWidth};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)
            );

            ${updateSnippet}
          }

          int xC = xCCorner + ${filterWidthNearestVec4};
          if (${filterWidthVec4Remainder === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              initializationValue
            );

            ${updateSnippet}
          }
        }
        setOutput(${returnValue});
      }
    `;
    }
  }
  class Pool3DProgram {
    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
      this.variableNames = ["x"];
      if (poolType === "avg" && computePositions) {
        throw new Error("Cannot compute positions for average pool.");
      }
      const filterWidth = convInfo.filterWidth;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationDepth = convInfo.dilationDepth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterDepth = convInfo.effectiveFilterDepth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padFront = convInfo.padInfo.front;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      this.outputShape = convInfo.outShape;
      const isAvgPool = poolType === "avg";
      let initializationValue = "0.0";
      if (!isAvgPool) {
        initializationValue = "-1.0 / 1e-20";
      }
      if (computePositions) {
        const compareOp2 = ">=";
        this.userCode = `
        const ivec3 strides =
            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${effectiveFilterDepth};
              wD += ${dilationDepth}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${convInfo.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${effectiveFilterHeight};
                wR += ${dilationHeight}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${effectiveFilterWidth};
                  wC += ${dilationWidth}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${compareOp2} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${flattenPositions ? includeBatchInIndex ? `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                      wR * ${effectiveFilterWidth} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      const compareOp = "max";
      let returnValue = `${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      if (poolType === "avg") {
        returnValue = `avgValue / max(count, 1.0)`;
      }
      const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
      const filterWidthVec4Remainder = filterWidth % 4;
      const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec3 strides =
        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
              int xC = xCCorner + wC * ${dilationWidth};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)
              );

              ${updateSnippet}
            }

            int xC = xCCorner + ${filterWidthNearestVec4};
            if (${filterWidthVec4Remainder === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                initializationValue
              );

              ${updateSnippet}
            }
          }
        }
        setOutput(${returnValue});
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function avgPool(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    assertNotComplex(x, "avgPool");
    const { filterSize, strides, pad: pad2, dimRoundingMode } = attrs;
    const dilations = 1;
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = computePool2DInfo(x.shape, filterSize, strides, dilations, pad2, dimRoundingMode);
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && arraysEqual(convInfo.inShape, convInfo.outShape)) {
      return identity({ inputs: { x }, backend: backend2 });
    }
    const avgPoolProgram = new Pool2DProgram(convInfo, "avg", false);
    return backend2.runWebGLProgram(avgPoolProgram, [x], "float32");
  }
  const avgPoolConfig = {
    kernelName: AvgPool,
    backendName: "webgl",
    kernelFunc: avgPool
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function avgPool3D(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { filterSize, strides, pad: pad2, dimRoundingMode, dataFormat } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = computePool3DInfo(x.shape, filterSize, strides, dilations, pad2, dimRoundingMode, dataFormat);
    const avgPoolProgram = new Pool3DProgram(convInfo, "avg", false);
    return backend2.runWebGLProgram(avgPoolProgram, [x], "float32");
  }
  const avgPool3DConfig = {
    kernelName: AvgPool3D,
    backendName: "webgl",
    kernelFunc: avgPool3D
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class AvgPool2DBackpropProgram {
    constructor(convInfo) {
      this.variableNames = ["dy"];
      this.outputShape = convInfo.inShape;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const avgMultiplier = 1 / (filterHeight * filterWidth);
      this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth};
            wC+= ${dilationWidth}) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class AvgPool3DBackpropProgram {
    constructor(convInfo) {
      this.variableNames = ["dy"];
      this.outputShape = convInfo.inShape;
      const filterDepth = convInfo.filterDepth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationDepth = convInfo.dilationDepth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterDepth = convInfo.effectiveFilterDepth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
      this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function avgPool3DGrad(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, input } = inputs;
    const x = input;
    const { filterSize, strides, pad: pad2, dimRoundingMode } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = computePool3DInfo(x.shape, filterSize, strides, dilations, pad2, dimRoundingMode);
    const avgPoolBackpropProgram = new AvgPool3DBackpropProgram(convInfo);
    return backend2.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);
  }
  const avgPool3DGradConfig = {
    kernelName: AvgPool3DGrad,
    backendName: "webgl",
    kernelFunc: avgPool3DGrad
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function avgPoolGrad(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, input } = inputs;
    const x = input;
    assertNotComplex([dy, input], "avgPoolGrad");
    const { filterSize, strides, pad: pad2 } = attrs;
    const convInfo = computePool2DInfo(x.shape, filterSize, strides, 1, pad2);
    const avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);
    return backend2.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);
  }
  const avgPoolGradConfig = {
    kernelName: AvgPoolGrad,
    backendName: "webgl",
    kernelFunc: avgPoolGrad
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function batchMatMul(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { a, b } = inputs;
    const { transposeA, transposeB } = attrs;
    return batchMatMulImpl({ a, b, transposeA, transposeB, backend: backend2 });
  }
  const batchMatMulConfig = {
    kernelName: BatchMatMul,
    backendName: "webgl",
    kernelFunc: batchMatMul
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class BatchNormProgram {
    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
      this.outputShape = [];
      this.variableNames = ["x", "mean", "variance"];
      assertAndGetBroadcastShape(xShape, meanShape);
      assertAndGetBroadcastShape(xShape, varianceShape);
      let offsetSnippet = "0.0";
      if (offsetShape != null) {
        assertAndGetBroadcastShape(xShape, offsetShape);
        this.variableNames.push("offset");
        offsetSnippet = "getOffsetAtOutCoords()";
      }
      let scaleSnippet = "1.0";
      if (scaleShape != null) {
        assertAndGetBroadcastShape(xShape, scaleShape);
        this.variableNames.push("scale");
        scaleSnippet = "getScaleAtOutCoords()";
      }
      this.outputShape = xShape;
      this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${offsetSnippet};
        float scale = ${scaleSnippet};
        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class BatchNormPackedProgram {
    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
      this.packedInputs = true;
      this.packedOutput = true;
      this.variableNames = ["x", "mean", "variance"];
      assertAndGetBroadcastShape(xShape, meanShape);
      assertAndGetBroadcastShape(xShape, varianceShape);
      let offsetSnippet = "vec4(0.0)";
      if (offsetShape != null) {
        assertAndGetBroadcastShape(xShape, offsetShape);
        this.variableNames.push("offset");
        offsetSnippet = "getOffsetAtOutCoords()";
      }
      let scaleSnippet = "vec4(1.0)";
      if (scaleShape != null) {
        assertAndGetBroadcastShape(xShape, scaleShape);
        this.variableNames.push("scale");
        scaleSnippet = "getScaleAtOutCoords()";
      }
      this.outputShape = xShape;
      this.userCode = `
      void main() {
        vec4 offset = ${offsetSnippet};
        vec4 scale = ${scaleSnippet};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));

        setOutput((x - mean) * inv + offset);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const batchNorm = ({ inputs, backend: backend2, attrs }) => {
    const { x, mean: mean2, variance, offset, scale } = inputs;
    assert(mean2.shape.length === variance.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
    assert(offset == null || mean2.shape.length === offset.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
    assert(scale == null || mean2.shape.length === scale.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    let { varianceEpsilon } = attrs;
    if (varianceEpsilon == null) {
      varianceEpsilon = 1e-3;
    }
    const finalInputs = [x, mean2, variance];
    let offsetShape = null;
    if (offset != null) {
      offsetShape = offset.shape;
      finalInputs.push(offset);
    }
    let scaleShape = null;
    if (scale != null) {
      scaleShape = scale.shape;
      finalInputs.push(scale);
    }
    const program = env().getBool("WEBGL_PACK_NORMALIZATION") ? new BatchNormPackedProgram(x.shape, mean2.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon) : new BatchNormProgram(x.shape, mean2.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
    const output = backend2.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);
    return output;
  };
  const batchNormConfig = {
    kernelName: FusedBatchNorm,
    backendName: "webgl",
    kernelFunc: batchNorm
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class SliceProgram {
    constructor(destSize) {
      this.variableNames = ["source"];
      this.outputShape = destSize;
      this.rank = destSize.length;
      const dtype = getCoordsDataType(this.rank);
      this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
      const sourceCoords = getCoords$1(this.rank);
      let body;
      const coordSum = destSize.map((_, i) => {
        return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;
      });
      body = `
        ${dtype} sourceLoc;
        ${dtype} coords = getOutputCoords();
        ${coordSum.join("\n")}
      `;
      this.userCode = `
      void main() {
        ${body}
        setOutput(getSource(${sourceCoords}));
      }
    `;
    }
  }
  const coords = ["x", "y", "z", "w", "u", "v"];
  function getCoords$1(rank) {
    if (rank === 1) {
      return "sourceLoc";
    } else if (rank <= 6) {
      return coords.slice(0, rank).map((x) => "sourceLoc." + x).join(",");
    } else {
      throw Error(`Slicing for rank ${rank} is not yet supported`);
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class SlicePackedProgram {
    constructor(destSize) {
      this.variableNames = ["source"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = destSize;
      this.rank = destSize.length;
      this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
      const dtype = getCoordsDataType(this.rank);
      const coords2 = getChannels("coords", this.rank);
      const sourceLoc = getChannels("sourceLoc", this.rank);
      const innerDims = this.rank === 1 ? "sourceLoc" : `vec2(${sourceLoc.slice(-2).join()})`;
      const getChannel = `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;
      const upperRow = `
      result.x = ${getChannel};
      if (++${coords2[this.rank - 1]} < ${destSize[this.rank - 1]}) {
        ++${sourceLoc[this.rank - 1]};
        result.y = ${getChannel};
        --${sourceLoc[this.rank - 1]};
      }
    `;
      const lowerRow = this.rank === 1 ? "" : `
      --${coords2[this.rank - 1]};
      if (++${coords2[this.rank - 2]} < ${destSize[this.rank - 2]}) {
        ++${sourceLoc[this.rank - 2]};
        result.z = ${getChannel};
        if (++${coords2[this.rank - 1]} < ${destSize[this.rank - 1]}) {
          ++${sourceLoc[this.rank - 1]};
          result.w = ${getChannel};
        }
      }
    `;
      const sourceLocSetup = this.rank <= 4 ? `sourceLoc = coords +
            ${dtype}(${destSize.map((_, i) => `start[${i}]`).join()});` : destSize.map((_, i) => `${sourceLoc[i]} = ${coords2[i]} + start[${i}];`).join("\n");
      this.userCode = `
      void main() {
        ${dtype} coords = getOutputCoords();
        ${dtype} sourceLoc;
        ${sourceLocSetup}
        vec4 result = vec4(0.);
        ${upperRow}
        ${lowerRow}
        setOutput(result);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function shallowSlice(x, begin, size, backend2) {
    const xTexData = backend2.texData.get(x.dataId);
    const t = backend2.makeTensorInfo(size, x.dtype);
    const newTexData = backend2.texData.get(t.dataId);
    Object.assign(newTexData, xTexData);
    newTexData.refCount = 1;
    newTexData.shape = size;
    newTexData.dtype = x.dtype;
    let flatOffset = computeFlatOffset(begin, computeStrides(x.shape));
    if (xTexData.slice) {
      flatOffset += xTexData.slice.flatOffset;
    }
    newTexData.slice = {
      flatOffset,
      // Point to the original dataId, which is used to do ref counting.
      origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId
    };
    const refCount = backend2.dataRefCount.get(newTexData.slice.origDataId) || 1;
    backend2.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);
    return t;
  }
  function slice(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { begin, size } = attrs;
    const [$begin, $size] = parseSliceParams(x, begin, size);
    assertParamsValid(x, $begin, $size);
    if (sizeFromShape($size) === 0) {
      return backend2.makeTensorInfo($size, x.dtype, []);
    }
    if (backend2.shouldExecuteOnCPU([x]) || x.dtype === "string") {
      const xTexData = backend2.texData.get(x.dataId);
      const outValues = sliceImplCPU(xTexData.values, $begin, $size, x.shape, x.dtype);
      return backend2.makeTensorInfo($size, x.dtype, outValues);
    }
    const { isPacked } = backend2.texData.get(x.dataId);
    const isContinous = isSliceContinous(x.shape, $begin, $size);
    if (isPacked || !isContinous) {
      const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new SlicePackedProgram($size) : new SliceProgram($size);
      const customValues = [$begin];
      return backend2.runWebGLProgram(program, [x], x.dtype, customValues);
    }
    backend2.uploadToGPU(x.dataId);
    return shallowSlice(x, $begin, $size, backend2);
  }
  const sliceConfig = {
    kernelName: Slice,
    backendName: "webgl",
    kernelFunc: slice
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const batchToSpaceND = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { blockShape, crops } = attrs;
    assert(x.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
    const prod2 = blockShape.reduce((a, b) => a * b);
    const reshaped = getReshaped(x.shape, blockShape, prod2);
    const permuted = getPermuted(reshaped.length, blockShape.length);
    const reshapedPermuted = getReshapedPermuted(x.shape, blockShape, prod2);
    const sliceBeginCoords = getSliceBeginCoords(crops, blockShape.length);
    const sliceSize = getSliceSize(reshapedPermuted, crops, blockShape.length);
    const toDispose = [];
    const reshapedIntermediate = reshape({ inputs: { x }, backend: backend2, attrs: { shape: reshaped } });
    const transposedIntermediate = transpose({ inputs: { x: reshapedIntermediate }, backend: backend2, attrs: { perm: permuted } });
    const reshapedIntermediate2 = reshape({
      inputs: { x: transposedIntermediate },
      backend: backend2,
      attrs: { shape: reshapedPermuted }
    });
    const sliced = slice({
      inputs: { x: reshapedIntermediate2 },
      backend: backend2,
      attrs: { begin: sliceBeginCoords, size: sliceSize }
    });
    toDispose.push(reshapedIntermediate);
    toDispose.push(transposedIntermediate);
    toDispose.push(reshapedIntermediate2);
    toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return sliced;
  };
  const batchToSpaceNDConfig = {
    kernelName: BatchToSpaceND,
    backendName: "webgl",
    kernelFunc: batchToSpaceND
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function bincount(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, weights } = inputs;
    const { size } = attrs;
    const xVals = backend2.readSync(x.dataId);
    const weightsVals = backend2.readSync(weights.dataId);
    const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);
    return backend2.makeTensorInfo([size], weights.dtype, outVals);
  }
  const bincountConfig = {
    kernelName: Bincount,
    backendName: "webgl",
    kernelFunc: bincount
  };
  /**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const BITWISEAND = `
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`;
  const BITWISEAND_UNPACKED = `
  return float(int(a.r) & int(b.r));
`;
  function bitwiseAnd(args) {
    const { inputs, backend: backend2 } = args;
    const { a, b } = inputs;
    const shouldUsePackedProgram = env().getBool("WEBGL_PACK_BINARY_OPERATIONS");
    const versionNumber = env().getNumber("WEBGL_VERSION");
    if (backend2.shouldExecuteOnCPU([a, b]) || versionNumber === 1) {
      const aVals = backend2.texData.get(a.dataId).values;
      const bVals = backend2.texData.get(b.dataId).values;
      const [outValues, outShape] = bitwiseAndImplCPU(a.shape, b.shape, aVals, bVals, a.dtype);
      const out = backend2.makeTensorInfo(outShape, a.dtype);
      const outData = backend2.texData.get(out.dataId);
      outData.values = outValues;
      return out;
    }
    let program;
    if (shouldUsePackedProgram) {
      program = new BinaryOpPackedProgram(BITWISEAND, a.shape, b.shape, false);
    } else {
      program = new BinaryOpProgram(BITWISEAND_UNPACKED, a.shape, b.shape);
    }
    return backend2.runWebGLProgram(program, [a, b], a.dtype);
  }
  const bitwiseAndConfig = {
    kernelName: BitwiseAnd,
    backendName: "webgl",
    kernelFunc: bitwiseAnd
  };
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function broadcastArgs(args) {
    const { inputs, backend: backend2 } = args;
    const { s0, s1 } = inputs;
    const s0Vals = backend2.readSync(s0.dataId);
    const s1Vals = backend2.readSync(s1.dataId);
    const broadcastShape = assertAndGetBroadcastShape(Array.from(s0Vals), Array.from(s1Vals));
    return backend2.makeTensorInfo([broadcastShape.length], "int32", Int32Array.from(broadcastShape));
  }
  const broadcastArgsConfig = {
    kernelName: BroadcastArgs,
    backendName: "webgl",
    kernelFunc: broadcastArgs
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const NOT_EQUAL = `return float(a != b);`;
  const notEqual = binaryKernelFunc({ opSnippet: NOT_EQUAL, cpuKernelImpl: notEqualImplCPU, dtype: "bool" });
  const notEqualConfig = {
    kernelName: NotEqual,
    backendName: "webgl",
    kernelFunc: notEqual
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function real(args) {
    const { inputs, backend: backend2 } = args;
    const { input } = inputs;
    const inputData = backend2.texData.get(input.dataId);
    return identity({ inputs: { x: inputData.complexTensorInfos.real }, backend: backend2 });
  }
  const realConfig = {
    kernelName: Real,
    backendName: "webgl",
    kernelFunc: real
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const TO_INT = `return float(int(x));`;
  function int(input, backend2) {
    const program = new UnaryOpProgram(input.shape, TO_INT);
    const output = backend2.runWebGLProgram(program, [input], "int32");
    return { dataId: output.dataId, shape: output.shape, dtype: output.dtype };
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function cast(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { dtype } = attrs;
    if (dtype === "complex64") {
      if (x.dtype === "complex64") {
        return identity({ inputs: { x }, backend: backend2 });
      }
      const zerosTensor = zeros(x.shape);
      const floatX = cast({ inputs: { x }, backend: backend2, attrs: { dtype: "float32" } });
      const result = complex({ inputs: { real: floatX, imag: zerosTensor }, backend: backend2 });
      zerosTensor.dispose();
      backend2.disposeIntermediateTensorInfo(floatX);
      return result;
    }
    if (x.dtype === "complex64") {
      const realPart = real({ inputs: { input: x }, backend: backend2 });
      const result = cast({ inputs: { x: realPart }, backend: backend2, attrs: { dtype } });
      backend2.disposeIntermediateTensorInfo(realPart);
      return result;
    }
    if (!hasEncodingLoss(x.dtype, dtype)) {
      const result = identity({ inputs: { x }, backend: backend2 });
      return { dataId: result.dataId, shape: result.shape, dtype };
    }
    if (backend2.shouldExecuteOnCPU([x])) {
      const values = backend2.texData.get(x.dataId).values;
      const [resultShape, resultType, resultData] = castImplCPU(values, x.shape, x.dtype, dtype);
      return backend2.makeTensorInfo(resultShape, resultType, resultData);
    }
    if (dtype === "int32") {
      return int(x, backend2);
    }
    if (dtype === "bool") {
      const zerosTensorInfo = backend2.makeTensorInfo([], "bool", getTypedArrayFromDType("bool", 1));
      const binaryInputs = { a: x, b: zerosTensorInfo };
      const result = notEqual({ inputs: binaryInputs, backend: backend2 });
      backend2.disposeIntermediateTensorInfo(zerosTensorInfo);
      return result;
    }
    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
  }
  const castConfig = {
    kernelName: Cast,
    backendName: "webgl",
    kernelFunc: cast
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const CEIL = `return ceil(x);`;
  const ceil = unaryKernelFunc({ opSnippet: CEIL, packedOpSnippet: CEIL, cpuKernelImpl: ceilImplCPU });
  const ceilConfig = {
    kernelName: Ceil,
    backendName: "webgl",
    kernelFunc: ceil
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ClipProgram {
    constructor(aShape) {
      this.variableNames = ["A"];
      this.customUniforms = [
        { name: "minVal", type: "float" },
        { name: "maxVal", type: "float" }
      ];
      this.outputShape = aShape;
      this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ClipPackedProgram {
    constructor(aShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [
        { name: "minVal", type: "float" },
        { name: "maxVal", type: "float" }
      ];
      this.outputShape = aShape;
      this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function clipByValue(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { clipValueMin, clipValueMax } = attrs;
    let program;
    if (env().getBool("WEBGL_PACK_CLIP")) {
      program = new ClipPackedProgram(x.shape);
    } else {
      program = new ClipProgram(x.shape);
    }
    const customValues = [[clipValueMin], [clipValueMax]];
    return backend2.runWebGLProgram(program, [x], x.dtype, customValues);
  }
  const clipByValueConfig = {
    kernelName: ClipByValue,
    backendName: "webgl",
    kernelFunc: clipByValue
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ComplexAbsProgram {
    constructor(shape) {
      this.variableNames = ["real", "imag"];
      this.outputShape = shape;
      this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function makeComplexComponentTensorInfo(complexTensor, complexPart) {
    return {
      dataId: complexPart.dataId,
      dtype: complexPart.dtype,
      shape: complexTensor.shape
    };
  }
  function complexAbs(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    const xData = backend2.texData.get(x.dataId);
    const program = new ComplexAbsProgram(x.shape);
    const programInputs = [
      makeComplexComponentTensorInfo(x, xData.complexTensorInfos.real),
      makeComplexComponentTensorInfo(x, xData.complexTensorInfos.imag)
    ];
    return backend2.runWebGLProgram(program, programInputs, programInputs[0].dtype);
  }
  const complexAbsConfig = {
    kernelName: ComplexAbs,
    backendName: "webgl",
    kernelFunc: complexAbs
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ConcatProgram {
    // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().
    constructor(shapes) {
      this.outputShape = [];
      this.outputShape = computeOutShape$1(
        shapes,
        1
        /* axis */
      );
      this.variableNames = shapes.map((_, i) => `T${i}`);
      const offsets = new Array(shapes.length - 1);
      offsets[0] = shapes[0][1];
      for (let i = 1; i < offsets.length; i++) {
        offsets[i] = offsets[i - 1] + shapes[i][1];
      }
      const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];
      for (let i = 1; i < offsets.length; i++) {
        const shift = offsets[i - 1];
        snippets.push(`else if (yC < ${offsets[i]}) setOutput(getT${i}(yR, yC-${shift}));`);
      }
      const lastIndex = offsets.length;
      const lastShift = offsets[offsets.length - 1];
      snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${snippets.join("\n        ")}
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ConcatPackedProgram {
    constructor(shapes, axis) {
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = [];
      this.outputShape = computeOutShape$1(shapes, axis);
      const shape = this.outputShape;
      const rank = shape.length;
      const dtype = getCoordsDataType(rank);
      const coords2 = getChannels("coords", rank);
      const channels = ["x", "y", "z", "w", "u", "v"].slice(0, rank);
      this.variableNames = shapes.map((_, i) => `T${i}`);
      const offsets = new Array(shapes.length - 1);
      offsets[0] = shapes[0][axis];
      for (let i = 1; i < offsets.length; i++) {
        offsets[i] = offsets[i - 1] + shapes[i][axis];
      }
      const channel = channels[axis];
      const lastChannels = channels.slice(-2);
      const allChannels = channels.join();
      let getValueSnippet = `if (${channel} < ${offsets[0]}) {
        return getChannel(
            getT0(${allChannels}), vec2(${lastChannels.join()}));
        }`;
      for (let i = 1; i < offsets.length; i++) {
        const shift2 = offsets[i - 1];
        getValueSnippet += `
        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {
          return getChannel(
            getT${i}(${shiftedChannels(channels, channel, shift2)}),
            vec2(${shiftedChannels(lastChannels, channel, shift2)}));
        }`;
      }
      const lastIndex = offsets.length;
      const shift = offsets[offsets.length - 1];
      getValueSnippet += `
        return getChannel(
          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),
          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;
      this.userCode = `
      float getValue(${channels.map((x) => "int " + x)}) {
        ${getValueSnippet}
      }

      void main() {
        ${dtype} coords = getOutputCoords();
        vec4 result = vec4(getValue(${coords2}), 0., 0., 0.);

        ${coords2[rank - 1]} = ${coords2[rank - 1]} + 1;
        if (${coords2[rank - 1]} < ${shape[rank - 1]}) {
          result.g = getValue(${coords2});
        }

        ${coords2[rank - 2]} = ${coords2[rank - 2]} + 1;
        if (${coords2[rank - 2]} < ${shape[rank - 2]}) {
          result.a = getValue(${coords2});
        }

        ${coords2[rank - 1]} = ${coords2[rank - 1]} - 1;
        if (${coords2[rank - 2]} < ${shape[rank - 2]} &&
            ${coords2[rank - 1]} < ${shape[rank - 1]}) {
          result.b = getValue(${coords2});
        }
        setOutput(result);
      }
    `;
    }
  }
  function shiftedChannels(channels, channel, shift) {
    const channelIdx = channels.indexOf(channel);
    const res = channels.map((c, idx) => {
      if (idx === channelIdx) {
        return `${c} - ${shift}`;
      } else {
        return c;
      }
    });
    return res.join();
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function imag(args) {
    const { inputs, backend: backend2 } = args;
    const { input } = inputs;
    const inputData = backend2.texData.get(input.dataId);
    return identity({ inputs: { x: inputData.complexTensorInfos.imag }, backend: backend2 });
  }
  const imagConfig = {
    kernelName: Imag,
    backendName: "webgl",
    kernelFunc: imag
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function concatImpl(inputs, axis, backend2) {
    const dtype = inputs[0].dtype;
    if (dtype === "complex64") {
      const reals = inputs.map((t) => real({ inputs: { input: t }, backend: backend2 }));
      const imags = inputs.map((t) => imag({ inputs: { input: t }, backend: backend2 }));
      const realConcated = concatImpl(reals, axis, backend2);
      const imagConcated = concatImpl(imags, axis, backend2);
      const result2 = complex({ inputs: { real: realConcated, imag: imagConcated }, backend: backend2 });
      reals.forEach((r) => backend2.disposeIntermediateTensorInfo(r));
      imags.forEach((i) => backend2.disposeIntermediateTensorInfo(i));
      backend2.disposeIntermediateTensorInfo(realConcated);
      backend2.disposeIntermediateTensorInfo(imagConcated);
      return result2;
    }
    let runOnCpu = backend2.shouldExecuteOnCPU(inputs);
    if (dtype === "string") {
      runOnCpu = true;
    }
    if (runOnCpu) {
      const tensors2D2 = inputs.map((t) => {
        const innerSize = sizeFromShape(t.shape.slice(axis));
        const shape = [-1, innerSize];
        return reshape({ inputs: { x: t }, backend: backend2, attrs: { shape } });
      });
      const inputsValShapes = tensors2D2.map((t) => {
        return { vals: backend2.readSync(t.dataId), shape: t.shape };
      });
      const outShape2 = computeOutShape$1(
        tensors2D2.map((t) => t.shape),
        1
        /* axis */
      );
      const simplyConcat = tensors2D2[0].shape[0] === 1;
      const outVals = concatImplCPU(inputsValShapes, outShape2, dtype, simplyConcat);
      const finalOutShape = computeOutShape$1(inputs.map((t) => t.shape), axis);
      const outInfo = backend2.makeTensorInfo(finalOutShape, dtype, outVals);
      tensors2D2.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
      return outInfo;
    }
    const $inputs = inputs.filter((t) => sizeFromShape(t.shape) > 0);
    const shouldPack = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && $inputs[0].shape.length > 1;
    if ($inputs.length === 1) {
      const program2 = shouldPack ? new UnaryOpProgram(inputs[0].shape, CLONE) : new UnaryOpPackedProgram(inputs[0].shape, CLONE);
      return backend2.runWebGLProgram(program2, inputs, dtype);
    }
    const maxTexturesInShader = env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
    if ($inputs.length > maxTexturesInShader) {
      const reducedInputs = [];
      for (let i = 0; i < $inputs.length; i += maxTexturesInShader) {
        const subArray = $inputs.slice(i, i + maxTexturesInShader);
        reducedInputs.push(concatImpl(subArray, axis, backend2));
      }
      const result2 = concatImpl(reducedInputs, axis, backend2);
      for (const i of reducedInputs) {
        backend2.disposeIntermediateTensorInfo(i);
      }
      return result2;
    }
    if (shouldPack) {
      const program2 = new ConcatPackedProgram($inputs.map((t) => t.shape), axis);
      return backend2.runWebGLProgram(program2, $inputs, dtype);
    }
    const { tensors2D, outShape } = computeTensors2D($inputs, axis, backend2);
    const program = new ConcatProgram(tensors2D.map((t) => t.shape));
    const result = backend2.runWebGLProgram(program, tensors2D, dtype);
    tensors2D.forEach((r) => backend2.disposeIntermediateTensorInfo(r));
    const reshapedResult = reshape({ inputs: { x: result }, attrs: { shape: outShape }, backend: backend2 });
    backend2.disposeIntermediateTensorInfo(result);
    return reshapedResult;
  }
  function computeTensors2D(inputs, axis, backend2) {
    const outShape = computeOutShape$1(inputs.map((t) => t.shape), axis);
    const tensors2D = inputs.map((x) => reshape({
      inputs: { x },
      attrs: { shape: [-1, sizeFromShape(x.shape.slice(axis))] },
      backend: backend2
    }));
    return { tensors2D, outShape };
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function concat(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { axis } = attrs;
    const $axis = parseAxisParam(axis, inputs[0].shape)[0];
    const shapes = inputs.map((t) => t.shape);
    assertParamsConsistent(shapes, $axis);
    const outShape = computeOutShape$1(inputs.map((t) => t.shape), $axis);
    if (sizeFromShape(outShape) === 0) {
      return backend2.makeTensorInfo(outShape, inputs[0].dtype, []);
    }
    const $inputs = inputs.filter((t) => sizeFromShape(t.shape) > 0);
    if ($inputs.length === 1) {
      return identity({ inputs: { x: $inputs[0] }, backend: backend2 });
    }
    return concatImpl($inputs, $axis, backend2);
  }
  const concatConfig = {
    kernelName: Concat,
    backendName: "webgl",
    kernelFunc: concat
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class Conv2DProgram {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {
      this.variableNames = ["x", "W"];
      this.outputShape = convInfo.outShape;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
      const inputDepthVec4Remainder = convInfo.inChannels % 4;
      const isChannelsLast = convInfo.dataFormat === "channelsLast";
      const rowDim = isChannelsLast ? 1 : 2;
      const colDim = isChannelsLast ? 2 : 3;
      const channelDim = isChannelsLast ? 3 : 1;
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation) {
        if (hasPreluActivationWeights) {
          activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
        } else if (hasLeakyreluAlpha) {
          activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
        } else {
          activationSnippet = `
          float activation(float x) {
            ${activation}
          }
        `;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivationWeights) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyreluAlpha) {
        this.variableNames.push("leakyreluAlpha");
      }
      this.userCode = `
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${channelDim}];

        ivec2 xRCCorner =
            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * ${dilationHeight};

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * ${dilationWidth};

            if (xC < 0 || xC >= ${convInfo.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${isChannelsLast}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${inputDepthVec4Remainder === 1}) {

              if (${isChannelsLast}) {
                dotProd +=
                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              } else {
                dotProd +=
                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              }

            } else if (${inputDepthVec4Remainder === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)
              );

              if (${isChannelsLast}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${inputDepthVec4Remainder === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)
              );

              if (${isChannelsLast}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
  }
  class Conv3DProgram {
    constructor(convInfo) {
      this.variableNames = ["x", "W"];
      this.outputShape = convInfo.outShape;
      const padFront = convInfo.padInfo.front;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationDepth = convInfo.dilationDepth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const filterDepth = convInfo.filterDepth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
      const inputDepthVec4Remainder = convInfo.inChannels % 4;
      this.userCode = `
      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          int xF = xFCorner + wF * ${dilationDepth};

          if (xF < 0 || xF >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            int xR = xRCorner + wR * ${dilationHeight};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              int xC = xCCorner + wC * ${dilationWidth};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${inputDepthVec4Remainder === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);
              } else if (${inputDepthVec4Remainder === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${inputDepthVec4Remainder === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class Conv2DPackedProgram {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
      this.variableNames = ["x", "W"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [
        { name: "pads", type: "ivec2" },
        { name: "strides", type: "ivec2" },
        { name: "dilations", type: "ivec2" },
        { name: "inDims", type: "ivec2" }
      ];
      this.outputShape = convInfo.outShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const padLeft = convInfo.padInfo.left;
      const strideWidth = convInfo.strideWidth;
      const dilationWidth = convInfo.dilationWidth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const texelsAcross = filterWidth;
      let mainLoop = `
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;
      for (let c = 0; c < filterWidth; c++) {
        mainLoop += `
           vec4 xTexelC${c * 2};
           int xTexelC${c * 2}Ready;
           vec4 xTexelC${c * 2 + 1};
           int xTexelC${c * 2 + 1}Ready;
           vec4 xC${c};`;
      }
      mainLoop += `
     for (int r = 0; r < ${filterHeight}; r++) {
      for (int d1 = 0; d1 < ${convInfo.inChannels}; d1 += 2) {
       `;
      for (let c = 0; c < filterWidth; c++) {
        mainLoop += `
           xTexelC${c * 2} = vec4(0.0);
           xTexelC${c * 2}Ready = 0;
           xTexelC${c * 2 + 1} = vec4(0.0);
           xTexelC${c * 2 + 1}Ready = 0;
           xC${c} = vec4(0.0);`;
      }
      mainLoop += `
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;
      for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {
        const colIndex = texelC * 2;
        mainLoop += `
           xC = xCCorner + ${colIndex * dilationWidth};
           `;
        if (strideWidth === 1) {
          if (colIndex < filterWidth) {
            if (padLeft % 2 === 1) {
              mainLoop += `
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                   xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${colIndex}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex}Ready = 1;
                 }
               `;
              if (dilationWidth === 1 && colIndex > 0) {
                mainLoop += `
                 xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${colIndex}.xy);
                 `;
              } else {
                mainLoop += `
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);
                   } else {
                     xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);
                   }
                   `;
              }
            } else {
              mainLoop += `
                 if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                   xTexelC${colIndex} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${colIndex}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex}Ready = 1;
                 }

                 xC${colIndex} = xTexelC${colIndex};
                 `;
            }
            if (colIndex + 1 < filterWidth) {
              const nextTexelOffset = padLeft % 2 === 0 ? nearestLargerEven(dilationWidth) : dilationWidth;
              if (dilationWidth % 2 === 0 && padLeft % 2 === 1 || dilationWidth % 2 !== 0 && padLeft % 2 !== 1) {
                mainLoop += `
                   xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                     xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${colIndex + 1}.zw = vec2(0.0);
                     }
                     xTexelC${colIndex + 1}Ready = 1;
                   }
                   `;
                if (dilationWidth > 1) {
                  mainLoop += `
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${colIndex + 1} = vec4(previous.zw, xTexelC${colIndex + 1}.xy);
                     } else {
                      xC${colIndex + 1} = vec4(0.0, 0.0, xTexelC${colIndex + 1}.xy);
                     }
                     `;
                } else {
                  mainLoop += `
                     xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.xy);
                     `;
                }
              } else {
                if (nextTexelOffset === 1) {
                  mainLoop += `
                     xC${colIndex + 1} = xTexelC${colIndex};
                     `;
                } else {
                  mainLoop += `
                     xCOffset = xC + ${nextTexelOffset};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                       xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${colIndex + 1}.zw = vec2(0.0);
                       }
                       xTexelC${colIndex + 1}Ready = 1;
                     }

                     xC${colIndex + 1} = xTexelC${colIndex + 1};
                     `;
                }
              }
            }
          }
        } else {
          if (colIndex < filterWidth) {
            if (padLeft % 2 === 1) {
              mainLoop += `
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                   xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${colIndex}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                   xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${colIndex + 1}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex + 1}Ready = 1;
                 }

                 xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
               `;
              if (colIndex + 1 < filterWidth) {
                mainLoop += `
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);
                 `;
              }
            } else {
              mainLoop += `
                 if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                   xTexelC${colIndex} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${colIndex}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                   xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${colIndex + 1}.zw = vec2(0.);
                   }
                   xTexelC${colIndex + 1}Ready = 1;
                 }

                 xC${colIndex} = vec4(
                   xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);
               `;
              if (colIndex + 1 < filterWidth) {
                mainLoop += `
                   xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
                 `;
              }
            }
          }
        }
        if (colIndex < filterWidth) {
          mainLoop += `
             wTexel = getW(r, ${colIndex}, d1, d2);
             dotProd += xC${colIndex}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${convInfo.inChannels}) {
               dotProd += xC${colIndex}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `;
          if (colIndex + 1 < filterWidth) {
            mainLoop += `
               wTexel = getW(r, ${colIndex + 1}, d1, d2);
               dotProd += xC${colIndex + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${convInfo.inChannels}) {
                 dotProd += xC${colIndex + 1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `;
          }
        }
      }
      mainLoop += `
     }
   `;
      mainLoop += `
     }
   `;
      mainLoop += `
     }
   `;
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation) {
        if (hasPreluActivation) {
          activationSnippet = `vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${activation}
         }`;
        } else if (hasLeakyReluAlpha) {
          activationSnippet = `vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${activation}
         }`;
        } else {
          activationSnippet = `vec4 activation(vec4 x) {
           ${activation}
         }`;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivation) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyReluAlpha) {
        this.variableNames.push("leakyreluAlpha");
      }
      this.userCode = `
       ${activationSnippet}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${mainLoop}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${addBiasSnippet}
         ${applyActivationSnippet}
         setOutput(result);
       }
     `;
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class Im2ColPackedProgram {
    constructor(outputShape, convInfo) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [
        { name: "inputShape", type: "ivec4" },
        { name: "pad", type: "ivec2" },
        { name: "stride", type: "ivec2" },
        { name: "dilation", type: "ivec2" },
        { name: "inChannels", type: "int" },
        { name: "itemsPerBlockRow", type: "int" },
        { name: "outWidth", type: "int" }
      ];
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const { dataFormat } = convInfo;
      const glsl = getGlslDifferences();
      const isChannelsLast = dataFormat === "channelsLast";
      const rowDim = isChannelsLast ? 1 : 2;
      const colDim = isChannelsLast ? 2 : 3;
      const boundsCheckingSnippet = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : `if(blockIndex < ${outputShape[2]} && pos < ${outputShape[1]}) {`;
      let unrolled = ``;
      for (let row = 0; row <= 1; row++) {
        for (let col = 0; col <= 1; col++) {
          unrolled += `
          blockIndex = rc.z + ${col};
          pos = rc.y + ${row};

          ${boundsCheckingSnippet}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${rowDim}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${colDim}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${isChannelsLast}) {
                  innerDims = vec2(d1, ch);
                  result[${row * 2 + col}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${row * 2 + col}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
        }
      }
      this.userCode = `
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${unrolled}

        ${glsl.output} = result;
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getShapeForBatchMatMul(shape, isChannelsLast) {
    const length = shape.length;
    if (length >= 3) {
      return isChannelsLast ? [
        ...shape.slice(0, -3),
        shape[length - 3] * shape[length - 2],
        shape[length - 1]
        /* channel */
      ] : [
        ...shape.slice(0, -3),
        shape[length - 3],
        shape[length - 2] * shape[length - 1]
        /* height * width */
      ];
    } else if (!isChannelsLast && length === 1 && shape[0] > 1) {
      return [shape[0], 1];
    } else {
      return null;
    }
  }
  function conv2dByMatMul({ x, filter, convInfo, backend: backend2, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    const xShape = x.shape;
    const xTexData = backend2.texData.get(x.dataId);
    const sharedMatMulDim = convInfo.inChannels;
    const outerShapeX = xShape[0] * xShape[1] * xShape[2];
    const outerShapeFilter = convInfo.outChannels;
    const isChannelsLast = convInfo.dataFormat === "channelsLast";
    const transposeA = false;
    const transposeB = false;
    let out;
    const intermediates = [];
    if (preluActivationWeights != null) {
      const targetShape = getShapeForBatchMatMul(preluActivationWeights.shape, isChannelsLast);
      if (targetShape != null) {
        preluActivationWeights = reshape({
          inputs: { x: preluActivationWeights },
          backend: backend2,
          attrs: { shape: targetShape }
        });
        intermediates.push(preluActivationWeights);
      }
    }
    if (bias != null) {
      const targetShape = getShapeForBatchMatMul(bias.shape, isChannelsLast);
      if (targetShape != null) {
        bias = reshape({ inputs: { x: bias }, backend: backend2, attrs: { shape: targetShape } });
        intermediates.push(bias);
      }
    }
    const batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) && sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;
    const canOptimize = !batchMatMulWillBeUnpacked && xTexData.isPacked && isChannelsLast && xTexData.texture != null && xShape[2] % 2 !== 0 && arraysEqual(xTexData.shape.slice(-3), xShape.slice(-3));
    if (canOptimize) {
      const targetShape = xShape[0] * xShape[1] * (xShape[2] + 1);
      const xReshaped = {
        dataId: x.dataId,
        shape: [1, targetShape, convInfo.inChannels],
        dtype: x.dtype
      };
      const originalXTexDataShape = xTexData.shape;
      xTexData.shape = xTexData.shape.slice();
      xTexData.shape[xTexData.shape.length - 2]++;
      assert(isReshapeFree(xTexData.shape, xReshaped.shape), () => `packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`);
      const filterReshaped = reshape({
        inputs: { x: filter },
        backend: backend2,
        attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
      });
      intermediates.push(filterReshaped);
      const pointwiseConv = batchMatMulImpl({
        a: xReshaped,
        b: filterReshaped,
        backend: backend2,
        transposeA,
        transposeB,
        bias,
        activation,
        preluActivationWeights,
        leakyreluAlpha
      });
      const pointwiseConvTexData = backend2.texData.get(pointwiseConv.dataId);
      assert(pointwiseConvTexData.isPacked, () => "batchMatMul result is expected to be packed");
      xTexData.shape = originalXTexDataShape;
      pointwiseConvTexData.shape = convInfo.outShape;
      out = identity({ inputs: { x: pointwiseConv }, backend: backend2 });
      out.shape = convInfo.outShape;
      intermediates.push(pointwiseConv);
    } else {
      const numCols = convInfo.outHeight * convInfo.outWidth;
      const xReshaped = reshape({
        inputs: { x },
        backend: backend2,
        attrs: {
          shape: isChannelsLast ? [convInfo.batchSize, numCols, convInfo.inChannels] : [convInfo.batchSize, convInfo.inChannels, numCols]
        }
      });
      const filterReshaped = reshape({
        inputs: { x: filter },
        backend: backend2,
        attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
      });
      const result = batchMatMulImpl({
        a: isChannelsLast ? xReshaped : filterReshaped,
        b: isChannelsLast ? filterReshaped : xReshaped,
        transposeA: !isChannelsLast,
        transposeB,
        backend: backend2,
        bias,
        activation,
        preluActivationWeights,
        leakyreluAlpha
      });
      out = reshape({ inputs: { x: result }, backend: backend2, attrs: { shape: convInfo.outShape } });
      intermediates.push(xReshaped);
      intermediates.push(filterReshaped);
      intermediates.push(result);
    }
    for (const i of intermediates) {
      backend2.disposeIntermediateTensorInfo(i);
    }
    return out;
  }
  function conv2dWithIm2Row({ x, filter, convInfo, backend: backend2, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    const { filterWidth, filterHeight, inChannels, outWidth, outHeight, dataFormat } = convInfo;
    const isChannelsLast = dataFormat === "channelsLast";
    const sharedDim = filterWidth * filterHeight * inChannels;
    const numCols = outHeight * outWidth;
    const x2ColShape = [convInfo.batchSize, sharedDim, numCols];
    const transposeA = true;
    const transposeB = false;
    const intermediates = [];
    if (preluActivationWeights != null) {
      const targetShape = getShapeForBatchMatMul(preluActivationWeights.shape, isChannelsLast);
      if (targetShape != null) {
        preluActivationWeights = reshape({
          inputs: { x: preluActivationWeights },
          backend: backend2,
          attrs: { shape: targetShape }
        });
        intermediates.push(preluActivationWeights);
      }
    }
    if (bias != null) {
      const targetShape = getShapeForBatchMatMul(bias.shape, isChannelsLast);
      if (targetShape != null) {
        bias = reshape({ inputs: { x: bias }, backend: backend2, attrs: { shape: targetShape } });
        intermediates.push(bias);
      }
    }
    const w2Row = reshape({
      inputs: { x: filter },
      backend: backend2,
      attrs: { shape: [1, sharedDim, sizeFromShape(filter.shape) / sharedDim] }
    });
    intermediates.push(w2Row);
    const im2ColProgram = new Im2ColPackedProgram(x2ColShape, convInfo);
    const customValues = [
      x.shape,
      [convInfo.padInfo.top, convInfo.padInfo.left],
      [convInfo.strideHeight, convInfo.strideWidth],
      [convInfo.dilationHeight, convInfo.dilationWidth],
      [convInfo.inChannels],
      [convInfo.filterWidth * convInfo.inChannels],
      [convInfo.outWidth]
    ];
    const im2Col = backend2.runWebGLProgram(im2ColProgram, [x], "float32", customValues);
    const im2ColReshaped = reshape({ inputs: { x: im2Col }, backend: backend2, attrs: { shape: x2ColShape } });
    intermediates.push(im2Col);
    intermediates.push(im2ColReshaped);
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === "leakyrelu";
    const fusedActivation = activation ? mapActivationToShaderProgram(activation, true) : null;
    const matmulProgram = new MatMulPackedProgram(isChannelsLast ? im2ColReshaped.shape : w2Row.shape, isChannelsLast ? w2Row.shape : im2ColReshaped.shape, isChannelsLast ? [convInfo.batchSize, numCols, convInfo.outChannels] : [convInfo.batchSize, convInfo.outChannels, numCols], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    const inputs = isChannelsLast ? [im2ColReshaped, w2Row] : [w2Row, im2ColReshaped];
    if (bias) {
      inputs.push(bias);
    }
    if (hasPreluActivationWeights) {
      inputs.push(preluActivationWeights);
    }
    if (hasLeakyreluAlpha) {
      const $leakyreluAlpha = backend2.makeTensorInfo([], "float32", createScalarValue(leakyreluAlpha, "float32"));
      inputs.push($leakyreluAlpha);
      intermediates.push($leakyreluAlpha);
    }
    const product = backend2.runWebGLProgram(matmulProgram, inputs, "float32");
    const out = reshape({ inputs: { x: product }, backend: backend2, attrs: { shape: convInfo.outShape } });
    intermediates.push(product);
    for (const i of intermediates) {
      backend2.disposeIntermediateTensorInfo(i);
    }
    return out;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function conv2d(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter } = inputs;
    const { strides, pad: pad2, dataFormat, dilations, dimRoundingMode } = attrs;
    const $dataFormat = convertConv2DDataFormat(dataFormat);
    const convInfo = computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad2, dimRoundingMode, false, $dataFormat);
    let out;
    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
      out = conv2dByMatMul({ x, filter, convInfo, backend: backend2 });
    } else if (convInfo.strideWidth <= 2 && $dataFormat === "channelsLast" && env().getBool("WEBGL_EXP_CONV")) {
      const program = new Conv2DPackedProgram(convInfo);
      const customValues = [
        [convInfo.padInfo.top, convInfo.padInfo.left],
        [convInfo.strideHeight, convInfo.strideWidth],
        [convInfo.dilationHeight, convInfo.dilationWidth],
        [convInfo.inHeight, convInfo.inWidth]
      ];
      out = backend2.runWebGLProgram(program, [x, filter], "float32", customValues);
    } else if (env().getBool("WEBGL_CONV_IM2COL")) {
      out = conv2dWithIm2Row({ x, filter, convInfo, backend: backend2 });
    } else {
      const program = new Conv2DProgram(convInfo);
      out = backend2.runWebGLProgram(program, [x, filter], "float32");
    }
    const outReshaped = reshape({ inputs: { x: out }, backend: backend2, attrs: { shape: convInfo.outShape } });
    backend2.disposeIntermediateTensorInfo(out);
    return outReshaped;
  }
  const conv2DConfig = {
    kernelName: Conv2D,
    backendName: "webgl",
    kernelFunc: conv2d
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class Conv2DDerFilterProgram {
    constructor(convInfo) {
      this.variableNames = ["x", "dy"];
      this.outputShape = convInfo.filterShape;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const isChannelsLast = convInfo.dataFormat === "channelsLast";
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              ${isChannelsLast ? `float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);` : `float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class Conv2DDerInputProgram {
    constructor(convInfo) {
      this.variableNames = ["dy", "W"];
      this.outputShape = convInfo.inShape;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const isChannelsLast = convInfo.dataFormat === "channelsLast";
      const padTop = filterHeight - 1 - convInfo.padInfo.top;
      const padLeft = filterWidth - 1 - convInfo.padInfo.left;
      const rowDim = isChannelsLast ? 1 : 2;
      const colDim = isChannelsLast ? 2 : 3;
      const channelDim = isChannelsLast ? 3 : 1;
      this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${channelDim}];

        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {

              if (${isChannelsLast}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class Conv3DDerFilterProgram {
    constructor(convInfo) {
      this.variableNames = ["x", "dy"];
      this.outputShape = convInfo.filterShape;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padFront = convInfo.padInfo.front;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {
            int xF = wF + yF * ${strideDepth} - ${padFront};

            if (xF < 0 || xF >= ${convInfo.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
              int xR = wR + yR * ${strideHeight} - ${padTop};

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
                int xC = wC + yC * ${strideWidth} - ${padLeft};

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class Conv3DDerInputProgram {
    constructor(convInfo) {
      this.variableNames = ["dy", "W"];
      this.outputShape = convInfo.inShape;
      const filterDepth = convInfo.filterDepth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padFront = filterDepth - 1 - convInfo.padInfo.front;
      const padTop = filterHeight - 1 - convInfo.padInfo.top;
      const padLeft = filterWidth - 1 - convInfo.padInfo.left;
      this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;

          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${filterDepth} - 1 - wF;

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${filterHeight} - 1 - wR;

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${filterWidth} - 1 - wC;

              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function conv2DBackpropFilter(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, dy } = inputs;
    const { strides, pad: pad2, dataFormat, dimRoundingMode, filterShape } = attrs;
    const $dataFormat = convertConv2DDataFormat(dataFormat);
    const convInfo = computeConv2DInfo(x.shape, filterShape, strides, 1, pad2, dimRoundingMode, false, $dataFormat);
    const program = new Conv2DDerFilterProgram(convInfo);
    return backend2.runWebGLProgram(program, [x, dy], "float32");
  }
  const conv2DBackpropFilterConfig = {
    kernelName: Conv2DBackpropFilter,
    backendName: "webgl",
    kernelFunc: conv2DBackpropFilter
  };
  /**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class Conv2DDerInputPackedProgram {
    constructor(convInfo) {
      this.variableNames = ["dy", "W"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [
        { name: "strides", type: "vec2" }
      ];
      this.outputShape = convInfo.inShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const padTop = filterHeight - 1 - convInfo.padInfo.top;
      const padLeft = filterWidth - 1 - convInfo.padInfo.left;
      this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int wCPerm = ${filterWidth} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${convInfo.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${convInfo.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function conv2DBackpropInput(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, filter } = inputs;
    const { inputShape, strides, pad: pad2, dataFormat, dimRoundingMode } = attrs;
    const $dataFormat = convertConv2DDataFormat(dataFormat);
    const convInfo = computeConv2DInfo(inputShape, filter.shape, strides, 1, pad2, dimRoundingMode, false, $dataFormat);
    if (env().getBool("WEBGL_PACK_CONV2DTRANSPOSE") && $dataFormat === "channelsLast") {
      const customValues = [
        [convInfo.strideHeight, convInfo.strideWidth]
      ];
      const program = new Conv2DDerInputPackedProgram(convInfo);
      return backend2.runWebGLProgram(program, [dy, filter], "float32", customValues);
    } else {
      const program = new Conv2DDerInputProgram(convInfo);
      return backend2.runWebGLProgram(program, [dy, filter], "float32");
    }
  }
  const conv2DBackpropInputConfig = {
    kernelName: Conv2DBackpropInput,
    backendName: "webgl",
    kernelFunc: conv2DBackpropInput
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function conv3D(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter } = inputs;
    const { strides, pad: pad2, dilations } = attrs;
    const convInfo = computeConv3DInfo(x.shape, filter.shape, strides, dilations, pad2);
    const program = new Conv3DProgram(convInfo);
    return backend2.runWebGLProgram(program, [x, filter], "float32");
  }
  const conv3DConfig = {
    kernelName: Conv3D,
    backendName: "webgl",
    kernelFunc: conv3D
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function conv3DBackpropFilterV2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, dy } = inputs;
    const { strides, pad: pad2, filterShape } = attrs;
    const convInfo = computeConv3DInfo(x.shape, filterShape, strides, 1, pad2);
    const program = new Conv3DDerFilterProgram(convInfo);
    return backend2.runWebGLProgram(program, [x, dy], "float32");
  }
  const conv3DBackpropFilterV2Config = {
    kernelName: Conv3DBackpropFilterV2,
    backendName: "webgl",
    kernelFunc: conv3DBackpropFilterV2
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function conv3DBackpropInput(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, filter } = inputs;
    const { pad: pad2, strides, inputShape } = attrs;
    const convInfo = computeConv3DInfo(inputShape, filter.shape, strides, 1, pad2);
    const program = new Conv3DDerInputProgram(convInfo);
    return backend2.runWebGLProgram(program, [dy, filter], "float32");
  }
  const conv3DBackpropInputConfig = {
    kernelName: Conv3DBackpropInputV2,
    backendName: "webgl",
    kernelFunc: conv3DBackpropInput
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const COS = CHECK_NAN_SNIPPET_UNARY + `
  return cos(x);
`;
  const COS_PACKED = `
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${CHECK_NAN_SNIPPET_PACKED}
  return result;
`;
  const cos = unaryKernelFunc({ opSnippet: COS, packedOpSnippet: COS_PACKED });
  const cosConfig = {
    kernelName: Cos,
    backendName: "webgl",
    kernelFunc: cos
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const COSH = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`;
  const cosh = unaryKernelFunc({ opSnippet: COSH });
  const coshConfig = {
    kernelName: Cosh,
    backendName: "webgl",
    kernelFunc: cosh
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class CropAndResizeProgram {
    constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {
      this.variableNames = ["Image", "Boxes", "BoxInd"];
      this.outputShape = [];
      const [batch, imageHeight, imageWidth, depth] = imageShape;
      const [numBoxes] = boxShape;
      const [cropHeight, cropWidth] = cropSize;
      this.outputShape = [numBoxes, cropHeight, cropWidth, depth];
      const methodId = method === "bilinear" ? 1 : 0;
      const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];
      const [heightRatio, heightScale, inY] = cropHeight > 1 ? [
        `${(imageHeight - 1) / (cropHeight - 1)}`,
        "(y2-y1) * height_ratio",
        `y1*${inputHeightFloat} + float(y)*(height_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (y1+y2) * ${inputHeightFloat}`
      ];
      const [widthRatio, widthScale, inX] = cropWidth > 1 ? [
        `${(imageWidth - 1) / (cropWidth - 1)}`,
        "(x2-x1) * width_ratio",
        `x1*${inputWidthFloat} + float(x)*(width_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (x1+x2) * ${inputWidthFloat}`
      ];
      this.userCode = `
      const float height_ratio = float(${heightRatio});
      const float width_ratio = float(${widthRatio});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${batch}) {
          return;
        }

        float height_scale = ${heightScale};
        float width_scale = ${widthScale};

        float in_y = ${inY};
        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }
        float in_x = ${inX};
        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${methodId} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const cropAndResize = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { image: image2, boxes, boxInd } = inputs;
    const { cropSize, method, extrapolationValue } = attrs;
    const program = new CropAndResizeProgram(image2.shape, boxes.shape, cropSize, method, extrapolationValue);
    return backend2.runWebGLProgram(program, [image2, boxes, boxInd], "float32");
  };
  const cropAndResizeConfig = {
    kernelName: CropAndResize,
    backendName: "webgl",
    kernelFunc: cropAndResize
  };
  var CumOpType;
  (function(CumOpType2) {
    CumOpType2["Prod"] = "*";
    CumOpType2["Sum"] = "+";
  })(CumOpType || (CumOpType = {}));
  class CumProgram {
    constructor(op2, outputShape, exclusive, reverse2) {
      this.op = op2;
      this.outputShape = outputShape;
      this.variableNames = ["x"];
      this.customUniforms = [{ name: "index", type: "float" }];
      const rank = this.outputShape.length;
      const initVal = this.op === CumOpType.Prod ? "1.0" : "0.0";
      const val = exclusive ? initVal : `getX(${getCoords(rank, "coords", this.op)})`;
      const length = this.outputShape[this.outputShape.length - 1];
      let condition = "";
      let idxString = "";
      if (exclusive) {
        condition = reverse2 ? `end != ${length - 1}` : "end != 0";
        idxString = reverse2 ? "end + 1" : "end - 1";
      } else {
        condition = reverse2 ? `end + pow2 < ${length}` : "end >= pow2";
        idxString = reverse2 ? "end + pow2" : "end - pow2";
      }
      this.userCode = `
      void main() {
        ${getCoordsDataType(rank)} coords = getOutputCoords();
        int end = ${getFinalCoord(rank, "coords", this.op)};
        float val = ${val};
        int pow2 = int(pow(2.0, index));
        if (${condition}) {
          int idx = ${idxString};
          ${getFinalCoord(rank, "coords", this.op)} = idx;
          val ${this.op}= getX(${getCoords(rank, "coords", this.op)});
        }
        setOutput(val);
      }
    `;
    }
  }
  function getCoords(rank, name, op2) {
    if (rank === 1) {
      return `${name}`;
    } else if (rank === 2) {
      return `${name}.x, ${name}.y`;
    } else if (rank === 3) {
      return `${name}.x, ${name}.y, ${name}.z`;
    } else if (rank === 4) {
      return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;
    } else {
      throw new Error(`Cumulative ${op2} for rank ${rank} is not yet supported`);
    }
  }
  function getFinalCoord(rank, name, op2) {
    if (rank === 1) {
      return `${name}`;
    } else if (rank === 2) {
      return `${name}.y`;
    } else if (rank === 3) {
      return `${name}.z`;
    } else if (rank === 4) {
      return `${name}.w`;
    } else {
      throw new Error(`Cumulative ${op2} for rank ${rank} is not yet supported`);
    }
  }
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function cumImpl(op2, x, backend2, axis, exclusive, reverse2) {
    const xRank = x.shape.length;
    const permutation = getAxesPermutation([axis], xRank);
    let permutedX = x;
    if (permutation != null) {
      permutedX = transpose({ inputs: { x }, backend: backend2, attrs: { perm: permutation } });
    }
    const permutedAxis = getInnerMostAxes(1, xRank)[0];
    if (permutedAxis !== xRank - 1) {
      throw new Error(`WebGL cumprod shader expects an inner-most axis=${x.shape.length - 1} but got axis=${axis}`);
    }
    const size = permutedX.shape[permutedAxis];
    let result = identity({ inputs: { x: permutedX }, backend: backend2 });
    for (let i = 0; i <= Math.ceil(Math.log2(size)) - 1; i++) {
      const program = new CumProgram(op2, permutedX.shape, false, reverse2);
      const customValues = [[i]];
      const prevResult = result;
      result = backend2.runWebGLProgram(program, [result], result.dtype, customValues);
      backend2.disposeIntermediateTensorInfo(prevResult);
    }
    if (exclusive) {
      const program = new CumProgram(op2, permutedX.shape, exclusive, reverse2);
      const prevResult = result;
      result = backend2.runWebGLProgram(program, [result], result.dtype);
      backend2.disposeIntermediateTensorInfo(prevResult);
    }
    if (permutation != null) {
      const reversePermutation = getUndoAxesPermutation(permutation);
      const reverseTransposedResult = transpose({ inputs: { x: result }, backend: backend2, attrs: { perm: reversePermutation } });
      backend2.disposeIntermediateTensorInfo(result);
      backend2.disposeIntermediateTensorInfo(permutedX);
      return reverseTransposedResult;
    }
    return result;
  }
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function cumprod(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, exclusive, reverse: reverse2 } = attrs;
    return cumImpl(CumOpType.Prod, x, backend2, axis, exclusive, reverse2);
  }
  const cumprodConfig = {
    kernelName: Cumprod,
    backendName: "webgl",
    kernelFunc: cumprod
  };
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function cumsum(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, exclusive, reverse: reverse2 } = attrs;
    return cumImpl(CumOpType.Sum, x, backend2, axis, exclusive, reverse2);
  }
  const cumsumConfig = {
    kernelName: Cumsum,
    backendName: "webgl",
    kernelFunc: cumsum
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function denseBincount(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, weights } = inputs;
    const { size, binaryOutput } = attrs;
    if (x.shape.length === 1) {
      const xVals = backend2.readSync(x.dataId);
      const weightsVals = backend2.readSync(weights.dataId);
      const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);
      return backend2.makeTensorInfo([size], weights.dtype, outVals);
    } else if (x.shape.length === 2) {
      const xBuf = backend2.bufferSync(x);
      const weightsBuf = backend2.bufferSync(weights);
      const outBuf = bincountReduceImplCPU(xBuf, weightsBuf, size, binaryOutput);
      return backend2.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${x.shape.length}.`);
  }
  const denseBincountConfig = {
    kernelName: DenseBincount,
    backendName: "webgl",
    kernelFunc: denseBincount
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class DepthToSpaceProgram {
    constructor(outputShape, blockSize, dataFormat) {
      this.variableNames = ["x"];
      this.outputShape = [];
      this.outputShape = outputShape;
      this.blockSize = blockSize;
      this.dataFormat = dataFormat;
      this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${blockSize};
      int offset_h = imod(h, ${blockSize});
      int in_w = w / ${blockSize};
      int offset_w = imod(w, ${blockSize});
      int offset_d = (offset_h * ${blockSize} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
    }
    getHeightCoordString() {
      if (this.dataFormat === "NHWC") {
        return `coords[1]`;
      } else {
        return `coords[2]`;
      }
    }
    getWidthCoordString() {
      if (this.dataFormat === "NHWC") {
        return `coords[2]`;
      } else {
        return `coords[3]`;
      }
    }
    getDepthCoordString() {
      if (this.dataFormat === "NHWC") {
        return `coords[3]`;
      } else {
        return `coords[1]`;
      }
    }
    getOutputDepthSize() {
      if (this.dataFormat === "NHWC") {
        return this.outputShape[3];
      } else {
        return this.outputShape[1];
      }
    }
    getInputSamplingString() {
      if (this.dataFormat === "NHWC") {
        return `getX(b, in_h, in_w, in_d)`;
      } else {
        return `getX(b, in_d, in_h, in_w)`;
      }
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function depthToSpace(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { blockSize, dataFormat } = attrs;
    const batchSize = x.shape[0];
    const inputHeight = dataFormat === "NHWC" ? x.shape[1] : x.shape[2];
    const inputWidth = dataFormat === "NHWC" ? x.shape[2] : x.shape[3];
    const inputDepth = dataFormat === "NHWC" ? x.shape[3] : x.shape[1];
    const outputHeight = inputHeight * blockSize;
    const outputWidth = inputWidth * blockSize;
    const outputDepth = inputDepth / (blockSize * blockSize);
    const outputShape = dataFormat === "NHWC" ? [batchSize, outputHeight, outputWidth, outputDepth] : [batchSize, outputDepth, outputHeight, outputWidth];
    const program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);
    return backend2.runWebGLProgram(program, [x], x.dtype);
  }
  const depthToSpaceConfig = {
    kernelName: DepthToSpace,
    backendName: "webgl",
    kernelFunc: depthToSpace
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class DepthwiseConv2DProgram {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
      this.variableNames = ["x", "W"];
      this.customUniforms = [
        { name: "pads", type: "ivec2" },
        { name: "strides", type: "ivec2" },
        { name: "dilations", type: "ivec2" },
        { name: "inDims", type: "ivec2" }
      ];
      this.outputShape = convInfo.outShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const channelMul = convInfo.outChannels / convInfo.inChannels;
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation) {
        if (hasPreluActivation) {
          activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
        } else if (hasLeakyReluAlpha) {
          activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
        } else {
          activationSnippet = `
          float activation(float x) {
            ${activation}
          }
        `;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivation) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyReluAlpha) {
        this.variableNames.push("leakyreluAlpha");
      }
      this.userCode = `
      ${activationSnippet}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class DepthwiseConvPacked2DProgram {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
      this.variableNames = ["x", "W"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [
        { name: "pads", type: "ivec2" },
        { name: "strides", type: "ivec2" },
        { name: "dilations", type: "ivec2" },
        { name: "inDims", type: "ivec2" }
      ];
      this.outputShape = convInfo.outShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const channelMul = convInfo.outChannels / convInfo.inChannels;
      const padLeft = convInfo.padInfo.left;
      const strideWidth = convInfo.strideWidth;
      const dilationWidth = convInfo.dilationWidth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const texelsAcross = filterWidth;
      let mainLoop = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
      for (let c = 0; c < filterWidth; c++) {
        mainLoop += `
          vec4 xTexelC${c * 2};
          int xTexelC${c * 2}Ready;
          vec4 xTexelC${c * 2 + 1};
          int xTexelC${c * 2 + 1}Ready;
          vec4 xC${c};`;
      }
      mainLoop += `
    for (int r = 0; r < ${filterHeight}; r++) {
      `;
      for (let c = 0; c < filterWidth; c++) {
        mainLoop += `
          xTexelC${c * 2} = vec4(0.0);
          xTexelC${c * 2}Ready = 0;
          xTexelC${c * 2 + 1} = vec4(0.0);
          xTexelC${c * 2 + 1}Ready = 0;
          xC${c} = vec4(0.0);`;
      }
      mainLoop += `
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
      for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {
        const colIndex = texelC * 2;
        mainLoop += `
          xC = xCCorner + ${colIndex * dilationWidth};
          `;
        if (strideWidth === 1) {
          if (colIndex < filterWidth) {
            if (padLeft % 2 === 1) {
              mainLoop += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }
              `;
              if (dilationWidth === 1 && colIndex > 0) {
                mainLoop += `
                xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${colIndex}.xy);
                `;
              } else {
                mainLoop += `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);
                  } else {
                    xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);
                  }
                  `;
              }
            } else {
              mainLoop += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                xC${colIndex} = xTexelC${colIndex};
                `;
            }
            if (colIndex + 1 < filterWidth) {
              const nextTexelOffset = padLeft % 2 === 0 ? nearestLargerEven(dilationWidth) : dilationWidth;
              if (dilationWidth % 2 === 0 && padLeft % 2 === 1 || dilationWidth % 2 !== 0 && padLeft % 2 !== 1) {
                mainLoop += `
                  xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                    xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${colIndex + 1}.zw = vec2(0.0);
                    }
                    xTexelC${colIndex + 1}Ready = 1;
                  }
                  `;
                if (dilationWidth > 1) {
                  mainLoop += `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${colIndex + 1} = vec4(previous.zw, xTexelC${colIndex + 1}.xy);
                    } else {
                     xC${colIndex + 1} = vec4(0.0, 0.0, xTexelC${colIndex + 1}.xy);
                    }
                    `;
                } else {
                  mainLoop += `
                    xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.xy);
                    `;
                }
              } else {
                if (nextTexelOffset === 1) {
                  mainLoop += `
                    xC${colIndex + 1} = xTexelC${colIndex};
                    `;
                } else {
                  mainLoop += `
                    xCOffset = xC + ${nextTexelOffset};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                      xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${colIndex + 1}.zw = vec2(0.0);
                      }
                      xTexelC${colIndex + 1}Ready = 1;
                    }

                    xC${colIndex + 1} = xTexelC${colIndex + 1};
                    `;
                }
              }
            }
          }
        } else {
          if (colIndex < filterWidth) {
            if (padLeft % 2 === 1) {
              mainLoop += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                  xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${colIndex + 1}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex + 1}Ready = 1;
                }

                xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
              `;
              if (colIndex + 1 < filterWidth) {
                mainLoop += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);
                `;
              }
            } else {
              mainLoop += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                  xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex + 1}.zw = vec2(0.);
                  }
                  xTexelC${colIndex + 1}Ready = 1;
                }

                xC${colIndex} = vec4(
                  xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);
              `;
              if (colIndex + 1 < filterWidth) {
                mainLoop += `
                  xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
                `;
              }
            }
          }
        }
        if (colIndex < filterWidth) {
          mainLoop += `
            wTexel = getW(r, ${colIndex}, d1, q);
            dotProd += xC${colIndex} * vec4(wTexel.xz, wTexel.xz);
          `;
          if (colIndex + 1 < filterWidth) {
            mainLoop += `
              wTexel = getW(r, ${colIndex + 1}, d1, q);
              dotProd += xC${colIndex + 1} * vec4(wTexel.xz, wTexel.xz);
            `;
          }
        }
      }
      mainLoop += `
    }
  `;
      mainLoop += `
      }
    `;
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation) {
        if (hasPreluActivation) {
          activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
        } else if (hasLeakyReluAlpha) {
          activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
        } else {
          activationSnippet = `vec4 activation(vec4 x) {
          ${activation}
        }`;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivation) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyReluAlpha) {
        this.variableNames.push("leakyreluAlpha");
      }
      this.userCode = `
      ${activationSnippet}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${mainLoop}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function depthwiseConv2dNative(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter } = inputs;
    const { strides, pad: pad2, dilations, dimRoundingMode } = attrs;
    let $dilations = dilations;
    if ($dilations == null) {
      $dilations = [1, 1];
    }
    assert(eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
    const convInfo = computeConv2DInfo(
      x.shape,
      filter.shape,
      strides,
      $dilations,
      pad2,
      dimRoundingMode,
      true
      /* depthwise */
    );
    let program;
    if (env().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1) {
      program = new DepthwiseConvPacked2DProgram(convInfo);
    } else {
      program = new DepthwiseConv2DProgram(convInfo);
    }
    const customValues = [
      [convInfo.padInfo.top, convInfo.padInfo.left],
      [convInfo.strideHeight, convInfo.strideWidth],
      [convInfo.dilationHeight, convInfo.dilationWidth],
      [convInfo.inHeight, convInfo.inWidth]
    ];
    return backend2.runWebGLProgram(program, [x, filter], "float32", customValues);
  }
  const depthwiseConv2dNativeConfig = {
    kernelName: DepthwiseConv2dNative,
    backendName: "webgl",
    kernelFunc: depthwiseConv2dNative
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class DepthwiseConv2DDerFilterProgram {
    constructor(convInfo) {
      this.variableNames = ["x", "dy"];
      this.outputShape = convInfo.filterShape;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const channelMul = convInfo.outChannels / convInfo.inChannels;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${channelMul} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class DepthwiseConv2DDerInputProgram {
    constructor(convInfo) {
      this.variableNames = ["dy", "W"];
      this.outputShape = convInfo.inShape;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padTop = filterHeight - 1 - convInfo.padInfo.top;
      const padLeft = filterWidth - 1 - convInfo.padInfo.left;
      const channelMul = convInfo.outChannels / convInfo.inChannels;
      this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${channelMul}; dm++) {
              int d2 = d1 * ${channelMul} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function depthwiseConv2dNativeBackpropFilter(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, dy } = inputs;
    const { strides, dilations, pad: pad2, dimRoundingMode, filterShape } = attrs;
    const convInfo = computeConv2DInfo(
      x.shape,
      filterShape,
      strides,
      dilations,
      pad2,
      dimRoundingMode,
      true
      /* depthwise */
    );
    const program = new DepthwiseConv2DDerFilterProgram(convInfo);
    return backend2.runWebGLProgram(program, [x, dy], "float32");
  }
  const depthwiseConv2dNativeBackpropFilterConfig = {
    kernelName: DepthwiseConv2dNativeBackpropFilter,
    backendName: "webgl",
    kernelFunc: depthwiseConv2dNativeBackpropFilter
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function depthwiseConv2dNativeBackpropInput(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, filter } = inputs;
    const { strides, dilations, pad: pad2, dimRoundingMode, inputShape } = attrs;
    const convInfo = computeConv2DInfo(
      inputShape,
      filter.shape,
      strides,
      dilations,
      pad2,
      dimRoundingMode,
      true
      /* depthwise */
    );
    const program = new DepthwiseConv2DDerInputProgram(convInfo);
    return backend2.runWebGLProgram(program, [dy, filter], "float32");
  }
  const depthwiseConv2dNativeBackpropInputConfig = {
    kernelName: DepthwiseConv2dNativeBackpropInput,
    backendName: "webgl",
    kernelFunc: depthwiseConv2dNativeBackpropInput
  };
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class DiagProgram {
    constructor(size) {
      this.variableNames = ["X"];
      this.outputShape = [size, size];
      this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function diag(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    const outShape = [...x.shape, ...x.shape];
    const xSize = sizeFromShape(x.shape);
    const flat = reshape({ inputs: { x }, backend: backend2, attrs: { shape: [xSize] } });
    const program = new DiagProgram(xSize);
    const res = backend2.runWebGLProgram(program, [flat], flat.dtype);
    const out = reshape({ inputs: { x: res }, backend: backend2, attrs: { shape: outShape } });
    backend2.disposeIntermediateTensorInfo(flat);
    backend2.disposeIntermediateTensorInfo(res);
    return out;
  }
  const diagConfig = {
    kernelName: Diag,
    backendName: "webgl",
    kernelFunc: diag
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class Dilation2DProgram {
    constructor(convInfo) {
      this.variableNames = ["x", "W"];
      this.outputShape = convInfo.outShape;
      const { inHeight, inWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth } = convInfo;
      const { top: padTop, left: padLeft } = padInfo;
      this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${filterHeight}; h++) {
          int hIn = hBeg + h * ${dilationHeight};

          if (hIn >= 0 && hIn < ${inHeight}) {
            for (int w = 0; w < ${filterWidth}; w++) {
              int wIn = wBeg + w * ${dilationWidth};

              if (wIn >= 0 && wIn < ${inWidth}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function dilation2D(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter } = inputs;
    const { strides, pad: pad2, dilations } = attrs;
    const convInfo = computeDilation2DInfo(x.shape, filter.shape, strides, pad2, "NHWC", dilations);
    let out;
    const program = new Dilation2DProgram(convInfo);
    out = backend2.runWebGLProgram(program, [x, filter], "float32");
    const outReshaped = reshape({ inputs: { x: out }, backend: backend2, attrs: { shape: convInfo.outShape } });
    backend2.disposeIntermediateTensorInfo(out);
    return outReshaped;
  }
  const dilation2DConfig = {
    kernelName: Dilation2D,
    backendName: "webgl",
    kernelFunc: dilation2D
  };
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function einsum(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { equation } = attrs;
    const tensors = inputs;
    const { allDims, summedDims, idDims } = decodeEinsumEquation(equation, tensors.length);
    checkEinsumDimSizes(allDims.length, idDims, tensors);
    const { path, steps } = getEinsumComputePath(summedDims, idDims);
    const nSteps = steps.length;
    let out = null;
    let numDimsRemaining = allDims.length;
    const tensorsToDispose = [];
    for (let i = 0; i < nSteps; ++i) {
      for (const idTerm of steps[i]) {
        const { permutationIndices: perm, expandDims: dimsToExpand } = getEinsumPermutation(numDimsRemaining, idDims[idTerm]);
        let x;
        if (isIdentityPermutation(perm)) {
          x = tensors[idTerm];
        } else {
          x = transpose({ inputs: { x: tensors[idTerm] }, backend: backend2, attrs: { perm } });
          tensorsToDispose.push(x);
        }
        const targetShape = x.shape.slice();
        for (let k3 = 0; k3 < dimsToExpand.length; ++k3) {
          targetShape.splice(dimsToExpand[k3], 0, 1);
        }
        if (!arraysEqual(x.shape, targetShape)) {
          x = reshape({ inputs: { x }, backend: backend2, attrs: { shape: targetShape } });
          tensorsToDispose.push(x);
        }
        if (out === null) {
          out = x;
        } else {
          out = multiply({ inputs: { a: x, b: out }, backend: backend2 });
          tensorsToDispose.push(out);
        }
      }
      if (i < nSteps - 1) {
        if (path[i] >= 0) {
          out = sum({
            inputs: { x: out },
            backend: backend2,
            attrs: {
              axis: path[i] - (allDims.length - numDimsRemaining),
              keepDims: false
            }
          });
          tensorsToDispose.push(out);
        }
        numDimsRemaining--;
      }
    }
    for (const tensorInfo of tensorsToDispose) {
      if (tensorInfo === out) {
        continue;
      }
      backend2.disposeIntermediateTensorInfo(tensorInfo);
    }
    return out;
  }
  const einsumConfig = {
    kernelName: Einsum,
    backendName: "webgl",
    kernelFunc: einsum
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
  const ELU_PACKED = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
  const elu = unaryKernelFunc({ opSnippet: ELU, packedOpSnippet: ELU_PACKED });
  const eluConfig = {
    kernelName: Elu,
    backendName: "webgl",
    kernelFunc: elu
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ELU_DER = `return (b >= 0.0) ? a : a * (b + 1.0);`;
  const ELU_DER_PACKED = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`;
  const eluGrad = (args) => {
    const { inputs, backend: backend2 } = args;
    const { dy, y } = inputs;
    const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(ELU_DER_PACKED, dy.shape, y.shape) : new BinaryOpProgram(ELU_DER, dy.shape, y.shape);
    return backend2.runWebGLProgram(program, [dy, y], dy.dtype);
  };
  const eluGradConfig = {
    kernelName: EluGrad,
    backendName: "webgl",
    kernelFunc: eluGrad
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const PACKED_EQUAL = `
  return vec4(equal(a, b));
`;
  const EQUAL = `return float(a == b);`;
  const equal = binaryKernelFunc({
    opSnippet: EQUAL,
    packedOpSnippet: PACKED_EQUAL,
    dtype: "bool",
    cpuKernelImpl: equalImplCPU
  });
  const equalConfig = {
    kernelName: Equal,
    backendName: "webgl",
    kernelFunc: equal
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ERF = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${ERF_P};
  float a1 = ${ERF_A1};
  float a2 = ${ERF_A2};
  float a3 = ${ERF_A3};
  float a4 = ${ERF_A4};
  float a5 = ${ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`;
  const erf = unaryKernelFunc({ opSnippet: ERF });
  const erfConfig = {
    kernelName: Erf,
    backendName: "webgl",
    kernelFunc: erf
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const EXP = CHECK_NAN_SNIPPET_UNARY + `
  return exp(x);
`;
  const EXP_PACKED = `
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  const exp = unaryKernelFunc({
    opSnippet: EXP,
    packedOpSnippet: EXP_PACKED,
    cpuKernelImpl: expImplCPU,
    dtype: "float32"
  });
  const expConfig = {
    kernelName: Exp,
    backendName: "webgl",
    kernelFunc: exp
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function expandDims(args) {
    const { inputs, attrs, backend: backend2 } = args;
    const { dim } = attrs;
    const { input } = inputs;
    const inputRank = input.shape.length;
    const newShape = input.shape.slice();
    let $dim = dim;
    if (dim < 0) {
      assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);
      $dim = inputRank + dim + 1;
    }
    newShape.splice($dim, 0, 1);
    return reshape({ inputs: { x: input }, backend: backend2, attrs: { shape: newShape } });
  }
  const expandDimsConfig = {
    kernelName: ExpandDims,
    backendName: "webgl",
    kernelFunc: expandDims
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const EXPM1 = `return exp(x) - 1.0;`;
  const expm1 = unaryKernelFunc({ opSnippet: EXPM1, packedOpSnippet: EXPM1, cpuKernelImpl: expm1ImplCPU });
  const expm1Config = {
    kernelName: Expm1,
    backendName: "webgl",
    kernelFunc: expm1
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class FFTProgram {
    constructor(component, inputShape, inverse) {
      this.variableNames = ["real", "imag"];
      const innerDim = inputShape[1];
      this.outputShape = inputShape;
      const exponentMultiplierSnippet = inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;
      const resultDenominator = inverse ? `${innerDim}.0` : "1.0";
      let opString;
      if (component === "real") {
        opString = "return real * expR - imag * expI;";
      } else if (component === "imag") {
        opString = "return real * expI + imag * expR;";
      } else {
        throw new Error(`FFT component must be either "real" or "imag", got ${component}.`);
      }
      this.userCode = `
      const float exponentMultiplier = ${exponentMultiplierSnippet};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${opString}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${innerDim});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${innerDim}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function fftImpl(x, inverse, backend2) {
    const xData = backend2.texData.get(x.dataId);
    const inputSize = sizeFromShape(x.shape);
    const innerDimensionSize = x.shape[x.shape.length - 1];
    const batch = inputSize / innerDimensionSize;
    const input2D = reshape({ inputs: { x }, backend: backend2, attrs: { shape: [batch, innerDimensionSize] } });
    const xShape = input2D.shape;
    const realProgram = new FFTProgram("real", xShape, inverse);
    const imagProgram = new FFTProgram("imag", xShape, inverse);
    const inputs = [
      {
        dataId: xData.complexTensorInfos.real.dataId,
        dtype: xData.complexTensorInfos.real.dtype,
        shape: xShape
      },
      {
        dataId: xData.complexTensorInfos.imag.dataId,
        dtype: xData.complexTensorInfos.imag.dtype,
        shape: xShape
      }
    ];
    const realPart = backend2.runWebGLProgram(realProgram, inputs, "float32");
    const imagPart = backend2.runWebGLProgram(imagProgram, inputs, "float32");
    const complexOutput = complex({ inputs: { real: realPart, imag: imagPart }, backend: backend2 });
    backend2.disposeIntermediateTensorInfo(realPart);
    backend2.disposeIntermediateTensorInfo(imagPart);
    const complexOutputReshaped = reshape({ inputs: { x: complexOutput }, backend: backend2, attrs: { shape: x.shape } });
    backend2.disposeIntermediateTensorInfo(input2D);
    backend2.disposeIntermediateTensorInfo(complexOutput);
    return complexOutputReshaped;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function fft(args) {
    const { inputs, backend: backend2 } = args;
    const { input } = inputs;
    return fftImpl(input, false, backend2);
  }
  const fftConfig = {
    kernelName: FFT,
    backendName: "webgl",
    kernelFunc: fft
  };
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class FillProgram {
    constructor(shape, value) {
      this.outputShape = [];
      this.customUniforms = [{ name: "value", type: "float" }];
      this.variableNames = ["x"];
      this.outputShape = shape;
      this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function fill(args) {
    const { backend: backend2, attrs } = args;
    const { shape, value } = attrs;
    let { dtype } = attrs;
    dtype = dtype || inferDtype(value);
    if (dtype === "string") {
      const values = getArrayFromDType(dtype, sizeFromShape(shape));
      values.fill(value);
      return backend2.makeTensorInfo(shape, dtype, values);
    } else {
      const program = new FillProgram(shape, value);
      const customValues = [[value]];
      return backend2.runWebGLProgram(program, [], dtype, customValues);
    }
  }
  const fillConfig = {
    kernelName: Fill,
    backendName: "webgl",
    kernelFunc: fill
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class FlipLeftRightProgram {
    constructor(imageShape) {
      this.variableNames = ["Image"];
      this.outputShape = [];
      const imageWidth = imageShape[2];
      this.outputShape = imageShape;
      this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${imageWidth} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${imageWidth}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const flipLeftRightConfig = {
    kernelName: FlipLeftRight,
    backendName: "webgl",
    kernelFunc: ({ inputs, backend: backend2 }) => {
      const { image: image2 } = inputs;
      const webglBackend = backend2;
      const program = new FlipLeftRightProgram(image2.shape);
      const output = webglBackend.runWebGLProgram(program, [image2], image2.dtype);
      return output;
    }
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const FLOOR = `return floor(x);`;
  const floor = unaryKernelFunc({ opSnippet: FLOOR, packedOpSnippet: FLOOR, cpuKernelImpl: floorImplCPU });
  const floorConfig = {
    kernelName: Floor,
    backendName: "webgl",
    kernelFunc: floor
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const INT_DIV = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`;
  const INT_DIV_PACKED = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`;
  const floorDiv = binaryKernelFunc({ opSnippet: INT_DIV, packedOpSnippet: INT_DIV_PACKED, dtype: "int32" });
  const floorDivConfig = {
    kernelName: FloorDiv,
    backendName: "webgl",
    kernelFunc: floorDiv
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class FromPixelsProgram {
    constructor(outputShape) {
      this.variableNames = ["A"];
      const glsl = getGlslDifferences();
      const [height, width] = outputShape;
      this.outputShape = outputShape;
      this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);

        vec4 values = ${glsl.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class FromPixelsPackedProgram {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = false;
      this.packedOutput = true;
      const glsl = getGlslDifferences();
      const [height, width] = outputShape;
      this.outputShape = outputShape;
      this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${width}.0, ${height}.0);
            vec4 values = ${glsl.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${glsl.output} = result;
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const fromPixelsConfig = {
    kernelName: FromPixels,
    backendName: "webgl",
    kernelFunc: fromPixels
  };
  let fromPixels2DContext;
  let willReadFrequently = env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
  function fromPixels(args) {
    const { inputs, backend: backend2, attrs } = args;
    let { pixels } = inputs;
    const { numChannels } = attrs;
    const isVideo = typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement;
    const isImage = typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement;
    const [width, height] = isVideo ? [
      pixels.videoWidth,
      pixels.videoHeight
    ] : [pixels.width, pixels.height];
    const texShape = [height, width];
    const outShape = [height, width, numChannels];
    if (isImage || isVideo) {
      const newWillReadFrequently = env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
      if (fromPixels2DContext == null || newWillReadFrequently !== willReadFrequently) {
        willReadFrequently = newWillReadFrequently;
        fromPixels2DContext = document.createElement("canvas").getContext("2d", { willReadFrequently });
      }
      fromPixels2DContext.canvas.width = width;
      fromPixels2DContext.canvas.height = height;
      fromPixels2DContext.drawImage(pixels, 0, 0, width, height);
      pixels = fromPixels2DContext.canvas;
    }
    const tempPixelHandle = backend2.makeTensorInfo(texShape, "int32");
    backend2.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;
    backend2.gpgpu.uploadPixelDataToTexture(backend2.getTexture(tempPixelHandle.dataId), pixels);
    const program = env().getBool("WEBGL_PACK") ? new FromPixelsPackedProgram(outShape) : new FromPixelsProgram(outShape);
    const res = backend2.runWebGLProgram(program, [tempPixelHandle], "int32");
    backend2.disposeData(tempPixelHandle.dataId);
    return res;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function fusedConv2d(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter, bias, preluActivationWeights } = inputs;
    const { strides, pad: pad2, dataFormat, dilations, dimRoundingMode, activation, leakyreluAlpha } = attrs;
    const $dataFormat = convertConv2DDataFormat(dataFormat);
    const convInfo = computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad2, dimRoundingMode, false, $dataFormat);
    let out;
    const intermediates = [];
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === "leakyrelu";
    const prepareInputs = () => {
      const inputs2 = [x, filter];
      const alignInputWithDataFormat = (input, dataFormat2) => {
        if (dataFormat2 === "NCHW" && input.shape.length === 1 && input.shape[0] !== 1) {
          const alignedInput = reshape({
            inputs: { x: input },
            backend: backend2,
            attrs: { shape: [input.shape[0], 1, 1] }
          });
          intermediates.push(alignedInput);
          return alignedInput;
        }
        return input;
      };
      if (hasBias) {
        inputs2.push(alignInputWithDataFormat(bias, dataFormat));
      }
      if (hasPreluActivationWeights) {
        inputs2.push(alignInputWithDataFormat(preluActivationWeights, dataFormat));
      }
      if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend2.makeTensorInfo([], "float32", createScalarValue(leakyreluAlpha, "float32"));
        inputs2.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
      }
      return inputs2;
    };
    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
      out = conv2dByMatMul({
        x,
        filter,
        convInfo,
        backend: backend2,
        bias,
        activation,
        preluActivationWeights,
        leakyreluAlpha
      });
    } else if (convInfo.strideWidth <= 2 && $dataFormat === "channelsLast" && env().getBool("WEBGL_EXP_CONV")) {
      const fusedActivation = activation ? mapActivationToShaderProgram(activation, true) : null;
      const program = new Conv2DPackedProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
      const customValues = [
        [convInfo.padInfo.top, convInfo.padInfo.left],
        [convInfo.strideHeight, convInfo.strideWidth],
        [convInfo.dilationHeight, convInfo.dilationWidth],
        [convInfo.inHeight, convInfo.inWidth]
      ];
      const inputs2 = prepareInputs();
      out = backend2.runWebGLProgram(program, inputs2, "float32", customValues);
    } else if (env().getBool("WEBGL_CONV_IM2COL")) {
      out = conv2dWithIm2Row({
        x,
        filter,
        convInfo,
        backend: backend2,
        bias,
        activation,
        preluActivationWeights,
        leakyreluAlpha
      });
    } else {
      const fusedActivation = activation ? mapActivationToShaderProgram(activation, false) : null;
      const program = new Conv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
      const inputs2 = prepareInputs();
      out = backend2.runWebGLProgram(program, inputs2, "float32");
    }
    const outReshaped = reshape({ inputs: { x: out }, backend: backend2, attrs: { shape: convInfo.outShape } });
    intermediates.push(out);
    intermediates.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return outReshaped;
  }
  const fusedConv2DConfig = {
    kernelName: FusedConv2D,
    backendName: "webgl",
    kernelFunc: fusedConv2d
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function fusedDepthwiseConv2D(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter, bias, preluActivationWeights } = inputs;
    const { strides, pad: pad2, dilations, dimRoundingMode, activation, leakyreluAlpha } = attrs;
    const intermediates = [];
    let $dilations = dilations;
    if ($dilations == null) {
      $dilations = [1, 1];
    }
    assert(eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
    const convInfo = computeConv2DInfo(
      x.shape,
      filter.shape,
      strides,
      $dilations,
      pad2,
      dimRoundingMode,
      true
      /* depthwise */
    );
    const shouldPackDepthwiseConv = env().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1;
    const fusedActivation = activation ? mapActivationToShaderProgram(activation, shouldPackDepthwiseConv) : null;
    const programInputs = [x, filter];
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === "leakyrelu";
    if (hasBias) {
      programInputs.push(bias);
    }
    if (hasPreluActivationWeights) {
      programInputs.push(preluActivationWeights);
    }
    if (hasLeakyreluAlpha) {
      const $leakyreluAlpha = backend2.makeTensorInfo([], "float32", createScalarValue(leakyreluAlpha, "float32"));
      programInputs.push($leakyreluAlpha);
      intermediates.push($leakyreluAlpha);
    }
    let program;
    if (shouldPackDepthwiseConv) {
      program = new DepthwiseConvPacked2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    } else {
      program = new DepthwiseConv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    }
    const customValues = [
      [convInfo.padInfo.top, convInfo.padInfo.left],
      [convInfo.strideHeight, convInfo.strideWidth],
      [convInfo.dilationHeight, convInfo.dilationWidth],
      [convInfo.inHeight, convInfo.inWidth]
    ];
    const result = backend2.runWebGLProgram(program, programInputs, "float32", customValues);
    intermediates.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return result;
  }
  const fusedDepthwiseConv2DConfig = {
    kernelName: FusedDepthwiseConv2D,
    backendName: "webgl",
    kernelFunc: fusedDepthwiseConv2D
  };
  class GatherNDProgram {
    constructor(sliceDim, strides, shape, paramsShape) {
      this.sliceDim = sliceDim;
      this.strides = strides;
      this.paramsShape = paramsShape;
      this.variableNames = ["x", "indices"];
      this.outputShape = shape;
      const dtype = getCoordsDataType(shape.length);
      let mainLoop = `
    int index;`;
      for (let j2 = 0; j2 < this.sliceDim; j2++) {
        mainLoop += `
          index = round(getIndices(coords[0], ${j2}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[j2]};
          flattenIndex += index * ${this.strides[j2]};`;
      }
      this.userCode = `
         void main() {
          ${dtype} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${mainLoop}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function gatherNd(args) {
    const { inputs, backend: backend2 } = args;
    const { params, indices } = inputs;
    const indicesShape = indices.shape;
    const sliceRank = indicesShape[indicesShape.length - 1];
    const paramsSize = sizeFromShape(params.shape);
    const [resultShape, numSlices, sliceSize, strides] = prepareAndValidate(params, indices);
    const flattenIndices = reshape({ inputs: { x: indices }, backend: backend2, attrs: { shape: [numSlices, sliceRank] } });
    const flattenX = reshape({
      inputs: { x: params },
      backend: backend2,
      attrs: { shape: [sizeFromShape(params.shape) / sliceSize, sliceSize] }
    });
    if (backend2.shouldExecuteOnCPU([params, indices]) || params.dtype === "string") {
      const indicesData = backend2.readSync(indices.dataId);
      const paramsBuf = backend2.bufferSync(params);
      const outValue = gatherNdImplCPU(indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize, strides, params.shape, paramsSize);
      return backend2.makeTensorInfo(resultShape, params.dtype, outValue.values);
    }
    const program = new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize], params.shape);
    const res = backend2.runWebGLProgram(program, [flattenX, flattenIndices], flattenX.dtype);
    const reshaped = reshape({ inputs: { x: res }, backend: backend2, attrs: { shape: resultShape } });
    backend2.disposeIntermediateTensorInfo(flattenIndices);
    backend2.disposeIntermediateTensorInfo(flattenX);
    backend2.disposeIntermediateTensorInfo(res);
    return reshaped;
  }
  const gatherNdConfig = {
    kernelName: GatherNd,
    backendName: "webgl",
    kernelFunc: gatherNd
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class GatherProgram {
    constructor(aShape, outputShape) {
      this.variableNames = ["A", "indices"];
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      const dtype = getCoordsDataType(this.rank);
      const sourceCoords = getSourceCoords$1(aShape);
      this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${aShape[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${sourceCoords}));
      }
    `;
    }
  }
  function getSourceCoords$1(aShape, axis) {
    const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
    const sourceCoords = [];
    for (let i = 0; i < aShape.length; i++) {
      if (i === 2) {
        sourceCoords.push("index");
      } else {
        sourceCoords.push(`${currentCoords[i]}`);
      }
    }
    return sourceCoords.join();
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function gatherV2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, indices } = inputs;
    const { axis, batchDims } = attrs;
    const parsedAxis = parseAxisParam(axis, x.shape)[0];
    if (env().get("DEBUG")) {
      const indicesVals = backend2.readSync(indices.dataId);
      const axisDim = x.shape[parsedAxis];
      for (let i = 0; i < indicesVals.length; ++i) {
        const index2 = indicesVals[i];
        assert(index2 <= axisDim - 1 && index2 >= 0, () => `GatherV2: the index value ${index2} is not in [0, ${axisDim - 1}]`);
      }
    }
    const shapeInfo = collectGatherOpShapeInfo(x, indices, parsedAxis, batchDims);
    const indicesSize = sizeFromShape(indices.shape);
    const toDispose = [];
    const flattenX = reshape({
      inputs: { x },
      backend: backend2,
      attrs: {
        shape: [
          shapeInfo.batchSize,
          shapeInfo.outerSize,
          shapeInfo.dimSize,
          shapeInfo.sliceSize
        ]
      }
    });
    const flattenIndex = reshape({
      inputs: { x: indices },
      backend: backend2,
      attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }
    });
    toDispose.push(flattenX);
    toDispose.push(flattenIndex);
    const flattenOutputShape = [
      shapeInfo.batchSize,
      shapeInfo.outerSize,
      indicesSize / shapeInfo.batchSize,
      shapeInfo.sliceSize
    ];
    if (backend2.shouldExecuteOnCPU([x, indices]) || x.dtype === "string") {
      const indicesBuf = backend2.bufferSync(flattenIndex);
      const xBuf = backend2.bufferSync(flattenX);
      const outBuf = gatherV2ImplCPU(xBuf, indicesBuf, flattenOutputShape);
      toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
      return backend2.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
    }
    const program = new GatherProgram(flattenX.shape, flattenOutputShape);
    const res = backend2.runWebGLProgram(program, [flattenX, flattenIndex], flattenX.dtype);
    toDispose.push(res);
    const reshaped = reshape({ inputs: { x: res }, backend: backend2, attrs: { shape: shapeInfo.outputShape } });
    toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return reshaped;
  }
  const gatherV2Config = {
    kernelName: GatherV2,
    backendName: "webgl",
    kernelFunc: gatherV2
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const GREATER = `return float(a > b);`;
  const GREATER_PACKED = `
  return vec4(greaterThan(a, b));
`;
  const greater = binaryKernelFunc({
    opSnippet: GREATER,
    packedOpSnippet: GREATER_PACKED,
    cpuKernelImpl: greaterImplCPU,
    dtype: "bool"
  });
  const greaterConfig = {
    kernelName: Greater,
    backendName: "webgl",
    kernelFunc: greater
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const GREATER_EQUAL = `return float(a >= b);`;
  const GREATER_EQUAL_PACKED = `
  return vec4(greaterThanEqual(a, b));
`;
  const greaterEqual = binaryKernelFunc({
    opSnippet: GREATER_EQUAL,
    packedOpSnippet: GREATER_EQUAL_PACKED,
    dtype: "bool",
    cpuKernelImpl: greaterEqualImplCPU
  });
  const greaterEqualConfig = {
    kernelName: GreaterEqual,
    backendName: "webgl",
    kernelFunc: greaterEqual
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function ifft(args) {
    const { inputs, backend: backend2 } = args;
    const { input } = inputs;
    return fftImpl(input, true, backend2);
  }
  const ifftConfig = {
    kernelName: IFFT,
    backendName: "webgl",
    kernelFunc: ifft
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const IS_FINITE = `return float(!isnan(x) && !isinf(x));`;
  const isFinite$1 = unaryKernelFunc({ opSnippet: IS_FINITE, dtype: "bool" });
  const isFiniteConfig = {
    kernelName: IsFinite,
    backendName: "webgl",
    kernelFunc: isFinite$1
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const IS_INF = `return float(isinf(x));`;
  const isInf = unaryKernelFunc({ opSnippet: IS_INF, dtype: "bool" });
  const isInfConfig = {
    kernelName: IsInf,
    backendName: "webgl",
    kernelFunc: isInf
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const IS_NAN = `return float(isnan(x));`;
  const isNaN$1 = unaryKernelFunc({ opSnippet: IS_NAN, dtype: "bool" });
  const isNaNConfig = {
    kernelName: IsNan,
    backendName: "webgl",
    kernelFunc: isNaN$1
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const LESS = `return float(a < b);`;
  const LESS_PACKED = `
  return vec4(lessThan(a, b));
`;
  const less = binaryKernelFunc({
    opSnippet: LESS,
    packedOpSnippet: LESS_PACKED,
    cpuKernelImpl: lessImplCPU,
    dtype: "bool"
  });
  const lessConfig = {
    kernelName: Less,
    backendName: "webgl",
    kernelFunc: less
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const LESS_EQUAL = `return float(a <= b);`;
  const LESS_EQUAL_PACKED = `
  return vec4(lessThanEqual(a, b));
`;
  const lessEqual = binaryKernelFunc({
    opSnippet: LESS_EQUAL,
    packedOpSnippet: LESS_EQUAL_PACKED,
    cpuKernelImpl: lessEqualImplCPU,
    dtype: "bool"
  });
  const lessEqualConfig = {
    kernelName: LessEqual,
    backendName: "webgl",
    kernelFunc: lessEqual
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function linSpace(args) {
    const { backend: backend2, attrs } = args;
    const { start, stop, num } = attrs;
    const outVals = linSpaceImplCPU(start, stop, num);
    return backend2.makeTensorInfo([outVals.length], "float32", outVals);
  }
  const linSpaceConfig = {
    kernelName: LinSpace,
    backendName: "webgl",
    kernelFunc: linSpace
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const LOG = CHECK_NAN_SNIPPET_UNARY + `
  return x < 0.0 ? 0./0. : log(x);
`;
  const LOG_PACKED = `
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`;
  const log = unaryKernelFunc({ opSnippet: LOG, packedOpSnippet: LOG_PACKED, cpuKernelImpl: logImplCPU });
  const logConfig = {
    kernelName: Log,
    backendName: "webgl",
    kernelFunc: log
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const LOG1P = CHECK_NAN_SNIPPET_UNARY + `
  return log(1.0 + x);
`;
  const log1p = unaryKernelFunc({ opSnippet: LOG1P });
  const log1pConfig = {
    kernelName: Log1p,
    backendName: "webgl",
    kernelFunc: log1p
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;
  const LOGICAL_AND_PACKED = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`;
  const logicalAnd = binaryKernelFunc({
    opSnippet: LOGICAL_AND,
    packedOpSnippet: LOGICAL_AND_PACKED,
    dtype: "bool"
  });
  const logicalAndConfig = {
    kernelName: LogicalAnd,
    backendName: "webgl",
    kernelFunc: logicalAnd
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const LOGICAL_NOT = `return float(!(x >= 1.0));`;
  const logicalNot = unaryKernelFunc({ opSnippet: LOGICAL_NOT });
  const logicalNotConfig = {
    kernelName: LogicalNot,
    backendName: "webgl",
    kernelFunc: logicalNot
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;
  const LOGICAL_OR_PACKED = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`;
  const logicalOr = binaryKernelFunc({ opSnippet: LOGICAL_OR, packedOpSnippet: LOGICAL_OR_PACKED, dtype: "bool" });
  const logicalOrConfig = {
    kernelName: LogicalOr,
    backendName: "webgl",
    kernelFunc: logicalOr
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class LRNProgram {
    constructor(xShape, radius, bias, alpha, beta) {
      this.variableNames = ["x"];
      this.outputShape = [];
      const rad = radius;
      const maxD = xShape[3] - 1;
      this.outputShape = xShape;
      let powOperator;
      const basis = `float(${bias}) + float(${alpha}) * sum`;
      if (beta === 0.5) {
        powOperator = `inversesqrt(${basis})`;
      } else if (beta === 1) {
        powOperator = `1.0/(${basis})`;
      } else {
        powOperator = `exp(log(${basis}) * float(-${beta}));`;
      }
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${rad}; j <= ${rad}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${maxD}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${powOperator};
        setOutput(val);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class LRNPackedProgram {
    constructor(xShape, radius, bias, alpha, beta) {
      this.variableNames = ["x"];
      this.outputShape = [];
      this.packedInputs = true;
      this.packedOutput = true;
      const rad = radius;
      const maxD = xShape[3] - 1;
      this.outputShape = xShape;
      let powOperator;
      const basis = `float(${bias}) + float(${alpha}) * sum`;
      if (beta === 0.5) {
        powOperator = `inversesqrt(${basis})`;
      } else if (beta === 1) {
        powOperator = `1.0/(${basis})`;
      } else {
        powOperator = `exp(log(${basis}) * float(-${beta}));`;
      }
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${rad};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${rad}; j <= ${rad}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${powOperator};
        setOutput(result);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const lrn = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { depthRadius, bias, alpha, beta } = attrs;
    const program = env().getBool("WEBGL_PACK_NORMALIZATION") ? new LRNPackedProgram(x.shape, depthRadius, bias, alpha, beta) : new LRNProgram(x.shape, depthRadius, bias, alpha, beta);
    return backend2.runWebGLProgram(program, [x], x.dtype);
  };
  const LRNConfig = {
    kernelName: LRN,
    backendName: "webgl",
    kernelFunc: lrn
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class LRNGradProgram {
    constructor(inputShape, depthRadius, bias, alpha, beta) {
      this.variableNames = ["inputImage", "outputImage", "dy"];
      this.outputShape = [];
      this.outputShape = inputShape;
      this.depth = inputShape[3];
      this.depthRadius = depthRadius;
      this.bias = bias;
      this.alpha = alpha;
      this.beta = beta;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${depthRadius})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${depthRadius} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${alpha}) * norm + float(${bias});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${alpha})
                * float(${beta})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${beta});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const lrnGrad = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { x, y, dy } = inputs;
    const { depthRadius, bias, alpha, beta } = attrs;
    const program = new LRNGradProgram(x.shape, depthRadius, bias, alpha, beta);
    return backend2.runWebGLProgram(program, [x, y, dy], x.dtype);
  };
  const LRNGradConfig = {
    kernelName: LRNGrad,
    backendName: "webgl",
    kernelFunc: lrnGrad
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function maxImpl(x, reduceShape, outShape, backend2) {
    const inSize = sizeFromShape(reduceShape);
    const xSize = sizeFromShape(x.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = reshape({ inputs: { x }, attrs: { shape: [batchSize, inSize] }, backend: backend2 });
    const reduced = reduce(reshapedInput, x.dtype, "max", backend2);
    const reshapedOutput = reshape({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend2 });
    backend2.disposeIntermediateTensorInfo(reshapedInput);
    backend2.disposeIntermediateTensorInfo(reduced);
    return reshapedOutput;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function max(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { reductionIndices, keepDims } = attrs;
    const xRank = x.shape.length;
    const origAxes = parseAxisParam(reductionIndices, x.shape);
    let axes = origAxes;
    const permutedAxes = getAxesPermutation(axes, xRank);
    const maxInputIsTransposed = permutedAxes != null;
    const shouldExecuteOnCPU = backend2.shouldExecuteOnCPU([x]);
    let maxInput = x;
    if (maxInputIsTransposed) {
      if (shouldExecuteOnCPU) {
        const xTexData = backend2.texData.get(maxInput.dataId);
        const values = xTexData.values;
        const newShape = new Array(xRank);
        for (let i = 0; i < newShape.length; i++) {
          newShape[i] = x.shape[permutedAxes[i]];
        }
        const maxInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);
        maxInput = backend2.makeTensorInfo(newShape, x.dtype);
        const maxInputData = backend2.texData.get(maxInput.dataId);
        maxInputData.values = maxInputValues;
      } else {
        maxInput = transposeImpl(x, permutedAxes, backend2);
      }
      axes = getInnerMostAxes(axes.length, xRank);
    }
    assertAxesAreInnerMostDims("max", axes, xRank);
    const [maxOutShape, reduceShape] = computeOutAndReduceShapes(maxInput.shape, axes);
    let outShape = maxOutShape;
    if (keepDims) {
      outShape = expandShapeToKeepDim(maxOutShape, origAxes);
    }
    let out;
    if (shouldExecuteOnCPU) {
      const xTexData = backend2.texData.get(maxInput.dataId);
      const values = xTexData.values;
      const outValues = maxImplCPU(values, sizeFromShape(reduceShape), outShape, x.dtype);
      out = backend2.makeTensorInfo(outShape, x.dtype);
      const outData = backend2.texData.get(out.dataId);
      outData.values = outValues;
    } else {
      out = maxImpl(maxInput, reduceShape, outShape, backend2);
    }
    if (maxInputIsTransposed) {
      backend2.disposeIntermediateTensorInfo(maxInput);
    }
    return out;
  }
  const maxConfig = {
    kernelName: Max,
    backendName: "webgl",
    kernelFunc: max
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const MAXIMUM = CHECK_NAN_SNIPPET + `
  return max(a, b);
`;
  const MAXIMUM_PACKED = `
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  const maximum = binaryKernelFunc({
    opSnippet: MAXIMUM,
    packedOpSnippet: MAXIMUM_PACKED,
    cpuKernelImpl: maximumImplCPU
  });
  const maximumConfig = {
    kernelName: Maximum,
    backendName: "webgl",
    kernelFunc: maximum
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function maxPool(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    assertNotComplex(x, "maxPool");
    const { filterSize, strides, pad: pad2, dimRoundingMode } = attrs;
    const dilations = 1;
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = computePool2DInfo(x.shape, filterSize, strides, dilations, pad2, dimRoundingMode);
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && arraysEqual(convInfo.inShape, convInfo.outShape)) {
      return identity({ inputs: { x }, backend: backend2 });
    }
    const maxPoolProgram = new Pool2DProgram(convInfo, "max", false);
    return backend2.runWebGLProgram(maxPoolProgram, [x], x.dtype);
  }
  const maxPoolConfig = {
    kernelName: MaxPool,
    backendName: "webgl",
    kernelFunc: maxPool
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function maxPool3d(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { filterSize, strides, pad: pad2, dataFormat, dimRoundingMode } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = computePool3DInfo(x.shape, filterSize, strides, dilations, pad2, dimRoundingMode, dataFormat);
    const maxPoolProgram = new Pool3DProgram(convInfo, "max", false);
    return backend2.runWebGLProgram(maxPoolProgram, [x], x.dtype);
  }
  const maxPool3DConfig = {
    kernelName: MaxPool3D,
    backendName: "webgl",
    kernelFunc: maxPool3d
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class MaxPool2DBackpropProgram {
    constructor(convInfo) {
      this.variableNames = ["dy", "maxPos"];
      this.outputShape = convInfo.inShape;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;
      this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
          wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${effectiveFilterWidth} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class MaxPool3DBackpropProgram {
    constructor(convInfo) {
      this.variableNames = ["dy", "maxPos"];
      this.outputShape = convInfo.inShape;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationDepth = convInfo.dilationDepth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterDepth = convInfo.effectiveFilterDepth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const lastIndex = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;
      this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
           wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${lastIndex} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                  wR * ${effectiveFilterWidth} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function maxPool3DGrad(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, input } = inputs;
    const x = input;
    const { filterSize, strides, pad: pad2, dimRoundingMode } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = computePool3DInfo(x.shape, filterSize, strides, dilations, pad2, dimRoundingMode);
    const maxPool3dPositionsProgram = new Pool3DProgram(
      convInfo,
      "max",
      true
      /* get positions */
    );
    const maxPool3dPositions = backend2.runWebGLProgram(maxPool3dPositionsProgram, [x], x.dtype);
    const maxPoolBackpropProgram = new MaxPool3DBackpropProgram(convInfo);
    const result = backend2.runWebGLProgram(maxPoolBackpropProgram, [dy, maxPool3dPositions], x.dtype);
    backend2.disposeIntermediateTensorInfo(maxPool3dPositions);
    return result;
  }
  const maxPool3DGradConfig = {
    kernelName: MaxPool3DGrad,
    backendName: "webgl",
    kernelFunc: maxPool3DGrad
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function maxPoolGrad(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, input, output } = inputs;
    const x = input;
    assertNotComplex([input, output], "maxPoolGrad");
    const { filterSize, strides, pad: pad2, dimRoundingMode } = attrs;
    const convInfo = computePool2DInfo(x.shape, filterSize, strides, 1, pad2, dimRoundingMode);
    const getPositions = true;
    const maxPoolPositionsProgram = new Pool2DProgram(convInfo, "max", getPositions);
    const maxPoolPositions = backend2.runWebGLProgram(maxPoolPositionsProgram, [x], x.dtype);
    const maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);
    const result = backend2.runWebGLProgram(maxPoolBackPropProgram, [dy, maxPoolPositions], x.dtype);
    backend2.disposeIntermediateTensorInfo(maxPoolPositions);
    return result;
  }
  const maxPoolGradConfig = {
    kernelName: MaxPoolGrad,
    backendName: "webgl",
    kernelFunc: maxPoolGrad
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function maxPoolWithArgmaxImpl(x, includeBatchInIndex, convInfo, backend2) {
    let program = new Pool2DProgram(convInfo, "max", false);
    const poolOutput = backend2.runWebGLProgram(program, [x], "float32");
    program = new Pool2DProgram(convInfo, "max", true, true, includeBatchInIndex);
    const indexOutput = backend2.runWebGLProgram(program, [x], "float32");
    return [poolOutput, indexOutput];
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const maxPoolWithArgmaxConfig = {
    kernelName: MaxPoolWithArgmax,
    backendName: "webgl",
    kernelFunc: ({ inputs, attrs, backend: backend2 }) => {
      const { x } = inputs;
      const { filterSize, strides, pad: pad2, includeBatchInIndex } = attrs;
      const webglBackend = backend2;
      assert(x.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x.shape.length}.`);
      const dilations = [1, 1];
      assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      const convInfo = computePool2DInfo(x.shape, filterSize, strides, dilations, pad2);
      const [result, indexes] = maxPoolWithArgmaxImpl(x, includeBatchInIndex, convInfo, webglBackend);
      return [result, indexes];
    }
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function meanImpl(x, reduceShape, outShape, backend2) {
    const inSize = sizeFromShape(reduceShape);
    const xSize = sizeFromShape(x.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = reshape({ inputs: { x }, attrs: { shape: [batchSize, inSize] }, backend: backend2 });
    const reduced = reduce(reshapedInput, "float32", "mean", backend2);
    const reshapedOutput = reshape({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend2 });
    backend2.disposeIntermediateTensorInfo(reshapedInput);
    backend2.disposeIntermediateTensorInfo(reduced);
    return reshapedOutput;
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const meanConfig = {
    kernelName: Mean,
    backendName: "webgl",
    kernelFunc: ({ inputs, attrs, backend: backend2 }) => {
      const { x } = inputs;
      const { keepDims, axis } = attrs;
      const webglBackend = backend2;
      const xRank = x.shape.length;
      const origAxes = parseAxisParam(axis, x.shape);
      let axes = origAxes;
      const permutedAxes = getAxesPermutation(axes, xRank);
      const meanInputIsTransposed = permutedAxes != null;
      const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);
      const intermediates = [];
      let meanInput = x;
      if (meanInputIsTransposed) {
        if (shouldExecuteOnCPU) {
          const xTexData = webglBackend.texData.get(meanInput.dataId);
          const values = xTexData.values;
          const newShape = new Array(xRank);
          for (let i = 0; i < newShape.length; i++) {
            newShape[i] = x.shape[permutedAxes[i]];
          }
          const meanInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);
          meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);
          const meanInputData = webglBackend.texData.get(meanInput.dataId);
          meanInputData.values = meanInputValues;
        } else {
          meanInput = transposeImpl(x, permutedAxes, webglBackend);
        }
        intermediates.push(meanInput);
        axes = getInnerMostAxes(axes.length, xRank);
      }
      assertAxesAreInnerMostDims("sum", axes, xRank);
      const [meanOutShape, reduceShape] = computeOutAndReduceShapes(meanInput.shape, axes);
      let outShape = meanOutShape;
      if (keepDims) {
        outShape = expandShapeToKeepDim(meanOutShape, origAxes);
      }
      const out = meanImpl(meanInput, reduceShape, outShape, webglBackend);
      for (const i of intermediates) {
        webglBackend.disposeIntermediateTensorInfo(i);
      }
      return out;
    }
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function min(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x.shape.length;
    const origAxes = parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
      permutedX = transpose({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      axes = getInnerMostAxes(axes.length, x.shape.length);
    }
    assertAxesAreInnerMostDims("min", axes, xRank);
    const [outShape, reduceShape] = computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = sizeFromShape(reduceShape);
    const a2D = reshape({ inputs: { x: permutedX }, backend: backend2, attrs: { shape: [-1, inSize] } });
    const reduced = reduce(a2D, a2D.dtype, "min", backend2);
    let res;
    if (keepDims) {
      const newShape = expandShapeToKeepDim(outShape, origAxes);
      res = reshape({ inputs: { x: reduced }, backend: backend2, attrs: { shape: newShape } });
    } else {
      res = reshape({ inputs: { x: reduced }, backend: backend2, attrs: { shape: outShape } });
    }
    backend2.disposeIntermediateTensorInfo(a2D);
    backend2.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) {
      backend2.disposeIntermediateTensorInfo(permutedX);
    }
    return res;
  }
  const minConfig = {
    kernelName: Min,
    backendName: "webgl",
    kernelFunc: min
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const MINIMUM = CHECK_NAN_SNIPPET + `
  return min(a, b);
`;
  const MINIMUM_PACKED = `
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  const minimum = binaryKernelFunc({
    opSnippet: MINIMUM,
    packedOpSnippet: MINIMUM_PACKED,
    cpuKernelImpl: minimumImplCPU
  });
  const minimumConfig = {
    kernelName: Minimum,
    backendName: "webgl",
    kernelFunc: minimum
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class MirrorPadProgram {
    constructor(xShape, paddings, mode) {
      this.variableNames = ["x"];
      this.outputShape = paddings.map(
        (p, i) => p[0] + xShape[i] + p[1]
        /* afterPad */
      );
      const rank = xShape.length;
      const dtype = getCoordsDataType(rank);
      const start = paddings.map((p) => p[0]).join(",");
      const end = paddings.map((p, i) => p[0] + xShape[i]).join(",");
      const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
      const offset = mode === "reflect" ? 0 : 1;
      if (rank === 1) {
        this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${offset};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${offset};
          }
          setOutput(getX(outC - start));
        }
      `;
        return;
      }
      this.userCode = `
      ${dtype} start = ${dtype}(${start});
      ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outC = getOutputCoords();
        for (int i = 0; i < ${rank}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${offset};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};
          }
        }
        ${dtype} coords = outC - start;
        setOutput(getX(${unpackedCoords}));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class MirrorPadPackedProgram {
    constructor(xShape, paddings, mode) {
      this.variableNames = ["x"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = paddings.map(
        (p, i) => p[0] + xShape[i] + p[1]
        /* afterPad */
      );
      const rank = xShape.length;
      const dtype = getCoordsDataType(rank);
      const start = paddings.map((p) => p[0]).join(",");
      const end = paddings.map((p, i) => p[0] + xShape[i]).join(",");
      const coords2 = getChannels("rc", rank);
      const source = getChannels("source", rank);
      const cLimit = `${coords2[rank - 1]} < ${this.outputShape[rank - 1]}`;
      const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
      const offset = mode === "reflect" ? 0 : 1;
      let mainLoop = "";
      if (rank === 1) {
        const padSetup = `
        ${dtype} source = rc;
        if (source < start) {
          source = start * 2 - source - ${offset};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${offset};
        }
        source -= start;
      `;
        mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords2[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
      } else {
        const padSetup = `
        ${dtype} source = rc;
        ${dtype} lt = ${dtype}(lessThan(source, start));
        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));
        ${dtype} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${offset}) +
                gte * ((end - 1) * 2 - source + ${offset});
        source -= start;
      `;
        mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords2[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
        rc = outputLoc;
        ${coords2[rank - 2]} += 1;
        if(${coords2[rank - 2]} < ${this.outputShape[rank - 2]}) {
          ${padSetup}
          result[2] = getChannel(getX(${source.join()}), ${innerDims});
          ${coords2[rank - 1]} += 1;
          if(${cLimit}) {
            ${padSetup}
            result[3] = getChannel(getX(${source.join()}), ${innerDims});
          }
        }
      `;
      }
      this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const mirrorPadKernelFunc = ({ inputs, backend: backend2, attrs }) => {
    const { x } = inputs;
    const { paddings, mode } = attrs;
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new MirrorPadPackedProgram(x.shape, paddings, mode) : new MirrorPadProgram(x.shape, paddings, mode);
    const output = backend2.runWebGLProgram(program, [x], x.dtype);
    return output;
  };
  const mirrorPadConfig = {
    kernelName: MirrorPad,
    backendName: "webgl",
    kernelFunc: mirrorPadKernelFunc
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const MOD = `if (b == 0.0) return NAN;
  return mod(a, b);`;
  const MOD_PACKED = `
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  const mod = binaryKernelFunc({
    opSnippet: MOD,
    packedOpSnippet: MOD_PACKED
  });
  const modConfig = {
    kernelName: Mod,
    backendName: "webgl",
    kernelFunc: mod
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class MultinomialProgram {
    constructor(batchSize, numOutcomes, numSamples) {
      this.variableNames = ["probs"];
      this.customUniforms = [{ name: "seed", type: "float" }];
      this.outputShape = [batchSize, numSamples];
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${numOutcomes - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${numOutcomes - 1}));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const DIV = `
if (a == b) {
  return 1.0;
};
return a / b;`;
  const DIV_PACKED = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`;
  const realDiv = binaryKernelFunc({ opSnippet: DIV, packedOpSnippet: DIV_PACKED, checkOutOfBounds: true });
  const realDivConfig = {
    kernelName: RealDiv,
    backendName: "webgl",
    kernelFunc: realDiv
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const SUB = "return a - b;";
  const sub = binaryKernelFunc({
    opSnippet: SUB,
    packedOpSnippet: SUB,
    supportsComplex: true,
    cpuKernelImpl: subImplCPU
  });
  const subConfig = {
    kernelName: Sub,
    backendName: "webgl",
    kernelFunc: sub
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function softmax(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { logits } = inputs;
    const { dim } = attrs;
    const axes = parseAxisParam([dim], logits.shape);
    const maxLogit = max({
      inputs: { x: logits },
      backend: backend2,
      attrs: { reductionIndices: axes, keepDims: false }
    });
    const expandedShape = expandShapeToKeepDim(maxLogit.shape, axes);
    const maxLogitsReshaped = reshape({ inputs: { x: maxLogit }, backend: backend2, attrs: { shape: expandedShape } });
    const a = sub({ inputs: { a: logits, b: maxLogitsReshaped }, backend: backend2 });
    const b = exp({ inputs: { x: a }, backend: backend2 });
    const sumExp = sum({ inputs: { x: b }, backend: backend2, attrs: { axis: axes, keepDims: false } });
    const sumExpReshaped = reshape({ inputs: { x: sumExp }, backend: backend2, attrs: { shape: expandedShape } });
    const res = realDiv({ inputs: { a: b, b: sumExpReshaped }, backend: backend2 });
    backend2.disposeIntermediateTensorInfo(maxLogit);
    backend2.disposeIntermediateTensorInfo(maxLogitsReshaped);
    backend2.disposeIntermediateTensorInfo(a);
    backend2.disposeIntermediateTensorInfo(b);
    backend2.disposeIntermediateTensorInfo(sumExp);
    backend2.disposeIntermediateTensorInfo(sumExpReshaped);
    return res;
  }
  const softmaxConfig = {
    kernelName: Softmax,
    backendName: "webgl",
    kernelFunc: softmax
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function multinomial(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { logits } = inputs;
    const { numSamples, seed, normalized } = attrs;
    const probs = normalized ? logits : softmax({ inputs: { logits }, backend: backend2, attrs: { dim: logits.shape.length - 1 } });
    const batchSize = probs.shape[0];
    const numOutcomes = probs.shape[1];
    const program = new MultinomialProgram(batchSize, numOutcomes, numSamples);
    const customValues = [[seed]];
    const res = backend2.runWebGLProgram(program, [probs], "int32", customValues);
    if (!normalized) {
      backend2.disposeIntermediateTensorInfo(probs);
    }
    return res;
  }
  const multinomialConfig = {
    kernelName: Multinomial,
    backendName: "webgl",
    kernelFunc: multinomial
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const NEG = CHECK_NAN_SNIPPET$1 + `
  return -x;
`;
  const NEG_PACKED = `
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  function neg(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    if (backend2.shouldExecuteOnCPU([x])) {
      const xData = backend2.texData.get(x.dataId);
      const [outValues, newShape] = negImplCPU(xData.values, x.shape, x.dtype);
      return backend2.makeTensorInfo(newShape, x.dtype, outValues);
    }
    let program;
    if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
      program = new UnaryOpPackedProgram(x.shape, NEG_PACKED);
    } else {
      program = new UnaryOpProgram(x.shape, NEG);
    }
    return backend2.runWebGLProgram(program, [x], x.dtype);
  }
  const negConfig = {
    kernelName: Neg,
    backendName: "webgl",
    kernelFunc: neg
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const nonMaxSuppressionV3Impl = nonMaxSuppressionV3Impl$1;
  function nonMaxSuppressionV3(args) {
    warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs, backend: backend2, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold } = attrs;
    const boxesVals = backend2.readSync(boxes.dataId);
    const scoresVals = backend2.readSync(scores.dataId);
    const { selectedIndices } = nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
    return backend2.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices));
  }
  const nonMaxSuppressionV3Config = {
    kernelName: NonMaxSuppressionV3,
    backendName: "webgl",
    kernelFunc: nonMaxSuppressionV3
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const nonMaxSuppressionV4Impl = nonMaxSuppressionV4Impl$1;
  function nonMaxSuppressionV4(args) {
    warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs, backend: backend2, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize } = attrs;
    const boxesVals = backend2.readSync(boxes.dataId);
    const scoresVals = backend2.readSync(scores.dataId);
    const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
    return [
      backend2.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
      backend2.makeTensorInfo([], "int32", new Int32Array([validOutputs]))
    ];
  }
  const nonMaxSuppressionV4Config = {
    kernelName: NonMaxSuppressionV4,
    backendName: "webgl",
    kernelFunc: nonMaxSuppressionV4
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const nonMaxSuppressionV5Impl = nonMaxSuppressionV5Impl$1;
  function nonMaxSuppressionV5(args) {
    warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs, backend: backend2, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = attrs;
    const boxesVals = backend2.readSync(boxes.dataId);
    const scoresVals = backend2.readSync(scores.dataId);
    const maxOutputSizeVal = maxOutputSize;
    const iouThresholdVal = iouThreshold;
    const scoreThresholdVal = scoreThreshold;
    const softNmsSigmaVal = softNmsSigma;
    const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
    return [
      backend2.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
      backend2.makeTensorInfo([selectedScores.length], "float32", new Float32Array(selectedScores))
    ];
  }
  const nonMaxSuppressionV5Config = {
    kernelName: NonMaxSuppressionV5,
    backendName: "webgl",
    kernelFunc: nonMaxSuppressionV5
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class OneHotProgram {
    constructor(numIndices, depth, onValue, offValue) {
      this.variableNames = ["indices"];
      this.outputShape = [numIndices, depth];
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${offValue}), float(${onValue}),
                      float(index == coords.y)));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const oneHot = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { indices } = inputs;
    const { dtype, depth, onValue, offValue } = attrs;
    const indicesSize = sizeFromShape(indices.shape);
    const program = new OneHotProgram(indicesSize, depth, onValue, offValue);
    const reshaped = reshape({ inputs: { x: indices }, backend: backend2, attrs: { shape: [indicesSize] } });
    const result = backend2.runWebGLProgram(program, [reshaped], dtype);
    backend2.disposeIntermediateTensorInfo(reshaped);
    const outShape = [...indices.shape, depth];
    const out = reshape({ inputs: { x: result }, backend: backend2, attrs: { shape: outShape } });
    backend2.disposeIntermediateTensorInfo(result);
    return out;
  };
  const oneHotConfig = {
    kernelName: OneHot,
    backendName: "webgl",
    kernelFunc: oneHot
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function zerosLike(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    if (x.dtype === "complex64") {
      const realPart = real({ inputs: { input: x }, backend: backend2 });
      const r = zerosLike({ inputs: { x: realPart }, backend: backend2 });
      const imagPart = imag({ inputs: { input: x }, backend: backend2 });
      const i = zerosLike({ inputs: { x: imagPart }, backend: backend2 });
      const result = complex({ inputs: { real: r, imag: i }, backend: backend2 });
      backend2.disposeIntermediateTensorInfo(realPart);
      backend2.disposeIntermediateTensorInfo(r);
      backend2.disposeIntermediateTensorInfo(imagPart);
      backend2.disposeIntermediateTensorInfo(i);
      return result;
    } else {
      return fill({
        attrs: {
          shape: x.shape,
          dtype: x.dtype,
          value: x.dtype === "string" ? "" : 0
        },
        backend: backend2
      });
    }
  }
  const zerosLikeConfig = {
    kernelName: ZerosLike,
    backendName: "webgl",
    kernelFunc: zerosLike
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function onesLike(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    if (x.dtype === "string") {
      throw new Error("onesLike is not supported under string dtype");
    } else if (x.dtype === "complex64") {
      const realPart = real({ inputs: { input: x }, backend: backend2 });
      const r = onesLike({ inputs: { x: realPart }, backend: backend2 });
      const imagPart = imag({ inputs: { input: x }, backend: backend2 });
      const i = zerosLike({ inputs: { x: imagPart }, backend: backend2 });
      const result = complex({ inputs: { real: r, imag: i }, backend: backend2 });
      backend2.disposeIntermediateTensorInfo(realPart);
      backend2.disposeIntermediateTensorInfo(r);
      backend2.disposeIntermediateTensorInfo(imagPart);
      backend2.disposeIntermediateTensorInfo(i);
      return result;
    } else {
      return fill({ attrs: { shape: x.shape, dtype: x.dtype, value: 1 }, backend: backend2 });
    }
  }
  const onesLikeConfig = {
    kernelName: OnesLike,
    backendName: "webgl",
    kernelFunc: onesLike
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function pack(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { axis } = attrs;
    if (inputs.length === 1) {
      return expandDims({ inputs: { input: inputs[0] }, backend: backend2, attrs: { dim: axis } });
    }
    const shape = inputs[0].shape;
    const dtype = inputs[0].dtype;
    inputs.forEach((t) => {
      assertShapesMatch(shape, t.shape, "All tensors passed to stack must have matching shapes");
      assert(dtype === t.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    const intermediateTensorInfos = [];
    const expandedTensors = inputs.map((t) => {
      const expandedT = expandDims({ inputs: { input: t }, backend: backend2, attrs: { dim: axis } });
      intermediateTensorInfos.push(expandedT);
      return expandedT;
    });
    const result = concat({ inputs: expandedTensors, backend: backend2, attrs: { axis } });
    intermediateTensorInfos.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return result;
  }
  const packConfig = {
    kernelName: Pack,
    backendName: "webgl",
    kernelFunc: pack
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class PadProgram {
    constructor(xShape, paddings, constantValue) {
      this.variableNames = ["x"];
      this.customUniforms = [{ name: "value", type: "float" }];
      this.outputShape = paddings.map(
        (p, i) => p[0] + xShape[i] + p[1]
        /* afterPad */
      );
      const rank = xShape.length;
      const type = getCoordsDataType(rank);
      const start = paddings.map((p) => p[0]).join(",");
      const end = paddings.map((p, i) => p[0] + xShape[i]).join(",");
      const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
      if (rank === 1) {
        this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
        return;
      }
      this.userCode = `
      ${type} start = ${type}(${start});
      ${type} end = ${type}(${end});

      void main() {
        ${type} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${type} coords = outC - start;
          setOutput(getX(${unpackedCoords}));
        }
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class PadPackedProgram {
    constructor(xShape, paddings, constantValue) {
      this.variableNames = ["x"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [{ name: "value", type: "float" }];
      this.outputShape = paddings.map(
        (p, i) => p[0] + xShape[i] + p[1]
        /* afterPad */
      );
      const rank = xShape.length;
      const dtype = getCoordsDataType(rank);
      const start = paddings.map((p) => p[0]).join(",");
      const end = paddings.map((p, i) => p[0] + xShape[i]).join(",");
      const coords2 = getChannels("rc", rank);
      const source = getChannels("source", rank);
      const cLimit = `${coords2[rank - 1]} < ${this.outputShape[rank - 1]}`;
      const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
      const componentSetup = [
        `${dtype} rc = outputLoc;`,
        `${coords2[rank - 1]} += 1;
       if(${cLimit}) {
      `,
        rank === 1 ? "" : `}
       rc = outputLoc;
       ${coords2[rank - 2]} += 1;
       if(${coords2[rank - 2]} < ${this.outputShape[rank - 2]}) {`,
        rank === 1 ? "" : `  ${coords2[rank - 1]} += 1;
         if(${cLimit}) {`
      ];
      const paddingArea = rank === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
      let mainLoop = "";
      for (let i = 0, j2 = rank === 1 ? 2 : 4; i < j2; i++) {
        mainLoop += `
        ${componentSetup[i]}
        if (${paddingArea}) {
          result[${i}] = float(value);
        } else {
          ${dtype} source = rc - start;
          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
      }
      mainLoop += rank === 1 ? `} ` : `}}`;
      this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const padV2 = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { paddings, constantValue } = attrs;
    if (sizeFromShape(x.shape) === 0) {
      const outputShape = paddings.map(
        (p, i) => p[0] + x.shape[i] + p[1]
        /* afterPad */
      );
      return fill({
        backend: backend2,
        attrs: { shape: outputShape, value: constantValue, dtype: x.dtype }
      });
    }
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new PadPackedProgram(x.shape, paddings, constantValue) : new PadProgram(x.shape, paddings, constantValue);
    const customValues = [[constantValue]];
    return backend2.runWebGLProgram(program, [x], x.dtype, customValues);
  };
  const padV2Config = {
    kernelName: PadV2,
    backendName: "webgl",
    kernelFunc: padV2
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const POW = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`;
  const POW_PACKED = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  const pow = binaryKernelFunc({ opSnippet: POW, packedOpSnippet: POW_PACKED });
  const powConfig = {
    kernelName: Pow,
    backendName: "webgl",
    kernelFunc: pow
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function prod(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x.shape.length;
    const toDispose = [];
    const origAxes = parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
      permutedX = transpose({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      axes = getInnerMostAxes(axes.length, xRank);
      toDispose.push(permutedX);
    }
    assertAxesAreInnerMostDims("prod", axes, xRank);
    let res;
    if (backend2.shouldExecuteOnCPU([permutedX])) {
      const xVals = backend2.texData.get(permutedX.dataId).values;
      const { outVals, outShape, outDtype } = prodImplCPU(permutedX.shape, permutedX.dtype, xVals, axes);
      res = backend2.makeTensorInfo(outShape, outDtype, outVals);
    } else {
      const [outShape, reduceShape] = computeOutAndReduceShapes(permutedX.shape, axes);
      const inSize = sizeFromShape(reduceShape);
      const a2D = reshape({ inputs: { x: permutedX }, backend: backend2, attrs: { shape: [-1, inSize] } });
      const outputDType = sumOutType(x.dtype);
      const reduced = reduce(a2D, outputDType, "prod", backend2);
      res = reshape({ inputs: { x: reduced }, backend: backend2, attrs: { shape: outShape } });
      toDispose.push(a2D);
      toDispose.push(reduced);
    }
    if (keepDims) {
      toDispose.push(res);
      const newShape = expandShapeToKeepDim(res.shape, origAxes);
      res = reshape({ inputs: { x: res }, backend: backend2, attrs: { shape: newShape } });
    }
    toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return res;
  }
  const prodConfig = {
    kernelName: Prod,
    backendName: "webgl",
    kernelFunc: prod
  };
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function raggedGather(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { paramsNestedSplits, paramsDenseValues, indices } = inputs;
    const { outputRaggedRank } = attrs;
    const $paramsNestedSplits = paramsNestedSplits.map((t) => backend2.readSync(t.dataId));
    const $paramsNestedSplitsShapes = paramsNestedSplits.map((t) => t.shape);
    const $paramsDenseValues = backend2.readSync(paramsDenseValues.dataId);
    const $indices = backend2.readSync(indices.dataId);
    const [outputNestedSplits, outputDenseValues, outputDenseValuesShape] = raggedGatherImplCPU($paramsNestedSplits, $paramsNestedSplitsShapes, $paramsDenseValues, paramsDenseValues.shape, paramsDenseValues.dtype, $indices, indices.shape, outputRaggedRank);
    const outputNestedSplitsTensors = outputNestedSplits.map((splits) => backend2.makeTensorInfo([splits.length], "int32", splits));
    const outputDenseValuesTensor = backend2.makeTensorInfo(outputDenseValuesShape, paramsDenseValues.dtype, outputDenseValues);
    return outputNestedSplitsTensors.concat([outputDenseValuesTensor]);
  }
  const raggedGatherConfig = {
    kernelName: RaggedGather,
    backendName: "webgl",
    kernelFunc: raggedGather
  };
  /**
   * @license
   * Copyright 2022 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function raggedRange(args) {
    const { inputs, backend: backend2 } = args;
    const { starts, limits, deltas } = inputs;
    const $starts = backend2.readSync(starts.dataId);
    const $limits = backend2.readSync(limits.dataId);
    const $deltas = backend2.readSync(deltas.dataId);
    const [rtNestedSplitsData, rtDenseValuesData] = raggedRangeImplCPU($starts, starts.shape, starts.dtype, $limits, limits.shape, $deltas, deltas.shape);
    const rtNestedSplits = backend2.makeTensorInfo([rtNestedSplitsData.length], "int32", rtNestedSplitsData);
    const rtDenseValues = backend2.makeTensorInfo([rtDenseValuesData.length], starts.dtype, rtDenseValuesData);
    return [rtNestedSplits, rtDenseValues];
  }
  const raggedRangeConfig = {
    kernelName: RaggedRange,
    backendName: "webgl",
    kernelFunc: raggedRange
  };
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function raggedTensorToTensor(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { shape, values, defaultValue, rowPartitionTensors } = inputs;
    const { rowPartitionTypes } = attrs;
    const $shape = backend2.readSync(shape.dataId);
    const $values = backend2.readSync(values.dataId);
    const $defaultValue = backend2.readSync(defaultValue.dataId);
    const $rowPartitionValues = rowPartitionTensors.map((t) => backend2.readSync(t.dataId));
    const rowPartitionValuesShapes = rowPartitionTensors.map((t) => t.shape);
    const [outputShape, output] = raggedTensorToTensorImplCPU($shape, shape.shape, $values, values.shape, values.dtype, $defaultValue, defaultValue.shape, $rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes);
    return backend2.makeTensorInfo(outputShape, values.dtype, output);
  }
  const raggedTensorToTensorConfig = {
    kernelName: RaggedTensorToTensor,
    backendName: "webgl",
    kernelFunc: raggedTensorToTensor
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const range = (args) => {
    const { backend: backend2, attrs } = args;
    const { start, stop, step: step2, dtype } = attrs;
    const values = rangeImplCPU(start, stop, step2, dtype);
    return backend2.makeTensorInfo([values.length], dtype, values);
  };
  const rangeConfig = {
    kernelName: Range,
    backendName: "webgl",
    kernelFunc: range
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const RECIPROCAL = `return 1.0 / x;`;
  const reciprocal = unaryKernelFunc({ opSnippet: RECIPROCAL });
  const reciprocalConfig = {
    kernelName: Reciprocal,
    backendName: "webgl",
    kernelFunc: reciprocal
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const RELU = CHECK_NAN_SNIPPET$1 + `
  return (x < 0.0) ? 0.0 : x;
`;
  const RELU_PACKED = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  const relu = unaryKernelFunc({ opSnippet: RELU, packedOpSnippet: RELU_PACKED });
  const reluConfig = {
    kernelName: Relu,
    backendName: "webgl",
    kernelFunc: relu
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const RELU6 = CHECK_NAN_SNIPPET$1 + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
  const RELU6_PACKED = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  const relu6 = unaryKernelFunc({ opSnippet: RELU6, packedOpSnippet: RELU6_PACKED });
  const relu6Config = {
    kernelName: Relu6,
    backendName: "webgl",
    kernelFunc: relu6
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ResizeBilinearProgram {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
      this.variableNames = ["A"];
      this.outputShape = [];
      const [batch, oldHeight, oldWidth, depth] = inputShape;
      this.outputShape = [batch, newHeight, newWidth, depth];
      const effectiveInSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
      ];
      const effectiveOutSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
      ];
      let sourceFracIndexRC;
      if (halfPixelCenters) {
        sourceFracIndexRC = `(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)`;
      } else {
        sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
      }
      this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ResizeBilinearPackedProgram {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = [];
      const [batch, oldHeight, oldWidth, depth] = inputShape;
      this.outputShape = [batch, newHeight, newWidth, depth];
      const effectiveInSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
      ];
      const effectiveOutSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
      ];
      let sourceFracIndexRC;
      if (halfPixelCenters) {
        sourceFracIndexRC = `(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)`;
      } else {
        sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
      }
      this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function resizeBilinear(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { images } = inputs;
    const { alignCorners, halfPixelCenters, size } = attrs;
    const [newHeight, newWidth] = size;
    const program = env().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ResizeBilinearPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new ResizeBilinearProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
    return backend2.runWebGLProgram(program, [images], "float32");
  }
  const resizeBilinearConfig = {
    kernelName: ResizeBilinear,
    backendName: "webgl",
    kernelFunc: resizeBilinear
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ResizeBilinearBackpropProgram {
    constructor(dyShape, inputShape, alignCorners) {
      this.variableNames = ["dy"];
      this.outputShape = [];
      this.outputShape = inputShape;
      const [, xHeight, xWidth] = inputShape;
      const [, yHeight, yWidth] = dyShape;
      const effectiveXSize = [
        alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
        alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
      ];
      const effectiveYSize = [
        alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
        alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
      ];
      const heightScale = effectiveXSize[0] / effectiveYSize[0];
      const widthScale = effectiveXSize[1] / effectiveYSize[1];
      const invHeightScale = 1 / heightScale;
      const invWidthScale = 1 / widthScale;
      const winHeight = Math.ceil(invHeightScale) * 2 + 2;
      const winWidth = Math.ceil(invWidthScale) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function resizeBilinearGrad(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { images, dy } = inputs;
    const { alignCorners } = attrs;
    const program = new ResizeBilinearBackpropProgram(dy.shape, images.shape, alignCorners);
    return backend2.runWebGLProgram(program, [dy], dy.dtype);
  }
  const resizeBilinearGradConfig = {
    kernelName: ResizeBilinearGrad,
    backendName: "webgl",
    kernelFunc: resizeBilinearGrad
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ResizeNearestNeighborProgram {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
      this.variableNames = ["A"];
      this.outputShape = [];
      const [batch, oldHeight, oldWidth, depth] = inputShape;
      this.outputShape = [batch, newHeight, newWidth, depth];
      const effectiveInSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
      ];
      const effectiveOutSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
      ];
      const roundBase = alignCorners ? "0.5" : "0.0";
      let sourceFracIndexRC;
      if (halfPixelCenters) {
        sourceFracIndexRC = `max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))`;
      } else {
        sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
      }
      this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ResizeNearestNeighborPackedProgram {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = [];
      const [batch, oldHeight, oldWidth, depth] = inputShape;
      this.outputShape = [batch, newHeight, newWidth, depth];
      const effectiveInSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
      ];
      const effectiveOutSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
      ];
      const roundBase = alignCorners ? "0.5" : "0.0";
      let sourceFracIndexRC;
      if (halfPixelCenters) {
        sourceFracIndexRC = `max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))`;
      } else {
        sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
      }
      this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function resizeNearestNeighbor(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { images } = inputs;
    const { alignCorners, halfPixelCenters, size } = attrs;
    const [newHeight, newWidth] = size;
    const program = env().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ResizeNearestNeighborPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new ResizeNearestNeighborProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
    return backend2.runWebGLProgram(program, [images], images.dtype);
  }
  const resizeNearestNeighborConfig = {
    kernelName: ResizeNearestNeighbor,
    backendName: "webgl",
    kernelFunc: resizeNearestNeighbor
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ResizeNearestNeigborBackpropProgram {
    constructor(dyShape, inputShape, alignCorners) {
      this.variableNames = ["dy"];
      this.outputShape = [];
      this.outputShape = inputShape;
      const [, xHeight, xWidth] = inputShape;
      const [, yHeight, yWidth] = dyShape;
      const effectiveXSize = [
        alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
        alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
      ];
      const effectiveYSize = [
        alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
        alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
      ];
      const heightScale = effectiveXSize[0] / effectiveYSize[0];
      const widthScale = effectiveXSize[1] / effectiveYSize[1];
      const invHeightScale = 1 / heightScale;
      const invWidthScale = 1 / widthScale;
      const winHeight = Math.ceil(invHeightScale) * 2 + 2;
      const winWidth = Math.ceil(invWidthScale) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float sourceFracRow =
              float(${effectiveXSize[0]}) *
                (float(dyR) / float(${effectiveYSize[0]}));

            float sourceFracCol =
                float(${effectiveXSize[1]}) *
                  (float(dyC) / float(${effectiveYSize[1]}));

            int sourceNearestRow = int(min(
                float(int(${xHeight}) - 1),
                ${alignCorners} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${xWidth}) - 1),
                ${alignCorners} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function resizeNearestNeighborGrad(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { images, dy } = inputs;
    const { alignCorners } = attrs;
    const program = new ResizeNearestNeigborBackpropProgram(dy.shape, images.shape, alignCorners);
    return backend2.runWebGLProgram(program, [dy], dy.dtype);
  }
  const resizeNearestNeighborGradConfig = {
    kernelName: ResizeNearestNeighborGrad,
    backendName: "webgl",
    kernelFunc: resizeNearestNeighborGrad
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ReverseProgram {
    constructor(xShape, axis) {
      this.variableNames = ["x"];
      const rank = xShape.length;
      if (rank > 4) {
        throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
      }
      this.outputShape = xShape;
      if (rank === 1) {
        this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${xShape[0]} - coord - 1));
        }
      `;
        return;
      }
      const getInCoord = (i) => {
        if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
          return `${xShape[i]} - coords[${i}] - 1`;
        }
        return `coords[${i}]`;
      };
      const inCoords = xShape.map((_, i) => getInCoord(i)).join(",");
      const type = getCoordsDataType(rank);
      this.userCode = `
      void main() {
        ${type} coords = getOutputCoords();
        setOutput(getX(${inCoords}));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ReversePackedProgram {
    constructor(xShape, axis) {
      this.variableNames = ["x"];
      this.packedInputs = true;
      this.packedOutput = true;
      const rank = xShape.length;
      if (rank > 4) {
        throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
      }
      this.outputShape = xShape;
      const channels = getChannels("rc", rank);
      const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;
      const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;
      const type = getCoordsDataType(rank);
      if (rank === 1) {
        this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${xShape[0]} - rc - 1),
            ${xShape[0]} - rc - 1);
          if(${nextColumn}){
              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),
                ${xShape[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `;
      } else {
        this.userCode = `
        void main() {
          ${type} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${getR(channels.slice())};
          if(${nextColumn}){
            result.g = ${getG(channels.slice())};
          }
          if(${nextRow}) {
            result.b = ${getB(channels.slice())};
            if(${nextColumn}) {
              result.a = ${getA(channels.slice())};
            }
          }
          setOutput(result);
        }
    `;
      }
      function getR(channels2) {
        return getChannel(channels2);
      }
      function getG(channels2) {
        channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
        return getChannel(channels2);
      }
      function getB(channels2) {
        channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
        return getChannel(channels2);
      }
      function getA(channels2) {
        channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
        channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
        return getChannel(channels2);
      }
      function getChannel(channels2) {
        const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels2));
        const inCoords = inCoordsArray.join(",");
        const innerDims = inCoordsArray.slice(-2).join(",");
        return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;
      }
      function getInCoord(i, channels1) {
        if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
          return `${xShape[i]} - ${channels1[i]} - 1`;
        } else {
          return `${channels1[i]}`;
        }
      }
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function reverse(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { dims } = attrs;
    const xRank = x.shape.length;
    const $dims = parseAxisParam(dims, x.shape);
    if (xRank === 0) {
      return identity({ inputs: { x }, backend: backend2 });
    }
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ReversePackedProgram(x.shape, $dims) : new ReverseProgram(x.shape, $dims);
    return backend2.runWebGLProgram(program, [x], x.dtype);
  }
  const reverseConfig = {
    kernelName: Reverse,
    backendName: "webgl",
    kernelFunc: reverse
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class RotateProgram {
    constructor(imageShape, fillValue) {
      this.variableNames = ["Image"];
      this.outputShape = [];
      this.customUniforms = [{ name: "params", type: "vec4" }];
      const imageHeight = imageShape[1];
      const imageWidth = imageShape[2];
      this.outputShape = imageShape;
      let fillSnippet = "";
      if (typeof fillValue === "number") {
        fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;
      } else {
        fillSnippet = `
        vec3 fill = vec3(${fillValue.join(",")});
        float outputValue = fill[coords[3]];`;
      }
      this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${fillSnippet}
          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${imageHeight}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const rotateWithOffsetConfig = {
    kernelName: RotateWithOffset,
    backendName: "webgl",
    kernelFunc: ({ inputs, attrs, backend: backend2 }) => {
      const { image: image2 } = inputs;
      const { radians, fillValue, center } = attrs;
      const webglBackend = backend2;
      const program = new RotateProgram(image2.shape, fillValue);
      const [centerX, centerY] = getImageCenter(center, image2.shape[1], image2.shape[2]);
      const customValues = [[centerX, centerY, Math.sin(radians), Math.cos(radians)]];
      const output = webglBackend.runWebGLProgram(program, [image2], image2.dtype, customValues);
      return output;
    }
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ROUND = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`;
  const round = unaryKernelFunc({ opSnippet: ROUND });
  const roundConfig = {
    kernelName: Round,
    backendName: "webgl",
    kernelFunc: round
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const RSQRT = `return inversesqrt(x);`;
  const rsqrt = unaryKernelFunc({ opSnippet: RSQRT, cpuKernelImpl: rsqrtImplCPU });
  const rsqrtConfig = {
    kernelName: Rsqrt,
    backendName: "webgl",
    kernelFunc: rsqrt
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ScatterProgram {
    constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true, defaultIsTensor = false) {
      this.variableNames = ["updates", "indices", "defaultValue"];
      this.outputShape = shape;
      const stridesType = getCoordsDataType(strides.length);
      const dtype = getCoordsDataType(shape.length);
      let indicesString = "";
      if (indicesRank === 1) {
        indicesString = "i";
      } else if (indicesRank === 2) {
        indicesString = "i, j";
      }
      const indicesSnippet = `getIndices(${indicesString})`;
      let updatesString = "";
      if (updatesRank === 1) {
        updatesString = "i";
      } else if (updatesRank === 2) {
        updatesString = "i, coords[1]";
      }
      const updatesSnippet = `getUpdates(${updatesString})`;
      let defaultValuesString = "";
      if (defaultIsTensor) {
        defaultValuesString = "coords[0], coords[1]";
      }
      const defaultValueSnippet = `getDefaultValue(${defaultValuesString})`;
      const strideString = sliceDim > 1 ? "strides[j]" : "strides";
      this.userCode = `
        ${stridesType} strides = ${stridesType}(${strides});

        void main() {
          ${dtype} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${updateSize}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${sliceDim}; j++) {
              int index = round(${indicesSnippet});
              flattenedIndex += index * ${strideString};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${updatesSnippet};
              found = true;
            }
          }
          setOutput(mix(${defaultValueSnippet}, sum, float(found)));
        }
      `;
    }
  }
  /**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class ScatterPackedProgram {
    constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true, defaultIsTensor = false) {
      this.variableNames = ["updates", "indices", "defaultValue"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = shape;
      const stridesType = getCoordsDataType(strides.length);
      const dtype = getCoordsDataType(shape.length);
      let indicesString = "";
      if (indicesRank === 1) {
        indicesString = "i";
      } else if (indicesRank === 2) {
        indicesString = "i, j";
      }
      const indicesSnippet = `getIndices(${indicesString})`;
      let updatesString = "";
      if (updatesRank === 1) {
        updatesString = "i";
      } else if (updatesRank === 2) {
        updatesString = "i, coords[1]";
      }
      const updatesSnippet = `getUpdates(${updatesString})`;
      let defaultValuesString = "";
      if (defaultIsTensor) {
        defaultValuesString = "coords[0], coords[1]";
      }
      const defaultValueSnippet = `getDefaultValue(${defaultValuesString})`;
      const strideString = sliceDim > 1 ? "strides[j]" : "strides";
      const strideString2 = sliceDim > 1 ? "strides[j + 1]" : "strides";
      this.userCode = `
        ${stridesType} strides = ${stridesType}(${strides});

        void main() {
          ${dtype} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${updateSize}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${sliceDim}; j+=2) {
              ivec4 index = round(${indicesSnippet});
              flattenedIndex += index.xz * ${strideString};
              if (j + 1 < ${sliceDim}) {
                flattenedIndex += index.yw * ${strideString2};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${updatesSnippet};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${defaultValueSnippet}, sum, found));
        }
      `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function scatterNd(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { indices, updates } = inputs;
    const { shape } = attrs;
    const { sliceRank, numUpdates, sliceSize, strides, outputSize } = calculateShapes(updates, indices, shape);
    const flattenShape = [outputSize / sliceSize, sliceSize];
    if (outputSize === 0) {
      return backend2.makeTensorInfo(shape, indices.dtype);
    }
    const flattenIndices = reshape({ inputs: { x: indices }, backend: backend2, attrs: { shape: [numUpdates, sliceRank] } });
    const flattenX = reshape({ inputs: { x: updates }, backend: backend2, attrs: { shape: [numUpdates, sliceSize] } });
    const defaultValue = backend2.makeTensorInfo([], "float32", new Float32Array([0]));
    let program;
    if (env().getBool("WEBGL_PACK")) {
      program = new ScatterPackedProgram(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape);
    } else {
      program = new ScatterProgram(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape);
    }
    const res = backend2.runWebGLProgram(program, [flattenX, flattenIndices, defaultValue], flattenX.dtype);
    const reshaped = reshape({ inputs: { x: res }, backend: backend2, attrs: { shape } });
    backend2.disposeIntermediateTensorInfo(flattenIndices);
    backend2.disposeIntermediateTensorInfo(flattenX);
    backend2.disposeIntermediateTensorInfo(res);
    backend2.disposeIntermediateTensorInfo(defaultValue);
    return reshaped;
  }
  const scatterNdConfig = {
    kernelName: ScatterNd,
    backendName: "webgl",
    kernelFunc: scatterNd
  };
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class SearchSortedProgram {
    constructor(batchSize, numInputs, numValues, side) {
      this.variableNames = ["sortedSequence", "values"];
      this.customUniforms = [{ name: "numInputs", type: "int" }];
      this.outputShape = [batchSize, numValues];
      const webGL2LoopHead = "while (left < right) {";
      const webGL1LoopHead = `for (int i = 0; i < ${Math.ceil(Math.log2(numInputs + 1))}; ++i) { if (left >= right) break;`;
      const loopHead = env().getNumber("WEBGL_VERSION") === 2 ? webGL2LoopHead : webGL1LoopHead;
      const boundComparator = side === "left" ? "<" : "<=";
      this.userCode = `
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${loopHead}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${boundComparator} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `;
    }
  }
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function searchSorted(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { sortedSequence, values } = inputs;
    const { side } = attrs;
    const program = new SearchSortedProgram(sortedSequence.shape[0], sortedSequence.shape[1], values.shape[1], side);
    const customValues = [[sortedSequence.shape[1]]];
    return backend2.runWebGLProgram(program, [sortedSequence, values], "int32", customValues);
  }
  const searchSortedConfig = {
    kernelName: SearchSorted,
    backendName: "webgl",
    kernelFunc: searchSorted
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class SelectProgram {
    constructor(cRank, shape, rank) {
      this.variableNames = ["c", "a", "b"];
      this.outputShape = shape;
      let cCoords;
      let abCoords;
      if (rank > 4) {
        throw Error(`Where for rank ${rank} is not yet supported`);
      }
      if (rank === 1) {
        abCoords = `resRC`;
        cCoords = `resRC`;
      } else {
        const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
        const cCoordVars = [];
        const abCoordVars = [];
        for (let i = 0; i < shape.length; i++) {
          abCoordVars.push(`${currentCoords[i]}`);
          if (i < cRank) {
            cCoordVars.push(`${currentCoords[i]}`);
          }
        }
        cCoords = cCoordVars.join();
        abCoords = abCoordVars.join();
      }
      const dtype = getCoordsDataType(rank);
      this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        float cVal = getC(${cCoords});
        if (cVal >= 1.0) {
          setOutput(getA(${abCoords}));
        } else {
          setOutput(getB(${abCoords}));
        }
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function select(args) {
    const { inputs, backend: backend2 } = args;
    const { condition, t, e } = inputs;
    const program = new SelectProgram(condition.shape.length, t.shape, t.shape.length);
    return backend2.runWebGLProgram(program, [condition, t, e], upcastType(t.dtype, e.dtype));
  }
  const selectConfig = {
    kernelName: Select,
    backendName: "webgl",
    kernelFunc: select
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const SELU = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${SELU_SCALEALPHA};
  float scale = ${SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`;
  const selu = unaryKernelFunc({ opSnippet: SELU });
  const seluConfig = {
    kernelName: Selu,
    backendName: "webgl",
    kernelFunc: selu
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const SIGMOID = CHECK_NAN_SNIPPET_UNARY + `
  return 1.0 / (1.0 + exp(-1.0 * x));
`;
  const SIGMOID_PACKED = `
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  const sigmoid = unaryKernelFunc({
    opSnippet: SIGMOID,
    packedOpSnippet: SIGMOID_PACKED,
    cpuKernelImpl: sigmoidImplCPU
  });
  const sigmoidConfig = {
    kernelName: Sigmoid,
    backendName: "webgl",
    kernelFunc: sigmoid
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const SIGN = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`;
  const sign = unaryKernelFunc({ opSnippet: SIGN });
  const signConfig = {
    kernelName: Sign,
    backendName: "webgl",
    kernelFunc: sign
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const SIN = CHECK_NAN_SNIPPET_UNARY + `
  return sin(x);
`;
  const SIN_PACKED = `
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${CHECK_NAN_SNIPPET_PACKED}
  return result;
`;
  const sin = unaryKernelFunc({ opSnippet: SIN, packedOpSnippet: SIN_PACKED });
  const sinConfig = {
    kernelName: Sin,
    backendName: "webgl",
    kernelFunc: sin
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const SINH = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`;
  const sinh = unaryKernelFunc({ opSnippet: SINH });
  const sinhConfig = {
    kernelName: Sinh,
    backendName: "webgl",
    kernelFunc: sinh
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const SOFTPLUS = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`;
  const softplus = unaryKernelFunc({ opSnippet: SOFTPLUS });
  const softplusConfig = {
    kernelName: Softplus,
    backendName: "webgl",
    kernelFunc: softplus
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const spaceToBatchND = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { blockShape, paddings } = attrs;
    assert(x.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
    const prod2 = blockShape.reduce((a, b) => a * b);
    const completePaddings = [[0, 0]];
    completePaddings.push(...paddings);
    for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {
      completePaddings.push([0, 0]);
    }
    const toDispose = [];
    const paddedX = padV2({
      inputs: { x },
      backend: backend2,
      attrs: { paddings: completePaddings, constantValue: 0 }
    });
    const reshapedPaddedShape = getReshaped(paddedX.shape, blockShape, prod2, false);
    const permutedReshapedPaddedPermutation = getPermuted(reshapedPaddedShape.length, blockShape.length, false);
    const flattenShape = getReshapedPermuted(paddedX.shape, blockShape, prod2, false);
    const reshapedPaddedX = reshape({ inputs: { x: paddedX }, backend: backend2, attrs: { shape: reshapedPaddedShape } });
    const paddedXT = transpose({
      inputs: { x: reshapedPaddedX },
      backend: backend2,
      attrs: { perm: permutedReshapedPaddedPermutation }
    });
    const result = reshape({ inputs: { x: paddedXT }, backend: backend2, attrs: { shape: flattenShape } });
    toDispose.push(paddedX);
    toDispose.push(reshapedPaddedX);
    toDispose.push(paddedXT);
    toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return result;
  };
  const spaceToBatchNDConfig = {
    kernelName: SpaceToBatchND,
    backendName: "webgl",
    kernelFunc: spaceToBatchND
  };
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sparseFillEmptyRows(args) {
    const { inputs, backend: backend2 } = args;
    const { indices, values, denseShape, defaultValue } = inputs;
    if (denseShape.shape.length !== 1) {
      throw new Error(`Dense shape must be a vector, saw:
         ${denseShape.shape}`);
    }
    if (indices.shape.length !== 2) {
      throw new Error(`Indices must be a matrix, saw:
         ${indices.shape}`);
    }
    if (values.shape.length !== 1) {
      throw new Error(`Values must be a vector, saw:
         ${values.shape}`);
    }
    if (defaultValue.shape.length !== 0) {
      throw new Error(`Default value must be a scalar, saw:
        ${defaultValue.shape}`);
    }
    const $indices = backend2.readSync(indices.dataId);
    const $values = backend2.readSync(values.dataId);
    const $denseShape = backend2.readSync(denseShape.dataId);
    const $defaultValue = backend2.readSync(defaultValue.dataId)[0];
    const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = sparseFillEmptyRowsImplCPU($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue);
    return [
      backend2.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),
      backend2.makeTensorInfo([outputIndicesShape[0]], values.dtype, outputValues),
      backend2.makeTensorInfo([emptyRowIndicator.length], "bool", new Uint8Array(emptyRowIndicator.map((value) => Number(value)))),
      backend2.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap))
    ];
  }
  const sparseFillEmptyRowsConfig = {
    kernelName: SparseFillEmptyRows,
    backendName: "webgl",
    kernelFunc: sparseFillEmptyRows
  };
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sparseReshape(args) {
    const { inputs, backend: backend2 } = args;
    const { inputIndices, inputShape, newShape } = inputs;
    if (inputIndices.shape.length !== 2) {
      throw new Error(`Input indices should be a matrix but received shape ${inputIndices.shape}`);
    }
    if (inputShape.shape.length !== 1) {
      throw new Error(`Input shape should be a vector but received shape ${inputShape.shape}`);
    }
    if (newShape.shape.length !== 1) {
      throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);
    }
    const $inputShape = Array.from(backend2.readSync(inputShape.dataId));
    const $inputIndices = backend2.readSync(inputIndices.dataId);
    const targetShape = Array.from(backend2.readSync(newShape.dataId));
    const [newIndices, indicesShape, outputShape] = sparseReshapeImplCPU($inputIndices, inputIndices.shape, inputIndices.dtype, $inputShape, targetShape);
    return [
      backend2.makeTensorInfo(indicesShape, inputIndices.dtype, newIndices),
      backend2.makeTensorInfo([outputShape.length], newShape.dtype, new Int32Array(outputShape))
    ];
  }
  const sparseReshapeConfig = {
    kernelName: SparseReshape,
    backendName: "webgl",
    kernelFunc: sparseReshape
  };
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sparseSegmentMean(args) {
    const { inputs, backend: backend2 } = args;
    const { data, indices, segmentIds } = inputs;
    if (data.shape.length < 1) {
      throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if (indices.shape.length !== 1) {
      throw new Error(`Indices should be a vector but received shape
              ${indices.shape}`);
    }
    if (segmentIds.shape.length !== 1) {
      throw new Error(`Segment ids should be a vector but received shape
              ${segmentIds.shape}`);
    }
    const $data = backend2.readSync(data.dataId);
    const $indices = backend2.readSync(indices.dataId);
    const $segmentIds = backend2.readSync(segmentIds.dataId);
    const [outputData, outputDataShape] = sparseSegmentReductionImplCPU($data, data.shape, data.dtype, $indices, $segmentIds, true);
    return backend2.makeTensorInfo(outputDataShape, data.dtype, outputData);
  }
  const sparseSegmentMeanConfig = {
    kernelName: SparseSegmentMean,
    backendName: "webgl",
    kernelFunc: sparseSegmentMean
  };
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sparseSegmentSum(args) {
    const { inputs, backend: backend2 } = args;
    const { data, indices, segmentIds } = inputs;
    if (data.shape.length < 1) {
      throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if (indices.shape.length !== 1) {
      throw new Error(`Indices should be a vector but received shape
             ${indices.shape}`);
    }
    if (segmentIds.shape.length !== 1) {
      throw new Error(`Segment ids should be a vector but received shape
             ${segmentIds.shape}`);
    }
    const $data = backend2.readSync(data.dataId);
    const $indices = backend2.readSync(indices.dataId);
    const $segmentIds = backend2.readSync(segmentIds.dataId);
    const [outputData, outputDataShape] = sparseSegmentReductionImplCPU($data, data.shape, data.dtype, $indices, $segmentIds);
    return backend2.makeTensorInfo(outputDataShape, data.dtype, outputData);
  }
  const sparseSegmentSumConfig = {
    kernelName: SparseSegmentSum,
    backendName: "webgl",
    kernelFunc: sparseSegmentSum
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function sparseToDense(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { sparseIndices, sparseValues, defaultValue } = inputs;
    const { outputShape } = attrs;
    const { sliceRank, numUpdates, sliceSize, strides, outputSize } = calculateShapes(sparseValues, sparseIndices, outputShape);
    const sumDupeIndices = false;
    if (sparseValues.dtype === "string") {
      const indicesBuf = backend2.bufferSync(sparseIndices);
      const updatesBuf = backend2.bufferSync(sparseValues);
      const $defaultValue = decodeString(backend2.readSync(defaultValue.dataId)[0]);
      const outBuf = scatterImplCPU(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);
      return backend2.makeTensorInfo(outputShape, outBuf.dtype, outBuf.values);
    }
    const program = new ScatterProgram(numUpdates, sliceRank, sparseIndices.shape.length, sparseValues.shape.length, strides, [outputSize, 1], sumDupeIndices);
    const res = backend2.runWebGLProgram(program, [sparseValues, sparseIndices, defaultValue], sparseValues.dtype);
    const reshaped = reshape({ inputs: { x: res }, backend: backend2, attrs: { shape: outputShape } });
    backend2.disposeIntermediateTensorInfo(res);
    return reshaped;
  }
  const sparseToDenseConfig = {
    kernelName: SparseToDense,
    backendName: "webgl",
    kernelFunc: sparseToDense
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function splitV(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { numOrSizeSplits, axis } = attrs;
    const $axis = parseAxisParam(axis, x.shape)[0];
    const splitSizes = prepareSplitSize(x, numOrSizeSplits, $axis);
    const xRank = x.shape.length;
    const begin = new Array(xRank).fill(0);
    const size = x.shape.slice();
    return splitSizes.map((s) => {
      const sliceSize = [...size];
      sliceSize[$axis] = s;
      const sliceT = slice({ inputs: { x }, backend: backend2, attrs: { begin, size: sliceSize } });
      begin[$axis] += s;
      return sliceT;
    });
  }
  const splitVConfig = {
    kernelName: SplitV,
    backendName: "webgl",
    kernelFunc: splitV
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const SQRT = `return sqrt(x);`;
  const sqrt = unaryKernelFunc({ opSnippet: SQRT, packedOpSnippet: SQRT, cpuKernelImpl: sqrtImplCPU });
  const sqrtConfig = {
    kernelName: Sqrt,
    backendName: "webgl",
    kernelFunc: sqrt
  };
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const SQUARE = `return x * x;`;
  const square = unaryKernelFunc({ opSnippet: SQUARE });
  const squareConfig = {
    kernelName: Square,
    backendName: "webgl",
    kernelFunc: square
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const SQUARED_DIFFERENCE = "return (a - b) * (a - b);";
  const squaredDifference = binaryKernelFunc({ opSnippet: SQUARED_DIFFERENCE, packedOpSnippet: SQUARED_DIFFERENCE });
  const squaredDifferenceConfig = {
    kernelName: SquaredDifference,
    backendName: "webgl",
    kernelFunc: squaredDifference
  };
  /**
   * @license
   * Copyright 2023 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function staticRegexReplace(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    if (x.dtype !== "string") {
      throw new Error("Input must be of datatype string");
    }
    const $x = backend2.readSync(x.dataId);
    const stringInput = fromUint8ToStringArray($x);
    const output = staticRegexReplaceImplCPU(stringInput, "string", attrs);
    return backend2.makeTensorInfo(x.shape, "string", output);
  }
  const staticRegexReplaceConfig = {
    kernelName: StaticRegexReplace,
    backendName: "webgl",
    kernelFunc: staticRegexReplace
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function step({ inputs, attrs, backend: backend2 }) {
    const { x } = inputs;
    const opSnippet = CHECK_NAN_SNIPPET$1 + `
    return x > 0.0 ? 1.0 : float(${attrs.alpha});
  `;
    const program = new UnaryOpProgram(x.shape, opSnippet);
    return backend2.runWebGLProgram(program, [x], x.dtype);
  }
  const stepConfig = {
    kernelName: Step,
    backendName: "webgl",
    kernelFunc: step
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class StridedSliceProgram {
    constructor(begin, strides, size) {
      this.variableNames = ["x"];
      this.outputShape = size;
      const rank = size.length;
      const inputDtype = getCoordsDataType(size.length);
      const dtype = getCoordsDataType(size.length);
      let newCoords = "";
      if (rank === 1) {
        newCoords = "coords * strides + begin";
      } else {
        let outputAxis = 0;
        newCoords = size.map((_, i) => {
          outputAxis++;
          return size.length === 1 ? `coords * strides[${i}] + begin[${i}]` : `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;
        }).join(",");
      }
      this.userCode = `
      ${inputDtype} begin = ${inputDtype}(${begin});
      ${inputDtype} strides = ${inputDtype}(${strides});

      void main() {
        ${dtype} coords = getOutputCoords();
        setOutput(getX(${newCoords}));
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function stridedSlice(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;
    const { finalShapeSparse, finalShape, isIdentity, sliceDim0, isSimpleSlice, begin: $begin, end: $end, strides: $strides } = sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
    let result;
    if (isIdentity) {
      result = reshape({ inputs: { x }, backend: backend2, attrs: { shape: finalShape } });
    } else if (sliceDim0 || isSimpleSlice) {
      assert(x.shape.length >= 1, () => `Input must have rank at least 1, got: ${x.shape.length}`);
      const size = computeOutShape$2($begin, $end, $strides);
      const sliced = slice({ inputs: { x }, backend: backend2, attrs: { begin: $begin, size } });
      result = reshape({ inputs: { x: sliced }, backend: backend2, attrs: { shape: finalShape } });
      backend2.disposeIntermediateTensorInfo(sliced);
    } else {
      const shouldExecuteOnCPU = backend2.shouldExecuteOnCPU([x]);
      if (shouldExecuteOnCPU) {
        const values = backend2.readSync(x.dataId);
        const xBuf = buffer(x.shape, x.dtype, values);
        const resultValues = stridedSliceImplCPU(finalShapeSparse, xBuf, $strides, $begin);
        result = backend2.makeTensorInfo(finalShape, x.dtype, resultValues.values);
      } else {
        const program = new StridedSliceProgram($begin, $strides, finalShapeSparse);
        result = backend2.runWebGLProgram(program, [x], x.dtype);
      }
    }
    const resultReshaped = reshape({ inputs: { x: result }, backend: backend2, attrs: { shape: finalShape } });
    backend2.disposeIntermediateTensorInfo(result);
    return resultReshaped;
  }
  const stridedSliceConfig = {
    kernelName: StridedSlice,
    backendName: "webgl",
    kernelFunc: stridedSlice
  };
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function stringNGrams(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { separator, nGramWidths, leftPad, rightPad: rightPad2, padWidth, preserveShortSequences } = attrs;
    const { data, dataSplits } = inputs;
    const $data = backend2.readSync(data.dataId);
    const $dataSplits = backend2.readSync(dataSplits.dataId);
    const [nGrams, nGramsSplits] = stringNGramsImplCPU($data, $dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences);
    return [
      backend2.makeTensorInfo([nGrams.length], "string", nGrams),
      backend2.makeTensorInfo(dataSplits.shape, "int32", nGramsSplits)
    ];
  }
  const stringNGramsConfig = {
    kernelName: StringNGrams,
    backendName: "webgl",
    kernelFunc: stringNGrams
  };
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function stringSplit(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { skipEmpty } = attrs;
    const { input, delimiter } = inputs;
    if (input.dtype !== "string") {
      throw new Error("Input must be of datatype string");
    }
    if (input.shape.length !== 1) {
      throw new Error(`Input must be a vector, got shape: ${input.shape}`);
    }
    if (delimiter.shape.length !== 0) {
      throw new Error(`Delimiter must be a scalar, got shape: ${delimiter.shape}`);
    }
    const $input = backend2.readSync(input.dataId);
    const $delimiter = backend2.readSync(delimiter.dataId)[0];
    const [indices, values, shape] = stringSplitImplCPU($input, $delimiter, skipEmpty);
    const outputSize = values.length;
    return [
      backend2.makeTensorInfo([outputSize, 2], "int32", indices),
      backend2.makeTensorInfo([outputSize], "string", values),
      backend2.makeTensorInfo([2], "int32", new Int32Array(shape))
    ];
  }
  const stringSplitConfig = {
    kernelName: StringSplit,
    backendName: "webgl",
    kernelFunc: stringSplit
  };
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function stringToHashBucketFast(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { numBuckets } = attrs;
    const { input } = inputs;
    if (input.dtype !== "string") {
      throw new Error("Input must be of datatype string");
    }
    if (numBuckets <= 0) {
      throw new Error(`Number of buckets must be at least 1`);
    }
    const $input = backend2.readSync(input.dataId);
    const output = stringToHashBucketFastImplCPU($input, numBuckets);
    return backend2.makeTensorInfo(input.shape, "int32", output);
  }
  const stringToHashBucketFastConfig = {
    kernelName: StringToHashBucketFast,
    backendName: "webgl",
    kernelFunc: stringToHashBucketFast
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const TAN = `return tan(x);`;
  const tan = unaryKernelFunc({ opSnippet: TAN });
  const tanConfig = {
    kernelName: Tan,
    backendName: "webgl",
    kernelFunc: tan
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const TANH = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`;
  const tanh = unaryKernelFunc({ opSnippet: TANH });
  const tanhConfig = {
    kernelName: Tanh,
    backendName: "webgl",
    kernelFunc: tanh
  };
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tensorScatterUpdate(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { tensor: tensor2, indices, updates } = inputs;
    const { sliceRank, numUpdates, sliceSize, strides, outputSize } = calculateShapes(updates, indices, tensor2.shape);
    const flattenShape = [outputSize / sliceSize, sliceSize];
    if (outputSize === 0) {
      return backend2.makeTensorInfo(tensor2.shape, indices.dtype);
    }
    const flattenIndices = reshape({ inputs: { x: indices }, backend: backend2, attrs: { shape: [numUpdates, sliceRank] } });
    const flattenX = reshape({ inputs: { x: updates }, backend: backend2, attrs: { shape: [numUpdates, sliceSize] } });
    const flattenTensor = reshape({ inputs: { x: tensor2 }, backend: backend2, attrs: { shape: flattenShape } });
    const program = new ScatterProgram(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape, false, true);
    const res = backend2.runWebGLProgram(program, [flattenX, flattenIndices, flattenTensor], flattenTensor.dtype);
    const reshaped = reshape({ inputs: { x: res }, backend: backend2, attrs: { shape: tensor2.shape } });
    backend2.disposeIntermediateTensorInfo(flattenIndices);
    backend2.disposeIntermediateTensorInfo(flattenX);
    backend2.disposeIntermediateTensorInfo(flattenTensor);
    backend2.disposeIntermediateTensorInfo(res);
    return reshaped;
  }
  const tensorScatterUpdateConfig = {
    kernelName: TensorScatterUpdate,
    backendName: "webgl",
    kernelFunc: tensorScatterUpdate
  };
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class TileProgram {
    constructor(aShape, reps) {
      this.variableNames = ["A"];
      const outputShape = new Array(aShape.length);
      for (let i = 0; i < outputShape.length; i++) {
        outputShape[i] = aShape[i] * reps[i];
      }
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      const dtype = getCoordsDataType(this.rank);
      const sourceCoords = getSourceCoords(aShape);
      this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `;
    }
  }
  function getSourceCoords(aShape) {
    const rank = aShape.length;
    if (rank > 5) {
      throw Error(`Tile for rank ${rank} is not yet supported`);
    }
    if (rank === 1) {
      return `imod(resRC, ${aShape[0]})`;
    }
    const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"];
    const sourceCoords = [];
    for (let i = 0; i < aShape.length; i++) {
      sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);
    }
    return sourceCoords.join();
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function tile(params) {
    const { inputs, backend: backend2, attrs } = params;
    const { x } = inputs;
    const { reps } = attrs;
    if (x.dtype === "string" || x.shape.length > 5) {
      const data = backend2.readSync(x.dataId);
      const value = x.dtype === "string" ? data.map((d) => decodeString(d)) : data;
      const buf = buffer(x.shape, x.dtype, value);
      const outBuf = tileImplCPU(buf, reps);
      return backend2.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
    }
    const program = new TileProgram(x.shape, reps);
    const output = backend2.runWebGLProgram(program, [x], x.dtype);
    return output;
  }
  const tileConfig = {
    kernelName: Tile,
    backendName: "webgl",
    kernelFunc: tile
  };
  class SwapProgram {
    /**
     * @param shape desired output shape (can be larger than input shape, output
     *                                    will be padded with -Infinity)
     */
    constructor(shape) {
      this.variableNames = ["x", "indices"];
      this.customUniforms = [
        { name: "n", type: "int" },
        { name: "firstPass", type: "int" },
        { name: "negativeInf", type: "float" },
        { name: "dir", type: "int" },
        { name: "inc", type: "int" }
      ];
      this.outputShape = shape;
      this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
    }
  }
  class MergeProgram {
    /**
     * @param shape desired output shape (must be half of the input size)
     */
    constructor(shape) {
      this.variableNames = ["x", "indices"];
      this.customUniforms = [
        { name: "n", type: "int" },
        { name: "firstPass", type: "int" },
        { name: "k", type: "int" }
      ];
      this.outputShape = shape;
      this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function disposeIntermediateTensorInfoOrNull(backend2, tensorInfo) {
    if (tensorInfo !== null) {
      backend2.disposeIntermediateTensorInfo(tensorInfo);
    }
  }
  function roundUpToPow2(num) {
    let pow2 = 1;
    while (pow2 < num) {
      pow2 *= 2;
    }
    return pow2;
  }
  function topK(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { k: k3, sorted } = attrs;
    const TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD");
    const TOPK_K_CPU_HANDOFF_THRESHOLD = env().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD");
    const xShape = x.shape;
    const lastDim = xShape[xShape.length - 1];
    if (backend2.shouldExecuteOnCPU([x]) || lastDim < TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD || k3 > TOPK_K_CPU_HANDOFF_THRESHOLD) {
      const xVals = backend2.readSync(x.dataId);
      const [allTopKVals, allTopKIndices] = topKImplCPU(xVals, xShape, x.dtype, k3, sorted);
      return [
        backend2.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
        backend2.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
      ];
    }
    if (k3 === 0) {
      xShape[xShape.length - 1] = 0;
      return [
        backend2.makeTensorInfo(xShape, x.dtype, []),
        backend2.makeTensorInfo(xShape, "int32", [])
      ];
    }
    if (lastDim === 1) {
      return [
        x,
        fill({ attrs: { shape: xShape, dtype: "int32", value: 0 }, backend: backend2 })
      ];
    }
    const xtexData = backend2.texData.get(x.dataId);
    const xIsPacked = xtexData !== null && xtexData.isPacked;
    const xUnPacked = xIsPacked ? backend2.unpackTensor(x) : x;
    const xSize = sizeFromShape(xShape);
    const batch = xSize / lastDim;
    const x2D = reshape({ inputs: { x: xUnPacked }, attrs: { shape: [batch, lastDim] }, backend: backend2 });
    if (xIsPacked) {
      disposeIntermediateTensorInfoOrNull(backend2, xUnPacked);
    }
    const kPow2 = roundUpToPow2(k3);
    const lastDimPow2 = roundUpToPow2(lastDim);
    let indices = null;
    const getInputs = () => indices === null ? [x2D, x2D] : [x2D, indices];
    const runSwap = (dir, inc, shape) => {
      const inputs2 = getInputs();
      const program = new SwapProgram(shape);
      const fistPass = indices === null ? 1 : 0;
      const customValues = [[lastDim], [fistPass], [Number.NEGATIVE_INFINITY], [dir], [inc]];
      const prevIndices2 = indices;
      indices = backend2.runWebGLProgram(program, inputs2, "int32", customValues);
      disposeIntermediateTensorInfoOrNull(backend2, prevIndices2);
    };
    for (let len = 1; len < kPow2; len *= 2) {
      const dir = len * 2;
      for (let inc = len; inc >= 1; inc /= 2) {
        runSwap(dir, inc, [batch, lastDimPow2]);
      }
    }
    for (let indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2) {
      const inputs2 = getInputs();
      const mergeProgram = new MergeProgram([batch, indicesSize / 2]);
      const firstPass = indices === null ? 1 : 0;
      const customValues = [[lastDim], [firstPass], [kPow2]];
      const prevIndices2 = indices;
      indices = backend2.runWebGLProgram(mergeProgram, inputs2, "int32", customValues);
      disposeIntermediateTensorInfoOrNull(backend2, prevIndices2);
      const len = kPow2 / 2;
      const dir = len * 2;
      for (let inc = len; inc >= 1; inc /= 2) {
        runSwap(dir, inc, indices.shape);
      }
    }
    let prevIndices = indices;
    indices = slice({ inputs: { x: indices }, backend: backend2, attrs: { begin: 0, size: [batch, k3] } });
    disposeIntermediateTensorInfoOrNull(backend2, prevIndices);
    let values = gatherV2({ inputs: { x: x2D, indices }, backend: backend2, attrs: { axis: 1, batchDims: 1 } });
    disposeIntermediateTensorInfoOrNull(backend2, x2D);
    const newShape = xShape.slice(0, -1);
    newShape.push(k3);
    prevIndices = indices;
    indices = reshape({ inputs: { x: indices }, attrs: { shape: newShape }, backend: backend2 });
    disposeIntermediateTensorInfoOrNull(backend2, prevIndices);
    const prevValues = values;
    values = reshape({ inputs: { x: values }, attrs: { shape: newShape }, backend: backend2 });
    disposeIntermediateTensorInfoOrNull(backend2, prevValues);
    return [values, indices];
  }
  const topKConfig = {
    kernelName: TopK,
    backendName: "webgl",
    kernelFunc: topK
  };
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class TransformProgram {
    constructor(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape) {
      this.variableNames = ["Image", "Transforms"];
      this.outputShape = outShape;
      const interpolationModeId = interpolation === "nearest" ? 1 : 2;
      let fillModeId;
      switch (fillMode) {
        case "constant":
          fillModeId = 1;
          break;
        case "reflect":
          fillModeId = 2;
          break;
        case "wrap":
          fillModeId = 3;
          break;
        case "nearest":
          fillModeId = 4;
          break;
        default:
          fillModeId = 1;
          break;
      }
      this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${fillModeId} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${fillModeId} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${fillModeId} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${imageHeight} && 0 <= coordX && coordX < ${imageWidth}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${fillValue});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${fillValue});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${imageWidth}));
                float mapY = mapCoord(inY, float(${imageHeight}));

                if (${interpolationModeId} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
    }
  }
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function transform(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { image: image2, transforms } = inputs;
    const { interpolation, fillMode, fillValue, outputShape } = attrs;
    const [batch, imageHeight, imageWidth, numChannels] = image2.shape;
    const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];
    const outShape = [
      batch,
      outHeight,
      outWidth,
      numChannels
    ];
    const program = new TransformProgram(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape);
    return backend2.runWebGLProgram(program, [image2, transforms], "float32");
  }
  const transformConfig = {
    kernelName: Transform,
    backendName: "webgl",
    kernelFunc: transform
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function unique(args) {
    const { inputs, attrs, backend: backend2 } = args;
    const { axis } = attrs;
    const { x } = inputs;
    assertNotComplex(x, "unique");
    console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
    const values = backend2.readSync(x.dataId);
    const { outputValues, outputShape, indices } = uniqueImplCPU(values, axis, x.shape, x.dtype);
    return [
      backend2.makeTensorInfo(outputShape, x.dtype, outputValues),
      backend2.makeTensorInfo([indices.length], "int32", indices)
    ];
  }
  const uniqueConfig = {
    kernelName: Unique,
    backendName: "webgl",
    kernelFunc: unique
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function unpack(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { value } = inputs;
    let { axis } = attrs;
    if (axis < 0) {
      axis += value.shape.length;
    }
    const x = value;
    const xRank = x.shape.length;
    const num = value.shape[axis];
    const outShape = new Array(xRank - 1);
    let outIndex = 0;
    for (let i = 0; i < xRank; i++) {
      if (i !== axis) {
        outShape[outIndex++] = x.shape[i];
      }
    }
    const toDispose = [];
    const begin = new Array(xRank).fill(0);
    const size = x.shape.slice();
    size[axis] = 1;
    const res = new Array(num);
    for (let i = 0; i < res.length; i++) {
      begin[axis] = i;
      const sliced = slice({ inputs: { x }, backend: backend2, attrs: { begin, size } });
      const reshaped = reshape({ inputs: { x: sliced }, backend: backend2, attrs: { shape: outShape } });
      res[i] = reshaped;
      toDispose.push(sliced);
    }
    toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return res;
  }
  const unpackConfig = {
    kernelName: Unpack,
    backendName: "webgl",
    kernelFunc: unpack
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class SegmentOpProgram {
    constructor(segOpInfo, segOpType) {
      this.variableNames = ["x", "segmentIds"];
      const windowSize = segOpInfo.windowSize;
      const batchSize = segOpInfo.batchSize;
      const inSize = segOpInfo.inSize;
      const numSegments = segOpInfo.numSegments;
      const outSize = numSegments * Math.ceil(inSize / windowSize);
      this.outputShape = [batchSize, outSize];
      const initializationValue = "0.0";
      const returnValue = `sumValue`;
      const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
      const windowSizeVec4Remainder = windowSize % 4;
      const updateSnippet = `
        sumValue += dot(values, segFilter);
    `;
      let checkValueOutOfBounds = "";
      if (inSize % windowSize > 0) {
        checkValueOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
      }
      let checkSegmentIdOutOfBounds = "";
      if (inSize % windowSize > 0) {
        checkSegmentIdOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return -1.0;
        }
      `;
      }
      this.userCode = `
      const float initializationValue = ${initializationValue};

      float getValue(int batch, int inIdx) {
        ${checkValueOutOfBounds}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${checkSegmentIdOutOfBounds}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${numSegments})) * float(${windowSize}));
        int currentSeg = int(mod(float(outIdx), float(${numSegments})));

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function unsortedSegmentSum(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, segmentIds } = inputs;
    const { numSegments } = attrs;
    const xRank = x.shape.length;
    const toDispose = [];
    let axis = 0;
    const permutation = getAxesPermutation([axis], xRank);
    let permutedX = x;
    if (permutation != null) {
      permutedX = transpose({ inputs: { x }, backend: backend2, attrs: { perm: permutation } });
      toDispose.push(permutedX);
      axis = getInnerMostAxes(1, xRank)[0];
    }
    const outShape = computeOutShape(permutedX.shape, axis, numSegments);
    const inSize = sizeFromShape([permutedX.shape[axis]]);
    const a2D = reshape({ inputs: { x: permutedX }, backend: backend2, attrs: { shape: [-1, inSize] } });
    toDispose.push(a2D);
    const outputDType = sumOutType(x.dtype);
    const segOpCompute = (x2, segOpType, segmentIds2, dtype, numSegments2) => {
      const batchSize = x2.shape[0];
      const inSize2 = x2.shape[1];
      const windowSize = segOpComputeOptimalWindowSize(inSize2, numSegments2);
      const segOpInfo = { windowSize, inSize: inSize2, batchSize, numSegments: numSegments2 };
      const program = new SegmentOpProgram(segOpInfo, segOpType);
      const output = backend2.compileAndRun(program, [x2, segmentIds2], dtype);
      toDispose.push(output);
      if (output.shape[1] === numSegments2) {
        return output;
      }
      const rangeInfo = range({
        backend: backend2,
        attrs: { start: 0, stop: numSegments2, step: 1, dtype: "float32" }
      });
      const tileInfo = tile({
        inputs: { x: rangeInfo },
        backend: backend2,
        attrs: { reps: [inSize2 / windowSize] }
      });
      toDispose.push(rangeInfo);
      toDispose.push(tileInfo);
      const result2 = segOpCompute(output, segOpType, tileInfo, dtype, numSegments2);
      return result2;
    };
    const segOpResult = segOpCompute(a2D, "unsortedSegmentSum", segmentIds, outputDType, numSegments);
    const reshaped = reshape({ inputs: { x: segOpResult }, backend: backend2, attrs: { shape: outShape } });
    let result = reshaped;
    if (permutation != null) {
      toDispose.push(reshaped);
      const perm = getUndoAxesPermutation(permutation);
      result = transpose({ inputs: { x: result }, backend: backend2, attrs: { perm } });
    }
    toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return result;
  }
  const unsortedSegmentSumConfig = {
    kernelName: UnsortedSegmentSum,
    backendName: "webgl",
    kernelFunc: unsortedSegmentSum
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const kernelConfigs = [
    _fusedMatMulConfig,
    absConfig,
    acosConfig,
    acoshConfig,
    addConfig,
    addNConfig,
    allConfig,
    anyConfig,
    argMaxConfig,
    argMinConfig,
    asinConfig,
    asinhConfig,
    atanConfig,
    atan2Config,
    atanhConfig,
    avgPoolConfig,
    avgPool3DConfig,
    avgPool3DGradConfig,
    avgPoolGradConfig,
    batchMatMulConfig,
    batchNormConfig,
    batchToSpaceNDConfig,
    bincountConfig,
    bitwiseAndConfig,
    broadcastArgsConfig,
    castConfig,
    ceilConfig,
    clipByValueConfig,
    complexConfig,
    complexAbsConfig,
    concatConfig,
    conv2DConfig,
    conv2DBackpropFilterConfig,
    conv2DBackpropInputConfig,
    conv3DConfig,
    conv3DBackpropFilterV2Config,
    conv3DBackpropInputConfig,
    cosConfig,
    coshConfig,
    cropAndResizeConfig,
    cumprodConfig,
    cumsumConfig,
    denseBincountConfig,
    depthToSpaceConfig,
    depthwiseConv2dNativeConfig,
    depthwiseConv2dNativeBackpropFilterConfig,
    depthwiseConv2dNativeBackpropInputConfig,
    diagConfig,
    dilation2DConfig,
    einsumConfig,
    eluConfig,
    eluGradConfig,
    equalConfig,
    erfConfig,
    expConfig,
    expandDimsConfig,
    expm1Config,
    fftConfig,
    fillConfig,
    flipLeftRightConfig,
    floorConfig,
    floorDivConfig,
    fromPixelsConfig,
    fusedConv2DConfig,
    fusedDepthwiseConv2DConfig,
    gatherNdConfig,
    gatherV2Config,
    greaterConfig,
    greaterEqualConfig,
    identityConfig,
    ifftConfig,
    imagConfig,
    isFiniteConfig,
    isInfConfig,
    isNaNConfig,
    leakyReluConfig,
    lessConfig,
    lessEqualConfig,
    linSpaceConfig,
    logConfig,
    log1pConfig,
    logicalAndConfig,
    logicalNotConfig,
    logicalOrConfig,
    LRNConfig,
    LRNGradConfig,
    maxConfig,
    maximumConfig,
    maxPoolConfig,
    maxPool3DConfig,
    maxPool3DGradConfig,
    maxPoolGradConfig,
    maxPoolWithArgmaxConfig,
    meanConfig,
    minConfig,
    minimumConfig,
    mirrorPadConfig,
    modConfig,
    multinomialConfig,
    multiplyConfig,
    negConfig,
    nonMaxSuppressionV3Config,
    nonMaxSuppressionV4Config,
    nonMaxSuppressionV5Config,
    notEqualConfig,
    oneHotConfig,
    onesLikeConfig,
    packConfig,
    padV2Config,
    powConfig,
    preluConfig,
    prodConfig,
    raggedGatherConfig,
    raggedRangeConfig,
    raggedTensorToTensorConfig,
    rangeConfig,
    realConfig,
    realDivConfig,
    reciprocalConfig,
    reluConfig,
    relu6Config,
    reshapeConfig,
    resizeBilinearConfig,
    resizeBilinearGradConfig,
    resizeNearestNeighborConfig,
    resizeNearestNeighborGradConfig,
    reverseConfig,
    rotateWithOffsetConfig,
    roundConfig,
    rsqrtConfig,
    scatterNdConfig,
    searchSortedConfig,
    selectConfig,
    seluConfig,
    sigmoidConfig,
    signConfig,
    sinConfig,
    sinhConfig,
    sliceConfig,
    softmaxConfig,
    softplusConfig,
    spaceToBatchNDConfig,
    sparseFillEmptyRowsConfig,
    sparseReshapeConfig,
    sparseSegmentMeanConfig,
    sparseSegmentSumConfig,
    sparseToDenseConfig,
    splitVConfig,
    sqrtConfig,
    squareConfig,
    squaredDifferenceConfig,
    staticRegexReplaceConfig,
    stepConfig,
    stridedSliceConfig,
    stringNGramsConfig,
    stringSplitConfig,
    stringToHashBucketFastConfig,
    subConfig,
    sumConfig,
    tanConfig,
    tanhConfig,
    tensorScatterUpdateConfig,
    tileConfig,
    topKConfig,
    transformConfig,
    transposeConfig,
    uniqueConfig,
    unpackConfig,
    unsortedSegmentSumConfig,
    zerosLikeConfig
  ];
  for (const kernelConfig of kernelConfigs) {
    registerKernel(kernelConfig);
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    GPGPUContext,
    MathBackendWebGL,
    forceHalfFloat,
    gpgpu_util,
    setWebGLContext,
    version_webgl: version,
    webgl,
    webgl_util
  }, Symbol.toStringTag, { value: "Module" }));
  const scriptRel = "modulepreload";
  const assetsURL = function(dep) {
    return "/" + dep;
  };
  const seen = {};
  const __vitePreload = function preload(baseModule, deps, importerUrl) {
    if (true) {
      return baseModule();
    }
    const links = document.getElementsByTagName("link");
    return Promise.all(deps.map((dep) => {
      dep = assetsURL(dep);
      if (dep in seen)
        return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      const isBaseRelative = !!importerUrl;
      if (isBaseRelative) {
        for (let i = links.length - 1; i >= 0; i--) {
          const link2 = links[i];
          if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
            return;
          }
        }
      } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
        return;
      }
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link.as = "script";
        link.crossOrigin = "";
      }
      link.href = dep;
      document.head.appendChild(link);
      if (isCss) {
        return new Promise((res, rej) => {
          link.addEventListener("load", res);
          link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
        });
      }
    })).then(() => baseModule()).catch((err) => {
      const e = new Event("vite:preloadError", { cancelable: true });
      e.payload = err;
      window.dispatchEvent(e);
      if (!e.defaultPrevented) {
        throw err;
      }
    });
  };
  var face_mesh = {};
  (function() {
    var v;
    function aa(a) {
      var b = 0;
      return function() {
        return b < a.length ? { done: false, value: a[b++] } : { done: true };
      };
    }
    var ba = "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, b, c) {
      if (a == Array.prototype || a == Object.prototype)
        return a;
      a[b] = c.value;
      return a;
    };
    function ca(a) {
      a = ["object" == typeof globalThis && globalThis, a, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof commonjsGlobal && commonjsGlobal];
      for (var b = 0; b < a.length; ++b) {
        var c = a[b];
        if (c && c.Math == Math)
          return c;
      }
      throw Error("Cannot find global object");
    }
    var G2 = ca(this);
    function J2(a, b) {
      if (b)
        a: {
          var c = G2;
          a = a.split(".");
          for (var d = 0; d < a.length - 1; d++) {
            var e = a[d];
            if (!(e in c))
              break a;
            c = c[e];
          }
          a = a[a.length - 1];
          d = c[a];
          b = b(d);
          b != d && null != b && ba(c, a, { configurable: true, writable: true, value: b });
        }
    }
    J2("Symbol", function(a) {
      function b(g) {
        if (this instanceof b)
          throw new TypeError("Symbol is not a constructor");
        return new c(d + (g || "") + "_" + e++, g);
      }
      function c(g, f) {
        this.g = g;
        ba(this, "description", { configurable: true, writable: true, value: f });
      }
      if (a)
        return a;
      c.prototype.toString = function() {
        return this.g;
      };
      var d = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", e = 0;
      return b;
    });
    J2("Symbol.iterator", function(a) {
      if (a)
        return a;
      a = Symbol("Symbol.iterator");
      for (var b = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), c = 0; c < b.length; c++) {
        var d = G2[b[c]];
        "function" === typeof d && "function" != typeof d.prototype[a] && ba(d.prototype, a, { configurable: true, writable: true, value: function() {
          return da(aa(this));
        } });
      }
      return a;
    });
    function da(a) {
      a = { next: a };
      a[Symbol.iterator] = function() {
        return this;
      };
      return a;
    }
    function K2(a) {
      var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
      return b ? b.call(a) : { next: aa(a) };
    }
    function L2(a) {
      if (!(a instanceof Array)) {
        a = K2(a);
        for (var b, c = []; !(b = a.next()).done; )
          c.push(b.value);
        a = c;
      }
      return a;
    }
    var ea = "function" == typeof Object.create ? Object.create : function(a) {
      function b() {
      }
      b.prototype = a;
      return new b();
    }, fa;
    if ("function" == typeof Object.setPrototypeOf)
      fa = Object.setPrototypeOf;
    else {
      var ha;
      a: {
        var ia = { a: true }, ja = {};
        try {
          ja.__proto__ = ia;
          ha = ja.a;
          break a;
        } catch (a) {
        }
        ha = false;
      }
      fa = ha ? function(a, b) {
        a.__proto__ = b;
        if (a.__proto__ !== b)
          throw new TypeError(a + " is not extensible");
        return a;
      } : null;
    }
    var ka = fa;
    function M(a, b) {
      a.prototype = ea(b.prototype);
      a.prototype.constructor = a;
      if (ka)
        ka(a, b);
      else
        for (var c in b)
          if ("prototype" != c)
            if (Object.defineProperties) {
              var d = Object.getOwnPropertyDescriptor(b, c);
              d && Object.defineProperty(a, c, d);
            } else
              a[c] = b[c];
      a.ea = b.prototype;
    }
    function ma() {
      this.l = false;
      this.i = null;
      this.h = void 0;
      this.g = 1;
      this.s = this.m = 0;
      this.j = null;
    }
    function na(a) {
      if (a.l)
        throw new TypeError("Generator is already running");
      a.l = true;
    }
    ma.prototype.o = function(a) {
      this.h = a;
    };
    function oa(a, b) {
      a.j = { U: b, V: true };
      a.g = a.m || a.s;
    }
    ma.prototype.return = function(a) {
      this.j = { return: a };
      this.g = this.s;
    };
    function N2(a, b, c) {
      a.g = c;
      return { value: b };
    }
    function pa(a) {
      this.g = new ma();
      this.h = a;
    }
    function qa(a, b) {
      na(a.g);
      var c = a.g.i;
      if (c)
        return ra(a, "return" in c ? c["return"] : function(d) {
          return { value: d, done: true };
        }, b, a.g.return);
      a.g.return(b);
      return sa(a);
    }
    function ra(a, b, c, d) {
      try {
        var e = b.call(a.g.i, c);
        if (!(e instanceof Object))
          throw new TypeError("Iterator result " + e + " is not an object");
        if (!e.done)
          return a.g.l = false, e;
        var g = e.value;
      } catch (f) {
        return a.g.i = null, oa(a.g, f), sa(a);
      }
      a.g.i = null;
      d.call(a.g, g);
      return sa(a);
    }
    function sa(a) {
      for (; a.g.g; )
        try {
          var b = a.h(a.g);
          if (b)
            return a.g.l = false, { value: b.value, done: false };
        } catch (c) {
          a.g.h = void 0, oa(a.g, c);
        }
      a.g.l = false;
      if (a.g.j) {
        b = a.g.j;
        a.g.j = null;
        if (b.V)
          throw b.U;
        return { value: b.return, done: true };
      }
      return { value: void 0, done: true };
    }
    function ta(a) {
      this.next = function(b) {
        na(a.g);
        a.g.i ? b = ra(a, a.g.i.next, b, a.g.o) : (a.g.o(b), b = sa(a));
        return b;
      };
      this.throw = function(b) {
        na(a.g);
        a.g.i ? b = ra(a, a.g.i["throw"], b, a.g.o) : (oa(a.g, b), b = sa(a));
        return b;
      };
      this.return = function(b) {
        return qa(a, b);
      };
      this[Symbol.iterator] = function() {
        return this;
      };
    }
    function O2(a, b) {
      b = new ta(new pa(b));
      ka && a.prototype && ka(b, a.prototype);
      return b;
    }
    function ua(a, b) {
      a instanceof String && (a += "");
      var c = 0, d = false, e = { next: function() {
        if (!d && c < a.length) {
          var g = c++;
          return { value: b(g, a[g]), done: false };
        }
        d = true;
        return { done: true, value: void 0 };
      } };
      e[Symbol.iterator] = function() {
        return e;
      };
      return e;
    }
    var va = "function" == typeof Object.assign ? Object.assign : function(a, b) {
      for (var c = 1; c < arguments.length; c++) {
        var d = arguments[c];
        if (d)
          for (var e in d)
            Object.prototype.hasOwnProperty.call(d, e) && (a[e] = d[e]);
      }
      return a;
    };
    J2("Object.assign", function(a) {
      return a || va;
    });
    J2("Promise", function(a) {
      function b(f) {
        this.h = 0;
        this.i = void 0;
        this.g = [];
        this.o = false;
        var h = this.j();
        try {
          f(h.resolve, h.reject);
        } catch (k3) {
          h.reject(k3);
        }
      }
      function c() {
        this.g = null;
      }
      function d(f) {
        return f instanceof b ? f : new b(function(h) {
          h(f);
        });
      }
      if (a)
        return a;
      c.prototype.h = function(f) {
        if (null == this.g) {
          this.g = [];
          var h = this;
          this.i(function() {
            h.l();
          });
        }
        this.g.push(f);
      };
      var e = G2.setTimeout;
      c.prototype.i = function(f) {
        e(f, 0);
      };
      c.prototype.l = function() {
        for (; this.g && this.g.length; ) {
          var f = this.g;
          this.g = [];
          for (var h = 0; h < f.length; ++h) {
            var k3 = f[h];
            f[h] = null;
            try {
              k3();
            } catch (l) {
              this.j(l);
            }
          }
        }
        this.g = null;
      };
      c.prototype.j = function(f) {
        this.i(function() {
          throw f;
        });
      };
      b.prototype.j = function() {
        function f(l) {
          return function(n) {
            k3 || (k3 = true, l.call(h, n));
          };
        }
        var h = this, k3 = false;
        return { resolve: f(this.C), reject: f(this.l) };
      };
      b.prototype.C = function(f) {
        if (f === this)
          this.l(new TypeError("A Promise cannot resolve to itself"));
        else if (f instanceof b)
          this.F(f);
        else {
          a:
            switch (typeof f) {
              case "object":
                var h = null != f;
                break a;
              case "function":
                h = true;
                break a;
              default:
                h = false;
            }
          h ? this.u(f) : this.m(f);
        }
      };
      b.prototype.u = function(f) {
        var h = void 0;
        try {
          h = f.then;
        } catch (k3) {
          this.l(k3);
          return;
        }
        "function" == typeof h ? this.G(h, f) : this.m(f);
      };
      b.prototype.l = function(f) {
        this.s(2, f);
      };
      b.prototype.m = function(f) {
        this.s(1, f);
      };
      b.prototype.s = function(f, h) {
        if (0 != this.h)
          throw Error("Cannot settle(" + f + ", " + h + "): Promise already settled in state" + this.h);
        this.h = f;
        this.i = h;
        2 === this.h && this.D();
        this.A();
      };
      b.prototype.D = function() {
        var f = this;
        e(function() {
          if (f.B()) {
            var h = G2.console;
            "undefined" !== typeof h && h.error(f.i);
          }
        }, 1);
      };
      b.prototype.B = function() {
        if (this.o)
          return false;
        var f = G2.CustomEvent, h = G2.Event, k3 = G2.dispatchEvent;
        if ("undefined" === typeof k3)
          return true;
        "function" === typeof f ? f = new f("unhandledrejection", { cancelable: true }) : "function" === typeof h ? f = new h("unhandledrejection", { cancelable: true }) : (f = G2.document.createEvent("CustomEvent"), f.initCustomEvent("unhandledrejection", false, true, f));
        f.promise = this;
        f.reason = this.i;
        return k3(f);
      };
      b.prototype.A = function() {
        if (null != this.g) {
          for (var f = 0; f < this.g.length; ++f)
            g.h(this.g[f]);
          this.g = null;
        }
      };
      var g = new c();
      b.prototype.F = function(f) {
        var h = this.j();
        f.J(h.resolve, h.reject);
      };
      b.prototype.G = function(f, h) {
        var k3 = this.j();
        try {
          f.call(h, k3.resolve, k3.reject);
        } catch (l) {
          k3.reject(l);
        }
      };
      b.prototype.then = function(f, h) {
        function k3(w, r) {
          return "function" == typeof w ? function(y) {
            try {
              l(w(y));
            } catch (m) {
              n(m);
            }
          } : r;
        }
        var l, n, u = new b(function(w, r) {
          l = w;
          n = r;
        });
        this.J(k3(f, l), k3(h, n));
        return u;
      };
      b.prototype.catch = function(f) {
        return this.then(void 0, f);
      };
      b.prototype.J = function(f, h) {
        function k3() {
          switch (l.h) {
            case 1:
              f(l.i);
              break;
            case 2:
              h(l.i);
              break;
            default:
              throw Error("Unexpected state: " + l.h);
          }
        }
        var l = this;
        null == this.g ? g.h(k3) : this.g.push(k3);
        this.o = true;
      };
      b.resolve = d;
      b.reject = function(f) {
        return new b(function(h, k3) {
          k3(f);
        });
      };
      b.race = function(f) {
        return new b(function(h, k3) {
          for (var l = K2(f), n = l.next(); !n.done; n = l.next())
            d(n.value).J(h, k3);
        });
      };
      b.all = function(f) {
        var h = K2(f), k3 = h.next();
        return k3.done ? d([]) : new b(function(l, n) {
          function u(y) {
            return function(m) {
              w[y] = m;
              r--;
              0 == r && l(w);
            };
          }
          var w = [], r = 0;
          do
            w.push(void 0), r++, d(k3.value).J(u(w.length - 1), n), k3 = h.next();
          while (!k3.done);
        });
      };
      return b;
    });
    J2("Object.is", function(a) {
      return a ? a : function(b, c) {
        return b === c ? 0 !== b || 1 / b === 1 / c : b !== b && c !== c;
      };
    });
    J2("Array.prototype.includes", function(a) {
      return a ? a : function(b, c) {
        var d = this;
        d instanceof String && (d = String(d));
        var e = d.length;
        c = c || 0;
        for (0 > c && (c = Math.max(c + e, 0)); c < e; c++) {
          var g = d[c];
          if (g === b || Object.is(g, b))
            return true;
        }
        return false;
      };
    });
    J2("String.prototype.includes", function(a) {
      return a ? a : function(b, c) {
        if (null == this)
          throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");
        if (b instanceof RegExp)
          throw new TypeError("First argument to String.prototype.includes must not be a regular expression");
        return -1 !== this.indexOf(b, c || 0);
      };
    });
    J2("Array.prototype.keys", function(a) {
      return a ? a : function() {
        return ua(this, function(b) {
          return b;
        });
      };
    });
    var wa = this || self;
    function P2(a, b) {
      a = a.split(".");
      var c = wa;
      a[0] in c || "undefined" == typeof c.execScript || c.execScript("var " + a[0]);
      for (var d; a.length && (d = a.shift()); )
        a.length || void 0 === b ? c[d] && c[d] !== Object.prototype[d] ? c = c[d] : c = c[d] = {} : c[d] = b;
    }
    function xa(a, b) {
      b = String.fromCharCode.apply(null, b);
      return null == a ? b : a + b;
    }
    var ya, za = "undefined" !== typeof TextDecoder, Aa, Ba = "undefined" !== typeof TextEncoder;
    function Ca(a) {
      if (Ba)
        a = (Aa || (Aa = new TextEncoder())).encode(a);
      else {
        var b = void 0;
        b = void 0 === b ? false : b;
        for (var c = 0, d = new Uint8Array(3 * a.length), e = 0; e < a.length; e++) {
          var g = a.charCodeAt(e);
          if (128 > g)
            d[c++] = g;
          else {
            if (2048 > g)
              d[c++] = g >> 6 | 192;
            else {
              if (55296 <= g && 57343 >= g) {
                if (56319 >= g && e < a.length) {
                  var f = a.charCodeAt(++e);
                  if (56320 <= f && 57343 >= f) {
                    g = 1024 * (g - 55296) + f - 56320 + 65536;
                    d[c++] = g >> 18 | 240;
                    d[c++] = g >> 12 & 63 | 128;
                    d[c++] = g >> 6 & 63 | 128;
                    d[c++] = g & 63 | 128;
                    continue;
                  } else
                    e--;
                }
                if (b)
                  throw Error("Found an unpaired surrogate");
                g = 65533;
              }
              d[c++] = g >> 12 | 224;
              d[c++] = g >> 6 & 63 | 128;
            }
            d[c++] = g & 63 | 128;
          }
        }
        a = d.subarray(0, c);
      }
      return a;
    }
    var Da = {}, Ea = null;
    function Fa(a, b) {
      void 0 === b && (b = 0);
      Ga();
      b = Da[b];
      for (var c = Array(Math.floor(a.length / 3)), d = b[64] || "", e = 0, g = 0; e < a.length - 2; e += 3) {
        var f = a[e], h = a[e + 1], k3 = a[e + 2], l = b[f >> 2];
        f = b[(f & 3) << 4 | h >> 4];
        h = b[(h & 15) << 2 | k3 >> 6];
        k3 = b[k3 & 63];
        c[g++] = l + f + h + k3;
      }
      l = 0;
      k3 = d;
      switch (a.length - e) {
        case 2:
          l = a[e + 1], k3 = b[(l & 15) << 2] || d;
        case 1:
          a = a[e], c[g] = b[a >> 2] + b[(a & 3) << 4 | l >> 4] + k3 + d;
      }
      return c.join("");
    }
    function Ha(a) {
      var b = a.length, c = 3 * b / 4;
      c % 3 ? c = Math.floor(c) : -1 != "=.".indexOf(a[b - 1]) && (c = -1 != "=.".indexOf(a[b - 2]) ? c - 2 : c - 1);
      var d = new Uint8Array(c), e = 0;
      Ia(a, function(g) {
        d[e++] = g;
      });
      return d.subarray(0, e);
    }
    function Ia(a, b) {
      function c(k3) {
        for (; d < a.length; ) {
          var l = a.charAt(d++), n = Ea[l];
          if (null != n)
            return n;
          if (!/^[\s\xa0]*$/.test(l))
            throw Error("Unknown base64 encoding at char: " + l);
        }
        return k3;
      }
      Ga();
      for (var d = 0; ; ) {
        var e = c(-1), g = c(0), f = c(64), h = c(64);
        if (64 === h && -1 === e)
          break;
        b(e << 2 | g >> 4);
        64 != f && (b(g << 4 & 240 | f >> 2), 64 != h && b(f << 6 & 192 | h));
      }
    }
    function Ga() {
      if (!Ea) {
        Ea = {};
        for (var a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), b = ["+/=", "+/", "-_=", "-_.", "-_"], c = 0; 5 > c; c++) {
          var d = a.concat(b[c].split(""));
          Da[c] = d;
          for (var e = 0; e < d.length; e++) {
            var g = d[e];
            void 0 === Ea[g] && (Ea[g] = e);
          }
        }
      }
    }
    var Ja = "function" === typeof Uint8Array.prototype.slice, Ka;
    function La(a, b, c) {
      return b === c ? Ka || (Ka = new Uint8Array(0)) : Ja ? a.slice(b, c) : new Uint8Array(a.subarray(b, c));
    }
    var Q2 = 0, R2 = 0;
    function Ma(a, b) {
      b = void 0 === b ? {} : b;
      b = void 0 === b.v ? false : b.v;
      this.h = null;
      this.g = this.j = this.l = 0;
      this.m = false;
      this.v = b;
      a && Na(this, a);
    }
    function Na(a, b) {
      b = b.constructor === Uint8Array ? b : b.constructor === ArrayBuffer ? new Uint8Array(b) : b.constructor === Array ? new Uint8Array(b) : b.constructor === String ? Ha(b) : b instanceof Uint8Array ? new Uint8Array(b.buffer, b.byteOffset, b.byteLength) : new Uint8Array(0);
      a.h = b;
      a.l = 0;
      a.j = a.h.length;
      a.g = a.l;
    }
    Ma.prototype.reset = function() {
      this.g = this.l;
    };
    function Oa(a) {
      for (var b = 128, c = 0, d = 0, e = 0; 4 > e && 128 <= b; e++)
        b = a.h[a.g++], c |= (b & 127) << 7 * e;
      128 <= b && (b = a.h[a.g++], c |= (b & 127) << 28, d |= (b & 127) >> 4);
      if (128 <= b)
        for (e = 0; 5 > e && 128 <= b; e++)
          b = a.h[a.g++], d |= (b & 127) << 7 * e + 3;
      if (128 > b) {
        a = c >>> 0;
        b = d >>> 0;
        if (d = b & 2147483648)
          a = ~a + 1 >>> 0, b = ~b >>> 0, 0 == a && (b = b + 1 >>> 0);
        a = 4294967296 * b + (a >>> 0);
        return d ? -a : a;
      }
      a.m = true;
    }
    Ma.prototype.i = function() {
      var a = this.h, b = a[this.g], c = b & 127;
      if (128 > b)
        return this.g += 1, c;
      b = a[this.g + 1];
      c |= (b & 127) << 7;
      if (128 > b)
        return this.g += 2, c;
      b = a[this.g + 2];
      c |= (b & 127) << 14;
      if (128 > b)
        return this.g += 3, c;
      b = a[this.g + 3];
      c |= (b & 127) << 21;
      if (128 > b)
        return this.g += 4, c;
      b = a[this.g + 4];
      c |= (b & 15) << 28;
      if (128 > b)
        return this.g += 5, c >>> 0;
      this.g += 5;
      128 <= a[this.g++] && 128 <= a[this.g++] && 128 <= a[this.g++] && 128 <= a[this.g++] && this.g++;
      return c;
    };
    Ma.prototype.o = function() {
      var a = this.h[this.g], b = this.h[this.g + 1];
      var c = this.h[this.g + 2];
      var d = this.h[this.g + 3];
      this.g += 4;
      c = (a << 0 | b << 8 | c << 16 | d << 24) >>> 0;
      a = 2 * (c >> 31) + 1;
      b = c >>> 23 & 255;
      c &= 8388607;
      return 255 == b ? c ? NaN : Infinity * a : 0 == b ? a * Math.pow(2, -149) * c : a * Math.pow(2, b - 150) * (c + Math.pow(2, 23));
    };
    var Pa = [];
    function Qa() {
      this.g = new Uint8Array(64);
      this.h = 0;
    }
    Qa.prototype.push = function(a) {
      if (!(this.h + 1 < this.g.length)) {
        var b = this.g;
        this.g = new Uint8Array(Math.ceil(1 + 2 * this.g.length));
        this.g.set(b);
      }
      this.g[this.h++] = a;
    };
    Qa.prototype.length = function() {
      return this.h;
    };
    Qa.prototype.end = function() {
      var a = this.g, b = this.h;
      this.h = 0;
      return La(a, 0, b);
    };
    function Ra(a, b) {
      for (; 127 < b; )
        a.push(b & 127 | 128), b >>>= 7;
      a.push(b);
    }
    function Sa(a) {
      var b = {}, c = void 0 === b.N ? false : b.N;
      this.o = { v: void 0 === b.v ? false : b.v };
      this.N = c;
      b = this.o;
      Pa.length ? (c = Pa.pop(), b && (c.v = b.v), a && Na(c, a), a = c) : a = new Ma(a, b);
      this.g = a;
      this.m = this.g.g;
      this.h = this.i = this.l = -1;
      this.j = false;
    }
    Sa.prototype.reset = function() {
      this.g.reset();
      this.h = this.l = -1;
    };
    function S2(a) {
      var b = a.g;
      (b = b.g == b.j) || (b = a.j) || (b = a.g, b = b.m || 0 > b.g || b.g > b.j);
      if (b)
        return false;
      a.m = a.g.g;
      b = a.g.i();
      var c = b & 7;
      if (0 != c && 5 != c && 1 != c && 2 != c && 3 != c && 4 != c)
        return a.j = true, false;
      a.i = b;
      a.l = b >>> 3;
      a.h = c;
      return true;
    }
    function Ta(a) {
      switch (a.h) {
        case 0:
          if (0 != a.h)
            Ta(a);
          else {
            for (a = a.g; a.h[a.g] & 128; )
              a.g++;
            a.g++;
          }
          break;
        case 1:
          1 != a.h ? Ta(a) : (a = a.g, a.g += 8);
          break;
        case 2:
          if (2 != a.h)
            Ta(a);
          else {
            var b = a.g.i();
            a = a.g;
            a.g += b;
          }
          break;
        case 5:
          5 != a.h ? Ta(a) : (a = a.g, a.g += 4);
          break;
        case 3:
          b = a.l;
          do {
            if (!S2(a)) {
              a.j = true;
              break;
            }
            if (4 == a.h) {
              a.l != b && (a.j = true);
              break;
            }
            Ta(a);
          } while (1);
          break;
        default:
          a.j = true;
      }
    }
    function Ua(a, b, c) {
      var d = a.g.j, e = a.g.i(), g = a.g.g + e;
      a.g.j = g;
      c(b, a);
      c = g - a.g.g;
      if (0 !== c)
        throw Error("Message parsing ended unexpectedly. Expected to read " + e + " bytes, instead read " + (e - c) + " bytes, either the data ended unexpectedly or the message misreported its own length");
      a.g.g = g;
      a.g.j = d;
      return b;
    }
    function T(a) {
      return a.g.o();
    }
    function Va(a) {
      var b = a.g.i();
      a = a.g;
      var c = a.g;
      a.g += b;
      a = a.h;
      var d;
      if (za)
        (d = ya) || (d = ya = new TextDecoder("utf-8", { fatal: false })), d = d.decode(a.subarray(c, c + b));
      else {
        b = c + b;
        for (var e = [], g = null, f, h, k3; c < b; )
          f = a[c++], 128 > f ? e.push(f) : 224 > f ? c >= b ? e.push(65533) : (h = a[c++], 194 > f || 128 !== (h & 192) ? (c--, e.push(65533)) : e.push((f & 31) << 6 | h & 63)) : 240 > f ? c >= b - 1 ? e.push(65533) : (h = a[c++], 128 !== (h & 192) || 224 === f && 160 > h || 237 === f && 160 <= h || 128 !== ((d = a[c++]) & 192) ? (c--, e.push(65533)) : e.push((f & 15) << 12 | (h & 63) << 6 | d & 63)) : 244 >= f ? c >= b - 2 ? e.push(65533) : (h = a[c++], 128 !== (h & 192) || 0 !== (f << 28) + (h - 144) >> 30 || 128 !== ((d = a[c++]) & 192) || 128 !== ((k3 = a[c++]) & 192) ? (c--, e.push(65533)) : (f = (f & 7) << 18 | (h & 63) << 12 | (d & 63) << 6 | k3 & 63, f -= 65536, e.push((f >> 10 & 1023) + 55296, (f & 1023) + 56320))) : e.push(65533), 8192 <= e.length && (g = xa(g, e), e.length = 0);
        d = xa(g, e);
      }
      return d;
    }
    function Wa(a, b, c) {
      var d = a.g.i();
      for (d = a.g.g + d; a.g.g < d; )
        c.push(b.call(a.g));
    }
    function Xa(a, b) {
      2 == a.h ? Wa(a, Ma.prototype.o, b) : b.push(T(a));
    }
    function Ya() {
      this.h = [];
      this.i = 0;
      this.g = new Qa();
    }
    function Za(a, b) {
      0 !== b.length && (a.h.push(b), a.i += b.length);
    }
    function $a(a) {
      var b = a.i + a.g.length();
      if (0 === b)
        return new Uint8Array(0);
      b = new Uint8Array(b);
      for (var c = a.h, d = c.length, e = 0, g = 0; g < d; g++) {
        var f = c[g];
        0 !== f.length && (b.set(f, e), e += f.length);
      }
      c = a.g;
      d = c.h;
      0 !== d && (b.set(c.g.subarray(0, d), e), c.h = 0);
      a.h = [b];
      return b;
    }
    function U2(a, b, c) {
      if (null != c) {
        Ra(a.g, 8 * b + 5);
        a = a.g;
        var d = c;
        d = (c = 0 > d ? 1 : 0) ? -d : d;
        0 === d ? 0 < 1 / d ? Q2 = R2 = 0 : (R2 = 0, Q2 = 2147483648) : isNaN(d) ? (R2 = 0, Q2 = 2147483647) : 34028234663852886e22 < d ? (R2 = 0, Q2 = (c << 31 | 2139095040) >>> 0) : 11754943508222875e-54 > d ? (d = Math.round(d / Math.pow(2, -149)), R2 = 0, Q2 = (c << 31 | d) >>> 0) : (b = Math.floor(Math.log(d) / Math.LN2), d *= Math.pow(2, -b), d = Math.round(8388608 * d), 16777216 <= d && ++b, R2 = 0, Q2 = (c << 31 | b + 127 << 23 | d & 8388607) >>> 0);
        c = Q2;
        a.push(c >>> 0 & 255);
        a.push(c >>> 8 & 255);
        a.push(c >>> 16 & 255);
        a.push(c >>> 24 & 255);
      }
    }
    var ab = "function" === typeof Uint8Array;
    function bb(a, b, c) {
      if (null != a)
        return "object" === typeof a ? ab && a instanceof Uint8Array ? c(a) : cb(a, b, c) : b(a);
    }
    function cb(a, b, c) {
      if (Array.isArray(a)) {
        for (var d = Array(a.length), e = 0; e < a.length; e++)
          d[e] = bb(a[e], b, c);
        Array.isArray(a) && a.W && db(d);
        return d;
      }
      d = {};
      for (e in a)
        d[e] = bb(a[e], b, c);
      return d;
    }
    function eb(a) {
      return "number" === typeof a ? isFinite(a) ? a : String(a) : a;
    }
    var fb = { W: { value: true, configurable: true } };
    function db(a) {
      Array.isArray(a) && !Object.isFrozen(a) && Object.defineProperties(a, fb);
      return a;
    }
    var gb;
    function V2(a, b, c) {
      var d = gb;
      gb = null;
      a || (a = d);
      d = this.constructor.ca;
      a || (a = d ? [d] : []);
      this.j = d ? 0 : -1;
      this.m = this.g = null;
      this.h = a;
      a: {
        d = this.h.length;
        a = d - 1;
        if (d && (d = this.h[a], !(null === d || "object" != typeof d || Array.isArray(d) || ab && d instanceof Uint8Array))) {
          this.l = a - this.j;
          this.i = d;
          break a;
        }
        void 0 !== b && -1 < b ? (this.l = Math.max(b, a + 1 - this.j), this.i = null) : this.l = Number.MAX_VALUE;
      }
      if (c)
        for (b = 0; b < c.length; b++)
          a = c[b], a < this.l ? (a += this.j, (d = this.h[a]) ? db(d) : this.h[a] = hb) : (ib(this), (d = this.i[a]) ? db(d) : this.i[a] = hb);
    }
    var hb = Object.freeze(db([]));
    function ib(a) {
      var b = a.l + a.j;
      a.h[b] || (a.i = a.h[b] = {});
    }
    function W2(a, b, c) {
      return -1 === b ? null : (void 0 === c ? 0 : c) || b >= a.l ? a.i ? a.i[b] : void 0 : a.h[b + a.j];
    }
    function jb(a, b) {
      var c = void 0 === c ? false : c;
      var d = W2(a, b, c);
      null == d && (d = hb);
      d === hb && (d = db([]), X2(a, b, d, c));
      return d;
    }
    function kb(a) {
      var b = jb(a, 3);
      a.m || (a.m = {});
      if (!a.m[3]) {
        for (var c = 0; c < b.length; c++)
          b[c] = +b[c];
        a.m[3] = true;
      }
      return b;
    }
    function lb(a, b, c) {
      a = W2(a, b);
      return null == a ? c : a;
    }
    function Y2(a, b, c) {
      a = W2(a, b);
      a = null == a ? a : +a;
      return null == a ? void 0 === c ? 0 : c : a;
    }
    function X2(a, b, c, d) {
      (void 0 === d ? 0 : d) || b >= a.l ? (ib(a), a.i[b] = c) : a.h[b + a.j] = c;
    }
    function mb(a, b, c) {
      if (-1 === c)
        return null;
      a.g || (a.g = {});
      if (!a.g[c]) {
        var d = W2(a, c, false);
        d && (a.g[c] = new b(d));
      }
      return a.g[c];
    }
    function nb(a, b) {
      a.g || (a.g = {});
      var c = a.g[1];
      if (!c) {
        var d = jb(a, 1);
        c = [];
        for (var e = 0; e < d.length; e++)
          c[e] = new b(d[e]);
        a.g[1] = c;
      }
      return c;
    }
    function ob(a, b, c) {
      var d = void 0 === d ? false : d;
      a.g || (a.g = {});
      var e = c ? pb(c) : c;
      a.g[b] = c;
      X2(a, b, e, d);
    }
    function qb(a, b, c, d) {
      var e = nb(a, c);
      b = b ? b : new c();
      a = jb(a, 1);
      void 0 != d ? (e.splice(d, 0, b), a.splice(d, 0, pb(b))) : (e.push(b), a.push(pb(b)));
    }
    V2.prototype.toJSON = function() {
      var a = pb(this);
      return cb(a, eb, Fa);
    };
    function pb(a, b) {
      if (a.g)
        for (var c in a.g) {
          var d = a.g[c];
          if (Array.isArray(d))
            for (var e = 0; e < d.length; e++)
              d[e] && pb(d[e]);
          else
            d && pb(d);
        }
      return a.h;
    }
    V2.prototype.toString = function() {
      return pb(this).toString();
    };
    function rb(a, b) {
      if (a = a.o) {
        Za(b, b.g.end());
        for (var c = 0; c < a.length; c++)
          Za(b, a[c]);
      }
    }
    function sb(a, b) {
      if (4 == b.h)
        return false;
      var c = b.m;
      Ta(b);
      b.N || (b = La(b.g.h, c, b.g.g), (c = a.o) ? c.push(b) : a.o = [b]);
      return true;
    }
    function tb(a) {
      V2.call(this, a, -1, ub);
    }
    M(tb, V2);
    tb.prototype.getRows = function() {
      return W2(this, 1);
    };
    tb.prototype.getCols = function() {
      return W2(this, 2);
    };
    tb.prototype.getPackedDataList = function() {
      return kb(this);
    };
    tb.prototype.getLayout = function() {
      return lb(this, 4, 0);
    };
    function vb(a, b) {
      for (; S2(b); )
        switch (b.i) {
          case 8:
            var c = b.g.i();
            X2(a, 1, c);
            break;
          case 16:
            c = b.g.i();
            X2(a, 2, c);
            break;
          case 29:
          case 26:
            Xa(b, a.getPackedDataList());
            break;
          case 32:
            c = Oa(b.g);
            X2(a, 4, c);
            break;
          default:
            if (!sb(a, b))
              return a;
        }
      return a;
    }
    var ub = [3];
    function Z2(a, b) {
      var c = void 0;
      return new (c || (c = Promise))(function(d, e) {
        function g(k3) {
          try {
            h(b.next(k3));
          } catch (l) {
            e(l);
          }
        }
        function f(k3) {
          try {
            h(b["throw"](k3));
          } catch (l) {
            e(l);
          }
        }
        function h(k3) {
          k3.done ? d(k3.value) : new c(function(l) {
            l(k3.value);
          }).then(g, f);
        }
        h((b = b.apply(a, void 0)).next());
      });
    }
    function wb(a) {
      V2.call(this, a);
    }
    M(wb, V2);
    function xb(a, b) {
      for (; S2(b); )
        switch (b.i) {
          case 8:
            var c = b.g.i();
            X2(a, 1, c);
            break;
          case 21:
            c = T(b);
            X2(a, 2, c);
            break;
          case 26:
            c = Va(b);
            X2(a, 3, c);
            break;
          case 34:
            c = Va(b);
            X2(a, 4, c);
            break;
          default:
            if (!sb(a, b))
              return a;
        }
      return a;
    }
    function yb(a) {
      V2.call(this, a, -1, zb);
    }
    M(yb, V2);
    yb.prototype.addClassification = function(a, b) {
      qb(this, a, wb, b);
      return this;
    };
    var zb = [1];
    function Ab(a) {
      V2.call(this, a);
    }
    M(Ab, V2);
    function Bb(a, b) {
      for (; S2(b); )
        switch (b.i) {
          case 13:
            var c = T(b);
            X2(a, 1, c);
            break;
          case 21:
            c = T(b);
            X2(a, 2, c);
            break;
          case 29:
            c = T(b);
            X2(a, 3, c);
            break;
          case 37:
            c = T(b);
            X2(a, 4, c);
            break;
          case 45:
            c = T(b);
            X2(a, 5, c);
            break;
          default:
            if (!sb(a, b))
              return a;
        }
      return a;
    }
    function Cb(a) {
      V2.call(this, a, -1, Db);
    }
    M(Cb, V2);
    function Eb(a) {
      a: {
        var b = new Cb();
        for (a = new Sa(a); S2(a); )
          switch (a.i) {
            case 10:
              var c = Ua(a, new Ab(), Bb);
              qb(b, c, Ab, void 0);
              break;
            default:
              if (!sb(b, a))
                break a;
          }
      }
      return b;
    }
    var Db = [1];
    function Fb(a) {
      V2.call(this, a);
    }
    M(Fb, V2);
    function Gb(a) {
      V2.call(this, a, -1, Hb);
    }
    M(Gb, V2);
    Gb.prototype.getVertexType = function() {
      return lb(this, 1, 0);
    };
    Gb.prototype.getPrimitiveType = function() {
      return lb(this, 2, 0);
    };
    Gb.prototype.getVertexBufferList = function() {
      return kb(this);
    };
    Gb.prototype.getIndexBufferList = function() {
      return jb(this, 4);
    };
    function Ib(a, b) {
      for (; S2(b); )
        switch (b.i) {
          case 8:
            var c = Oa(b.g);
            X2(a, 1, c);
            break;
          case 16:
            c = Oa(b.g);
            X2(a, 2, c);
            break;
          case 29:
          case 26:
            Xa(b, a.getVertexBufferList());
            break;
          case 32:
          case 34:
            c = b;
            var d = a.getIndexBufferList();
            2 == c.h ? Wa(c, Ma.prototype.i, d) : d.push(c.g.i());
            break;
          default:
            if (!sb(a, b))
              return a;
        }
      return a;
    }
    var Hb = [3, 4];
    function Jb(a) {
      V2.call(this, a);
    }
    M(Jb, V2);
    Jb.prototype.getMesh = function() {
      return mb(this, Gb, 1);
    };
    Jb.prototype.getPoseTransformMatrix = function() {
      return mb(this, tb, 2);
    };
    function Kb(a) {
      a: {
        var b = new Jb();
        for (a = new Sa(a); S2(a); )
          switch (a.i) {
            case 10:
              var c = Ua(a, new Gb(), Ib);
              ob(b, 1, c);
              break;
            case 18:
              c = Ua(a, new tb(), vb);
              ob(b, 2, c);
              break;
            default:
              if (!sb(b, a))
                break a;
          }
      }
      return b;
    }
    function Lb(a, b, c) {
      c = a.createShader(0 === c ? a.VERTEX_SHADER : a.FRAGMENT_SHADER);
      a.shaderSource(c, b);
      a.compileShader(c);
      if (!a.getShaderParameter(c, a.COMPILE_STATUS))
        throw Error("Could not compile WebGL shader.\n\n" + a.getShaderInfoLog(c));
      return c;
    }
    function Mb(a) {
      return nb(a, wb).map(function(b) {
        return { index: lb(b, 1, 0), Y: Y2(b, 2), label: null != W2(b, 3) ? lb(b, 3, "") : void 0, displayName: null != W2(b, 4) ? lb(b, 4, "") : void 0 };
      });
    }
    function Nb(a) {
      return { x: Y2(a, 1), y: Y2(a, 2), z: Y2(a, 3), visibility: null != W2(a, 4) ? Y2(a, 4) : void 0 };
    }
    function Ob(a, b) {
      this.h = a;
      this.g = b;
      this.l = 0;
    }
    function Pb(a, b, c) {
      Qb(a, b);
      if ("function" === typeof a.g.canvas.transferToImageBitmap)
        return Promise.resolve(a.g.canvas.transferToImageBitmap());
      if (c)
        return Promise.resolve(a.g.canvas);
      if ("function" === typeof createImageBitmap)
        return createImageBitmap(a.g.canvas);
      void 0 === a.i && (a.i = document.createElement("canvas"));
      return new Promise(function(d) {
        a.i.height = a.g.canvas.height;
        a.i.width = a.g.canvas.width;
        a.i.getContext("2d", {}).drawImage(a.g.canvas, 0, 0, a.g.canvas.width, a.g.canvas.height);
        d(a.i);
      });
    }
    function Qb(a, b) {
      var c = a.g;
      if (void 0 === a.m) {
        var d = Lb(c, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", 0), e = Lb(c, "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }", 1), g = c.createProgram();
        c.attachShader(g, d);
        c.attachShader(g, e);
        c.linkProgram(g);
        if (!c.getProgramParameter(g, c.LINK_STATUS))
          throw Error("Could not compile WebGL program.\n\n" + c.getProgramInfoLog(g));
        d = a.m = g;
        c.useProgram(d);
        e = c.getUniformLocation(d, "sampler0");
        a.j = { I: c.getAttribLocation(d, "aVertex"), H: c.getAttribLocation(d, "aTex"), da: e };
        a.s = c.createBuffer();
        c.bindBuffer(c.ARRAY_BUFFER, a.s);
        c.enableVertexAttribArray(a.j.I);
        c.vertexAttribPointer(a.j.I, 2, c.FLOAT, false, 0, 0);
        c.bufferData(c.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), c.STATIC_DRAW);
        c.bindBuffer(c.ARRAY_BUFFER, null);
        a.o = c.createBuffer();
        c.bindBuffer(c.ARRAY_BUFFER, a.o);
        c.enableVertexAttribArray(a.j.H);
        c.vertexAttribPointer(
          a.j.H,
          2,
          c.FLOAT,
          false,
          0,
          0
        );
        c.bufferData(c.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]), c.STATIC_DRAW);
        c.bindBuffer(c.ARRAY_BUFFER, null);
        c.uniform1i(e, 0);
      }
      d = a.j;
      c.useProgram(a.m);
      c.canvas.width = b.width;
      c.canvas.height = b.height;
      c.viewport(0, 0, b.width, b.height);
      c.activeTexture(c.TEXTURE0);
      a.h.bindTexture2d(b.glName);
      c.enableVertexAttribArray(d.I);
      c.bindBuffer(c.ARRAY_BUFFER, a.s);
      c.vertexAttribPointer(d.I, 2, c.FLOAT, false, 0, 0);
      c.enableVertexAttribArray(d.H);
      c.bindBuffer(c.ARRAY_BUFFER, a.o);
      c.vertexAttribPointer(
        d.H,
        2,
        c.FLOAT,
        false,
        0,
        0
      );
      c.bindFramebuffer(c.DRAW_FRAMEBUFFER ? c.DRAW_FRAMEBUFFER : c.FRAMEBUFFER, null);
      c.clearColor(0, 0, 0, 0);
      c.clear(c.COLOR_BUFFER_BIT);
      c.colorMask(true, true, true, true);
      c.drawArrays(c.TRIANGLE_FAN, 0, 4);
      c.disableVertexAttribArray(d.I);
      c.disableVertexAttribArray(d.H);
      c.bindBuffer(c.ARRAY_BUFFER, null);
      a.h.bindTexture2d(0);
    }
    function Rb(a) {
      this.g = a;
    }
    var Sb = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]);
    function Tb(a, b) {
      return b + a;
    }
    function Ub(a, b) {
      window[a] = b;
    }
    function Vb(a) {
      var b = document.createElement("script");
      b.setAttribute("src", a);
      b.setAttribute("crossorigin", "anonymous");
      return new Promise(function(c) {
        b.addEventListener("load", function() {
          c();
        }, false);
        b.addEventListener("error", function() {
          c();
        }, false);
        document.body.appendChild(b);
      });
    }
    function Wb() {
      return Z2(this, function b() {
        return O2(b, function(c) {
          switch (c.g) {
            case 1:
              return c.m = 2, N2(c, WebAssembly.instantiate(Sb), 4);
            case 4:
              c.g = 3;
              c.m = 0;
              break;
            case 2:
              return c.m = 0, c.j = null, c.return(false);
            case 3:
              return c.return(true);
          }
        });
      });
    }
    function Xb(a) {
      this.g = a;
      this.listeners = {};
      this.j = {};
      this.F = {};
      this.m = {};
      this.s = {};
      this.G = this.o = this.R = true;
      this.C = Promise.resolve();
      this.P = "";
      this.B = {};
      this.locateFile = a && a.locateFile || Tb;
      if ("object" === typeof window)
        var b = window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/";
      else if ("undefined" !== typeof location)
        b = location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/";
      else
        throw Error("solutions can only be loaded on a web page or in a web worker");
      this.S = b;
      if (a.options) {
        b = K2(Object.keys(a.options));
        for (var c = b.next(); !c.done; c = b.next()) {
          c = c.value;
          var d = a.options[c].default;
          void 0 !== d && (this.j[c] = "function" === typeof d ? d() : d);
        }
      }
    }
    v = Xb.prototype;
    v.close = function() {
      this.i && this.i.delete();
      return Promise.resolve();
    };
    function Yb(a, b) {
      return void 0 === a.g.files ? [] : "function" === typeof a.g.files ? a.g.files(b) : a.g.files;
    }
    function Zb(a) {
      return Z2(a, function c() {
        var d = this, e, g, f, h, k3, l, n, u, w, r, y;
        return O2(c, function(m) {
          switch (m.g) {
            case 1:
              e = d;
              if (!d.R)
                return m.return();
              g = Yb(d, d.j);
              return N2(m, Wb(), 2);
            case 2:
              f = m.h;
              if ("object" === typeof window)
                return Ub("createMediapipeSolutionsWasm", { locateFile: d.locateFile }), Ub("createMediapipeSolutionsPackedAssets", { locateFile: d.locateFile }), l = g.filter(function(t) {
                  return void 0 !== t.data;
                }), n = g.filter(function(t) {
                  return void 0 === t.data;
                }), u = Promise.all(l.map(function(t) {
                  var x = $b(e, t.url);
                  if (void 0 !== t.path) {
                    var z2 = t.path;
                    x = x.then(function(E2) {
                      e.overrideFile(z2, E2);
                      return Promise.resolve(E2);
                    });
                  }
                  return x;
                })), w = Promise.all(n.map(function(t) {
                  return void 0 === t.simd || t.simd && f || !t.simd && !f ? Vb(e.locateFile(t.url, e.S)) : Promise.resolve();
                })).then(function() {
                  return Z2(e, function x() {
                    var z2, E2, F2 = this;
                    return O2(x, function(I2) {
                      if (1 == I2.g)
                        return z2 = window.createMediapipeSolutionsWasm, E2 = window.createMediapipeSolutionsPackedAssets, N2(I2, z2(E2), 2);
                      F2.h = I2.h;
                      I2.g = 0;
                    });
                  });
                }), r = function() {
                  return Z2(e, function x() {
                    var z2 = this;
                    return O2(x, function(E2) {
                      z2.g.graph && z2.g.graph.url ? E2 = N2(E2, $b(z2, z2.g.graph.url), 0) : (E2.g = 0, E2 = void 0);
                      return E2;
                    });
                  });
                }(), N2(m, Promise.all([w, u, r]), 7);
              if ("function" !== typeof importScripts)
                throw Error("solutions can only be loaded on a web page or in a web worker");
              h = g.filter(function(t) {
                return void 0 === t.simd || t.simd && f || !t.simd && !f;
              }).map(function(t) {
                return e.locateFile(t.url, e.S);
              });
              importScripts.apply(null, L2(h));
              return N2(m, createMediapipeSolutionsWasm(Module), 6);
            case 6:
              d.h = m.h;
              d.l = new OffscreenCanvas(1, 1);
              d.h.canvas = d.l;
              k3 = d.h.GL.createContext(
                d.l,
                { antialias: false, alpha: false, ba: "undefined" !== typeof WebGL2RenderingContext ? 2 : 1 }
              );
              d.h.GL.makeContextCurrent(k3);
              m.g = 4;
              break;
            case 7:
              d.l = document.createElement("canvas");
              y = d.l.getContext("webgl2", {});
              if (!y && (y = d.l.getContext("webgl", {}), !y))
                return alert("Failed to create WebGL canvas context when passing video frame."), m.return();
              d.D = y;
              d.h.canvas = d.l;
              d.h.createContext(d.l, true, true, {});
            case 4:
              d.i = new d.h.SolutionWasm(), d.R = false, m.g = 0;
          }
        });
      });
    }
    function ac(a) {
      return Z2(a, function c() {
        var d = this, e, g, f, h, k3, l, n, u;
        return O2(c, function(w) {
          if (1 == w.g) {
            if (d.g.graph && d.g.graph.url && d.P === d.g.graph.url)
              return w.return();
            d.o = true;
            if (!d.g.graph || !d.g.graph.url) {
              w.g = 2;
              return;
            }
            d.P = d.g.graph.url;
            return N2(w, $b(d, d.g.graph.url), 3);
          }
          2 != w.g && (e = w.h, d.i.loadGraph(e));
          g = K2(Object.keys(d.B));
          for (f = g.next(); !f.done; f = g.next())
            h = f.value, d.i.overrideFile(h, d.B[h]);
          d.B = {};
          if (d.g.listeners)
            for (k3 = K2(d.g.listeners), l = k3.next(); !l.done; l = k3.next())
              n = l.value, bc(d, n);
          u = d.j;
          d.j = {};
          d.setOptions(u);
          w.g = 0;
        });
      });
    }
    v.reset = function() {
      return Z2(this, function b() {
        var c = this;
        return O2(b, function(d) {
          c.i && (c.i.reset(), c.m = {}, c.s = {});
          d.g = 0;
        });
      });
    };
    v.setOptions = function(a, b) {
      var c = this;
      if (b = b || this.g.options) {
        for (var d = [], e = [], g = {}, f = K2(Object.keys(a)), h = f.next(); !h.done; g = { K: g.K, L: g.L }, h = f.next()) {
          var k3 = h.value;
          k3 in this.j && this.j[k3] === a[k3] || (this.j[k3] = a[k3], h = b[k3], void 0 !== h && (h.onChange && (g.K = h.onChange, g.L = a[k3], d.push(function(l) {
            return function() {
              return Z2(c, function u() {
                var w, r = this;
                return O2(u, function(y) {
                  if (1 == y.g)
                    return N2(y, l.K(l.L), 2);
                  w = y.h;
                  true === w && (r.o = true);
                  y.g = 0;
                });
              });
            };
          }(g))), h.graphOptionXref && (k3 = { valueNumber: 1 === h.type ? a[k3] : 0, valueBoolean: 0 === h.type ? a[k3] : false, valueString: 2 === h.type ? a[k3] : "" }, h = Object.assign(Object.assign(Object.assign({}, { calculatorName: "", calculatorIndex: 0 }), h.graphOptionXref), k3), e.push(h))));
        }
        if (0 !== d.length || 0 !== e.length)
          this.o = true, this.A = (void 0 === this.A ? [] : this.A).concat(e), this.u = (void 0 === this.u ? [] : this.u).concat(d);
      }
    };
    function cc(a) {
      return Z2(a, function c() {
        var d = this, e, g, f, h, k3, l, n;
        return O2(c, function(u) {
          switch (u.g) {
            case 1:
              if (!d.o)
                return u.return();
              if (!d.u) {
                u.g = 2;
                break;
              }
              e = K2(d.u);
              g = e.next();
            case 3:
              if (g.done) {
                u.g = 5;
                break;
              }
              f = g.value;
              return N2(u, f(), 4);
            case 4:
              g = e.next();
              u.g = 3;
              break;
            case 5:
              d.u = void 0;
            case 2:
              if (d.A) {
                h = new d.h.GraphOptionChangeRequestList();
                k3 = K2(d.A);
                for (l = k3.next(); !l.done; l = k3.next())
                  n = l.value, h.push_back(n);
                d.i.changeOptions(h);
                h.delete();
                d.A = void 0;
              }
              d.o = false;
              u.g = 0;
          }
        });
      });
    }
    v.initialize = function() {
      return Z2(this, function b() {
        var c = this;
        return O2(b, function(d) {
          return 1 == d.g ? N2(d, Zb(c), 2) : 3 != d.g ? N2(d, ac(c), 3) : N2(d, cc(c), 0);
        });
      });
    };
    function $b(a, b) {
      return Z2(a, function d() {
        var e = this, g, f;
        return O2(d, function(h) {
          if (b in e.F)
            return h.return(e.F[b]);
          g = e.locateFile(b, "");
          f = fetch(g).then(function(k3) {
            return k3.arrayBuffer();
          });
          e.F[b] = f;
          return h.return(f);
        });
      });
    }
    v.overrideFile = function(a, b) {
      this.i ? this.i.overrideFile(a, b) : this.B[a] = b;
    };
    v.clearOverriddenFiles = function() {
      this.B = {};
      this.i && this.i.clearOverriddenFiles();
    };
    v.send = function(a, b) {
      return Z2(this, function d() {
        var e = this, g, f, h, k3, l, n, u, w, r;
        return O2(d, function(y) {
          switch (y.g) {
            case 1:
              if (!e.g.inputs)
                return y.return();
              g = 1e3 * (void 0 === b || null === b ? performance.now() : b);
              return N2(y, e.C, 2);
            case 2:
              return N2(y, e.initialize(), 3);
            case 3:
              f = new e.h.PacketDataList();
              h = K2(Object.keys(a));
              for (k3 = h.next(); !k3.done; k3 = h.next())
                if (l = k3.value, n = e.g.inputs[l]) {
                  a: {
                    var m = e;
                    var t = a[l];
                    switch (n.type) {
                      case "video":
                        var x = m.m[n.stream];
                        x || (x = new Ob(m.h, m.D), m.m[n.stream] = x);
                        m = x;
                        0 === m.l && (m.l = m.h.createTexture());
                        if ("undefined" !== typeof HTMLVideoElement && t instanceof HTMLVideoElement) {
                          var z2 = t.videoWidth;
                          x = t.videoHeight;
                        } else
                          "undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement ? (z2 = t.naturalWidth, x = t.naturalHeight) : (z2 = t.width, x = t.height);
                        x = { glName: m.l, width: z2, height: x };
                        z2 = m.g;
                        z2.canvas.width = x.width;
                        z2.canvas.height = x.height;
                        z2.activeTexture(z2.TEXTURE0);
                        m.h.bindTexture2d(m.l);
                        z2.texImage2D(z2.TEXTURE_2D, 0, z2.RGBA, z2.RGBA, z2.UNSIGNED_BYTE, t);
                        m.h.bindTexture2d(0);
                        m = x;
                        break a;
                      case "detections":
                        x = m.m[n.stream];
                        x || (x = new Rb(m.h), m.m[n.stream] = x);
                        m = x;
                        m.data || (m.data = new m.g.DetectionListData());
                        m.data.reset(t.length);
                        for (x = 0; x < t.length; ++x) {
                          z2 = t[x];
                          var E2 = m.data, F2 = E2.setBoundingBox, I2 = x;
                          var H2 = z2.T;
                          var p = new Fb();
                          X2(p, 1, H2.Z);
                          X2(p, 2, H2.$);
                          X2(p, 3, H2.height);
                          X2(p, 4, H2.width);
                          X2(p, 5, H2.rotation);
                          X2(p, 6, H2.X);
                          var A = H2 = new Ya();
                          U2(A, 1, W2(p, 1));
                          U2(A, 2, W2(p, 2));
                          U2(A, 3, W2(p, 3));
                          U2(A, 4, W2(p, 4));
                          U2(A, 5, W2(p, 5));
                          var C2 = W2(p, 6);
                          if (null != C2 && null != C2) {
                            Ra(A.g, 48);
                            var q2 = A.g, B2 = C2;
                            C2 = 0 > B2;
                            B2 = Math.abs(B2);
                            var D2 = B2 >>> 0;
                            B2 = Math.floor((B2 - D2) / 4294967296);
                            B2 >>>= 0;
                            C2 && (B2 = ~B2 >>> 0, D2 = (~D2 >>> 0) + 1, 4294967295 < D2 && (D2 = 0, B2++, 4294967295 < B2 && (B2 = 0)));
                            Q2 = D2;
                            R2 = B2;
                            C2 = Q2;
                            for (D2 = R2; 0 < D2 || 127 < C2; )
                              q2.push(C2 & 127 | 128), C2 = (C2 >>> 7 | D2 << 25) >>> 0, D2 >>>= 7;
                            q2.push(C2);
                          }
                          rb(p, A);
                          H2 = $a(H2);
                          F2.call(E2, I2, H2);
                          if (z2.O)
                            for (E2 = 0; E2 < z2.O.length; ++E2)
                              p = z2.O[E2], A = p.visibility ? true : false, F2 = m.data, I2 = F2.addNormalizedLandmark, H2 = x, p = Object.assign(Object.assign({}, p), { visibility: A ? p.visibility : 0 }), A = new Ab(), X2(A, 1, p.x), X2(A, 2, p.y), X2(A, 3, p.z), p.visibility && X2(A, 4, p.visibility), q2 = p = new Ya(), U2(q2, 1, W2(A, 1)), U2(q2, 2, W2(A, 2)), U2(q2, 3, W2(A, 3)), U2(q2, 4, W2(A, 4)), U2(q2, 5, W2(A, 5)), rb(A, q2), p = $a(p), I2.call(F2, H2, p);
                          if (z2.M)
                            for (E2 = 0; E2 < z2.M.length; ++E2) {
                              F2 = m.data;
                              I2 = F2.addClassification;
                              H2 = x;
                              p = z2.M[E2];
                              A = new wb();
                              X2(A, 2, p.Y);
                              p.index && X2(A, 1, p.index);
                              p.label && X2(A, 3, p.label);
                              p.displayName && X2(A, 4, p.displayName);
                              q2 = p = new Ya();
                              D2 = W2(A, 1);
                              if (null != D2 && null != D2)
                                if (Ra(q2.g, 8), C2 = q2.g, 0 <= D2)
                                  Ra(C2, D2);
                                else {
                                  for (B2 = 0; 9 > B2; B2++)
                                    C2.push(D2 & 127 | 128), D2 >>= 7;
                                  C2.push(1);
                                }
                              U2(q2, 2, W2(A, 2));
                              C2 = W2(A, 3);
                              null != C2 && (C2 = Ca(C2), Ra(q2.g, 26), Ra(q2.g, C2.length), Za(q2, q2.g.end()), Za(q2, C2));
                              C2 = W2(A, 4);
                              null != C2 && (C2 = Ca(C2), Ra(q2.g, 34), Ra(q2.g, C2.length), Za(q2, q2.g.end()), Za(q2, C2));
                              rb(A, q2);
                              p = $a(p);
                              I2.call(F2, H2, p);
                            }
                        }
                        m = m.data;
                        break a;
                      default:
                        m = {};
                    }
                  }
                  u = m;
                  w = n.stream;
                  switch (n.type) {
                    case "video":
                      f.pushTexture2d(Object.assign(Object.assign({}, u), { stream: w, timestamp: g }));
                      break;
                    case "detections":
                      r = u;
                      r.stream = w;
                      r.timestamp = g;
                      f.pushDetectionList(r);
                      break;
                    default:
                      throw Error("Unknown input config type: '" + n.type + "'");
                  }
                }
              e.i.send(f);
              return N2(y, e.C, 4);
            case 4:
              f.delete(), y.g = 0;
          }
        });
      });
    };
    function dc(a, b, c) {
      return Z2(a, function e() {
        var g, f, h, k3, l, n, u = this, w, r, y, m, t, x, z2, E2;
        return O2(e, function(F2) {
          switch (F2.g) {
            case 1:
              if (!c)
                return F2.return(b);
              g = {};
              f = 0;
              h = K2(Object.keys(c));
              for (k3 = h.next(); !k3.done; k3 = h.next())
                l = k3.value, n = c[l], "string" !== typeof n && "texture" === n.type && void 0 !== b[n.stream] && ++f;
              1 < f && (u.G = false);
              w = K2(Object.keys(c));
              k3 = w.next();
            case 2:
              if (k3.done) {
                F2.g = 4;
                break;
              }
              r = k3.value;
              y = c[r];
              if ("string" === typeof y)
                return z2 = g, E2 = r, N2(F2, ec(u, r, b[y]), 14);
              m = b[y.stream];
              if ("detection_list" === y.type) {
                if (m) {
                  var I2 = m.getRectList();
                  for (var H2 = m.getLandmarksList(), p = m.getClassificationsList(), A = [], C2 = 0; C2 < I2.size(); ++C2) {
                    var q2 = I2.get(C2);
                    a: {
                      var B2 = new Fb();
                      for (q2 = new Sa(q2); S2(q2); )
                        switch (q2.i) {
                          case 13:
                            var D2 = T(q2);
                            X2(B2, 1, D2);
                            break;
                          case 21:
                            D2 = T(q2);
                            X2(B2, 2, D2);
                            break;
                          case 29:
                            D2 = T(q2);
                            X2(B2, 3, D2);
                            break;
                          case 37:
                            D2 = T(q2);
                            X2(B2, 4, D2);
                            break;
                          case 45:
                            D2 = T(q2);
                            X2(B2, 5, D2);
                            break;
                          case 48:
                            D2 = Oa(q2.g);
                            X2(B2, 6, D2);
                            break;
                          default:
                            if (!sb(B2, q2))
                              break a;
                        }
                    }
                    B2 = { Z: Y2(B2, 1), $: Y2(B2, 2), height: Y2(B2, 3), width: Y2(B2, 4), rotation: Y2(B2, 5, 0), X: lb(B2, 6, 0) };
                    q2 = nb(Eb(H2.get(C2)), Ab).map(Nb);
                    var la = p.get(C2);
                    a:
                      for (D2 = new yb(), la = new Sa(la); S2(la); )
                        switch (la.i) {
                          case 10:
                            D2.addClassification(Ua(la, new wb(), xb));
                            break;
                          default:
                            if (!sb(D2, la))
                              break a;
                        }
                    B2 = { T: B2, O: q2, M: Mb(D2) };
                    A.push(B2);
                  }
                  I2 = A;
                } else
                  I2 = [];
                g[r] = I2;
                F2.g = 7;
                break;
              }
              if ("proto_list" === y.type) {
                if (m) {
                  I2 = Array(m.size());
                  for (H2 = 0; H2 < m.size(); H2++)
                    I2[H2] = m.get(H2);
                  m.delete();
                } else
                  I2 = [];
                g[r] = I2;
                F2.g = 7;
                break;
              }
              if (void 0 === m) {
                F2.g = 3;
                break;
              }
              if ("float_list" === y.type) {
                g[r] = m;
                F2.g = 7;
                break;
              }
              if ("proto" === y.type) {
                g[r] = m;
                F2.g = 7;
                break;
              }
              if ("texture" !== y.type)
                throw Error("Unknown output config type: '" + y.type + "'");
              t = u.s[r];
              t || (t = new Ob(u.h, u.D), u.s[r] = t);
              return N2(F2, Pb(t, m, u.G), 13);
            case 13:
              x = F2.h, g[r] = x;
            case 7:
              y.transform && g[r] && (g[r] = y.transform(g[r]));
              F2.g = 3;
              break;
            case 14:
              z2[E2] = F2.h;
            case 3:
              k3 = w.next();
              F2.g = 2;
              break;
            case 4:
              return F2.return(g);
          }
        });
      });
    }
    function ec(a, b, c) {
      return Z2(a, function e() {
        var g = this, f;
        return O2(e, function(h) {
          return "number" === typeof c || c instanceof Uint8Array || c instanceof g.h.Uint8BlobList ? h.return(c) : c instanceof g.h.Texture2dDataOut ? (f = g.s[b], f || (f = new Ob(g.h, g.D), g.s[b] = f), h.return(Pb(f, c, g.G))) : h.return(void 0);
        });
      });
    }
    function bc(a, b) {
      for (var c = b.name || "$", d = [].concat(L2(b.wants)), e = new a.h.StringList(), g = K2(b.wants), f = g.next(); !f.done; f = g.next())
        e.push_back(f.value);
      g = a.h.PacketListener.implement({ onResults: function(h) {
        for (var k3 = {}, l = 0; l < b.wants.length; ++l)
          k3[d[l]] = h.get(l);
        var n = a.listeners[c];
        n && (a.C = dc(a, k3, b.outs).then(function(u) {
          u = n(u);
          for (var w = 0; w < b.wants.length; ++w) {
            var r = k3[d[w]];
            "object" === typeof r && r.hasOwnProperty && r.hasOwnProperty("delete") && r.delete();
          }
          u && (a.C = u);
        }));
      } });
      a.i.attachMultiListener(e, g);
      e.delete();
    }
    v.onResults = function(a, b) {
      this.listeners[b || "$"] = a;
    };
    P2("Solution", Xb);
    P2("OptionType", { BOOL: 0, NUMBER: 1, aa: 2, 0: "BOOL", 1: "NUMBER", 2: "STRING" });
    function fc(a) {
      a = Kb(a);
      var b = a.getMesh();
      if (!b)
        return a;
      var c = new Float32Array(b.getVertexBufferList());
      b.getVertexBufferList = function() {
        return c;
      };
      var d = new Uint32Array(b.getIndexBufferList());
      b.getIndexBufferList = function() {
        return d;
      };
      return a;
    }
    var gc = { files: [{ url: "face_mesh_solution_packed_assets_loader.js" }, { simd: true, url: "face_mesh_solution_simd_wasm_bin.js" }, { simd: false, url: "face_mesh_solution_wasm_bin.js" }], graph: { url: "face_mesh.binarypb" }, listeners: [{ wants: ["multi_face_geometry", "image_transformed", "multi_face_landmarks"], outs: { image: "image_transformed", multiFaceGeometry: { type: "proto_list", stream: "multi_face_geometry", transform: function(a) {
      return a.map(fc);
    } }, multiFaceLandmarks: { type: "proto_list", stream: "multi_face_landmarks", transform: function(a) {
      return a.map(function(b) {
        return nb(
          Eb(b),
          Ab
        ).map(Nb);
      });
    } } } }], inputs: { image: { type: "video", stream: "input_frames_gpu" } }, options: { useCpuInference: { type: 0, graphOptionXref: { calculatorType: "InferenceCalculator", fieldName: "use_cpu_inference" }, default: "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document }, enableFaceGeometry: { type: 0, graphOptionXref: {
      calculatorName: "EnableFaceGeometryConstant",
      calculatorType: "ConstantSidePacketCalculator",
      fieldName: "bool_value"
    } }, selfieMode: { type: 0, graphOptionXref: { calculatorType: "GlScalerCalculator", calculatorIndex: 1, fieldName: "flip_horizontal" } }, maxNumFaces: { type: 1, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorNumFaces", fieldName: "int_value" } }, refineLandmarks: { type: 0, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorRefineLandmarks", fieldName: "bool_value" } }, minDetectionConfidence: {
      type: 1,
      graphOptionXref: { calculatorType: "TensorsToDetectionsCalculator", calculatorName: "facelandmarkfrontgpu__facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator", fieldName: "min_score_thresh" }
    }, minTrackingConfidence: { type: 1, graphOptionXref: { calculatorType: "ThresholdingCalculator", calculatorName: "facelandmarkfrontgpu__facelandmarkgpu__ThresholdingCalculator", fieldName: "threshold" } }, cameraNear: { type: 1, graphOptionXref: {
      calculatorType: "FaceGeometryEnvGeneratorCalculator",
      fieldName: "near"
    } }, cameraFar: { type: 1, graphOptionXref: { calculatorType: "FaceGeometryEnvGeneratorCalculator", fieldName: "far" } }, cameraVerticalFovDegrees: { type: 1, graphOptionXref: { calculatorType: "FaceGeometryEnvGeneratorCalculator", fieldName: "vertical_fov_degrees" } } } };
    var hc = [[61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]], ic = [[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [
      386,
      385
    ], [385, 384], [384, 398], [398, 362]], jc = [[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]], kc = [[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]], lc = [[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]], mc = [
      [10, 338],
      [338, 297],
      [297, 332],
      [332, 284],
      [284, 251],
      [251, 389],
      [389, 356],
      [356, 454],
      [454, 323],
      [323, 361],
      [361, 288],
      [288, 397],
      [397, 365],
      [365, 379],
      [379, 378],
      [378, 400],
      [400, 377],
      [377, 152],
      [152, 148],
      [148, 176],
      [176, 149],
      [149, 150],
      [150, 136],
      [136, 172],
      [172, 58],
      [58, 132],
      [132, 93],
      [93, 234],
      [234, 127],
      [127, 162],
      [162, 21],
      [21, 54],
      [54, 103],
      [103, 67],
      [67, 109],
      [109, 10]
    ], nc = [].concat(L2(hc), L2(ic), L2(jc), L2(kc), L2(lc), L2(mc));
    function oc(a) {
      a = a || {};
      a = Object.assign(Object.assign({}, gc), a);
      this.g = new Xb(a);
    }
    v = oc.prototype;
    v.close = function() {
      this.g.close();
      return Promise.resolve();
    };
    v.onResults = function(a) {
      this.g.onResults(a);
    };
    v.initialize = function() {
      return Z2(this, function b() {
        var c = this;
        return O2(b, function(d) {
          return N2(d, c.g.initialize(), 0);
        });
      });
    };
    v.reset = function() {
      this.g.reset();
    };
    v.send = function(a) {
      return Z2(this, function c() {
        var d = this;
        return O2(c, function(e) {
          return N2(e, d.g.send(a), 0);
        });
      });
    };
    v.setOptions = function(a) {
      this.g.setOptions(a);
    };
    P2("FACE_GEOMETRY", { Layout: { COLUMN_MAJOR: 0, ROW_MAJOR: 1, 0: "COLUMN_MAJOR", 1: "ROW_MAJOR" }, PrimitiveType: { TRIANGLE: 0, 0: "TRIANGLE" }, VertexType: { VERTEX_PT: 0, 0: "VERTEX_PT" }, DEFAULT_CAMERA_PARAMS: { verticalFovDegrees: 63, near: 1, far: 1e4 } });
    P2("FaceMesh", oc);
    P2("FACEMESH_LIPS", hc);
    P2("FACEMESH_LEFT_EYE", ic);
    P2("FACEMESH_LEFT_EYEBROW", jc);
    P2("FACEMESH_LEFT_IRIS", [[474, 475], [475, 476], [476, 477], [477, 474]]);
    P2("FACEMESH_RIGHT_EYE", kc);
    P2("FACEMESH_RIGHT_EYEBROW", lc);
    P2("FACEMESH_RIGHT_IRIS", [[469, 470], [470, 471], [471, 472], [472, 469]]);
    P2("FACEMESH_FACE_OVAL", mc);
    P2("FACEMESH_CONTOURS", nc);
    P2("FACEMESH_TESSELATION", [
      [127, 34],
      [34, 139],
      [139, 127],
      [11, 0],
      [0, 37],
      [37, 11],
      [232, 231],
      [231, 120],
      [120, 232],
      [72, 37],
      [37, 39],
      [39, 72],
      [128, 121],
      [121, 47],
      [47, 128],
      [232, 121],
      [121, 128],
      [128, 232],
      [104, 69],
      [69, 67],
      [67, 104],
      [175, 171],
      [171, 148],
      [148, 175],
      [118, 50],
      [50, 101],
      [101, 118],
      [73, 39],
      [39, 40],
      [40, 73],
      [9, 151],
      [151, 108],
      [108, 9],
      [48, 115],
      [115, 131],
      [131, 48],
      [194, 204],
      [204, 211],
      [211, 194],
      [74, 40],
      [40, 185],
      [185, 74],
      [80, 42],
      [42, 183],
      [183, 80],
      [40, 92],
      [92, 186],
      [186, 40],
      [230, 229],
      [229, 118],
      [118, 230],
      [202, 212],
      [
        212,
        214
      ],
      [214, 202],
      [83, 18],
      [18, 17],
      [17, 83],
      [76, 61],
      [61, 146],
      [146, 76],
      [160, 29],
      [29, 30],
      [30, 160],
      [56, 157],
      [157, 173],
      [173, 56],
      [106, 204],
      [204, 194],
      [194, 106],
      [135, 214],
      [214, 192],
      [192, 135],
      [203, 165],
      [165, 98],
      [98, 203],
      [21, 71],
      [71, 68],
      [68, 21],
      [51, 45],
      [45, 4],
      [4, 51],
      [144, 24],
      [24, 23],
      [23, 144],
      [77, 146],
      [146, 91],
      [91, 77],
      [205, 50],
      [50, 187],
      [187, 205],
      [201, 200],
      [200, 18],
      [18, 201],
      [91, 106],
      [106, 182],
      [182, 91],
      [90, 91],
      [91, 181],
      [181, 90],
      [85, 84],
      [84, 17],
      [17, 85],
      [206, 203],
      [203, 36],
      [36, 206],
      [148, 171],
      [171, 140],
      [140, 148],
      [
        92,
        40
      ],
      [40, 39],
      [39, 92],
      [193, 189],
      [189, 244],
      [244, 193],
      [159, 158],
      [158, 28],
      [28, 159],
      [247, 246],
      [246, 161],
      [161, 247],
      [236, 3],
      [3, 196],
      [196, 236],
      [54, 68],
      [68, 104],
      [104, 54],
      [193, 168],
      [168, 8],
      [8, 193],
      [117, 228],
      [228, 31],
      [31, 117],
      [189, 193],
      [193, 55],
      [55, 189],
      [98, 97],
      [97, 99],
      [99, 98],
      [126, 47],
      [47, 100],
      [100, 126],
      [166, 79],
      [79, 218],
      [218, 166],
      [155, 154],
      [154, 26],
      [26, 155],
      [209, 49],
      [49, 131],
      [131, 209],
      [135, 136],
      [136, 150],
      [150, 135],
      [47, 126],
      [126, 217],
      [217, 47],
      [223, 52],
      [52, 53],
      [53, 223],
      [45, 51],
      [51, 134],
      [134, 45],
      [211, 170],
      [
        170,
        140
      ],
      [140, 211],
      [67, 69],
      [69, 108],
      [108, 67],
      [43, 106],
      [106, 91],
      [91, 43],
      [230, 119],
      [119, 120],
      [120, 230],
      [226, 130],
      [130, 247],
      [247, 226],
      [63, 53],
      [53, 52],
      [52, 63],
      [238, 20],
      [20, 242],
      [242, 238],
      [46, 70],
      [70, 156],
      [156, 46],
      [78, 62],
      [62, 96],
      [96, 78],
      [46, 53],
      [53, 63],
      [63, 46],
      [143, 34],
      [34, 227],
      [227, 143],
      [123, 117],
      [117, 111],
      [111, 123],
      [44, 125],
      [125, 19],
      [19, 44],
      [236, 134],
      [134, 51],
      [51, 236],
      [216, 206],
      [206, 205],
      [205, 216],
      [154, 153],
      [153, 22],
      [22, 154],
      [39, 37],
      [37, 167],
      [167, 39],
      [200, 201],
      [201, 208],
      [208, 200],
      [36, 142],
      [142, 100],
      [
        100,
        36
      ],
      [57, 212],
      [212, 202],
      [202, 57],
      [20, 60],
      [60, 99],
      [99, 20],
      [28, 158],
      [158, 157],
      [157, 28],
      [35, 226],
      [226, 113],
      [113, 35],
      [160, 159],
      [159, 27],
      [27, 160],
      [204, 202],
      [202, 210],
      [210, 204],
      [113, 225],
      [225, 46],
      [46, 113],
      [43, 202],
      [202, 204],
      [204, 43],
      [62, 76],
      [76, 77],
      [77, 62],
      [137, 123],
      [123, 116],
      [116, 137],
      [41, 38],
      [38, 72],
      [72, 41],
      [203, 129],
      [129, 142],
      [142, 203],
      [64, 98],
      [98, 240],
      [240, 64],
      [49, 102],
      [102, 64],
      [64, 49],
      [41, 73],
      [73, 74],
      [74, 41],
      [212, 216],
      [216, 207],
      [207, 212],
      [42, 74],
      [74, 184],
      [184, 42],
      [169, 170],
      [170, 211],
      [211, 169],
      [
        170,
        149
      ],
      [149, 176],
      [176, 170],
      [105, 66],
      [66, 69],
      [69, 105],
      [122, 6],
      [6, 168],
      [168, 122],
      [123, 147],
      [147, 187],
      [187, 123],
      [96, 77],
      [77, 90],
      [90, 96],
      [65, 55],
      [55, 107],
      [107, 65],
      [89, 90],
      [90, 180],
      [180, 89],
      [101, 100],
      [100, 120],
      [120, 101],
      [63, 105],
      [105, 104],
      [104, 63],
      [93, 137],
      [137, 227],
      [227, 93],
      [15, 86],
      [86, 85],
      [85, 15],
      [129, 102],
      [102, 49],
      [49, 129],
      [14, 87],
      [87, 86],
      [86, 14],
      [55, 8],
      [8, 9],
      [9, 55],
      [100, 47],
      [47, 121],
      [121, 100],
      [145, 23],
      [23, 22],
      [22, 145],
      [88, 89],
      [89, 179],
      [179, 88],
      [6, 122],
      [122, 196],
      [196, 6],
      [88, 95],
      [95, 96],
      [96, 88],
      [138, 172],
      [172, 136],
      [136, 138],
      [215, 58],
      [58, 172],
      [172, 215],
      [115, 48],
      [48, 219],
      [219, 115],
      [42, 80],
      [80, 81],
      [81, 42],
      [195, 3],
      [3, 51],
      [51, 195],
      [43, 146],
      [146, 61],
      [61, 43],
      [171, 175],
      [175, 199],
      [199, 171],
      [81, 82],
      [82, 38],
      [38, 81],
      [53, 46],
      [46, 225],
      [225, 53],
      [144, 163],
      [163, 110],
      [110, 144],
      [52, 65],
      [65, 66],
      [66, 52],
      [229, 228],
      [228, 117],
      [117, 229],
      [34, 127],
      [127, 234],
      [234, 34],
      [107, 108],
      [108, 69],
      [69, 107],
      [109, 108],
      [108, 151],
      [151, 109],
      [48, 64],
      [64, 235],
      [235, 48],
      [62, 78],
      [78, 191],
      [191, 62],
      [129, 209],
      [209, 126],
      [126, 129],
      [111, 35],
      [35, 143],
      [
        143,
        111
      ],
      [117, 123],
      [123, 50],
      [50, 117],
      [222, 65],
      [65, 52],
      [52, 222],
      [19, 125],
      [125, 141],
      [141, 19],
      [221, 55],
      [55, 65],
      [65, 221],
      [3, 195],
      [195, 197],
      [197, 3],
      [25, 7],
      [7, 33],
      [33, 25],
      [220, 237],
      [237, 44],
      [44, 220],
      [70, 71],
      [71, 139],
      [139, 70],
      [122, 193],
      [193, 245],
      [245, 122],
      [247, 130],
      [130, 33],
      [33, 247],
      [71, 21],
      [21, 162],
      [162, 71],
      [170, 169],
      [169, 150],
      [150, 170],
      [188, 174],
      [174, 196],
      [196, 188],
      [216, 186],
      [186, 92],
      [92, 216],
      [2, 97],
      [97, 167],
      [167, 2],
      [141, 125],
      [125, 241],
      [241, 141],
      [164, 167],
      [167, 37],
      [37, 164],
      [72, 38],
      [38, 12],
      [12, 72],
      [38, 82],
      [82, 13],
      [13, 38],
      [63, 68],
      [68, 71],
      [71, 63],
      [226, 35],
      [35, 111],
      [111, 226],
      [101, 50],
      [50, 205],
      [205, 101],
      [206, 92],
      [92, 165],
      [165, 206],
      [209, 198],
      [198, 217],
      [217, 209],
      [165, 167],
      [167, 97],
      [97, 165],
      [220, 115],
      [115, 218],
      [218, 220],
      [133, 112],
      [112, 243],
      [243, 133],
      [239, 238],
      [238, 241],
      [241, 239],
      [214, 135],
      [135, 169],
      [169, 214],
      [190, 173],
      [173, 133],
      [133, 190],
      [171, 208],
      [208, 32],
      [32, 171],
      [125, 44],
      [44, 237],
      [237, 125],
      [86, 87],
      [87, 178],
      [178, 86],
      [85, 86],
      [86, 179],
      [179, 85],
      [84, 85],
      [85, 180],
      [180, 84],
      [83, 84],
      [84, 181],
      [181, 83],
      [201, 83],
      [83, 182],
      [182, 201],
      [137, 93],
      [93, 132],
      [132, 137],
      [76, 62],
      [62, 183],
      [183, 76],
      [61, 76],
      [76, 184],
      [184, 61],
      [57, 61],
      [61, 185],
      [185, 57],
      [212, 57],
      [57, 186],
      [186, 212],
      [214, 207],
      [207, 187],
      [187, 214],
      [34, 143],
      [143, 156],
      [156, 34],
      [79, 239],
      [239, 237],
      [237, 79],
      [123, 137],
      [137, 177],
      [177, 123],
      [44, 1],
      [1, 4],
      [4, 44],
      [201, 194],
      [194, 32],
      [32, 201],
      [64, 102],
      [102, 129],
      [129, 64],
      [213, 215],
      [215, 138],
      [138, 213],
      [59, 166],
      [166, 219],
      [219, 59],
      [242, 99],
      [99, 97],
      [97, 242],
      [2, 94],
      [94, 141],
      [141, 2],
      [75, 59],
      [59, 235],
      [235, 75],
      [24, 110],
      [110, 228],
      [
        228,
        24
      ],
      [25, 130],
      [130, 226],
      [226, 25],
      [23, 24],
      [24, 229],
      [229, 23],
      [22, 23],
      [23, 230],
      [230, 22],
      [26, 22],
      [22, 231],
      [231, 26],
      [112, 26],
      [26, 232],
      [232, 112],
      [189, 190],
      [190, 243],
      [243, 189],
      [221, 56],
      [56, 190],
      [190, 221],
      [28, 56],
      [56, 221],
      [221, 28],
      [27, 28],
      [28, 222],
      [222, 27],
      [29, 27],
      [27, 223],
      [223, 29],
      [30, 29],
      [29, 224],
      [224, 30],
      [247, 30],
      [30, 225],
      [225, 247],
      [238, 79],
      [79, 20],
      [20, 238],
      [166, 59],
      [59, 75],
      [75, 166],
      [60, 75],
      [75, 240],
      [240, 60],
      [147, 177],
      [177, 215],
      [215, 147],
      [20, 79],
      [79, 166],
      [166, 20],
      [187, 147],
      [147, 213],
      [213, 187],
      [112, 233],
      [233, 244],
      [244, 112],
      [233, 128],
      [128, 245],
      [245, 233],
      [128, 114],
      [114, 188],
      [188, 128],
      [114, 217],
      [217, 174],
      [174, 114],
      [131, 115],
      [115, 220],
      [220, 131],
      [217, 198],
      [198, 236],
      [236, 217],
      [198, 131],
      [131, 134],
      [134, 198],
      [177, 132],
      [132, 58],
      [58, 177],
      [143, 35],
      [35, 124],
      [124, 143],
      [110, 163],
      [163, 7],
      [7, 110],
      [228, 110],
      [110, 25],
      [25, 228],
      [356, 389],
      [389, 368],
      [368, 356],
      [11, 302],
      [302, 267],
      [267, 11],
      [452, 350],
      [350, 349],
      [349, 452],
      [302, 303],
      [303, 269],
      [269, 302],
      [357, 343],
      [343, 277],
      [277, 357],
      [452, 453],
      [453, 357],
      [357, 452],
      [333, 332],
      [
        332,
        297
      ],
      [297, 333],
      [175, 152],
      [152, 377],
      [377, 175],
      [347, 348],
      [348, 330],
      [330, 347],
      [303, 304],
      [304, 270],
      [270, 303],
      [9, 336],
      [336, 337],
      [337, 9],
      [278, 279],
      [279, 360],
      [360, 278],
      [418, 262],
      [262, 431],
      [431, 418],
      [304, 408],
      [408, 409],
      [409, 304],
      [310, 415],
      [415, 407],
      [407, 310],
      [270, 409],
      [409, 410],
      [410, 270],
      [450, 348],
      [348, 347],
      [347, 450],
      [422, 430],
      [430, 434],
      [434, 422],
      [313, 314],
      [314, 17],
      [17, 313],
      [306, 307],
      [307, 375],
      [375, 306],
      [387, 388],
      [388, 260],
      [260, 387],
      [286, 414],
      [414, 398],
      [398, 286],
      [335, 406],
      [406, 418],
      [418, 335],
      [364, 367],
      [
        367,
        416
      ],
      [416, 364],
      [423, 358],
      [358, 327],
      [327, 423],
      [251, 284],
      [284, 298],
      [298, 251],
      [281, 5],
      [5, 4],
      [4, 281],
      [373, 374],
      [374, 253],
      [253, 373],
      [307, 320],
      [320, 321],
      [321, 307],
      [425, 427],
      [427, 411],
      [411, 425],
      [421, 313],
      [313, 18],
      [18, 421],
      [321, 405],
      [405, 406],
      [406, 321],
      [320, 404],
      [404, 405],
      [405, 320],
      [315, 16],
      [16, 17],
      [17, 315],
      [426, 425],
      [425, 266],
      [266, 426],
      [377, 400],
      [400, 369],
      [369, 377],
      [322, 391],
      [391, 269],
      [269, 322],
      [417, 465],
      [465, 464],
      [464, 417],
      [386, 257],
      [257, 258],
      [258, 386],
      [466, 260],
      [260, 388],
      [388, 466],
      [456, 399],
      [399, 419],
      [419, 456],
      [284, 332],
      [332, 333],
      [333, 284],
      [417, 285],
      [285, 8],
      [8, 417],
      [346, 340],
      [340, 261],
      [261, 346],
      [413, 441],
      [441, 285],
      [285, 413],
      [327, 460],
      [460, 328],
      [328, 327],
      [355, 371],
      [371, 329],
      [329, 355],
      [392, 439],
      [439, 438],
      [438, 392],
      [382, 341],
      [341, 256],
      [256, 382],
      [429, 420],
      [420, 360],
      [360, 429],
      [364, 394],
      [394, 379],
      [379, 364],
      [277, 343],
      [343, 437],
      [437, 277],
      [443, 444],
      [444, 283],
      [283, 443],
      [275, 440],
      [440, 363],
      [363, 275],
      [431, 262],
      [262, 369],
      [369, 431],
      [297, 338],
      [338, 337],
      [337, 297],
      [273, 375],
      [375, 321],
      [321, 273],
      [450, 451],
      [
        451,
        349
      ],
      [349, 450],
      [446, 342],
      [342, 467],
      [467, 446],
      [293, 334],
      [334, 282],
      [282, 293],
      [458, 461],
      [461, 462],
      [462, 458],
      [276, 353],
      [353, 383],
      [383, 276],
      [308, 324],
      [324, 325],
      [325, 308],
      [276, 300],
      [300, 293],
      [293, 276],
      [372, 345],
      [345, 447],
      [447, 372],
      [352, 345],
      [345, 340],
      [340, 352],
      [274, 1],
      [1, 19],
      [19, 274],
      [456, 248],
      [248, 281],
      [281, 456],
      [436, 427],
      [427, 425],
      [425, 436],
      [381, 256],
      [256, 252],
      [252, 381],
      [269, 391],
      [391, 393],
      [393, 269],
      [200, 199],
      [199, 428],
      [428, 200],
      [266, 330],
      [330, 329],
      [329, 266],
      [287, 273],
      [273, 422],
      [422, 287],
      [250, 462],
      [
        462,
        328
      ],
      [328, 250],
      [258, 286],
      [286, 384],
      [384, 258],
      [265, 353],
      [353, 342],
      [342, 265],
      [387, 259],
      [259, 257],
      [257, 387],
      [424, 431],
      [431, 430],
      [430, 424],
      [342, 353],
      [353, 276],
      [276, 342],
      [273, 335],
      [335, 424],
      [424, 273],
      [292, 325],
      [325, 307],
      [307, 292],
      [366, 447],
      [447, 345],
      [345, 366],
      [271, 303],
      [303, 302],
      [302, 271],
      [423, 266],
      [266, 371],
      [371, 423],
      [294, 455],
      [455, 460],
      [460, 294],
      [279, 278],
      [278, 294],
      [294, 279],
      [271, 272],
      [272, 304],
      [304, 271],
      [432, 434],
      [434, 427],
      [427, 432],
      [272, 407],
      [407, 408],
      [408, 272],
      [394, 430],
      [430, 431],
      [431, 394],
      [395, 369],
      [369, 400],
      [400, 395],
      [334, 333],
      [333, 299],
      [299, 334],
      [351, 417],
      [417, 168],
      [168, 351],
      [352, 280],
      [280, 411],
      [411, 352],
      [325, 319],
      [319, 320],
      [320, 325],
      [295, 296],
      [296, 336],
      [336, 295],
      [319, 403],
      [403, 404],
      [404, 319],
      [330, 348],
      [348, 349],
      [349, 330],
      [293, 298],
      [298, 333],
      [333, 293],
      [323, 454],
      [454, 447],
      [447, 323],
      [15, 16],
      [16, 315],
      [315, 15],
      [358, 429],
      [429, 279],
      [279, 358],
      [14, 15],
      [15, 316],
      [316, 14],
      [285, 336],
      [336, 9],
      [9, 285],
      [329, 349],
      [349, 350],
      [350, 329],
      [374, 380],
      [380, 252],
      [252, 374],
      [318, 402],
      [402, 403],
      [403, 318],
      [6, 197],
      [
        197,
        419
      ],
      [419, 6],
      [318, 319],
      [319, 325],
      [325, 318],
      [367, 364],
      [364, 365],
      [365, 367],
      [435, 367],
      [367, 397],
      [397, 435],
      [344, 438],
      [438, 439],
      [439, 344],
      [272, 271],
      [271, 311],
      [311, 272],
      [195, 5],
      [5, 281],
      [281, 195],
      [273, 287],
      [287, 291],
      [291, 273],
      [396, 428],
      [428, 199],
      [199, 396],
      [311, 271],
      [271, 268],
      [268, 311],
      [283, 444],
      [444, 445],
      [445, 283],
      [373, 254],
      [254, 339],
      [339, 373],
      [282, 334],
      [334, 296],
      [296, 282],
      [449, 347],
      [347, 346],
      [346, 449],
      [264, 447],
      [447, 454],
      [454, 264],
      [336, 296],
      [296, 299],
      [299, 336],
      [338, 10],
      [10, 151],
      [151, 338],
      [278, 439],
      [
        439,
        455
      ],
      [455, 278],
      [292, 407],
      [407, 415],
      [415, 292],
      [358, 371],
      [371, 355],
      [355, 358],
      [340, 345],
      [345, 372],
      [372, 340],
      [346, 347],
      [347, 280],
      [280, 346],
      [442, 443],
      [443, 282],
      [282, 442],
      [19, 94],
      [94, 370],
      [370, 19],
      [441, 442],
      [442, 295],
      [295, 441],
      [248, 419],
      [419, 197],
      [197, 248],
      [263, 255],
      [255, 359],
      [359, 263],
      [440, 275],
      [275, 274],
      [274, 440],
      [300, 383],
      [383, 368],
      [368, 300],
      [351, 412],
      [412, 465],
      [465, 351],
      [263, 467],
      [467, 466],
      [466, 263],
      [301, 368],
      [368, 389],
      [389, 301],
      [395, 378],
      [378, 379],
      [379, 395],
      [412, 351],
      [351, 419],
      [419, 412],
      [436, 426],
      [426, 322],
      [322, 436],
      [2, 164],
      [164, 393],
      [393, 2],
      [370, 462],
      [462, 461],
      [461, 370],
      [164, 0],
      [0, 267],
      [267, 164],
      [302, 11],
      [11, 12],
      [12, 302],
      [268, 12],
      [12, 13],
      [13, 268],
      [293, 300],
      [300, 301],
      [301, 293],
      [446, 261],
      [261, 340],
      [340, 446],
      [330, 266],
      [266, 425],
      [425, 330],
      [426, 423],
      [423, 391],
      [391, 426],
      [429, 355],
      [355, 437],
      [437, 429],
      [391, 327],
      [327, 326],
      [326, 391],
      [440, 457],
      [457, 438],
      [438, 440],
      [341, 382],
      [382, 362],
      [362, 341],
      [459, 457],
      [457, 461],
      [461, 459],
      [434, 430],
      [430, 394],
      [394, 434],
      [414, 463],
      [463, 362],
      [362, 414],
      [396, 369],
      [369, 262],
      [262, 396],
      [354, 461],
      [461, 457],
      [457, 354],
      [316, 403],
      [403, 402],
      [402, 316],
      [315, 404],
      [404, 403],
      [403, 315],
      [314, 405],
      [405, 404],
      [404, 314],
      [313, 406],
      [406, 405],
      [405, 313],
      [421, 418],
      [418, 406],
      [406, 421],
      [366, 401],
      [401, 361],
      [361, 366],
      [306, 408],
      [408, 407],
      [407, 306],
      [291, 409],
      [409, 408],
      [408, 291],
      [287, 410],
      [410, 409],
      [409, 287],
      [432, 436],
      [436, 410],
      [410, 432],
      [434, 416],
      [416, 411],
      [411, 434],
      [264, 368],
      [368, 383],
      [383, 264],
      [309, 438],
      [438, 457],
      [457, 309],
      [352, 376],
      [376, 401],
      [401, 352],
      [274, 275],
      [275, 4],
      [4, 274],
      [421, 428],
      [
        428,
        262
      ],
      [262, 421],
      [294, 327],
      [327, 358],
      [358, 294],
      [433, 416],
      [416, 367],
      [367, 433],
      [289, 455],
      [455, 439],
      [439, 289],
      [462, 370],
      [370, 326],
      [326, 462],
      [2, 326],
      [326, 370],
      [370, 2],
      [305, 460],
      [460, 455],
      [455, 305],
      [254, 449],
      [449, 448],
      [448, 254],
      [255, 261],
      [261, 446],
      [446, 255],
      [253, 450],
      [450, 449],
      [449, 253],
      [252, 451],
      [451, 450],
      [450, 252],
      [256, 452],
      [452, 451],
      [451, 256],
      [341, 453],
      [453, 452],
      [452, 341],
      [413, 464],
      [464, 463],
      [463, 413],
      [441, 413],
      [413, 414],
      [414, 441],
      [258, 442],
      [442, 441],
      [441, 258],
      [257, 443],
      [443, 442],
      [442, 257],
      [259, 444],
      [444, 443],
      [443, 259],
      [260, 445],
      [445, 444],
      [444, 260],
      [467, 342],
      [342, 445],
      [445, 467],
      [459, 458],
      [458, 250],
      [250, 459],
      [289, 392],
      [392, 290],
      [290, 289],
      [290, 328],
      [328, 460],
      [460, 290],
      [376, 433],
      [433, 435],
      [435, 376],
      [250, 290],
      [290, 392],
      [392, 250],
      [411, 416],
      [416, 433],
      [433, 411],
      [341, 463],
      [463, 464],
      [464, 341],
      [453, 464],
      [464, 465],
      [465, 453],
      [357, 465],
      [465, 412],
      [412, 357],
      [343, 412],
      [412, 399],
      [399, 343],
      [360, 363],
      [363, 440],
      [440, 360],
      [437, 399],
      [399, 456],
      [456, 437],
      [420, 456],
      [456, 363],
      [363, 420],
      [401, 435],
      [435, 288],
      [288, 401],
      [
        372,
        383
      ],
      [383, 353],
      [353, 372],
      [339, 255],
      [255, 249],
      [249, 339],
      [448, 261],
      [261, 255],
      [255, 448],
      [133, 243],
      [243, 190],
      [190, 133],
      [133, 155],
      [155, 112],
      [112, 133],
      [33, 246],
      [246, 247],
      [247, 33],
      [33, 130],
      [130, 25],
      [25, 33],
      [398, 384],
      [384, 286],
      [286, 398],
      [362, 398],
      [398, 414],
      [414, 362],
      [362, 463],
      [463, 341],
      [341, 362],
      [263, 359],
      [359, 467],
      [467, 263],
      [263, 249],
      [249, 255],
      [255, 263],
      [466, 467],
      [467, 260],
      [260, 466],
      [75, 60],
      [60, 166],
      [166, 75],
      [238, 239],
      [239, 79],
      [79, 238],
      [162, 127],
      [127, 139],
      [139, 162],
      [72, 11],
      [11, 37],
      [37, 72],
      [121, 232],
      [
        232,
        120
      ],
      [120, 121],
      [73, 72],
      [72, 39],
      [39, 73],
      [114, 128],
      [128, 47],
      [47, 114],
      [233, 232],
      [232, 128],
      [128, 233],
      [103, 104],
      [104, 67],
      [67, 103],
      [152, 175],
      [175, 148],
      [148, 152],
      [119, 118],
      [118, 101],
      [101, 119],
      [74, 73],
      [73, 40],
      [40, 74],
      [107, 9],
      [9, 108],
      [108, 107],
      [49, 48],
      [48, 131],
      [131, 49],
      [32, 194],
      [194, 211],
      [211, 32],
      [184, 74],
      [74, 185],
      [185, 184],
      [191, 80],
      [80, 183],
      [183, 191],
      [185, 40],
      [40, 186],
      [186, 185],
      [119, 230],
      [230, 118],
      [118, 119],
      [210, 202],
      [202, 214],
      [214, 210],
      [84, 83],
      [83, 17],
      [17, 84],
      [77, 76],
      [76, 146],
      [146, 77],
      [161, 160],
      [160, 30],
      [30, 161],
      [190, 56],
      [56, 173],
      [173, 190],
      [182, 106],
      [106, 194],
      [194, 182],
      [138, 135],
      [135, 192],
      [192, 138],
      [129, 203],
      [203, 98],
      [98, 129],
      [54, 21],
      [21, 68],
      [68, 54],
      [5, 51],
      [51, 4],
      [4, 5],
      [145, 144],
      [144, 23],
      [23, 145],
      [90, 77],
      [77, 91],
      [91, 90],
      [207, 205],
      [205, 187],
      [187, 207],
      [83, 201],
      [201, 18],
      [18, 83],
      [181, 91],
      [91, 182],
      [182, 181],
      [180, 90],
      [90, 181],
      [181, 180],
      [16, 85],
      [85, 17],
      [17, 16],
      [205, 206],
      [206, 36],
      [36, 205],
      [176, 148],
      [148, 140],
      [140, 176],
      [165, 92],
      [92, 39],
      [39, 165],
      [245, 193],
      [193, 244],
      [244, 245],
      [27, 159],
      [159, 28],
      [28, 27],
      [
        30,
        247
      ],
      [247, 161],
      [161, 30],
      [174, 236],
      [236, 196],
      [196, 174],
      [103, 54],
      [54, 104],
      [104, 103],
      [55, 193],
      [193, 8],
      [8, 55],
      [111, 117],
      [117, 31],
      [31, 111],
      [221, 189],
      [189, 55],
      [55, 221],
      [240, 98],
      [98, 99],
      [99, 240],
      [142, 126],
      [126, 100],
      [100, 142],
      [219, 166],
      [166, 218],
      [218, 219],
      [112, 155],
      [155, 26],
      [26, 112],
      [198, 209],
      [209, 131],
      [131, 198],
      [169, 135],
      [135, 150],
      [150, 169],
      [114, 47],
      [47, 217],
      [217, 114],
      [224, 223],
      [223, 53],
      [53, 224],
      [220, 45],
      [45, 134],
      [134, 220],
      [32, 211],
      [211, 140],
      [140, 32],
      [109, 67],
      [67, 108],
      [108, 109],
      [146, 43],
      [43, 91],
      [91, 146],
      [231, 230],
      [230, 120],
      [120, 231],
      [113, 226],
      [226, 247],
      [247, 113],
      [105, 63],
      [63, 52],
      [52, 105],
      [241, 238],
      [238, 242],
      [242, 241],
      [124, 46],
      [46, 156],
      [156, 124],
      [95, 78],
      [78, 96],
      [96, 95],
      [70, 46],
      [46, 63],
      [63, 70],
      [116, 143],
      [143, 227],
      [227, 116],
      [116, 123],
      [123, 111],
      [111, 116],
      [1, 44],
      [44, 19],
      [19, 1],
      [3, 236],
      [236, 51],
      [51, 3],
      [207, 216],
      [216, 205],
      [205, 207],
      [26, 154],
      [154, 22],
      [22, 26],
      [165, 39],
      [39, 167],
      [167, 165],
      [199, 200],
      [200, 208],
      [208, 199],
      [101, 36],
      [36, 100],
      [100, 101],
      [43, 57],
      [57, 202],
      [202, 43],
      [242, 20],
      [20, 99],
      [99, 242],
      [56, 28],
      [
        28,
        157
      ],
      [157, 56],
      [124, 35],
      [35, 113],
      [113, 124],
      [29, 160],
      [160, 27],
      [27, 29],
      [211, 204],
      [204, 210],
      [210, 211],
      [124, 113],
      [113, 46],
      [46, 124],
      [106, 43],
      [43, 204],
      [204, 106],
      [96, 62],
      [62, 77],
      [77, 96],
      [227, 137],
      [137, 116],
      [116, 227],
      [73, 41],
      [41, 72],
      [72, 73],
      [36, 203],
      [203, 142],
      [142, 36],
      [235, 64],
      [64, 240],
      [240, 235],
      [48, 49],
      [49, 64],
      [64, 48],
      [42, 41],
      [41, 74],
      [74, 42],
      [214, 212],
      [212, 207],
      [207, 214],
      [183, 42],
      [42, 184],
      [184, 183],
      [210, 169],
      [169, 211],
      [211, 210],
      [140, 170],
      [170, 176],
      [176, 140],
      [104, 105],
      [105, 69],
      [69, 104],
      [193, 122],
      [122, 168],
      [168, 193],
      [50, 123],
      [123, 187],
      [187, 50],
      [89, 96],
      [96, 90],
      [90, 89],
      [66, 65],
      [65, 107],
      [107, 66],
      [179, 89],
      [89, 180],
      [180, 179],
      [119, 101],
      [101, 120],
      [120, 119],
      [68, 63],
      [63, 104],
      [104, 68],
      [234, 93],
      [93, 227],
      [227, 234],
      [16, 15],
      [15, 85],
      [85, 16],
      [209, 129],
      [129, 49],
      [49, 209],
      [15, 14],
      [14, 86],
      [86, 15],
      [107, 55],
      [55, 9],
      [9, 107],
      [120, 100],
      [100, 121],
      [121, 120],
      [153, 145],
      [145, 22],
      [22, 153],
      [178, 88],
      [88, 179],
      [179, 178],
      [197, 6],
      [6, 196],
      [196, 197],
      [89, 88],
      [88, 96],
      [96, 89],
      [135, 138],
      [138, 136],
      [136, 135],
      [138, 215],
      [215, 172],
      [172, 138],
      [
        218,
        115
      ],
      [115, 219],
      [219, 218],
      [41, 42],
      [42, 81],
      [81, 41],
      [5, 195],
      [195, 51],
      [51, 5],
      [57, 43],
      [43, 61],
      [61, 57],
      [208, 171],
      [171, 199],
      [199, 208],
      [41, 81],
      [81, 38],
      [38, 41],
      [224, 53],
      [53, 225],
      [225, 224],
      [24, 144],
      [144, 110],
      [110, 24],
      [105, 52],
      [52, 66],
      [66, 105],
      [118, 229],
      [229, 117],
      [117, 118],
      [227, 34],
      [34, 234],
      [234, 227],
      [66, 107],
      [107, 69],
      [69, 66],
      [10, 109],
      [109, 151],
      [151, 10],
      [219, 48],
      [48, 235],
      [235, 219],
      [183, 62],
      [62, 191],
      [191, 183],
      [142, 129],
      [129, 126],
      [126, 142],
      [116, 111],
      [111, 143],
      [143, 116],
      [118, 117],
      [117, 50],
      [50, 118],
      [223, 222],
      [
        222,
        52
      ],
      [52, 223],
      [94, 19],
      [19, 141],
      [141, 94],
      [222, 221],
      [221, 65],
      [65, 222],
      [196, 3],
      [3, 197],
      [197, 196],
      [45, 220],
      [220, 44],
      [44, 45],
      [156, 70],
      [70, 139],
      [139, 156],
      [188, 122],
      [122, 245],
      [245, 188],
      [139, 71],
      [71, 162],
      [162, 139],
      [149, 170],
      [170, 150],
      [150, 149],
      [122, 188],
      [188, 196],
      [196, 122],
      [206, 216],
      [216, 92],
      [92, 206],
      [164, 2],
      [2, 167],
      [167, 164],
      [242, 141],
      [141, 241],
      [241, 242],
      [0, 164],
      [164, 37],
      [37, 0],
      [11, 72],
      [72, 12],
      [12, 11],
      [12, 38],
      [38, 13],
      [13, 12],
      [70, 63],
      [63, 71],
      [71, 70],
      [31, 226],
      [226, 111],
      [111, 31],
      [36, 101],
      [101, 205],
      [205, 36],
      [203, 206],
      [206, 165],
      [165, 203],
      [126, 209],
      [209, 217],
      [217, 126],
      [98, 165],
      [165, 97],
      [97, 98],
      [237, 220],
      [220, 218],
      [218, 237],
      [237, 239],
      [239, 241],
      [241, 237],
      [210, 214],
      [214, 169],
      [169, 210],
      [140, 171],
      [171, 32],
      [32, 140],
      [241, 125],
      [125, 237],
      [237, 241],
      [179, 86],
      [86, 178],
      [178, 179],
      [180, 85],
      [85, 179],
      [179, 180],
      [181, 84],
      [84, 180],
      [180, 181],
      [182, 83],
      [83, 181],
      [181, 182],
      [194, 201],
      [201, 182],
      [182, 194],
      [177, 137],
      [137, 132],
      [132, 177],
      [184, 76],
      [76, 183],
      [183, 184],
      [185, 61],
      [61, 184],
      [184, 185],
      [186, 57],
      [57, 185],
      [185, 186],
      [216, 212],
      [
        212,
        186
      ],
      [186, 216],
      [192, 214],
      [214, 187],
      [187, 192],
      [139, 34],
      [34, 156],
      [156, 139],
      [218, 79],
      [79, 237],
      [237, 218],
      [147, 123],
      [123, 177],
      [177, 147],
      [45, 44],
      [44, 4],
      [4, 45],
      [208, 201],
      [201, 32],
      [32, 208],
      [98, 64],
      [64, 129],
      [129, 98],
      [192, 213],
      [213, 138],
      [138, 192],
      [235, 59],
      [59, 219],
      [219, 235],
      [141, 242],
      [242, 97],
      [97, 141],
      [97, 2],
      [2, 141],
      [141, 97],
      [240, 75],
      [75, 235],
      [235, 240],
      [229, 24],
      [24, 228],
      [228, 229],
      [31, 25],
      [25, 226],
      [226, 31],
      [230, 23],
      [23, 229],
      [229, 230],
      [231, 22],
      [22, 230],
      [230, 231],
      [232, 26],
      [26, 231],
      [231, 232],
      [233, 112],
      [112, 232],
      [232, 233],
      [244, 189],
      [189, 243],
      [243, 244],
      [189, 221],
      [221, 190],
      [190, 189],
      [222, 28],
      [28, 221],
      [221, 222],
      [223, 27],
      [27, 222],
      [222, 223],
      [224, 29],
      [29, 223],
      [223, 224],
      [225, 30],
      [30, 224],
      [224, 225],
      [113, 247],
      [247, 225],
      [225, 113],
      [99, 60],
      [60, 240],
      [240, 99],
      [213, 147],
      [147, 215],
      [215, 213],
      [60, 20],
      [20, 166],
      [166, 60],
      [192, 187],
      [187, 213],
      [213, 192],
      [243, 112],
      [112, 244],
      [244, 243],
      [244, 233],
      [233, 245],
      [245, 244],
      [245, 128],
      [128, 188],
      [188, 245],
      [188, 114],
      [114, 174],
      [174, 188],
      [134, 131],
      [131, 220],
      [220, 134],
      [174, 217],
      [217, 236],
      [236, 174],
      [236, 198],
      [198, 134],
      [134, 236],
      [215, 177],
      [177, 58],
      [58, 215],
      [156, 143],
      [143, 124],
      [124, 156],
      [25, 110],
      [110, 7],
      [7, 25],
      [31, 228],
      [228, 25],
      [25, 31],
      [264, 356],
      [356, 368],
      [368, 264],
      [0, 11],
      [11, 267],
      [267, 0],
      [451, 452],
      [452, 349],
      [349, 451],
      [267, 302],
      [302, 269],
      [269, 267],
      [350, 357],
      [357, 277],
      [277, 350],
      [350, 452],
      [452, 357],
      [357, 350],
      [299, 333],
      [333, 297],
      [297, 299],
      [396, 175],
      [175, 377],
      [377, 396],
      [280, 347],
      [347, 330],
      [330, 280],
      [269, 303],
      [303, 270],
      [270, 269],
      [151, 9],
      [9, 337],
      [337, 151],
      [344, 278],
      [278, 360],
      [360, 344],
      [424, 418],
      [
        418,
        431
      ],
      [431, 424],
      [270, 304],
      [304, 409],
      [409, 270],
      [272, 310],
      [310, 407],
      [407, 272],
      [322, 270],
      [270, 410],
      [410, 322],
      [449, 450],
      [450, 347],
      [347, 449],
      [432, 422],
      [422, 434],
      [434, 432],
      [18, 313],
      [313, 17],
      [17, 18],
      [291, 306],
      [306, 375],
      [375, 291],
      [259, 387],
      [387, 260],
      [260, 259],
      [424, 335],
      [335, 418],
      [418, 424],
      [434, 364],
      [364, 416],
      [416, 434],
      [391, 423],
      [423, 327],
      [327, 391],
      [301, 251],
      [251, 298],
      [298, 301],
      [275, 281],
      [281, 4],
      [4, 275],
      [254, 373],
      [373, 253],
      [253, 254],
      [375, 307],
      [307, 321],
      [321, 375],
      [280, 425],
      [425, 411],
      [411, 280],
      [200, 421],
      [
        421,
        18
      ],
      [18, 200],
      [335, 321],
      [321, 406],
      [406, 335],
      [321, 320],
      [320, 405],
      [405, 321],
      [314, 315],
      [315, 17],
      [17, 314],
      [423, 426],
      [426, 266],
      [266, 423],
      [396, 377],
      [377, 369],
      [369, 396],
      [270, 322],
      [322, 269],
      [269, 270],
      [413, 417],
      [417, 464],
      [464, 413],
      [385, 386],
      [386, 258],
      [258, 385],
      [248, 456],
      [456, 419],
      [419, 248],
      [298, 284],
      [284, 333],
      [333, 298],
      [168, 417],
      [417, 8],
      [8, 168],
      [448, 346],
      [346, 261],
      [261, 448],
      [417, 413],
      [413, 285],
      [285, 417],
      [326, 327],
      [327, 328],
      [328, 326],
      [277, 355],
      [355, 329],
      [329, 277],
      [309, 392],
      [392, 438],
      [438, 309],
      [381, 382],
      [
        382,
        256
      ],
      [256, 381],
      [279, 429],
      [429, 360],
      [360, 279],
      [365, 364],
      [364, 379],
      [379, 365],
      [355, 277],
      [277, 437],
      [437, 355],
      [282, 443],
      [443, 283],
      [283, 282],
      [281, 275],
      [275, 363],
      [363, 281],
      [395, 431],
      [431, 369],
      [369, 395],
      [299, 297],
      [297, 337],
      [337, 299],
      [335, 273],
      [273, 321],
      [321, 335],
      [348, 450],
      [450, 349],
      [349, 348],
      [359, 446],
      [446, 467],
      [467, 359],
      [283, 293],
      [293, 282],
      [282, 283],
      [250, 458],
      [458, 462],
      [462, 250],
      [300, 276],
      [276, 383],
      [383, 300],
      [292, 308],
      [308, 325],
      [325, 292],
      [283, 276],
      [276, 293],
      [293, 283],
      [264, 372],
      [372, 447],
      [447, 264],
      [346, 352],
      [352, 340],
      [340, 346],
      [354, 274],
      [274, 19],
      [19, 354],
      [363, 456],
      [456, 281],
      [281, 363],
      [426, 436],
      [436, 425],
      [425, 426],
      [380, 381],
      [381, 252],
      [252, 380],
      [267, 269],
      [269, 393],
      [393, 267],
      [421, 200],
      [200, 428],
      [428, 421],
      [371, 266],
      [266, 329],
      [329, 371],
      [432, 287],
      [287, 422],
      [422, 432],
      [290, 250],
      [250, 328],
      [328, 290],
      [385, 258],
      [258, 384],
      [384, 385],
      [446, 265],
      [265, 342],
      [342, 446],
      [386, 387],
      [387, 257],
      [257, 386],
      [422, 424],
      [424, 430],
      [430, 422],
      [445, 342],
      [342, 276],
      [276, 445],
      [422, 273],
      [273, 424],
      [424, 422],
      [306, 292],
      [292, 307],
      [307, 306],
      [
        352,
        366
      ],
      [366, 345],
      [345, 352],
      [268, 271],
      [271, 302],
      [302, 268],
      [358, 423],
      [423, 371],
      [371, 358],
      [327, 294],
      [294, 460],
      [460, 327],
      [331, 279],
      [279, 294],
      [294, 331],
      [303, 271],
      [271, 304],
      [304, 303],
      [436, 432],
      [432, 427],
      [427, 436],
      [304, 272],
      [272, 408],
      [408, 304],
      [395, 394],
      [394, 431],
      [431, 395],
      [378, 395],
      [395, 400],
      [400, 378],
      [296, 334],
      [334, 299],
      [299, 296],
      [6, 351],
      [351, 168],
      [168, 6],
      [376, 352],
      [352, 411],
      [411, 376],
      [307, 325],
      [325, 320],
      [320, 307],
      [285, 295],
      [295, 336],
      [336, 285],
      [320, 319],
      [319, 404],
      [404, 320],
      [329, 330],
      [330, 349],
      [349, 329],
      [334, 293],
      [293, 333],
      [333, 334],
      [366, 323],
      [323, 447],
      [447, 366],
      [316, 15],
      [15, 315],
      [315, 316],
      [331, 358],
      [358, 279],
      [279, 331],
      [317, 14],
      [14, 316],
      [316, 317],
      [8, 285],
      [285, 9],
      [9, 8],
      [277, 329],
      [329, 350],
      [350, 277],
      [253, 374],
      [374, 252],
      [252, 253],
      [319, 318],
      [318, 403],
      [403, 319],
      [351, 6],
      [6, 419],
      [419, 351],
      [324, 318],
      [318, 325],
      [325, 324],
      [397, 367],
      [367, 365],
      [365, 397],
      [288, 435],
      [435, 397],
      [397, 288],
      [278, 344],
      [344, 439],
      [439, 278],
      [310, 272],
      [272, 311],
      [311, 310],
      [248, 195],
      [195, 281],
      [281, 248],
      [375, 273],
      [273, 291],
      [291, 375],
      [175, 396],
      [396, 199],
      [199, 175],
      [312, 311],
      [311, 268],
      [268, 312],
      [276, 283],
      [283, 445],
      [445, 276],
      [390, 373],
      [373, 339],
      [339, 390],
      [295, 282],
      [282, 296],
      [296, 295],
      [448, 449],
      [449, 346],
      [346, 448],
      [356, 264],
      [264, 454],
      [454, 356],
      [337, 336],
      [336, 299],
      [299, 337],
      [337, 338],
      [338, 151],
      [151, 337],
      [294, 278],
      [278, 455],
      [455, 294],
      [308, 292],
      [292, 415],
      [415, 308],
      [429, 358],
      [358, 355],
      [355, 429],
      [265, 340],
      [340, 372],
      [372, 265],
      [352, 346],
      [346, 280],
      [280, 352],
      [295, 442],
      [442, 282],
      [282, 295],
      [354, 19],
      [19, 370],
      [370, 354],
      [285, 441],
      [441, 295],
      [295, 285],
      [
        195,
        248
      ],
      [248, 197],
      [197, 195],
      [457, 440],
      [440, 274],
      [274, 457],
      [301, 300],
      [300, 368],
      [368, 301],
      [417, 351],
      [351, 465],
      [465, 417],
      [251, 301],
      [301, 389],
      [389, 251],
      [394, 395],
      [395, 379],
      [379, 394],
      [399, 412],
      [412, 419],
      [419, 399],
      [410, 436],
      [436, 322],
      [322, 410],
      [326, 2],
      [2, 393],
      [393, 326],
      [354, 370],
      [370, 461],
      [461, 354],
      [393, 164],
      [164, 267],
      [267, 393],
      [268, 302],
      [302, 12],
      [12, 268],
      [312, 268],
      [268, 13],
      [13, 312],
      [298, 293],
      [293, 301],
      [301, 298],
      [265, 446],
      [446, 340],
      [340, 265],
      [280, 330],
      [330, 425],
      [425, 280],
      [322, 426],
      [426, 391],
      [391, 322],
      [
        420,
        429
      ],
      [429, 437],
      [437, 420],
      [393, 391],
      [391, 326],
      [326, 393],
      [344, 440],
      [440, 438],
      [438, 344],
      [458, 459],
      [459, 461],
      [461, 458],
      [364, 434],
      [434, 394],
      [394, 364],
      [428, 396],
      [396, 262],
      [262, 428],
      [274, 354],
      [354, 457],
      [457, 274],
      [317, 316],
      [316, 402],
      [402, 317],
      [316, 315],
      [315, 403],
      [403, 316],
      [315, 314],
      [314, 404],
      [404, 315],
      [314, 313],
      [313, 405],
      [405, 314],
      [313, 421],
      [421, 406],
      [406, 313],
      [323, 366],
      [366, 361],
      [361, 323],
      [292, 306],
      [306, 407],
      [407, 292],
      [306, 291],
      [291, 408],
      [408, 306],
      [291, 287],
      [287, 409],
      [409, 291],
      [287, 432],
      [432, 410],
      [410, 287],
      [427, 434],
      [434, 411],
      [411, 427],
      [372, 264],
      [264, 383],
      [383, 372],
      [459, 309],
      [309, 457],
      [457, 459],
      [366, 352],
      [352, 401],
      [401, 366],
      [1, 274],
      [274, 4],
      [4, 1],
      [418, 421],
      [421, 262],
      [262, 418],
      [331, 294],
      [294, 358],
      [358, 331],
      [435, 433],
      [433, 367],
      [367, 435],
      [392, 289],
      [289, 439],
      [439, 392],
      [328, 462],
      [462, 326],
      [326, 328],
      [94, 2],
      [2, 370],
      [370, 94],
      [289, 305],
      [305, 455],
      [455, 289],
      [339, 254],
      [254, 448],
      [448, 339],
      [359, 255],
      [255, 446],
      [446, 359],
      [254, 253],
      [253, 449],
      [449, 254],
      [253, 252],
      [252, 450],
      [450, 253],
      [252, 256],
      [256, 451],
      [451, 252],
      [
        256,
        341
      ],
      [341, 452],
      [452, 256],
      [414, 413],
      [413, 463],
      [463, 414],
      [286, 441],
      [441, 414],
      [414, 286],
      [286, 258],
      [258, 441],
      [441, 286],
      [258, 257],
      [257, 442],
      [442, 258],
      [257, 259],
      [259, 443],
      [443, 257],
      [259, 260],
      [260, 444],
      [444, 259],
      [260, 467],
      [467, 445],
      [445, 260],
      [309, 459],
      [459, 250],
      [250, 309],
      [305, 289],
      [289, 290],
      [290, 305],
      [305, 290],
      [290, 460],
      [460, 305],
      [401, 376],
      [376, 435],
      [435, 401],
      [309, 250],
      [250, 392],
      [392, 309],
      [376, 411],
      [411, 433],
      [433, 376],
      [453, 341],
      [341, 464],
      [464, 453],
      [357, 453],
      [453, 465],
      [465, 357],
      [343, 357],
      [357, 412],
      [412, 343],
      [437, 343],
      [343, 399],
      [399, 437],
      [344, 360],
      [360, 440],
      [440, 344],
      [420, 437],
      [437, 456],
      [456, 420],
      [360, 420],
      [420, 363],
      [363, 360],
      [361, 401],
      [401, 288],
      [288, 361],
      [265, 372],
      [372, 353],
      [353, 265],
      [390, 339],
      [339, 249],
      [249, 390],
      [339, 448],
      [448, 255],
      [255, 339]
    ]);
    P2("matrixDataToMatrix", function(a) {
      for (var b = a.getCols(), c = a.getRows(), d = a.getPackedDataList(), e = [], g = 0; g < c; g++)
        e.push(Array(b));
      for (g = 0; g < c; g++)
        for (var f = 0; f < b; f++) {
          var h = 1 === a.getLayout() ? g * b + f : f * c + g;
          e[g][f] = d[h];
        }
      return e;
    });
    P2("VERSION", "0.4.1633559619");
  }).call(commonjsGlobal);
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const ENV = env();
  ENV.registerFlag("KEEP_INTERMEDIATE_TENSORS", () => false, (debugValue) => {
    if (debugValue) {
      console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
    }
  });
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   */
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["DT_INVALID"] = 0] = "DT_INVALID";
    DataType2[DataType2["DT_FLOAT"] = 1] = "DT_FLOAT";
    DataType2[DataType2["DT_DOUBLE"] = 2] = "DT_DOUBLE";
    DataType2[DataType2["DT_INT32"] = 3] = "DT_INT32";
    DataType2[DataType2["DT_UINT8"] = 4] = "DT_UINT8";
    DataType2[DataType2["DT_INT16"] = 5] = "DT_INT16";
    DataType2[DataType2["DT_INT8"] = 6] = "DT_INT8";
    DataType2[DataType2["DT_STRING"] = 7] = "DT_STRING";
    DataType2[DataType2["DT_COMPLEX64"] = 8] = "DT_COMPLEX64";
    DataType2[DataType2["DT_INT64"] = 9] = "DT_INT64";
    DataType2[DataType2["DT_BOOL"] = 10] = "DT_BOOL";
    DataType2[DataType2["DT_QINT8"] = 11] = "DT_QINT8";
    DataType2[DataType2["DT_QUINT8"] = 12] = "DT_QUINT8";
    DataType2[DataType2["DT_QINT32"] = 13] = "DT_QINT32";
    DataType2[DataType2["DT_BFLOAT16"] = 14] = "DT_BFLOAT16";
    DataType2[DataType2["DT_QINT16"] = 15] = "DT_QINT16";
    DataType2[DataType2["DT_QUINT16"] = 16] = "DT_QUINT16";
    DataType2[DataType2["DT_UINT16"] = 17] = "DT_UINT16";
    DataType2[DataType2["DT_COMPLEX128"] = 18] = "DT_COMPLEX128";
    DataType2[DataType2["DT_HALF"] = 19] = "DT_HALF";
    DataType2[DataType2["DT_RESOURCE"] = 20] = "DT_RESOURCE";
    DataType2[DataType2["DT_VARIANT"] = 21] = "DT_VARIANT";
    DataType2[DataType2["DT_UINT32"] = 22] = "DT_UINT32";
    DataType2[DataType2["DT_UINT64"] = 23] = "DT_UINT64";
    DataType2[DataType2["DT_FLOAT_REF"] = 101] = "DT_FLOAT_REF";
    DataType2[DataType2["DT_DOUBLE_REF"] = 102] = "DT_DOUBLE_REF";
    DataType2[DataType2["DT_INT32_REF"] = 103] = "DT_INT32_REF";
    DataType2[DataType2["DT_UINT8_REF"] = 104] = "DT_UINT8_REF";
    DataType2[DataType2["DT_INT16_REF"] = 105] = "DT_INT16_REF";
    DataType2[DataType2["DT_INT8_REF"] = 106] = "DT_INT8_REF";
    DataType2[DataType2["DT_STRING_REF"] = 107] = "DT_STRING_REF";
    DataType2[DataType2["DT_COMPLEX64_REF"] = 108] = "DT_COMPLEX64_REF";
    DataType2[DataType2["DT_INT64_REF"] = 109] = "DT_INT64_REF";
    DataType2[DataType2["DT_BOOL_REF"] = 110] = "DT_BOOL_REF";
    DataType2[DataType2["DT_QINT8_REF"] = 111] = "DT_QINT8_REF";
    DataType2[DataType2["DT_QUINT8_REF"] = 112] = "DT_QUINT8_REF";
    DataType2[DataType2["DT_QINT32_REF"] = 113] = "DT_QINT32_REF";
    DataType2[DataType2["DT_BFLOAT16_REF"] = 114] = "DT_BFLOAT16_REF";
    DataType2[DataType2["DT_QINT16_REF"] = 115] = "DT_QINT16_REF";
    DataType2[DataType2["DT_QUINT16_REF"] = 116] = "DT_QUINT16_REF";
    DataType2[DataType2["DT_UINT16_REF"] = 117] = "DT_UINT16_REF";
    DataType2[DataType2["DT_COMPLEX128_REF"] = 118] = "DT_COMPLEX128_REF";
    DataType2[DataType2["DT_HALF_REF"] = 119] = "DT_HALF_REF";
    DataType2[DataType2["DT_RESOURCE_REF"] = 120] = "DT_RESOURCE_REF";
    DataType2[DataType2["DT_VARIANT_REF"] = 121] = "DT_VARIANT_REF";
    DataType2[DataType2["DT_UINT32_REF"] = 122] = "DT_UINT32_REF";
    DataType2[DataType2["DT_UINT64_REF"] = 123] = "DT_UINT64_REF";
  })(DataType || (DataType = {}));
  var SaverDef;
  (function(SaverDef2) {
    (function(CheckpointFormatVersion) {
      CheckpointFormatVersion[CheckpointFormatVersion["LEGACY"] = 0] = "LEGACY";
      CheckpointFormatVersion[CheckpointFormatVersion["V1"] = 1] = "V1";
      CheckpointFormatVersion[CheckpointFormatVersion["V2"] = 2] = "V2";
    })(SaverDef2.CheckpointFormatVersion || (SaverDef2.CheckpointFormatVersion = {}));
  })(SaverDef || (SaverDef = {}));
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const CUSTOM_OPS = {};
  function getRegisteredOp(name) {
    return CUSTOM_OPS[name];
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getParamValue(paramName, node, tensorMap, context, resourceManager) {
    const inputParam = node.inputParams[paramName];
    if (inputParam && inputParam.inputIndexStart !== void 0) {
      const start = inputParam.inputIndexStart;
      const end = inputParam.inputIndexEnd === 0 ? void 0 : inputParam.inputIndexEnd === void 0 ? start + 1 : inputParam.inputIndexEnd;
      const shiftedStart = start < 0 ? node.inputNames.length + start : start;
      if (inputParam.type === "tensor") {
        return getTensor(node.inputNames[shiftedStart], tensorMap, context, resourceManager);
      }
      if (inputParam.type === "tensors") {
        const inputs = node.inputs.slice(start, end);
        const inputNames = node.inputNames.slice(start, end).filter((_name, index2) => {
          var _a;
          return ((_a = inputs[index2]) === null || _a === void 0 ? void 0 : _a.op) !== "NoOp";
        });
        return inputNames.map((name) => getTensor(name, tensorMap, context, resourceManager));
      }
      const tensor2 = getTensor(node.inputNames[shiftedStart], tensorMap, context, resourceManager);
      const data = tensor2.dataSync();
      return inputParam.type === "number" ? data[0] : toNestedArray(tensor2.shape, data);
    }
    const attrParam = node.attrParams[paramName];
    return attrParam && attrParam.value;
  }
  function getTensor(name, tensorsMap, context, resourceManager) {
    const [nodeName, index2] = parseNodeName(name, context);
    if (resourceManager != null) {
      const tensor2 = resourceManager.getHashTableHandleByName(nodeName);
      if (tensor2 != null) {
        return tensor2;
      }
    }
    const contextId = context.currentContextIds.find((contextId2) => {
      return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId2)];
    });
    return contextId !== void 0 ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index2] : void 0;
  }
  function getTensorsForCurrentContext(name, tensorsMap, context) {
    return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];
  }
  function getNodeNameAndIndex(inputName, context) {
    const [nodeName, index2, outputName] = parseNodeName(inputName, context);
    return [
      getNodeNameWithContextId(nodeName, context && context.currentContextId),
      index2,
      outputName
    ];
  }
  function getNodeNameWithContextId(name, contextId) {
    return !!contextId ? `${name}-${contextId}` : name;
  }
  function parseNodeName(name, context) {
    if (name === "") {
      return ["", 0, void 0];
    }
    const isCacheEnabled = context != null && context.parseNodeNameCache != null;
    if (isCacheEnabled) {
      const cachedResult = context.parseNodeNameCache.get(name);
      if (cachedResult != null) {
        return cachedResult;
      }
    }
    const parts = name.split(":");
    let result;
    if (parts.length === 1) {
      result = [name, 0, void 0];
    } else {
      const nodeName = parts[0];
      const outputName = parts.length === 3 ? parts[1] : void 0;
      const index2 = Number(parts[parts.length - 1]);
      result = [nodeName, index2, outputName];
    }
    if (isCacheEnabled) {
      context.parseNodeNameCache.set(name, result);
    }
    return result;
  }
  function getPadding(node, tensorMap, context) {
    let pad2 = getParamValue("pad", node, tensorMap, context);
    if (pad2 === "explicit") {
      pad2 = getParamValue("explicitPaddings", node, tensorMap, context);
      const explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];
      for (let i = 0; i < 4; i++) {
        explicitPadding[i][0] = pad2[i * 2];
        explicitPadding[i][1] = pad2[i * 2 + 1];
      }
      return explicitPadding;
    }
    return pad2;
  }
  function cloneTensor(tensor2) {
    return tensor2.kept ? tensor2 : clone(tensor2);
  }
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$i = [
    {
      "tfOpName": "Add",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "AddV2",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "AddN",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "tensors",
          "type": "tensors"
        }
      ]
    },
    {
      "tfOpName": "BiasAdd",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Sub",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "RealDiv",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Div",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "DivNoNan",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "FloorDiv",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Mul",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Maximum",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Minimum",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Pow",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "SquaredDifference",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Mod",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "FloorMod",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    }
  ];
  const arithmetic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$i
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$h = [
    {
      "tfOpName": "Abs",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Acos",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Asin",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Atan",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Atan2",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "y",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Ceil",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "ClipByValue",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "clipValueMin",
          "type": "number"
        },
        {
          "start": 2,
          "name": "clipValueMax",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Complex",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "real",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "imag",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "ComplexAbs",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Cos",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Cosh",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Elu",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Exp",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Floor",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Log",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Imag",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "Tout",
          "name": "outputType",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Neg",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Real",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "Tout",
          "name": "outputType",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Prelu",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "alpha",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Relu",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Relu6",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Selu",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Sigmoid",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Sin",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Sinh",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Sqrt",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Rsqrt",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Square",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Tan",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Tanh",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Sign",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Round",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Expm1",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Log1p",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Reciprocal",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Softplus",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Asinh",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Acosh",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Atanh",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Erf",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LeakyRelu",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "alpha",
          "name": "alpha",
          "type": "number",
          "defaultValue": 0.2
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "IsNan",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "IsFinite",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "IsInf",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    }
  ];
  const basicMath = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$h
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$g = [
    {
      "tfOpName": "EmptyTensorList",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "elementShape",
          "type": "shape"
        },
        {
          "start": 1,
          "name": "maxNumElements",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "LoopCond",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "pred",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "Switch",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "data",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "pred",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "Merge",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "tensors",
          "type": "tensors"
        }
      ]
    },
    {
      "tfOpName": "Enter",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "frame_name",
          "name": "frameName",
          "type": "string"
        },
        {
          "tfName": "is_constant",
          "name": "isConstant",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Exit",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "NextIteration",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "TensorArrayV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "size",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "element_shape",
          "name": "elementShape",
          "type": "shape"
        },
        {
          "tfName": "dynamic_size",
          "name": "dynamicSize",
          "type": "bool"
        },
        {
          "tfName": "clear_after_read",
          "name": "clearAfterRead",
          "type": "bool"
        },
        {
          "tfName": "identical_element_shapes",
          "name": "identicalElementShapes",
          "type": "bool"
        },
        {
          "tfName": "tensor_array_name",
          "name": "name",
          "type": "string"
        }
      ]
    },
    {
      "tfOpName": "TensorArrayWriteV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "index",
          "type": "number"
        },
        {
          "start": 2,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "flowIn",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "TensorArrayReadV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "index",
          "type": "number"
        },
        {
          "start": 2,
          "name": "flowIn",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "TensorArrayGatherV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "flowIn",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "element_shape",
          "name": "elementShape",
          "type": "shape"
        }
      ]
    },
    {
      "tfOpName": "TensorArrayScatterV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "flowIn",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorArrayConcatV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "flowIn",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "element_shape_except0",
          "name": "elementShapeExcept0",
          "type": "shape",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "TensorArraySplitV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "lengths",
          "type": "number[]"
        },
        {
          "start": 3,
          "name": "flowIn",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorArraySizeV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "flowIn",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "TensorArrayCloseV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "StatelessIf",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "cond",
          "type": "tensor"
        },
        {
          "start": 1,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "then_branch",
          "name": "thenBranch",
          "type": "func"
        },
        {
          "tfName": "else_branch",
          "name": "elseBranch",
          "type": "func"
        }
      ]
    },
    {
      "tfOpName": "If",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "cond",
          "type": "tensor"
        },
        {
          "start": 1,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "then_branch",
          "name": "thenBranch",
          "type": "func"
        },
        {
          "tfName": "else_branch",
          "name": "elseBranch",
          "type": "func"
        }
      ]
    },
    {
      "tfOpName": "StatelessWhile",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "cond",
          "name": "cond",
          "type": "func"
        },
        {
          "tfName": "body",
          "name": "body",
          "type": "func"
        }
      ]
    },
    {
      "tfOpName": "While",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "cond",
          "name": "cond",
          "type": "func"
        },
        {
          "tfName": "body",
          "name": "body",
          "type": "func"
        }
      ]
    },
    {
      "tfOpName": "TensorListScatter",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "elementShape",
          "type": "shape"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListScatterV2",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "elementShape",
          "type": "shape"
        },
        {
          "start": 3,
          "name": "numElements",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListGather",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "elementShape",
          "type": "shape"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListGetItem",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "index",
          "type": "number"
        },
        {
          "start": 2,
          "name": "elementShape",
          "type": "shape"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListSetItem",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "index",
          "type": "number"
        },
        {
          "start": 2,
          "name": "tensor",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListReserve",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "elementShape",
          "type": "shape"
        },
        {
          "start": 1,
          "name": "numElements",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListFromTensor",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "elementShape",
          "type": "shape"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListStack",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "elementShape",
          "type": "shape"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        },
        {
          "tfName": "num_elements",
          "name": "numElements",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListSplit",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "elementShape",
          "type": "shape"
        },
        {
          "start": 2,
          "name": "lengths",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListConcat",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "element_shape",
          "name": "elementShape",
          "type": "shape"
        },
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListConcatV2",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "element_shape",
          "name": "elementShape",
          "type": "shape"
        },
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListPopBack",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "elementShape",
          "type": "shape"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListPushBack",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "tensor",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListLength",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "TensorListResize",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "size",
          "type": "number"
        }
      ]
    }
  ];
  const control = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$g
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$f = [
    {
      "tfOpName": "AvgPool",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        },
        {
          "tfName": "ksize",
          "name": "kernelSize",
          "type": "number[]"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "MaxPool",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        },
        {
          "tfName": "ksize",
          "name": "kernelSize",
          "type": "number[]"
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": [],
          "notSupported": true
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "MaxPoolWithArgmax",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "ksize",
          "name": "kernelSize",
          "type": "number[]"
        },
        {
          "tfName": "include_batch_in_index",
          "name": "includeBatchInIndex",
          "type": "bool"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "AvgPool3D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        },
        {
          "tfName": "ksize",
          "name": "kernelSize",
          "type": "number[]"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "MaxPool3D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        },
        {
          "tfName": "ksize",
          "name": "kernelSize",
          "type": "number[]"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Conv1D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "stride",
          "name": "stride",
          "type": "number"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NWC"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "dilation",
          "name": "dilation",
          "type": "number",
          "defaultValue": 1
        }
      ]
    },
    {
      "tfOpName": "Conv2D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "useCudnnOnGpu",
          "name": "useCudnnOnGpu",
          "type": "bool"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NHWC"
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": []
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "_FusedConv2D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        },
        {
          "start": 2,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "num_args",
          "name": "numArgs",
          "type": "number"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": []
        },
        {
          "tfName": "use_cudnn_on_gpu",
          "name": "useCudnnOnGpu",
          "type": "bool",
          "defaultValue": true
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NHWC"
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]",
          "defaultValue": [
            1,
            1,
            1,
            1
          ]
        },
        {
          "tfName": "fused_ops",
          "name": "fusedOps",
          "type": "string[]",
          "defaultValue": []
        },
        {
          "tfName": "epsilon",
          "name": "epsilon",
          "type": "number",
          "defaultValue": 1e-4
        },
        {
          "tfName": "leakyrelu_alpha",
          "name": "leakyreluAlpha",
          "type": "number",
          "defaultValue": 0.2
        }
      ]
    },
    {
      "tfOpName": "Conv2DBackpropInput",
      "category": "convolution",
      "inputs": [
        {
          "start": 2,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        },
        {
          "start": 0,
          "name": "outputShape",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": []
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "DepthwiseConv2d",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "input",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NHWC"
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": []
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "DepthwiseConv2dNative",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "input",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NHWC"
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": []
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "FusedDepthwiseConv2dNative",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        },
        {
          "start": 2,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "num_args",
          "name": "numArgs",
          "type": "number"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NHWC"
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]",
          "defaultValue": [
            1,
            1,
            1,
            1
          ]
        },
        {
          "tfName": "fused_ops",
          "name": "fusedOps",
          "type": "string[]",
          "defaultValue": []
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": []
        }
      ]
    },
    {
      "tfOpName": "Conv3D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NHWC"
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "Dilation2D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "rates",
          "name": "dilations",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        }
      ]
    }
  ];
  const convolution = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$f
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$e = [
    {
      "tfOpName": "Fill",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "shape",
          "type": "number[]"
        },
        {
          "start": 1,
          "name": "value",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "LinSpace",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "start",
          "type": "number"
        },
        {
          "start": 1,
          "name": "stop",
          "type": "number"
        },
        {
          "start": 2,
          "name": "num",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "OneHot",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "indices",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "depth",
          "type": "number"
        },
        {
          "start": 2,
          "name": "onValue",
          "type": "number",
          "defaultValue": 1
        },
        {
          "start": 3,
          "name": "offValue",
          "type": "number",
          "defaultValue": 0
        }
      ],
      "attrs": [
        {
          "tfName": "axis",
          "name": "axis",
          "type": "number",
          "notSupported": true
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "Ones",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "shape",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "OnesLike",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "RandomStandardNormal",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "shape",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "seed",
          "name": "seed",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "seed2",
          "name": "seed2",
          "type": "number",
          "defaultValue": 0,
          "notSupported": true
        },
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "T",
          "name": "T",
          "type": "number",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "RandomUniform",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "shape",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "minval",
          "name": "minval",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "maxval",
          "name": "maxval",
          "type": "number",
          "defaultValue": 1
        },
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "seed",
          "name": "seed",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "seed2",
          "name": "seed2",
          "type": "number",
          "defaultValue": 0,
          "notSupported": true
        },
        {
          "tfName": "T",
          "name": "T",
          "type": "number",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "RandomUniformInt",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "shape",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "minval",
          "name": "minval",
          "type": "number"
        },
        {
          "tfName": "maxval",
          "name": "maxval",
          "type": "number"
        },
        {
          "tfName": "seed",
          "name": "seed",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "seed2",
          "name": "seed2",
          "type": "number",
          "defaultValue": 0,
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Range",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "start",
          "type": "number"
        },
        {
          "start": 1,
          "name": "stop",
          "type": "number"
        },
        {
          "start": 2,
          "name": "step",
          "type": "number",
          "defaultValue": 0
        }
      ],
      "attrs": [
        {
          "tfName": "Tidx",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TruncatedNormal",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "shape",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "means",
          "name": "mean",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "stddev",
          "name": "stdDev",
          "type": "number",
          "defaultValue": 1
        },
        {
          "tfName": "seed",
          "name": "seed",
          "type": "number"
        },
        {
          "tfName": "seed2",
          "name": "seed2",
          "type": "number",
          "defaultValue": 0,
          "notSupported": true
        },
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "T",
          "name": "T",
          "type": "number",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Zeros",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "shape",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "ZerosLike",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "Multinomial",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "logits",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "numSamples",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "seed",
          "name": "seed",
          "type": "number"
        },
        {
          "tfName": "seed2",
          "name": "seed2",
          "type": "number"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "output_dtype",
          "name": "output_dtype",
          "type": "dtype"
        }
      ]
    }
  ];
  const creation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$e
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$d = [
    {
      "tfOpName": "NonMaxSuppressionV2",
      "category": "dynamic",
      "inputs": [
        {
          "start": 0,
          "name": "boxes",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scores",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "maxOutputSize",
          "type": "number"
        },
        {
          "start": 3,
          "name": "iouThreshold",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "NonMaxSuppressionV3",
      "category": "dynamic",
      "inputs": [
        {
          "start": 0,
          "name": "boxes",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scores",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "maxOutputSize",
          "type": "number"
        },
        {
          "start": 3,
          "name": "iouThreshold",
          "type": "number"
        },
        {
          "start": 4,
          "name": "scoreThreshold",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "NonMaxSuppressionV4",
      "category": "dynamic",
      "inputs": [
        {
          "start": 0,
          "name": "boxes",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scores",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "maxOutputSize",
          "type": "number"
        },
        {
          "start": 3,
          "name": "iouThreshold",
          "type": "number"
        },
        {
          "start": 4,
          "name": "scoreThreshold",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "T_threshold",
          "name": "threshold",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "pad_to_max_output_size",
          "name": "padToMaxOutputSize",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "NonMaxSuppressionV5",
      "category": "dynamic",
      "inputs": [
        {
          "start": 0,
          "name": "boxes",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scores",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "maxOutputSize",
          "type": "number"
        },
        {
          "start": 3,
          "name": "iouThreshold",
          "type": "number"
        },
        {
          "start": 4,
          "name": "scoreThreshold",
          "type": "number"
        },
        {
          "start": 5,
          "name": "softNmsSigma",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "Where",
      "category": "dynamic",
      "inputs": [
        {
          "start": 0,
          "name": "condition",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "ListDiff",
      "category": "dynamic",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "y",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    }
  ];
  const dynamic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$d
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$c = [
    {
      "tfOpName": "LowerBound",
      "category": "evaluation",
      "inputs": [
        {
          "start": 0,
          "name": "sortedSequence",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "values",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "TopKV2",
      "category": "evaluation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "k",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "sorted",
          "name": "sorted",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "UpperBound",
      "category": "evaluation",
      "inputs": [
        {
          "start": 0,
          "name": "sortedSequence",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "values",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "Unique",
      "category": "evaluation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "UniqueV2",
      "category": "evaluation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number"
        }
      ]
    }
  ];
  const evaluation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$c
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$b = [
    {
      "tfOpName": "PlaceholderWithDefault",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "default",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "shape",
          "name": "shape",
          "type": "shape"
        },
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "Placeholder",
      "category": "graph",
      "attrs": [
        {
          "tfName": "shape",
          "name": "shape",
          "type": "shape"
        },
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "Const",
      "category": "graph"
    },
    {
      "tfOpName": "Identity",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "IdentityN",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "x",
          "type": "tensors"
        }
      ]
    },
    {
      "tfOpName": "Snapshot",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "Rank",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "Size",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "Shape",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "ShapeN",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "x",
          "type": "tensors"
        }
      ]
    },
    {
      "tfOpName": "Print",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "data",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "message",
          "name": "message",
          "type": "string"
        },
        {
          "tfName": "first_n",
          "name": "firstN",
          "type": "number",
          "notSupported": true
        },
        {
          "tfName": "summarize",
          "name": "summarize",
          "type": "number",
          "defaultValue": 3
        }
      ]
    },
    {
      "tfOpName": "NoOp",
      "category": "graph",
      "inputs": []
    },
    {
      "tfOpName": "StopGradient",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "FakeQuantWithMinMaxVars",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "min",
          "name": "min",
          "type": "number"
        },
        {
          "tfName": "max",
          "name": "max",
          "type": "number"
        }
      ]
    }
  ];
  const graph = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$b
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$a = [
    {
      "tfOpName": "HashTable",
      "category": "hash_table",
      "inputs": [],
      "attrs": [
        {
          "tfName": "shared_name",
          "name": "sharedName",
          "type": "string"
        },
        {
          "tfName": "use_node_name_sharing",
          "name": "useNodeNameSharing",
          "type": "bool"
        },
        {
          "tfName": "key_dtype",
          "name": "keyDType",
          "type": "dtype"
        },
        {
          "tfName": "value_dtype",
          "name": "valueDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "HashTableV2",
      "category": "hash_table",
      "inputs": [],
      "attrs": [
        {
          "tfName": "shared_name",
          "name": "sharedName",
          "type": "string"
        },
        {
          "tfName": "use_node_name_sharing",
          "name": "useNodeNameSharing",
          "type": "bool"
        },
        {
          "tfName": "key_dtype",
          "name": "keyDType",
          "type": "dtype"
        },
        {
          "tfName": "value_dtype",
          "name": "valueDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "LookupTableImport",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "keys",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "values",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "Tin",
          "name": "tIn",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "Tout",
          "name": "tOut",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LookupTableImportV2",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "keys",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "values",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "Tin",
          "name": "tIn",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "Tout",
          "name": "tOut",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LookupTableFind",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "keys",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "defaultValue",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "Tin",
          "name": "tIn",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "Tout",
          "name": "tOut",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LookupTableFindV2",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "keys",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "defaultValue",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "Tin",
          "name": "tIn",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "Tout",
          "name": "tOut",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LookupTableSize",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "LookupTableSizeV2",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "InitializeTable",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "keys",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "values",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "InitializeTableV2",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "keys",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "values",
          "type": "tensor"
        }
      ]
    }
  ];
  const hashTable = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$a
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$9 = [
    {
      "tfOpName": "ResizeBilinear",
      "category": "image",
      "inputs": [
        {
          "start": 0,
          "name": "images",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "size",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "align_corners",
          "name": "alignCorners",
          "type": "bool"
        },
        {
          "tfName": "half_pixel_centers",
          "name": "halfPixelCenters",
          "type": "bool"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "ResizeNearestNeighbor",
      "category": "image",
      "inputs": [
        {
          "start": 0,
          "name": "images",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "size",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "align_corners",
          "name": "alignCorners",
          "type": "bool"
        },
        {
          "tfName": "half_pixel_centers",
          "name": "halfPixelCenters",
          "type": "bool"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "CropAndResize",
      "category": "image",
      "inputs": [
        {
          "start": 0,
          "name": "image",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "boxes",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "boxInd",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "cropSize",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "method",
          "name": "method",
          "type": "string"
        },
        {
          "tfName": "extrapolation_value",
          "name": "extrapolationValue",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "ImageProjectiveTransformV3",
      "category": "image",
      "inputs": [
        {
          "start": 0,
          "name": "images",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "transforms",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "outputShape",
          "type": "number[]"
        },
        {
          "start": 3,
          "name": "fillValue",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "interpolation",
          "name": "interpolation",
          "type": "string"
        },
        {
          "tfName": "fill_mode",
          "name": "fillMode",
          "type": "string"
        }
      ]
    }
  ];
  const image = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$9
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$8 = [
    {
      "tfOpName": "Equal",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "NotEqual",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Greater",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "GreaterEqual",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Less",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LessEqual",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LogicalAnd",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LogicalNot",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LogicalOr",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Select",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "condition",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "SelectV2",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "condition",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "BitwiseAnd",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "y",
          "type": "tensor"
        }
      ]
    }
  ];
  const logical = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$8
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$7 = [
    {
      "tfOpName": "_FusedMatMul",
      "category": "matrices",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        },
        {
          "start": 2,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "num_args",
          "name": "numArgs",
          "type": "number"
        },
        {
          "tfName": "fused_ops",
          "name": "fusedOps",
          "type": "string[]",
          "defaultValue": []
        },
        {
          "tfName": "epsilon",
          "name": "epsilon",
          "type": "number",
          "defaultValue": 1e-4
        },
        {
          "tfName": "transpose_a",
          "name": "transposeA",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "transpose_b",
          "name": "transposeB",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "leakyrelu_alpha",
          "name": "leakyreluAlpha",
          "type": "number",
          "defaultValue": 0.2
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "MatMul",
      "category": "matrices",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "transpose_a",
          "name": "transposeA",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "transpose_b",
          "name": "transposeB",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "BatchMatMul",
      "category": "matrices",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "adj_x",
          "name": "transposeA",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "adj_y",
          "name": "transposeB",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "BatchMatMulV2",
      "category": "matrices",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "adj_x",
          "name": "transposeA",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "adj_y",
          "name": "transposeB",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Transpose",
      "category": "matrices",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "perm",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Einsum",
      "category": "matrices",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "tensors",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "equation",
          "name": "equation",
          "type": "string"
        },
        {
          "tfName": "N",
          "name": "n",
          "type": "number",
          "defaultValue": 2
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "MatrixBandPart",
      "category": "matrices",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "numLower",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "numUpper",
          "type": "tensor"
        }
      ]
    }
  ];
  const matrices = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$7
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$6 = [
    {
      "tfOpName": "EuclideanNorm",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool",
          "defaultValue": false
        }
      ]
    },
    {
      "tfOpName": "FusedBatchNorm",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scale",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "offset",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "mean",
          "type": "tensor"
        },
        {
          "start": 4,
          "name": "variance",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "epsilon",
          "name": "epsilon",
          "type": "number",
          "defaultValue": 1e-3
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "FusedBatchNormV2",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scale",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "offset",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "mean",
          "type": "tensor"
        },
        {
          "start": 4,
          "name": "variance",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "epsilon",
          "name": "epsilon",
          "type": "number",
          "defaultValue": 1e-3
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "FusedBatchNormV3",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scale",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "offset",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "mean",
          "type": "tensor"
        },
        {
          "start": 4,
          "name": "variance",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "epsilon",
          "name": "epsilon",
          "type": "number",
          "defaultValue": 1e-3
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LRN",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "depth_radius",
          "name": "radius",
          "type": "number",
          "defaultValue": 5
        },
        {
          "tfName": "bias",
          "name": "bias",
          "type": "number",
          "defaultValue": 1
        },
        {
          "tfName": "alpha",
          "name": "alpha",
          "type": "number",
          "defaultValue": 1
        },
        {
          "tfName": "beta",
          "name": "beta",
          "type": "number",
          "defaultValue": 0.5
        }
      ]
    },
    {
      "tfOpName": "Softmax",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "LogSoftmax",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    }
  ];
  const normalization = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$6
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$5 = [
    {
      "tfOpName": "Bincount",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "size",
          "type": "number"
        },
        {
          "start": 2,
          "name": "weights",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "DenseBincount",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "size",
          "type": "number"
        },
        {
          "start": 2,
          "name": "weights",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "binary_output",
          "name": "binaryOutput",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Max",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Mean",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Min",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Sum",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "All",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Any",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "ArgMax",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "ArgMin",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "Prod",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Cumprod",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "exclusive",
          "name": "exclusive",
          "type": "bool"
        },
        {
          "tfName": "reverse",
          "name": "reverse",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Cumsum",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "exclusive",
          "name": "exclusive",
          "type": "bool"
        },
        {
          "tfName": "reverse",
          "name": "reverse",
          "type": "bool"
        }
      ]
    }
  ];
  const reduction = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$5
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$4 = [
    {
      "tfOpName": "ConcatV2",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "end": -1,
          "name": "tensors",
          "type": "tensors"
        },
        {
          "start": -1,
          "name": "axis",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "N",
          "name": "n",
          "type": "number",
          "defaultValue": 2
        }
      ]
    },
    {
      "tfOpName": "Concat",
      "category": "slice_join",
      "inputs": [
        {
          "start": 1,
          "end": 0,
          "name": "tensors",
          "type": "tensors"
        },
        {
          "start": 0,
          "name": "axis",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "N",
          "name": "n",
          "type": "number",
          "defaultValue": 2
        }
      ]
    },
    {
      "tfOpName": "GatherV2",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "axis",
          "type": "number",
          "defaultValue": 0
        }
      ],
      "attrs": [
        {
          "tfName": "batch_dims",
          "name": "batchDims",
          "type": "number",
          "defaultValue": 0
        }
      ]
    },
    {
      "tfOpName": "Gather",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "validate_indices",
          "name": "validateIndices",
          "type": "bool",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Reverse",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "dims",
          "type": "bool[]"
        }
      ]
    },
    {
      "tfOpName": "ReverseV2",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "Slice",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "begin",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "size",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "StridedSlice",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "begin",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "end",
          "type": "number[]"
        },
        {
          "start": 3,
          "name": "strides",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "begin_mask",
          "name": "beginMask",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "end_mask",
          "name": "endMask",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "new_axis_mask",
          "name": "newAxisMask",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "ellipsis_mask",
          "name": "ellipsisMask",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "shrink_axis_mask",
          "name": "shrinkAxisMask",
          "type": "number",
          "defaultValue": 0
        }
      ]
    },
    {
      "tfOpName": "Pack",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "tensors",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "axis",
          "name": "axis",
          "type": "number",
          "defaultValue": 0
        }
      ]
    },
    {
      "tfOpName": "Unpack",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "axis",
          "name": "axis",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "num",
          "name": "num",
          "type": "number",
          "defaultValue": 0,
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Tile",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "reps",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "Split",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "axis",
          "type": "number",
          "defaultValue": 0
        },
        {
          "start": 1,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "num_split",
          "name": "numOrSizeSplits",
          "type": "number",
          "defaultValue": 1
        }
      ]
    },
    {
      "tfOpName": "SplitV",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "numOrSizeSplits",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "axis",
          "type": "number",
          "defaultValue": 0
        }
      ]
    },
    {
      "tfOpName": "ScatterNd",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "indices",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "values",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "shape",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "GatherNd",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "SparseToDense",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "sparseIndices",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "outputShape",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "sparseValues",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "defaultValue",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "validate_indices",
          "name": "validateIndices",
          "type": "bool",
          "defaultValue": false,
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "TensorScatterUpdate",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "values",
          "type": "tensor"
        }
      ]
    }
  ];
  const sliceJoin = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$4
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$3 = [
    {
      "tfOpName": "SparseFillEmptyRows",
      "category": "sparse",
      "inputs": [
        {
          "start": 0,
          "name": "indices",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "values",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "denseShape",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "defaultValue",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "SparseReshape",
      "category": "sparse",
      "inputs": [
        {
          "start": 0,
          "name": "inputIndices",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "inputShape",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "newShape",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "SparseSegmentMean",
      "category": "sparse",
      "inputs": [
        {
          "start": 0,
          "name": "data",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "segmentIds",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "SparseSegmentSum",
      "category": "sparse",
      "inputs": [
        {
          "start": 0,
          "name": "data",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "segmentIds",
          "type": "tensor"
        }
      ]
    }
  ];
  const sparse = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$3
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$2 = [
    {
      "tfOpName": "FFT",
      "category": "spectral",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "IFFT",
      "category": "spectral",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "RFFT",
      "category": "spectral",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "fft_length",
          "type": "number",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "IRFFT",
      "category": "spectral",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "fft_length",
          "type": "number",
          "notSupported": true
        }
      ]
    }
  ];
  const spectral = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$2
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json$1 = [
    {
      "tfOpName": "StaticRegexReplace",
      "category": "string",
      "inputs": [
        {
          "start": 0,
          "name": "input",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "pattern",
          "name": "pattern",
          "type": "string"
        },
        {
          "tfName": "rewrite",
          "name": "rewrite",
          "type": "string"
        },
        {
          "tfName": "replace_global",
          "name": "replaceGlobal",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "StringNGrams",
      "category": "string",
      "inputs": [
        {
          "start": 0,
          "name": "data",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "dataSplits",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "separator",
          "name": "separator",
          "type": "string"
        },
        {
          "tfName": "ngram_widths",
          "name": "nGramWidths",
          "type": "number[]"
        },
        {
          "tfName": "left_pad",
          "name": "leftPad",
          "type": "string"
        },
        {
          "tfName": "right_pad",
          "name": "rightPad",
          "type": "string"
        },
        {
          "tfName": "pad_width",
          "name": "padWidth",
          "type": "number"
        },
        {
          "tfName": "preserve_short_sequences",
          "name": "preserveShortSequences",
          "type": "bool"
        }
      ],
      "outputs": [
        "ngrams",
        "ngrams_splits"
      ]
    },
    {
      "tfOpName": "StringSplit",
      "category": "string",
      "inputs": [
        {
          "start": 0,
          "name": "input",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "delimiter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "skip_empty",
          "name": "skipEmpty",
          "type": "bool"
        }
      ],
      "outputs": [
        "indices",
        "values",
        "shape"
      ]
    },
    {
      "tfOpName": "StringToHashBucketFast",
      "category": "string",
      "inputs": [
        {
          "start": 0,
          "name": "input",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "num_buckets",
          "name": "numBuckets",
          "type": "number"
        }
      ]
    }
  ];
  const string = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json: json$1
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const json = [
    {
      "tfOpName": "Cast",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "SrcT",
          "name": "sdtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "DstT",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "ExpandDims",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "MirrorPad",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "padding",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "mode",
          "name": "mode",
          "type": "string"
        }
      ]
    },
    {
      "tfOpName": "Pad",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "padding",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "constant_value",
          "name": "constantValue",
          "type": "number",
          "defaultValue": 0
        }
      ]
    },
    {
      "tfOpName": "PadV2",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "padding",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "constantValue",
          "type": "number",
          "defaultValue": 0
        }
      ]
    },
    {
      "tfOpName": "Reshape",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "shape",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "EnsureShape",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "shape",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "Squeeze",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "axis",
          "tfDeprecatedName": "squeeze_dims",
          "name": "axis",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "SpaceToBatchND",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "blockShape",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "paddings",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "BatchToSpaceND",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "blockShape",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "crops",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "DepthToSpace",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "block_size",
          "name": "blockSize",
          "type": "number"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string"
        }
      ]
    },
    {
      "tfOpName": "BroadcastTo",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "shape",
          "type": "number[]"
        }
      ],
      "attrs": []
    },
    {
      "tfOpName": "BroadcastArgs",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "s0",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "s1",
          "type": "tensor"
        }
      ],
      "attrs": []
    }
  ];
  const transformation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    json
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class OperationMapper {
    // Singleton instance for the mapper
    static get Instance() {
      return this._instance || (this._instance = new this());
    }
    // Loads the op mapping from the JSON file.
    constructor() {
      const ops = [
        arithmetic,
        basicMath,
        control,
        convolution,
        creation,
        dynamic,
        evaluation,
        graph,
        hashTable,
        image,
        logical,
        matrices,
        normalization,
        reduction,
        sliceJoin,
        sparse,
        spectral,
        string,
        transformation
      ];
      const mappersJson = [].concat(...ops.map((op2) => op2.json));
      this.opMappers = mappersJson.reduce((map, mapper) => {
        map[mapper.tfOpName] = mapper;
        return map;
      }, {});
    }
    // Converts the model inference graph from Tensorflow GraphDef to local
    // representation for TensorFlow.js API
    transformGraph(graph2, signature = {}) {
      const tfNodes = graph2.node;
      const placeholders = [];
      const weights = [];
      const initNodes = [];
      const nodes = tfNodes.reduce((map, node) => {
        map[node.name] = this.mapNode(node);
        if (node.op.startsWith("Placeholder")) {
          placeholders.push(map[node.name]);
        } else if (node.op === "Const") {
          weights.push(map[node.name]);
        } else if (node.input == null || node.input.length === 0) {
          initNodes.push(map[node.name]);
        }
        return map;
      }, {});
      let inputs = [];
      const outputs = [];
      let inputNodeNameToKey = {};
      let outputNodeNameToKey = {};
      if (signature != null) {
        inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);
        outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);
      }
      const allNodes = Object.keys(nodes);
      allNodes.forEach((key) => {
        const node = nodes[key];
        node.inputNames.forEach((name, index2) => {
          const [nodeName, , outputName] = getNodeNameAndIndex(name);
          const inputNode = nodes[nodeName];
          if (inputNode.outputs != null) {
            const outputIndex = inputNode.outputs.indexOf(outputName);
            if (outputIndex !== -1) {
              const inputName = `${nodeName}:${outputIndex}`;
              node.inputNames[index2] = inputName;
            }
          }
          node.inputs.push(inputNode);
          inputNode.children.push(node);
        });
      });
      if (Object.keys(outputNodeNameToKey).length === 0) {
        allNodes.forEach((key) => {
          const node = nodes[key];
          if (node.children.length === 0) {
            outputs.push(node);
          }
        });
      } else {
        Object.keys(outputNodeNameToKey).forEach((name) => {
          const [nodeName] = getNodeNameAndIndex(name);
          const node = nodes[nodeName];
          if (node != null) {
            node.signatureKey = outputNodeNameToKey[name];
            outputs.push(node);
          }
        });
      }
      if (Object.keys(inputNodeNameToKey).length > 0) {
        Object.keys(inputNodeNameToKey).forEach((name) => {
          const [nodeName] = getNodeNameAndIndex(name);
          const node = nodes[nodeName];
          if (node) {
            node.signatureKey = inputNodeNameToKey[name];
            inputs.push(node);
          }
        });
      } else {
        inputs = placeholders;
      }
      let functions = {};
      if (graph2.library != null && graph2.library.function != null) {
        functions = graph2.library.function.reduce((functions2, func) => {
          functions2[func.signature.name] = this.mapFunction(func);
          return functions2;
        }, {});
      }
      const result = { nodes, inputs, outputs, weights, placeholders, signature, functions };
      if (initNodes.length > 0) {
        result.initNodes = initNodes;
      }
      return result;
    }
    mapSignatureEntries(entries) {
      return Object.keys(entries || {}).reduce((prev, curr) => {
        prev[entries[curr].name] = curr;
        return prev;
      }, {});
    }
    mapNode(node) {
      const mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};
      if (node.attr == null) {
        node.attr = {};
      }
      const newNode = {
        name: node.name,
        op: node.op,
        category: mapper.category,
        inputNames: (node.input || []).map((input) => input.startsWith("^") ? input.slice(1) : input),
        inputs: [],
        children: [],
        inputParams: {},
        attrParams: {},
        rawAttrs: node.attr,
        outputs: mapper.outputs
      };
      if (mapper.inputs != null) {
        newNode.inputParams = mapper.inputs.reduce((map, param) => {
          map[param.name] = {
            type: param.type,
            inputIndexStart: param.start,
            inputIndexEnd: param.end
          };
          return map;
        }, {});
      }
      if (mapper.attrs != null) {
        newNode.attrParams = mapper.attrs.reduce((map, param) => {
          const type = param.type;
          let value = void 0;
          switch (param.type) {
            case "string":
              value = getStringParam(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "string[]":
              value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "number":
              value = getNumberParam(node.attr, param.tfName, param.defaultValue || 0);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "number[]":
              value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "bool":
              value = getBoolParam(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "bool[]":
              value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "shape":
              value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "shape[]":
              value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "dtype":
              value = getDtypeParam(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "dtype[]":
              value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "func":
              value = getFuncParam(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "tensor":
            case "tensors":
              break;
            default:
              throw new Error(`Unsupported param type: ${param.type} for op: ${node.op}`);
          }
          map[param.name] = { value, type };
          return map;
        }, {});
      }
      return newNode;
    }
    // map the TFunctionDef to TFJS graph object
    mapFunction(functionDef) {
      const tfNodes = functionDef.nodeDef;
      const placeholders = [];
      const weights = [];
      let nodes = {};
      if (tfNodes != null) {
        nodes = tfNodes.reduce((map, node) => {
          map[node.name] = this.mapNode(node);
          if (node.op === "Const") {
            weights.push(map[node.name]);
          }
          return map;
        }, {});
      }
      const inputs = [];
      const outputs = [];
      functionDef.signature.inputArg.forEach((arg) => {
        const [nodeName] = getNodeNameAndIndex(arg.name);
        const node = {
          name: nodeName,
          op: "Placeholder",
          inputs: [],
          inputNames: [],
          category: "graph",
          inputParams: {},
          attrParams: { dtype: { value: parseDtypeParam(arg.type), type: "dtype" } },
          children: []
        };
        node.signatureKey = arg.name;
        inputs.push(node);
        nodes[nodeName] = node;
      });
      const allNodes = Object.keys(nodes);
      allNodes.forEach((key) => {
        const node = nodes[key];
        node.inputNames.forEach((name, index2) => {
          const [nodeName, , outputName] = getNodeNameAndIndex(name);
          const inputNode = nodes[nodeName];
          if (inputNode.outputs != null) {
            const outputIndex = inputNode.outputs.indexOf(outputName);
            if (outputIndex !== -1) {
              const inputName = `${nodeName}:${outputIndex}`;
              node.inputNames[index2] = inputName;
            }
          }
          node.inputs.push(inputNode);
          inputNode.children.push(node);
        });
      });
      const returnNodeMap = functionDef.ret;
      functionDef.signature.outputArg.forEach((output) => {
        const [nodeName, index2] = getNodeNameAndIndex(returnNodeMap[output.name]);
        const node = nodes[nodeName];
        if (node != null) {
          node.defaultOutput = index2;
          outputs.push(node);
        }
      });
      const signature = this.mapArgsToSignature(functionDef);
      return { nodes, inputs, outputs, weights, placeholders, signature };
    }
    mapArgsToSignature(functionDef) {
      return {
        methodName: functionDef.signature.name,
        inputs: functionDef.signature.inputArg.reduce((map, arg) => {
          map[arg.name] = this.mapArgToTensorInfo(arg);
          return map;
        }, {}),
        outputs: functionDef.signature.outputArg.reduce((map, arg) => {
          map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);
          return map;
        }, {})
      };
    }
    mapArgToTensorInfo(arg, nameMap) {
      let name = arg.name;
      if (nameMap != null) {
        name = nameMap[name];
      }
      return { name, dtype: arg.type };
    }
  }
  function decodeBase64(text) {
    const global2 = env().global;
    if (typeof global2.atob !== "undefined") {
      return global2.atob(text);
    } else if (typeof Buffer !== "undefined") {
      return new Buffer(text, "base64").toString();
    } else {
      throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
    }
  }
  function parseStringParam(s, keepCase) {
    const value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);
    return keepCase ? value : value.toLowerCase();
  }
  function getStringParam(attrs, name, def, keepCase = false) {
    const param = attrs[name];
    if (param != null) {
      return parseStringParam(param.s, keepCase);
    }
    return def;
  }
  function getBoolParam(attrs, name, def) {
    const param = attrs[name];
    return param ? param.b : def;
  }
  function getNumberParam(attrs, name, def) {
    const param = attrs[name] || {};
    const value = param["i"] != null ? param["i"] : param["f"] != null ? param["f"] : def;
    return typeof value === "number" ? value : parseInt(value, 10);
  }
  function parseDtypeParam(value) {
    if (typeof value === "string") {
      value = DataType[value];
    }
    switch (value) {
      case DataType.DT_FLOAT:
      case DataType.DT_HALF:
        return "float32";
      case DataType.DT_INT32:
      case DataType.DT_INT64:
      case DataType.DT_INT8:
      case DataType.DT_UINT8:
        return "int32";
      case DataType.DT_BOOL:
        return "bool";
      case DataType.DT_DOUBLE:
        return "float32";
      case DataType.DT_STRING:
        return "string";
      case DataType.DT_COMPLEX64:
      case DataType.DT_COMPLEX128:
        return "complex64";
      default:
        return null;
    }
  }
  function getFuncParam(attrs, name, def) {
    const param = attrs[name];
    if (param && param.func) {
      return param.func.name;
    }
    return def;
  }
  function getDtypeParam(attrs, name, def) {
    const param = attrs[name];
    if (param && param.type) {
      return parseDtypeParam(param.type);
    }
    return def;
  }
  function getDtypeArrayParam(attrs, name, def) {
    const param = attrs[name];
    if (param && param.list && param.list.type) {
      return param.list.type.map((v) => parseDtypeParam(v));
    }
    return def;
  }
  function parseTensorShapeParam(shape) {
    if (shape.unknownRank) {
      return void 0;
    }
    if (shape.dim != null) {
      return shape.dim.map((dim) => typeof dim.size === "number" ? dim.size : parseInt(dim.size, 10));
    }
    return [];
  }
  function getTensorShapeParam(attrs, name, def) {
    const param = attrs[name];
    if (param && param.shape) {
      return parseTensorShapeParam(param.shape);
    }
    return def;
  }
  function getNumericArrayParam(attrs, name, def) {
    const param = attrs[name];
    if (param) {
      return ((param.list.f && param.list.f.length ? param.list.f : param.list.i) || []).map((v) => typeof v === "number" ? v : parseInt(v, 10));
    }
    return def;
  }
  function getStringArrayParam(attrs, name, def, keepCase = false) {
    const param = attrs[name];
    if (param && param.list && param.list.s) {
      return param.list.s.map((v) => {
        return parseStringParam(v, keepCase);
      });
    }
    return def;
  }
  function getTensorShapeArrayParam(attrs, name, def) {
    const param = attrs[name];
    if (param && param.list && param.list.shape) {
      return param.list.shape.map((v) => {
        return parseTensorShapeParam(v);
      });
    }
    return def;
  }
  function getBoolArrayParam(attrs, name, def) {
    const param = attrs[name];
    if (param && param.list && param.list.b) {
      return param.list.b;
    }
    return def;
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class NodeValueImpl {
    constructor(node, tensorMap, context) {
      this.node = node;
      this.tensorMap = tensorMap;
      this.context = context;
      this.inputs = [];
      this.attrs = {};
      this.inputs = node.inputNames.map((name) => this.getInput(name));
      if (node.rawAttrs != null) {
        this.attrs = Object.keys(node.rawAttrs).reduce((attrs, key) => {
          attrs[key] = this.getAttr(key);
          return attrs;
        }, {});
      }
    }
    /**
     * Return the value of the attribute or input param.
     * @param name String: name of attribute or input param.
     */
    getInput(name) {
      return getTensor(name, this.tensorMap, this.context);
    }
    /**
     * Return the value of the attribute or input param.
     * @param name String: name of attribute or input param.
     */
    getAttr(name, defaultValue) {
      const value = this.node.rawAttrs[name];
      if (value.tensor != null) {
        return getTensor(name, this.tensorMap, this.context);
      }
      if (value.i != null || value.f != null) {
        return getNumberParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.s != null) {
        return getStringParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.b != null) {
        return getBoolParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.shape != null) {
        return getTensorShapeParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.type != null) {
        return getDtypeParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list != null) {
        if (value.list.i != null || value.list.f != null) {
          return getNumericArrayParam(this.node.rawAttrs, name, defaultValue);
        }
        if (value.list.s != null) {
          return getStringArrayParam(this.node.rawAttrs, name, defaultValue);
        }
        if (value.list.shape != null) {
          return getTensorShapeArrayParam(this.node.rawAttrs, name, defaultValue);
        }
        if (value.list.b != null) {
          return getBoolArrayParam(this.node.rawAttrs, name, defaultValue);
        }
        if (value.list.type != null) {
          return getDtypeArrayParam(this.node.rawAttrs, name, defaultValue);
        }
      }
      return defaultValue;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const tfOps = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    OP_SCOPE_SUFFIX,
    abs: abs$1,
    acos: acos$1,
    acosh: acosh$1,
    add,
    addN: addN$1,
    all: all$1,
    any: any$1,
    argMax: argMax$1,
    argMin: argMin$1,
    asin: asin$1,
    asinh: asinh$1,
    atan: atan$1,
    atan2: atan2$1,
    atanh: atanh$1,
    avgPool: avgPool$1,
    avgPool3d,
    basicLSTMCell,
    batchNorm: batchNorm$1,
    batchNorm2d,
    batchNorm3d,
    batchNorm4d,
    batchToSpaceND: batchToSpaceND$1,
    bincount: bincount$1,
    bitwiseAnd: bitwiseAnd$1,
    booleanMaskAsync,
    broadcastArgs: broadcastArgs$1,
    broadcastTo,
    buffer,
    cast: cast$1,
    ceil: ceil$1,
    clipByValue: clipByValue$1,
    clone,
    complex: complex$1,
    concat: concat$1,
    concat1d,
    concat2d,
    concat3d,
    concat4d,
    conv1d,
    conv2d: conv2d$2,
    conv2dTranspose,
    conv3d,
    conv3dTranspose,
    cos: cos$1,
    cosh: cosh$1,
    cosineWindow,
    cumprod: cumprod$1,
    cumsum: cumsum$1,
    denseBincount: denseBincount$1,
    depthToSpace: depthToSpace$1,
    depthwiseConv2d: depthwiseConv2d$1,
    diag: diag$1,
    dilation2d,
    div,
    divNoNan,
    dot,
    dropout,
    einsum: einsum$1,
    elu: elu$1,
    enclosingPowerOfTwo,
    ensureShape,
    equal: equal$1,
    erf: erf$1,
    euclideanNorm,
    exp: exp$1,
    expandDims: expandDims$1,
    expm1: expm1$1,
    eye,
    fft: fft$1,
    fill: fill$1,
    floor: floor$1,
    floorDiv: floorDiv$1,
    fused: fused_ops,
    gather,
    gatherND,
    greater: greater$1,
    greaterEqual: greaterEqual$1,
    ifft: ifft$1,
    imag: imag$1,
    image: image$1,
    inTopKAsync,
    irfft,
    isFinite: isFinite$2,
    isInf: isInf$1,
    isNaN: isNaN$2,
    leakyRelu: leakyRelu$1,
    less: less$1,
    lessEqual: lessEqual$1,
    linalg,
    linspace,
    localResponseNormalization,
    log: log$1,
    log1p: log1p$1,
    logSigmoid,
    logSoftmax,
    logSumExp,
    logicalAnd: logicalAnd$1,
    logicalNot: logicalNot$1,
    logicalOr: logicalOr$1,
    logicalXor,
    losses,
    lowerBound,
    matMul: matMul$1,
    max: max$1,
    maxPool: maxPool$1,
    maxPool3d: maxPool3d$1,
    maxPoolWithArgmax,
    maximum: maximum$1,
    mean,
    meshgrid,
    min: min$1,
    minimum: minimum$1,
    mirrorPad,
    mod: mod$1,
    moments,
    movingAverage,
    mul,
    multiRNNCell,
    multinomial: multinomial$1,
    neg: neg$1,
    norm,
    notEqual: notEqual$1,
    oneHot: oneHot$1,
    ones,
    onesLike: onesLike$1,
    op,
    outerProduct,
    pad,
    pad1d,
    pad2d,
    pad3d,
    pad4d,
    pool,
    pow: pow$1,
    prelu: prelu$1,
    print,
    prod: prod$1,
    raggedGather: raggedGather$1,
    raggedRange: raggedRange$1,
    raggedTensorToTensor: raggedTensorToTensor$1,
    rand,
    randomGamma,
    randomNormal,
    randomStandardNormal,
    randomUniform,
    randomUniformInt,
    range: range$1,
    real: real$1,
    reciprocal: reciprocal$1,
    relu: relu$1,
    relu6: relu6$1,
    reshape: reshape$1,
    reverse: reverse$1,
    reverse1d,
    reverse2d,
    reverse3d,
    reverse4d,
    rfft,
    round: round$1,
    rsqrt: rsqrt$1,
    scalar,
    scatterND,
    searchSorted: searchSorted$1,
    selu: selu$1,
    separableConv2d,
    setdiff1dAsync,
    sigmoid: sigmoid$1,
    sign: sign$1,
    signal,
    sin: sin$1,
    sinh: sinh$1,
    slice: slice$1,
    slice1d,
    slice2d,
    slice3d,
    slice4d,
    softmax: softmax$1,
    softplus: softplus$1,
    spaceToBatchND: spaceToBatchND$1,
    sparse: sparse$1,
    sparseToDense: sparseToDense$1,
    spectral: spectral$1,
    split: split$2,
    sqrt: sqrt$1,
    square: square$1,
    squaredDifference: squaredDifference$1,
    squeeze,
    stack,
    step: step$1,
    stridedSlice: stridedSlice$1,
    string: string$1,
    sub: sub$1,
    sum: sum$1,
    tan: tan$1,
    tanh: tanh$1,
    tensor,
    tensor1d,
    tensor2d,
    tensor3d,
    tensor4d,
    tensor5d,
    tensor6d,
    tensorScatterUpdate: tensorScatterUpdate$1,
    tile: tile$1,
    topk,
    transpose: transpose$1,
    truncatedNormal,
    unique: unique$1,
    unsortedSegmentSum: unsortedSegmentSum$1,
    unstack,
    upperBound,
    variable,
    where,
    whereAsync,
    zeros,
    zerosLike: zerosLike$1
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$k = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "BiasAdd":
      case "AddV2":
      case "Add": {
        return [ops.add(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "AddN": {
        return [ops.addN(getParamValue("tensors", node, tensorMap, context))];
      }
      case "FloorMod":
      case "Mod":
        return [ops.mod(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      case "Mul":
        return [ops.mul(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      case "RealDiv":
      case "Div": {
        return [ops.div(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "DivNoNan": {
        return [ops.divNoNan(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "FloorDiv": {
        return [ops.floorDiv(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "Sub": {
        return [ops.sub(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "Minimum": {
        return [ops.minimum(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "Maximum": {
        return [ops.maximum(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "Pow": {
        return [ops.pow(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "SquaredDifference": {
        return [ops.squaredDifference(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$j = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "Abs":
      case "ComplexAbs":
        return [ops.abs(getParamValue("x", node, tensorMap, context))];
      case "Acos":
        return [ops.acos(getParamValue("x", node, tensorMap, context))];
      case "Acosh":
        return [ops.acosh(getParamValue("x", node, tensorMap, context))];
      case "Asin":
        return [ops.asin(getParamValue("x", node, tensorMap, context))];
      case "Asinh":
        return [ops.asinh(getParamValue("x", node, tensorMap, context))];
      case "Atan":
        return [ops.atan(getParamValue("x", node, tensorMap, context))];
      case "Atan2":
        return [ops.atan2(getParamValue("x", node, tensorMap, context), getParamValue("y", node, tensorMap, context))];
      case "Atanh":
        return [ops.atanh(getParamValue("x", node, tensorMap, context))];
      case "Ceil":
        return [ops.ceil(getParamValue("x", node, tensorMap, context))];
      case "Complex":
        return [ops.complex(getParamValue("real", node, tensorMap, context), getParamValue("imag", node, tensorMap, context))];
      case "Cos":
        return [ops.cos(getParamValue("x", node, tensorMap, context))];
      case "Cosh":
        return [ops.cosh(getParamValue("x", node, tensorMap, context))];
      case "Elu":
        return [ops.elu(getParamValue("x", node, tensorMap, context))];
      case "Erf":
        return [ops.erf(getParamValue("x", node, tensorMap, context))];
      case "Exp":
        return [ops.exp(getParamValue("x", node, tensorMap, context))];
      case "Expm1": {
        return [ops.expm1(getParamValue("x", node, tensorMap, context))];
      }
      case "Floor":
        return [ops.floor(getParamValue("x", node, tensorMap, context))];
      case "Log":
        return [ops.log(getParamValue("x", node, tensorMap, context))];
      case "Log1p": {
        return [ops.log1p(getParamValue("x", node, tensorMap, context))];
      }
      case "Imag":
        return [ops.imag(getParamValue("x", node, tensorMap, context))];
      case "Neg":
        return [ops.neg(getParamValue("x", node, tensorMap, context))];
      case "Reciprocal": {
        return [ops.reciprocal(getParamValue("x", node, tensorMap, context))];
      }
      case "Real":
        return [ops.real(getParamValue("x", node, tensorMap, context))];
      case "Relu":
        return [ops.relu(getParamValue("x", node, tensorMap, context))];
      case "Round": {
        return [ops.round(getParamValue("x", node, tensorMap, context))];
      }
      case "Selu":
        return [ops.selu(getParamValue("x", node, tensorMap, context))];
      case "Sigmoid":
        return [ops.sigmoid(getParamValue("x", node, tensorMap, context))];
      case "Sin":
        return [ops.sin(getParamValue("x", node, tensorMap, context))];
      case "Sign": {
        return [ops.sign(getParamValue("x", node, tensorMap, context))];
      }
      case "Sinh": {
        return [ops.sinh(getParamValue("x", node, tensorMap, context))];
      }
      case "Softplus": {
        return [ops.softplus(getParamValue("x", node, tensorMap, context))];
      }
      case "Sqrt": {
        return [ops.sqrt(getParamValue("x", node, tensorMap, context))];
      }
      case "Square": {
        return [ops.square(getParamValue("x", node, tensorMap, context))];
      }
      case "Tanh": {
        return [ops.tanh(getParamValue("x", node, tensorMap, context))];
      }
      case "Tan":
        return [ops.tan(getParamValue("x", node, tensorMap, context))];
      case "ClipByValue":
        return [ops.clipByValue(getParamValue("x", node, tensorMap, context), getParamValue("clipValueMin", node, tensorMap, context), getParamValue("clipValueMax", node, tensorMap, context))];
      case "Relu6":
        return [ops.relu6(getParamValue("x", node, tensorMap, context))];
      case "Rsqrt":
        return [ops.rsqrt(getTensor(node.inputNames[0], tensorMap, context))];
      case "LeakyRelu":
        return [ops.leakyRelu(getParamValue("x", node, tensorMap, context), getParamValue("alpha", node, tensorMap, context))];
      case "Prelu":
        return [ops.prelu(getParamValue("x", node, tensorMap, context), getParamValue("alpha", node, tensorMap, context))];
      case "IsNan":
        return [ops.isNaN(getTensor(node.inputNames[0], tensorMap, context))];
      case "IsInf":
        return [ops.isInf(getTensor(node.inputNames[0], tensorMap, context))];
      case "IsFinite":
        return [ops.isFinite(getTensor(node.inputNames[0], tensorMap, context))];
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function assertShapesMatchAllowUndefinedSize(shapeA, shapeB, errorMessagePrefix = "") {
    if (typeof shapeA === "number" || typeof shapeB === "number") {
      return;
    }
    assert(shapeA.length === shapeB.length, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
    for (let i = 0; i < shapeA.length; i++) {
      const dim0 = shapeA[i];
      const dim1 = shapeB[i];
      assert(dim0 < 0 || dim1 < 0 || dim0 === dim1, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
    }
  }
  function fullDefinedShape(elementShape) {
    if (typeof elementShape === "number" || elementShape.some((dim) => dim < 0)) {
      return false;
    }
    return true;
  }
  function inferElementShape(listElementShape, tensors, elementShape) {
    let partialShape = mergeElementShape(listElementShape, elementShape);
    const notfullDefinedShape = !fullDefinedShape(partialShape);
    if (notfullDefinedShape && tensors.length === 0) {
      throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${partialShape}`);
    }
    if (notfullDefinedShape) {
      tensors.forEach((tensor2) => {
        partialShape = mergeElementShape(tensor2.shape, partialShape);
      });
    }
    if (!fullDefinedShape(partialShape)) {
      throw new Error(`Non-fully-defined elementShape: ${partialShape}`);
    }
    return partialShape;
  }
  function mergeElementShape(elementShapeA, elementShapeB) {
    if (typeof elementShapeA === "number") {
      return elementShapeB;
    }
    if (typeof elementShapeB === "number") {
      return elementShapeA;
    }
    if (elementShapeA.length !== elementShapeB.length) {
      throw new Error(`Incompatible ranks during merge: ${elementShapeA} vs. ${elementShapeB}`);
    }
    const result = [];
    for (let i = 0; i < elementShapeA.length; ++i) {
      const dim0 = elementShapeA[i];
      const dim1 = elementShapeB[i];
      if (dim0 >= 0 && dim1 >= 0 && dim0 !== dim1) {
        throw new Error(`Incompatible shape during merge: ${elementShapeA} vs. ${elementShapeB}`);
      }
      result[i] = dim0 >= 0 ? dim0 : dim1;
    }
    return result;
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class TensorArray {
    constructor(name, dtype, maxSize, elementShape, identicalElementShapes, dynamicSize, clearAfterRead) {
      this.name = name;
      this.dtype = dtype;
      this.maxSize = maxSize;
      this.elementShape = elementShape;
      this.identicalElementShapes = identicalElementShapes;
      this.dynamicSize = dynamicSize;
      this.clearAfterRead = clearAfterRead;
      this.tensors = [];
      this.closed_ = false;
      this.idTensor = scalar(0);
      keep(this.idTensor);
    }
    get id() {
      return this.idTensor.id;
    }
    get closed() {
      return this.closed_;
    }
    /**
     * Dispose the tensors and idTensor and mark the TensoryArray as closed.
     */
    clearAndClose(keepIds) {
      this.tensors.forEach((tensor2) => {
        if (keepIds == null || !keepIds.has(tensor2.tensor.id)) {
          tensor2.tensor.dispose();
        }
      });
      this.tensors = [];
      this.closed_ = true;
      this.idTensor.dispose();
    }
    size() {
      return this.tensors.length;
    }
    /**
     * Read the value at location index in the TensorArray.
     * @param index Number the index to read from.
     */
    read(index2) {
      if (this.closed_) {
        throw new Error(`TensorArray ${this.name} has already been closed.`);
      }
      if (index2 < 0 || index2 >= this.size()) {
        throw new Error(`Tried to read from index ${index2}, but array size is: ${this.size()}`);
      }
      const tensorWithState = this.tensors[index2];
      if (tensorWithState.cleared) {
        throw new Error(`TensorArray ${this.name}: Could not read index ${index2} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
      }
      if (this.clearAfterRead) {
        tensorWithState.cleared = true;
      }
      tensorWithState.read = true;
      return tensorWithState.tensor;
    }
    /**
     * Helper method to read multiple tensors from the specified indices.
     */
    readMany(indices) {
      return indices.map((index2) => this.read(index2));
    }
    /**
     * Write value into the index of the TensorArray.
     * @param index number the index to write to.
     * @param tensor
     */
    write(index2, tensor2) {
      if (this.closed_) {
        throw new Error(`TensorArray ${this.name} has already been closed.`);
      }
      if (index2 < 0 || !this.dynamicSize && index2 >= this.maxSize) {
        throw new Error(`Tried to write to index ${index2}, but array is not resizeable and size is: ${this.maxSize}`);
      }
      const t = this.tensors[index2] || {};
      if (tensor2.dtype !== this.dtype) {
        throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index2},
          because the value dtype is ${tensor2.dtype}, but TensorArray dtype is ${this.dtype}.`);
      }
      if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0)) {
        this.elementShape = tensor2.shape;
      }
      assertShapesMatchAllowUndefinedSize(this.elementShape, tensor2.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${index2}.`);
      if (t.read) {
        throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index2}, because it has already been read.`);
      }
      if (t.written) {
        throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index2}, because it has already been written.`);
      }
      t.tensor = tensor2;
      keep(tensor2);
      t.written = true;
      this.tensors[index2] = t;
    }
    /**
     * Helper method to write multiple tensors to the specified indices.
     */
    writeMany(indices, tensors) {
      if (indices.length !== tensors.length) {
        throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${indices.length} is not the same as tensors size: ${tensors.length}.`);
      }
      indices.forEach((i, index2) => this.write(i, tensors[index2]));
    }
    /**
     * Return selected values in the TensorArray as a packed Tensor. All of
     * selected values must have been written and their shapes must all match.
     * @param [indices] number[] Optional. Taking values in [0, max_value). If the
     *    TensorArray is not dynamic, max_value=size(). If not specified returns
     *    all tensors in the original order.
     * @param [dtype]
     */
    gather(indices, dtype) {
      if (!!dtype && dtype !== this.dtype) {
        throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${dtype}`);
      }
      if (!indices) {
        indices = [];
        for (let i = 0; i < this.size(); i++) {
          indices.push(i);
        }
      } else {
        indices = indices.slice(0, this.size());
      }
      if (indices.length === 0) {
        return tensor([], [0].concat(this.elementShape));
      }
      const tensors = this.readMany(indices);
      assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, "TensorArray shape mismatch: ");
      return stack(tensors, 0);
    }
    /**
     * Return the values in the TensorArray as a concatenated Tensor.
     */
    concat(dtype) {
      if (!!dtype && dtype !== this.dtype) {
        throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${dtype}`);
      }
      if (this.size() === 0) {
        return tensor([], [0].concat(this.elementShape));
      }
      const indices = [];
      for (let i = 0; i < this.size(); i++) {
        indices.push(i);
      }
      const tensors = this.readMany(indices);
      assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${tensors[0].shape})`);
      return concat$1(tensors, 0);
    }
    /**
     * Scatter the values of a Tensor in specific indices of a TensorArray.
     * @param indices number[] values in [0, max_value). If the
     *    TensorArray is not dynamic, max_value=size().
     * @param tensor Tensor input tensor.
     */
    scatter(indices, tensor2) {
      if (tensor2.dtype !== this.dtype) {
        throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor2.dtype}`);
      }
      if (indices.length !== tensor2.shape[0]) {
        throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor2.shape[0]}`);
      }
      const maxIndex = Math.max(...indices);
      if (!this.dynamicSize && maxIndex >= this.maxSize) {
        throw new Error(`Max index must be < array size (${maxIndex}  vs. ${this.maxSize})`);
      }
      this.writeMany(indices, unstack(tensor2, 0));
    }
    /**
     * Split the values of a Tensor into the TensorArray.
     * @param length number[] with the lengths to use when splitting value along
     *    its first dimension.
     * @param tensor Tensor, the tensor to split.
     */
    split(length, tensor2) {
      if (tensor2.dtype !== this.dtype) {
        throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor2.dtype}`);
      }
      let totalLength = 0;
      const cumulativeLengths = length.map((len) => {
        totalLength += len;
        return totalLength;
      });
      if (totalLength !== tensor2.shape[0]) {
        throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${totalLength}, and tensor's shape is: ${tensor2.shape}`);
      }
      if (!this.dynamicSize && length.length !== this.maxSize) {
        throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${length.length}), and the TensorArray is not marked as dynamically resizeable`);
      }
      const elementPerRow = totalLength === 0 ? 0 : tensor2.size / totalLength;
      const tensors = [];
      tidy(() => {
        tensor2 = reshape$1(tensor2, [1, totalLength, elementPerRow]);
        for (let i = 0; i < length.length; ++i) {
          const previousLength = i === 0 ? 0 : cumulativeLengths[i - 1];
          const indices2 = [0, previousLength, 0];
          const sizes = [1, length[i], elementPerRow];
          tensors[i] = reshape$1(slice$1(tensor2, indices2, sizes), this.elementShape);
        }
        return tensors;
      });
      const indices = [];
      for (let i = 0; i < length.length; i++) {
        indices[i] = i;
      }
      this.writeMany(indices, tensors);
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class TensorList {
    get id() {
      return this.idTensor.id;
    }
    /**
     *
     * @param tensors list of tensors
     * @param elementShape shape of each tensor, this can be a single number (any
     * shape is allowed) or partial shape (dim = -1).
     * @param elementDtype data type of each tensor
     * @param maxNumElements The maximum allowed size of `tensors`. Defaults to -1
     *   meaning that the size of `tensors` is unbounded.
     */
    constructor(tensors, elementShape, elementDtype, maxNumElements = -1) {
      this.tensors = tensors;
      this.elementShape = elementShape;
      this.elementDtype = elementDtype;
      if (tensors != null) {
        tensors.forEach((tensor2) => {
          if (elementDtype !== tensor2.dtype) {
            throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${tensor2.dtype}`);
          }
          assertShapesMatchAllowUndefinedSize(elementShape, tensor2.shape, "TensorList shape mismatch: ");
          keep(tensor2);
        });
      }
      this.idTensor = scalar(0);
      this.maxNumElements = maxNumElements;
      keep(this.idTensor);
    }
    /**
     * Get a new TensorList containing a copy of the underlying tensor container.
     */
    copy() {
      return new TensorList([...this.tensors], this.elementShape, this.elementDtype);
    }
    /**
     * Dispose the tensors and idTensor and clear the tensor list.
     */
    clearAndClose(keepIds) {
      this.tensors.forEach((tensor2) => {
        if (keepIds == null || !keepIds.has(tensor2.id)) {
          tensor2.dispose();
        }
      });
      this.tensors.length = 0;
      this.idTensor.dispose();
    }
    /**
     * The size of the tensors in the tensor list.
     */
    size() {
      return this.tensors.length;
    }
    /**
     * Return a tensor that stacks a list of rank-R tf.Tensors into one rank-(R+1)
     * tf.Tensor.
     * @param elementShape shape of each tensor
     * @param elementDtype data type of each tensor
     * @param numElements the number of elements to stack
     */
    stack(elementShape, elementDtype, numElements = -1) {
      if (elementDtype !== this.elementDtype) {
        throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
      }
      if (numElements !== -1 && this.tensors.length !== numElements) {
        throw new Error(`Operation expected a list with ${numElements} elements but got a list with ${this.tensors.length} elements.`);
      }
      assertShapesMatchAllowUndefinedSize(elementShape, this.elementShape, "TensorList shape mismatch: ");
      const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
      return tidy(() => {
        const reshapedTensors = this.tensors.map((tensor2) => reshape$1(tensor2, outputElementShape));
        return stack(reshapedTensors, 0);
      });
    }
    /**
     * Pop a tensor from the end of the list.
     * @param elementShape shape of the tensor
     * @param elementDtype data type of the tensor
     */
    popBack(elementShape, elementDtype) {
      if (elementDtype !== this.elementDtype) {
        throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
      }
      if (this.size() === 0) {
        throw new Error("Trying to pop from an empty list.");
      }
      const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
      const tensor2 = this.tensors.pop();
      tensor2.kept = false;
      assertShapesMatchAllowUndefinedSize(tensor2.shape, elementShape, "TensorList shape mismatch: ");
      return reshape$1(tensor2, outputElementShape);
    }
    /**
     * Push a tensor to the end of the list.
     * @param tensor Tensor to be pushed.
     */
    pushBack(tensor2) {
      if (tensor2.dtype !== this.elementDtype) {
        throw new Error(`Invalid data types; op elements ${tensor2.dtype}, but list elements ${this.elementDtype}`);
      }
      assertShapesMatchAllowUndefinedSize(tensor2.shape, this.elementShape, "TensorList shape mismatch: ");
      if (this.maxNumElements === this.size()) {
        throw new Error(`Trying to push element into a full list.`);
      }
      keep(tensor2);
      this.tensors.push(tensor2);
    }
    /**
     * Update the size of the list.
     * @param size the new size of the list.
     */
    resize(size) {
      if (size < 0) {
        throw new Error(`TensorListResize expects size to be non-negative. Got: ${size}`);
      }
      if (this.maxNumElements !== -1 && size > this.maxNumElements) {
        throw new Error(`TensorListResize input size ${size} is greater maxNumElement ${this.maxNumElements}.`);
      }
      const destTensorList = new TensorList([], this.elementShape, this.elementDtype, this.maxNumElements);
      destTensorList.tensors.length = size;
      for (let i = 0; i < Math.min(this.tensors.length, size); ++i) {
        destTensorList.tensors[i] = this.tensors[i];
      }
      return destTensorList;
    }
    /**
     * Retrieve the element at the provided index
     * @param elementShape shape of the tensor
     * @param elementDtype dtype of the tensor
     * @param elementIndex index of the tensor
     */
    getItem(elementIndex, elementShape, elementDtype) {
      if (elementDtype !== this.elementDtype) {
        throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
      }
      if (elementIndex < 0 || elementIndex > this.tensors.length) {
        throw new Error(`Trying to access element ${elementIndex} in a list with ${this.tensors.length} elements.`);
      }
      if (this.tensors[elementIndex] == null) {
        throw new Error(`element at index ${elementIndex} is null.`);
      }
      assertShapesMatchAllowUndefinedSize(this.tensors[elementIndex].shape, elementShape, "TensorList shape mismatch: ");
      const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
      return reshape$1(this.tensors[elementIndex], outputElementShape);
    }
    /**
     * Set the tensor at the index
     * @param elementIndex index of the tensor
     * @param tensor the tensor to be inserted into the list
     */
    setItem(elementIndex, tensor2) {
      if (tensor2.dtype !== this.elementDtype) {
        throw new Error(`Invalid data types; op elements ${tensor2.dtype}, but list elements ${this.elementDtype}`);
      }
      if (elementIndex < 0 || this.maxNumElements !== -1 && elementIndex >= this.maxNumElements) {
        throw new Error(`Trying to set element ${elementIndex} in a list with max ${this.maxNumElements} elements.`);
      }
      assertShapesMatchAllowUndefinedSize(this.elementShape, tensor2.shape, "TensorList shape mismatch: ");
      keep(tensor2);
      if (this.tensors[elementIndex] != null) {
        this.tensors[elementIndex].kept = false;
      }
      this.tensors[elementIndex] = tensor2;
    }
    /**
     * Return selected values in the TensorList as a stacked Tensor. All of
     * selected values must have been written and their shapes must all match.
     * @param indices indices of tensors to gather
     * @param elementDtype output tensor dtype
     * @param elementShape output tensor element shape
     */
    gather(indices, elementDtype, elementShape) {
      if (elementDtype !== this.elementDtype) {
        throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
      }
      assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
      indices = indices.slice(0, this.size());
      const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
      if (indices.length === 0) {
        return tensor([], [0].concat(outputElementShape));
      }
      return tidy(() => {
        const tensors = indices.map((i) => reshape$1(this.tensors[i], outputElementShape));
        return stack(tensors, 0);
      });
    }
    /**
     * Return the values in the TensorList as a concatenated Tensor.
     * @param elementDtype output tensor dtype
     * @param elementShape output tensor element shape
     */
    concat(elementDtype, elementShape) {
      if (!!elementDtype && elementDtype !== this.elementDtype) {
        throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${elementDtype}`);
      }
      assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
      const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
      if (this.size() === 0) {
        return tensor([], [0].concat(outputElementShape));
      }
      return tidy(() => {
        const tensors = this.tensors.map((t) => reshape$1(t, outputElementShape));
        return concat$1(tensors, 0);
      });
    }
  }
  function fromTensor(tensor2, elementShape, elementDtype) {
    const dtype = tensor2.dtype;
    if (tensor2.shape.length < 1) {
      throw new Error(`Tensor must be at least a vector, but saw shape: ${tensor2.shape}`);
    }
    if (tensor2.dtype !== elementDtype) {
      throw new Error(`Invalid data types; op elements ${tensor2.dtype}, but list elements ${elementDtype}`);
    }
    const tensorElementShape = tensor2.shape.slice(1);
    assertShapesMatchAllowUndefinedSize(tensorElementShape, elementShape, "TensorList shape mismatch: ");
    const tensorList = unstack(tensor2);
    return new TensorList(tensorList, elementShape, dtype);
  }
  function reserve(elementShape, elementDtype, numElements, maxNumElements) {
    return new TensorList([], elementShape, elementDtype, maxNumElements);
  }
  function scatter(tensor2, indices, elementShape, numElements) {
    if (indices.length !== tensor2.shape[0]) {
      throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor2.shape[0]}`);
    }
    const maxIndex = Math.max(...indices);
    if (numElements != null && numElements !== -1 && maxIndex >= numElements) {
      throw new Error(`Max index must be < array size (${maxIndex}  vs. ${numElements})`);
    }
    const list = new TensorList([], elementShape, tensor2.dtype, numElements);
    const tensors = unstack(tensor2, 0);
    indices.forEach((value, index2) => {
      list.setItem(value, tensors[index2]);
    });
    return list;
  }
  function split(tensor2, length, elementShape) {
    let totalLength = 0;
    const cumulativeLengths = length.map((len) => {
      totalLength += len;
      return totalLength;
    });
    if (totalLength !== tensor2.shape[0]) {
      throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${totalLength}, and tensor's shape is: ${tensor2.shape}`);
    }
    const shapeWithoutFirstDim = tensor2.shape.slice(1);
    const outputElementShape = mergeElementShape(shapeWithoutFirstDim, elementShape);
    const elementPerRow = totalLength === 0 ? 0 : tensor2.size / totalLength;
    const tensors = tidy(() => {
      const tensors2 = [];
      tensor2 = reshape$1(tensor2, [1, totalLength, elementPerRow]);
      for (let i = 0; i < length.length; ++i) {
        const previousLength = i === 0 ? 0 : cumulativeLengths[i - 1];
        const indices = [0, previousLength, 0];
        const sizes = [1, length[i], elementPerRow];
        tensors2[i] = reshape$1(slice$1(tensor2, indices, sizes), outputElementShape);
      }
      tensor2.dispose();
      return tensors2;
    });
    const list = new TensorList([], elementShape, tensor2.dtype, length.length);
    for (let i = 0; i < tensors.length; i++) {
      list.setItem(i, tensors[i]);
    }
    return list;
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$i = async (node, tensorMap, context) => {
    switch (node.op) {
      case "If":
      case "StatelessIf": {
        const thenFunc = getParamValue("thenBranch", node, tensorMap, context);
        const elseFunc = getParamValue("elseBranch", node, tensorMap, context);
        const cond = getParamValue("cond", node, tensorMap, context);
        const args = getParamValue("args", node, tensorMap, context);
        const condValue = await cond.data();
        if (condValue[0]) {
          return context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
        } else {
          return context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
        }
      }
      case "While":
      case "StatelessWhile": {
        const bodyFunc = getParamValue("body", node, tensorMap, context);
        const condFunc = getParamValue("cond", node, tensorMap, context);
        const args = getParamValue("args", node, tensorMap, context);
        const condResult = await context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
        const argIds = args.map((tensor2) => tensor2.id);
        let condValue = await condResult[0].data();
        condResult.forEach((tensor2) => {
          if (!tensor2.kept && argIds.indexOf(tensor2.id) === -1) {
            tensor2.dispose();
          }
        });
        let result = args;
        while (condValue[0]) {
          const origResult = result;
          result = await context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);
          const resultIds = result.map((tensor2) => tensor2.id);
          origResult.forEach((tensor2) => {
            if (!tensor2.kept && argIds.indexOf(tensor2.id) === -1 && resultIds.indexOf(tensor2.id) === -1) {
              tensor2.dispose();
            }
          });
          const condResult2 = await context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);
          condValue = await condResult2[0].data();
          condResult2.forEach((tensor2) => {
            if (!tensor2.kept && argIds.indexOf(tensor2.id) === -1 && resultIds.indexOf(tensor2.id) === -1) {
              tensor2.dispose();
            }
          });
        }
        return result;
      }
      case "LoopCond": {
        const pred = getParamValue("pred", node, tensorMap, context);
        return [cloneTensor(pred)];
      }
      case "Switch": {
        const pred = getParamValue("pred", node, tensorMap, context);
        let data = getParamValue("data", node, tensorMap, context);
        if (!data.kept) {
          data = cloneTensor(data);
        }
        return (await pred.data())[0] ? [void 0, data] : [data, void 0];
      }
      case "Merge": {
        const inputName = node.inputNames.find((name) => getTensor(name, tensorMap, context) !== void 0);
        if (inputName) {
          const data = getTensor(inputName, tensorMap, context);
          return [cloneTensor(data)];
        }
        return void 0;
      }
      case "Enter": {
        const frameId = getParamValue("frameName", node, tensorMap, context);
        const data = getParamValue("tensor", node, tensorMap, context);
        context.enterFrame(frameId);
        return [cloneTensor(data)];
      }
      case "Exit": {
        const data = getParamValue("tensor", node, tensorMap, context);
        context.exitFrame();
        return [cloneTensor(data)];
      }
      case "NextIteration": {
        const data = getParamValue("tensor", node, tensorMap, context);
        context.nextIteration();
        return [cloneTensor(data)];
      }
      case "TensorArrayV3": {
        const size = getParamValue("size", node, tensorMap, context);
        const dtype = getParamValue("dtype", node, tensorMap, context);
        const elementShape = getParamValue("elementShape", node, tensorMap, context);
        const dynamicSize = getParamValue("dynamicSize", node, tensorMap, context);
        const clearAfterRead = getParamValue("clearAfterRead", node, tensorMap, context);
        const identicalElementShapes = getParamValue("identicalElementShapes", node, tensorMap, context);
        const name = getParamValue("name", node, tensorMap, context);
        const tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);
        context.addTensorArray(tensorArray);
        return [tensorArray.idTensor, scalar(1)];
      }
      case "TensorArrayWriteV3": {
        const id = getParamValue("tensorArrayId", node, tensorMap, context);
        const index2 = getParamValue("index", node, tensorMap, context);
        const writeTensor = getParamValue("tensor", node, tensorMap, context);
        const writeTensorArray = context.getTensorArray(id.id);
        writeTensorArray.write(index2, writeTensor);
        return [writeTensorArray.idTensor];
      }
      case "TensorArrayReadV3": {
        const readId = getParamValue("tensorArrayId", node, tensorMap, context);
        const readIndex = getParamValue("index", node, tensorMap, context);
        const readTensorArray = context.getTensorArray(readId.id);
        return [readTensorArray.read(readIndex)];
      }
      case "TensorArrayGatherV3": {
        const gatherId = getParamValue("tensorArrayId", node, tensorMap, context);
        const gatherIndices = getParamValue("indices", node, tensorMap, context);
        const gatherDtype = getParamValue("dtype", node, tensorMap, context);
        const gatherTensorArray = context.getTensorArray(gatherId.id);
        return [gatherTensorArray.gather(gatherIndices, gatherDtype)];
      }
      case "TensorArrayScatterV3": {
        const scatterId = getParamValue("tensorArrayId", node, tensorMap, context);
        const scatterIndices = getParamValue("indices", node, tensorMap, context);
        const scatterTensor = getParamValue("tensor", node, tensorMap, context);
        const scatterTensorArray = context.getTensorArray(scatterId.id);
        scatterTensorArray.scatter(scatterIndices, scatterTensor);
        return [scatterTensorArray.idTensor];
      }
      case "TensorArrayConcatV3": {
        const concatId = getParamValue("tensorArrayId", node, tensorMap, context);
        const concatTensorArray = context.getTensorArray(concatId.id);
        const concatDtype = getParamValue("dtype", node, tensorMap, context);
        return [concatTensorArray.concat(concatDtype)];
      }
      case "TensorArraySplitV3": {
        const splitId = getParamValue("tensorArrayId", node, tensorMap, context);
        const splitTensor = getParamValue("tensor", node, tensorMap, context);
        const lengths = getParamValue("lengths", node, tensorMap, context);
        const splitTensorArray = context.getTensorArray(splitId.id);
        splitTensorArray.split(lengths, splitTensor);
        return [splitTensorArray.idTensor];
      }
      case "TensorArraySizeV3": {
        const sizeId = getParamValue("tensorArrayId", node, tensorMap, context);
        const sizeTensorArray = context.getTensorArray(sizeId.id);
        return [scalar(sizeTensorArray.size(), "int32")];
      }
      case "TensorArrayCloseV3": {
        const closeId = getParamValue("tensorArrayId", node, tensorMap, context);
        const closeTensorArray = context.getTensorArray(closeId.id);
        closeTensorArray.clearAndClose();
        return [closeTensorArray.idTensor];
      }
      case "TensorListSetItem": {
        const idTensor = getParamValue("tensorListId", node, tensorMap, context);
        const index2 = getParamValue("index", node, tensorMap, context);
        const writeTensor = getParamValue("tensor", node, tensorMap, context);
        const tensorList = context.getTensorList(idTensor.id);
        tensorList.setItem(index2, writeTensor);
        return [tensorList.idTensor];
      }
      case "TensorListGetItem": {
        const idTensor = getParamValue("tensorListId", node, tensorMap, context);
        const readIndex = getParamValue("index", node, tensorMap, context);
        const elementShape = getParamValue("elementShape", node, tensorMap, context);
        const elementDType = getParamValue("elementDType", node, tensorMap, context);
        const tensorList = context.getTensorList(idTensor.id);
        return [tensorList.getItem(readIndex, elementShape, elementDType)];
      }
      case "TensorListScatterV2":
      case "TensorListScatter": {
        const scatterIndices = getParamValue("indices", node, tensorMap, context);
        const scatterTensor = getParamValue("tensor", node, tensorMap, context);
        const elementShape = getParamValue("elementShape", node, tensorMap, context);
        const numElements = getParamValue("numElements", node, tensorMap, context);
        const tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);
        context.addTensorList(tensorList);
        return [tensorList.idTensor];
      }
      case "TensorListReserve":
      case "EmptyTensorList": {
        const elementShape = getParamValue("elementShape", node, tensorMap, context);
        const elementDtype = getParamValue("elementDType", node, tensorMap, context);
        let numElementsParam;
        if (node.op === "TensorListReserve") {
          numElementsParam = "numElements";
        } else {
          numElementsParam = "maxNumElements";
        }
        const numElements = getParamValue(numElementsParam, node, tensorMap, context);
        const maxNumElements = node.op === "TensorListReserve" ? -1 : numElements;
        const tensorList = reserve(elementShape, elementDtype, numElements, maxNumElements);
        context.addTensorList(tensorList);
        return [tensorList.idTensor];
      }
      case "TensorListGather": {
        const gatherId = getParamValue("tensorListId", node, tensorMap, context);
        const gatherIndices = getParamValue("indices", node, tensorMap, context);
        const elementShape = getParamValue("elementShape", node, tensorMap, context);
        const elementDtype = getParamValue("elementDType", node, tensorMap, context);
        const tensorList = context.getTensorList(gatherId.id);
        return [tensorList.gather(gatherIndices, elementDtype, elementShape)];
      }
      case "TensorListStack": {
        const idTensor = getParamValue("tensorListId", node, tensorMap, context);
        const elementShape = getParamValue("elementShape", node, tensorMap, context);
        const elementDtype = getParamValue("elementDType", node, tensorMap, context);
        const numElements = getParamValue("numElements", node, tensorMap, context);
        const tensorList = context.getTensorList(idTensor.id);
        return [tensorList.stack(elementShape, elementDtype, numElements)];
      }
      case "TensorListFromTensor": {
        const tensor2 = getParamValue("tensor", node, tensorMap, context);
        const elementShape = getParamValue("elementShape", node, tensorMap, context);
        const elementDtype = getParamValue("elementDType", node, tensorMap, context);
        const tensorList = fromTensor(tensor2, elementShape, elementDtype);
        context.addTensorList(tensorList);
        return [tensorList.idTensor];
      }
      case "TensorListConcat":
      case "TensorListConcatV2": {
        const concatId = getParamValue("tensorListId", node, tensorMap, context);
        const tensorList = context.getTensorList(concatId.id);
        const concatDtype = getParamValue("dtype", node, tensorMap, context);
        const elementShape = getParamValue("elementShape", node, tensorMap, context);
        return [tensorList.concat(concatDtype, elementShape)];
      }
      case "TensorListPushBack": {
        const idTensor = getParamValue("tensorListId", node, tensorMap, context);
        const writeTensor = getParamValue("tensor", node, tensorMap, context);
        const tensorList = context.getTensorList(idTensor.id);
        tensorList.pushBack(writeTensor);
        return [tensorList.idTensor];
      }
      case "TensorListPopBack": {
        const idTensor = getParamValue("tensorListId", node, tensorMap, context);
        const elementShape = getParamValue("elementShape", node, tensorMap, context);
        const elementDType = getParamValue("elementDType", node, tensorMap, context);
        const tensorList = context.getTensorList(idTensor.id);
        return [tensorList.popBack(elementShape, elementDType)];
      }
      case "TensorListSplit": {
        const splitTensor = getParamValue("tensor", node, tensorMap, context);
        const elementShape = getParamValue("elementShape", node, tensorMap, context);
        const lengths = getParamValue("lengths", node, tensorMap, context);
        const tensorList = split(splitTensor, lengths, elementShape);
        context.addTensorList(tensorList);
        return [tensorList.idTensor];
      }
      case "TensorListLength": {
        const idTensor = getParamValue("tensorListId", node, tensorMap, context);
        const tensorList = context.getTensorList(idTensor.id);
        return [scalar(tensorList.size(), "int32")];
      }
      case "TensorListResize": {
        const idTensor = getParamValue("tensorListId", node, tensorMap, context);
        const size = getParamValue("size", node, tensorMap, context);
        const srcTensorList = context.getTensorList(idTensor.id);
        const destTensorList = srcTensorList.resize(size);
        context.addTensorList(destTensorList);
        return [destTensorList.idTensor];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function fusedConvAndDepthWiseParams(node, tensorMap, context) {
    const [extraOp, activationFunc] = getParamValue("fusedOps", node, tensorMap, context);
    const isBiasAdd = extraOp === "biasadd";
    const noBiasAdd = !isBiasAdd;
    const isPrelu = activationFunc === "prelu";
    const isBatchNorm = extraOp === "fusedbatchnorm";
    const numArgs = getParamValue("numArgs", node, tensorMap, context);
    if (isBiasAdd) {
      if (isPrelu && numArgs !== 2) {
        throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
      }
      if (!isPrelu && isBiasAdd && numArgs !== 1) {
        throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
      }
    }
    if (isBatchNorm) {
      throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
    }
    const stride = getParamValue("strides", node, tensorMap, context);
    const pad2 = getPadding(node, tensorMap, context);
    const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
    const dilations = getParamValue("dilations", node, tensorMap, context);
    let [biasArg, preluArg] = getParamValue("args", node, tensorMap, context);
    if (noBiasAdd) {
      preluArg = biasArg;
      biasArg = void 0;
    }
    const leakyreluAlpha = getParamValue("leakyreluAlpha", node, tensorMap, context);
    return {
      stride,
      pad: pad2,
      dataFormat,
      dilations,
      biasArg,
      preluArg,
      activationFunc,
      leakyreluAlpha
    };
  }
  const executeOp$h = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "Conv1D": {
        const stride = getParamValue("stride", node, tensorMap, context);
        const pad2 = getParamValue("pad", node, tensorMap, context);
        const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
        const dilation = getParamValue("dilation", node, tensorMap, context);
        return [ops.conv1d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), stride, pad2, dataFormat, dilation)];
      }
      case "Conv2D": {
        const stride = getParamValue("strides", node, tensorMap, context);
        const pad2 = getPadding(node, tensorMap, context);
        const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
        const dilations = getParamValue("dilations", node, tensorMap, context);
        return [ops.conv2d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [stride[1], stride[2]], pad2, dataFormat, [dilations[1], dilations[2]])];
      }
      case "_FusedConv2D": {
        const { stride, pad: pad2, dataFormat, dilations, biasArg, preluArg, activationFunc, leakyreluAlpha } = fusedConvAndDepthWiseParams(node, tensorMap, context);
        return [ops.fused.conv2d({
          x: getParamValue("x", node, tensorMap, context),
          filter: getParamValue("filter", node, tensorMap, context),
          strides: [stride[1], stride[2]],
          pad: pad2,
          dataFormat,
          dilations: [dilations[1], dilations[2]],
          bias: biasArg,
          activation: activationFunc,
          preluActivationWeights: preluArg,
          leakyreluAlpha
        })];
      }
      case "FusedDepthwiseConv2dNative": {
        const { stride, pad: pad2, dataFormat, dilations, biasArg, preluArg, activationFunc, leakyreluAlpha } = fusedConvAndDepthWiseParams(node, tensorMap, context);
        return [ops.fused.depthwiseConv2d({
          x: getParamValue("x", node, tensorMap, context),
          filter: getParamValue("filter", node, tensorMap, context),
          strides: [stride[1], stride[2]],
          pad: pad2,
          dataFormat,
          dilations: [dilations[1], dilations[2]],
          bias: biasArg,
          activation: activationFunc,
          preluActivationWeights: preluArg,
          leakyreluAlpha
        })];
      }
      case "Conv2DBackpropInput":
      case "Conv2dTranspose": {
        const shape = getParamValue("outputShape", node, tensorMap, context);
        const stride = getParamValue("strides", node, tensorMap, context);
        const pad2 = getPadding(node, tensorMap, context);
        return [ops.conv2dTranspose(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), shape, [stride[1], stride[2]], pad2)];
      }
      case "DepthwiseConv2dNative":
      case "DepthwiseConv2d": {
        const stride = getParamValue("strides", node, tensorMap, context);
        const pad2 = getPadding(node, tensorMap, context);
        const dilations = getParamValue("dilations", node, tensorMap, context);
        const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
        return [ops.depthwiseConv2d(getParamValue("input", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [stride[1], stride[2]], pad2, dataFormat, [dilations[1], dilations[2]])];
      }
      case "Conv3D": {
        const stride = getParamValue("strides", node, tensorMap, context);
        const pad2 = getParamValue("pad", node, tensorMap, context);
        const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
        const dilations = getParamValue("dilations", node, tensorMap, context);
        return [ops.conv3d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [stride[1], stride[2], stride[3]], pad2, dataFormat, [dilations[1], dilations[2], dilations[3]])];
      }
      case "AvgPool": {
        const stride = getParamValue("strides", node, tensorMap, context);
        const pad2 = getParamValue("pad", node, tensorMap, context);
        const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
        return [ops.avgPool(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad2)];
      }
      case "MaxPool": {
        const stride = getParamValue("strides", node, tensorMap, context);
        const pad2 = getParamValue("pad", node, tensorMap, context);
        const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
        return [ops.maxPool(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad2)];
      }
      case "MaxPoolWithArgmax": {
        const stride = getParamValue("strides", node, tensorMap, context);
        const pad2 = getParamValue("pad", node, tensorMap, context);
        const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
        const includeBatchInIndex = getParamValue("includeBatchInIndex", node, tensorMap, context);
        const { result, indexes } = ops.maxPoolWithArgmax(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad2, includeBatchInIndex);
        return [result, indexes];
      }
      case "AvgPool3D": {
        const stride = getParamValue("strides", node, tensorMap, context);
        const pad2 = getParamValue("pad", node, tensorMap, context);
        const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
        return [ops.avgPool3d(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad2)];
      }
      case "MaxPool3D": {
        const stride = getParamValue("strides", node, tensorMap, context);
        const pad2 = getParamValue("pad", node, tensorMap, context);
        const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
        return [ops.maxPool3d(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad2)];
      }
      case "Dilation2D": {
        const strides = getParamValue("strides", node, tensorMap, context);
        const pad2 = getParamValue("pad", node, tensorMap, context);
        const dilations = getParamValue("dilations", node, tensorMap, context);
        const strideHeight = strides[1];
        const strideWidth = strides[2];
        const dilationHeight = dilations[1];
        const dilationWidth = dilations[2];
        return [ops.dilation2d(
          getParamValue("x", node, tensorMap, context),
          getParamValue("filter", node, tensorMap, context),
          [strideHeight, strideWidth],
          pad2,
          [dilationHeight, dilationWidth],
          "NHWC"
          /* dataFormat */
        )];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$g = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "Fill": {
        const shape = getParamValue("shape", node, tensorMap, context);
        const dtype = getParamValue("dtype", node, tensorMap, context);
        const value = getParamValue("value", node, tensorMap, context);
        return [ops.fill(shape, value, dtype)];
      }
      case "LinSpace": {
        const start = getParamValue("start", node, tensorMap, context);
        const stop = getParamValue("stop", node, tensorMap, context);
        const num = getParamValue("num", node, tensorMap, context);
        return [ops.linspace(start, stop, num)];
      }
      case "Multinomial": {
        const logits = getParamValue("logits", node, tensorMap, context);
        const numSamples = getParamValue("numSamples", node, tensorMap, context);
        const seed = getParamValue("seed", node, tensorMap, context);
        return [ops.multinomial(logits, numSamples, seed)];
      }
      case "OneHot": {
        const indices = getParamValue("indices", node, tensorMap, context);
        const depth = getParamValue("depth", node, tensorMap, context);
        const onValue = getParamValue("onValue", node, tensorMap, context);
        const offValue = getParamValue("offValue", node, tensorMap, context);
        const dtype = getParamValue("dtype", node, tensorMap, context);
        return [ops.oneHot(indices, depth, onValue, offValue, dtype)];
      }
      case "Ones": {
        return [ops.ones(getParamValue("shape", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
      }
      case "OnesLike": {
        return [ops.onesLike(getParamValue("x", node, tensorMap, context))];
      }
      case "RandomStandardNormal": {
        return [ops.randomStandardNormal(getParamValue("shape", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context), getParamValue("seed", node, tensorMap, context))];
      }
      case "RandomUniform": {
        return [ops.randomUniform(
          // tslint:disable-next-line:no-any
          getParamValue("shape", node, tensorMap, context),
          getParamValue("minval", node, tensorMap, context),
          getParamValue("maxval", node, tensorMap, context),
          getParamValue("dtype", node, tensorMap, context)
        )];
      }
      case "RandomUniformInt": {
        return [ops.randomUniformInt(getParamValue("shape", node, tensorMap, context), getParamValue("minval", node, tensorMap, context), getParamValue("maxval", node, tensorMap, context), getParamValue("seed", node, tensorMap, context))];
      }
      case "Range": {
        const start = getParamValue("start", node, tensorMap, context);
        const stop = getParamValue("stop", node, tensorMap, context);
        const step2 = getParamValue("step", node, tensorMap, context);
        return [ops.range(start, stop, step2, getParamValue("dtype", node, tensorMap, context))];
      }
      case "TruncatedNormal": {
        const shape = getParamValue("shape", node, tensorMap, context);
        const mean2 = getParamValue("mean", node, tensorMap, context);
        const stdDev = getParamValue("stdDev", node, tensorMap, context);
        const seed = getParamValue("seed", node, tensorMap, context);
        return [ops.truncatedNormal(shape, mean2, stdDev, getParamValue("dtype", node, tensorMap, context), seed)];
      }
      case "Zeros": {
        return [ops.zeros(getParamValue("shape", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
      }
      case "ZerosLike": {
        return [ops.zerosLike(getParamValue("x", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function nmsParams(node, tensorMap, context) {
    const boxes = getParamValue("boxes", node, tensorMap, context);
    const scores = getParamValue("scores", node, tensorMap, context);
    const maxOutputSize = getParamValue("maxOutputSize", node, tensorMap, context);
    const iouThreshold = getParamValue("iouThreshold", node, tensorMap, context);
    const scoreThreshold = getParamValue("scoreThreshold", node, tensorMap, context);
    const softNmsSigma = getParamValue("softNmsSigma", node, tensorMap, context);
    return {
      boxes,
      scores,
      maxOutputSize,
      iouThreshold,
      scoreThreshold,
      softNmsSigma
    };
  }
  const executeOp$f = async (node, tensorMap, context, resourceManager, ops = tfOps) => {
    switch (node.op) {
      case "NonMaxSuppressionV5": {
        const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = nmsParams(node, tensorMap, context);
        const result = await ops.image.nonMaxSuppressionWithScoreAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
        return [result.selectedIndices, result.selectedScores];
      }
      case "NonMaxSuppressionV4": {
        const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold } = nmsParams(node, tensorMap, context);
        const padToMaxOutputSize = getParamValue("padToMaxOutputSize", node, tensorMap, context);
        const result = await ops.image.nonMaxSuppressionPaddedAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
        return [result.selectedIndices, result.validOutputs];
      }
      case "NonMaxSuppressionV3":
      case "NonMaxSuppressionV2": {
        const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold } = nmsParams(node, tensorMap, context);
        return [await ops.image.nonMaxSuppressionAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold)];
      }
      case "Where": {
        const condition = ops.cast(getParamValue("condition", node, tensorMap, context), "bool");
        const result = [await ops.whereAsync(condition)];
        condition.dispose();
        return result;
      }
      case "ListDiff": {
        return ops.setdiff1dAsync(getParamValue("x", node, tensorMap, context), getParamValue("y", node, tensorMap, context));
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$e = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "LowerBound": {
        const sortedSequence = getParamValue("sortedSequence", node, tensorMap, context);
        const values = getParamValue("values", node, tensorMap, context);
        return [ops.lowerBound(sortedSequence, values)];
      }
      case "TopKV2": {
        const x = getParamValue("x", node, tensorMap, context);
        const k3 = getParamValue("k", node, tensorMap, context);
        const sorted = getParamValue("sorted", node, tensorMap, context);
        const result = ops.topk(x, k3, sorted);
        return [result.values, result.indices];
      }
      case "UpperBound": {
        const sortedSequence = getParamValue("sortedSequence", node, tensorMap, context);
        const values = getParamValue("values", node, tensorMap, context);
        return [ops.upperBound(sortedSequence, values)];
      }
      case "Unique": {
        const x = getParamValue("x", node, tensorMap, context);
        const result = ops.unique(x);
        return [result.values, result.indices];
      }
      case "UniqueV2": {
        const x = getParamValue("x", node, tensorMap, context);
        const axis = getParamValue("axis", node, tensorMap, context);
        const result = ops.unique(x, axis);
        return [result.values, result.indices];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$d = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "Const": {
        return tensorMap[node.name];
      }
      case "PlaceholderWithDefault":
        const def = getParamValue("default", node, tensorMap, context);
        return [getTensor(node.name, tensorMap, context) || def];
      case "Placeholder":
        return [getTensor(node.name, tensorMap, context)];
      case "Identity":
      case "StopGradient":
      case "FakeQuantWithMinMaxVars": {
        const data2 = getParamValue("x", node, tensorMap, context);
        return [cloneTensor(data2)];
      }
      case "IdentityN":
        return getParamValue("x", node, tensorMap, context).map((t) => cloneTensor(t));
      case "Snapshot":
        const snapshot = getParamValue("x", node, tensorMap, context);
        return [cloneTensor(snapshot)];
      case "Shape":
        return [ops.tensor1d(getParamValue("x", node, tensorMap, context).shape, "int32")];
      case "ShapeN":
        return getParamValue("x", node, tensorMap, context).map((t) => ops.tensor1d(t.shape));
      case "Size":
        return [ops.scalar(getParamValue("x", node, tensorMap, context).size, "int32")];
      case "Rank":
        return [ops.scalar(getParamValue("x", node, tensorMap, context).rank, "int32")];
      case "NoOp":
        return [ops.scalar(1)];
      case "Print":
        const input = getParamValue("x", node, tensorMap, context);
        const data = getParamValue("data", node, tensorMap, context);
        const message = getParamValue("message", node, tensorMap, context);
        const summarize = getParamValue("summarize", node, tensorMap, context);
        console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance.");
        console.log(message);
        for (let i = 0; i < data.length; i++) {
          console.log(Array.prototype.slice.call(data[i].dataSync()).slice(0, summarize));
        }
        return [input];
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class HashTable {
    get id() {
      return this.handle.id;
    }
    /**
     * Constructor of HashTable. Creates a hash table.
     *
     * @param keyDType `dtype` of the table keys.
     * @param valueDType `dtype` of the table values.
     */
    constructor(keyDType, valueDType) {
      this.keyDType = keyDType;
      this.valueDType = valueDType;
      this.handle = scalar(0);
      this.tensorMap = /* @__PURE__ */ new Map();
      keep(this.handle);
    }
    /**
     * Dispose the tensors and handle and clear the hashtable.
     */
    clearAndClose() {
      this.tensorMap.forEach((value) => value.dispose());
      this.tensorMap.clear();
      this.handle.dispose();
    }
    /**
     * The number of items in the hash table.
     */
    size() {
      return this.tensorMap.size;
    }
    /**
     * The number of items in the hash table as a rank-0 tensor.
     */
    tensorSize() {
      return scalar(this.size(), "int32");
    }
    /**
     * Replaces the contents of the table with the specified keys and values.
     * @param keys Keys to store in the hashtable.
     * @param values Values to store in the hashtable.
     */
    async import(keys, values) {
      this.checkKeyAndValueTensor(keys, values);
      const $keys = await keys.data();
      this.tensorMap.forEach((value) => value.dispose());
      this.tensorMap.clear();
      return tidy(() => {
        const $values = unstack(values);
        const keysLength = $keys.length;
        const valuesLength = $values.length;
        assert(keysLength === valuesLength, () => `The number of elements doesn't match, keys has ${keysLength} elements, the values has ${valuesLength} elements.`);
        for (let i = 0; i < keysLength; i++) {
          const key = $keys[i];
          const value = $values[i];
          keep(value);
          this.tensorMap.set(key, value);
        }
        return this.handle;
      });
    }
    /**
     * Looks up keys in a hash table, outputs the corresponding values.
     *
     * Performs batch lookups, for every element in the key tensor, `find`
     * stacks the corresponding value into the return tensor.
     *
     * If an element is not present in the table, the given `defaultValue` is
     * used.
     *
     * @param keys Keys to look up. Must have the same type as the keys of the
     *     table.
     * @param defaultValue The scalar `defaultValue` is the value output for keys
     *     not present in the table. It must also be of the same type as the
     *     table values.
     */
    async find(keys, defaultValue) {
      this.checkKeyAndValueTensor(keys, defaultValue);
      const $keys = await keys.data();
      return tidy(() => {
        const result = [];
        for (let i = 0; i < $keys.length; i++) {
          const key = $keys[i];
          const value = this.findWithDefault(key, defaultValue);
          result.push(value);
        }
        return stack(result);
      });
    }
    // tslint:disable-next-line: no-any
    findWithDefault(key, defaultValue) {
      const result = this.tensorMap.get(key);
      return result != null ? result : defaultValue;
    }
    checkKeyAndValueTensor(key, value) {
      if (key.dtype !== this.keyDType) {
        throw new Error(`Expect key dtype ${this.keyDType}, but got ${key.dtype}`);
      }
      if (value.dtype !== this.valueDType) {
        throw new Error(`Expect value dtype ${this.valueDType}, but got ${value.dtype}`);
      }
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$c = async (node, tensorMap, context, resourceManager) => {
    switch (node.op) {
      case "HashTable":
      case "HashTableV2": {
        const existingTableHandle = resourceManager.getHashTableHandleByName(node.name);
        if (existingTableHandle != null) {
          return [existingTableHandle];
        } else {
          const keyDType = getParamValue("keyDType", node, tensorMap, context);
          const valueDType = getParamValue("valueDType", node, tensorMap, context);
          const hashTable2 = new HashTable(keyDType, valueDType);
          resourceManager.addHashTable(node.name, hashTable2);
          return [hashTable2.handle];
        }
      }
      case "InitializeTable":
      case "InitializeTableV2":
      case "LookupTableImport":
      case "LookupTableImportV2": {
        const handle = getParamValue("tableHandle", node, tensorMap, context, resourceManager);
        const keys = getParamValue("keys", node, tensorMap, context);
        const values = getParamValue("values", node, tensorMap, context);
        const hashTable2 = resourceManager.getHashTableById(handle.id);
        return [await hashTable2.import(keys, values)];
      }
      case "LookupTableFind":
      case "LookupTableFindV2": {
        const handle = getParamValue("tableHandle", node, tensorMap, context, resourceManager);
        const keys = getParamValue("keys", node, tensorMap, context);
        const defaultValue = getParamValue("defaultValue", node, tensorMap, context);
        const hashTable2 = resourceManager.getHashTableById(handle.id);
        return [await hashTable2.find(keys, defaultValue)];
      }
      case "LookupTableSize":
      case "LookupTableSizeV2": {
        const handle = getParamValue("tableHandle", node, tensorMap, context, resourceManager);
        const hashTable2 = resourceManager.getHashTableById(handle.id);
        return [hashTable2.tensorSize()];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$b = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "ResizeBilinear": {
        const images = getParamValue("images", node, tensorMap, context);
        const size = getParamValue("size", node, tensorMap, context);
        const alignCorners = getParamValue("alignCorners", node, tensorMap, context);
        const halfPixelCenters = getParamValue("halfPixelCenters", node, tensorMap, context);
        return [ops.image.resizeBilinear(images, [size[0], size[1]], alignCorners, halfPixelCenters)];
      }
      case "ResizeNearestNeighbor": {
        const images = getParamValue("images", node, tensorMap, context);
        const size = getParamValue("size", node, tensorMap, context);
        const alignCorners = getParamValue("alignCorners", node, tensorMap, context);
        const halfPixelCenters = getParamValue("halfPixelCenters", node, tensorMap, context);
        return [ops.image.resizeNearestNeighbor(images, [size[0], size[1]], alignCorners, halfPixelCenters)];
      }
      case "CropAndResize": {
        const image2 = getParamValue("image", node, tensorMap, context);
        const boxes = getParamValue("boxes", node, tensorMap, context);
        const boxInd = getParamValue("boxInd", node, tensorMap, context);
        const cropSize = getParamValue("cropSize", node, tensorMap, context);
        const method = getParamValue("method", node, tensorMap, context);
        const extrapolationValue = getParamValue("extrapolationValue", node, tensorMap, context);
        return [ops.image.cropAndResize(image2, boxes, boxInd, cropSize, method, extrapolationValue)];
      }
      case "ImageProjectiveTransformV3": {
        const images = getParamValue("images", node, tensorMap, context);
        const transforms = getParamValue("transforms", node, tensorMap, context);
        const outputShape = getParamValue("outputShape", node, tensorMap, context);
        const fillValue = getParamValue("fillValue", node, tensorMap, context);
        const interpolation = getParamValue("interpolation", node, tensorMap, context);
        const fillMode = getParamValue("fillMode", node, tensorMap, context);
        return [ops.image.transform(images, transforms, interpolation.toLowerCase(), fillMode.toLowerCase(), fillValue, outputShape)];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$a = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "Equal": {
        return [ops.equal(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "NotEqual": {
        return [ops.notEqual(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "Greater": {
        return [ops.greater(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "GreaterEqual": {
        return [ops.greaterEqual(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "Less": {
        return [ops.less(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "LessEqual": {
        return [ops.lessEqual(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "LogicalAnd": {
        return [ops.logicalAnd(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "LogicalNot": {
        return [ops.logicalNot(getParamValue("a", node, tensorMap, context))];
      }
      case "LogicalOr": {
        return [ops.logicalOr(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "Select":
      case "SelectV2": {
        return [ops.where(getParamValue("condition", node, tensorMap, context), getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      case "BitwiseAnd": {
        return [ops.bitwiseAnd(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$9 = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "BatchMatMul":
      case "BatchMatMulV2":
      case "MatMul":
        return [ops.matMul(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context), getParamValue("transposeA", node, tensorMap, context), getParamValue("transposeB", node, tensorMap, context))];
      case "Einsum":
        return [ops.einsum(getParamValue("equation", node, tensorMap, context), ...getParamValue("tensors", node, tensorMap, context))];
      case "Transpose":
        return [ops.transpose(getParamValue("x", node, tensorMap, context), getParamValue("perm", node, tensorMap, context))];
      case "_FusedMatMul":
        const [extraOp, activationFunc] = getParamValue("fusedOps", node, tensorMap, context);
        const isBiasAdd = extraOp === "biasadd";
        const isPrelu = activationFunc === "prelu";
        const numArgs = getParamValue("numArgs", node, tensorMap, context);
        const leakyreluAlpha = getParamValue("leakyreluAlpha", node, tensorMap, context);
        if (isBiasAdd) {
          if (isPrelu && numArgs !== 2) {
            throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
          }
          if (!isPrelu && numArgs !== 1) {
            throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
          }
        }
        const [biasArg, preluArg] = getParamValue("args", node, tensorMap, context);
        return [ops.fused.matMul({
          a: getParamValue("a", node, tensorMap, context),
          b: getParamValue("b", node, tensorMap, context),
          transposeA: getParamValue("transposeA", node, tensorMap, context),
          transposeB: getParamValue("transposeB", node, tensorMap, context),
          bias: biasArg,
          activation: activationFunc,
          preluActivationWeights: preluArg,
          leakyreluAlpha
        })];
      case "MatrixBandPart":
        return [ops.linalg.bandPart(getParamValue("a", node, tensorMap, context), getParamValue("numLower", node, tensorMap, context), getParamValue("numUpper", node, tensorMap, context))];
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$8 = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "EuclideanNorm":
        return [ops.euclideanNorm(getParamValue("x", node, tensorMap, context), getParamValue("axis", node, tensorMap, context), getParamValue("keepDims", node, tensorMap, context))];
      case "FusedBatchNorm":
      case "FusedBatchNormV2": {
        return [ops.batchNorm(getParamValue("x", node, tensorMap, context), getParamValue("mean", node, tensorMap, context), getParamValue("variance", node, tensorMap, context), getParamValue("offset", node, tensorMap, context), getParamValue("scale", node, tensorMap, context), getParamValue("epsilon", node, tensorMap, context))];
      }
      case "FusedBatchNormV3": {
        return [ops.batchNorm(getParamValue("x", node, tensorMap, context), getParamValue("mean", node, tensorMap, context), getParamValue("variance", node, tensorMap, context), getParamValue("offset", node, tensorMap, context), getParamValue("scale", node, tensorMap, context), getParamValue("epsilon", node, tensorMap, context))];
      }
      case "LRN": {
        return [ops.localResponseNormalization(getParamValue("x", node, tensorMap, context), getParamValue("radius", node, tensorMap, context), getParamValue("bias", node, tensorMap, context), getParamValue("alpha", node, tensorMap, context), getParamValue("beta", node, tensorMap, context))];
      }
      case "Softmax": {
        return [ops.softmax(getParamValue("x", node, tensorMap, context))];
      }
      case "LogSoftmax": {
        return [ops.logSoftmax(getParamValue("x", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$7 = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "RaggedGather": {
        const { outputNestedSplits, outputDenseValues } = ops.raggedGather(getParamValue("paramsNestedSplits", node, tensorMap, context), getParamValue("paramsDenseValues", node, tensorMap, context), getParamValue("indices", node, tensorMap, context), getParamValue("outputRaggedRank", node, tensorMap, context));
        return outputNestedSplits.concat(outputDenseValues);
      }
      case "RaggedRange": {
        const { rtNestedSplits, rtDenseValues } = ops.raggedRange(getParamValue("starts", node, tensorMap, context), getParamValue("limits", node, tensorMap, context), getParamValue("splits", node, tensorMap, context));
        return [rtNestedSplits, rtDenseValues];
      }
      case "RaggedTensorToTensor": {
        return [ops.raggedTensorToTensor(getParamValue("shape", node, tensorMap, context), getParamValue("values", node, tensorMap, context), getParamValue("defaultValue", node, tensorMap, context), getParamValue("rowPartitionTensors", node, tensorMap, context), getParamValue("rowPartitionTypes", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$6 = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "Max": {
        const axis = getParamValue("axis", node, tensorMap, context);
        const keepDims = getParamValue("keepDims", node, tensorMap, context);
        return [ops.max(getParamValue("x", node, tensorMap, context), axis, keepDims)];
      }
      case "Mean": {
        const axis = getParamValue("axis", node, tensorMap, context);
        const keepDims = getParamValue("keepDims", node, tensorMap, context);
        return [ops.mean(getParamValue("x", node, tensorMap, context), axis, keepDims)];
      }
      case "Min": {
        const axis = getParamValue("axis", node, tensorMap, context);
        const keepDims = getParamValue("keepDims", node, tensorMap, context);
        return [ops.min(getParamValue("x", node, tensorMap, context), axis, keepDims)];
      }
      case "Sum": {
        const axis = getParamValue("axis", node, tensorMap, context);
        const keepDims = getParamValue("keepDims", node, tensorMap, context);
        return [ops.sum(getParamValue("x", node, tensorMap, context), axis, keepDims)];
      }
      case "All": {
        const axis = getParamValue("axis", node, tensorMap, context);
        const keepDims = getParamValue("keepDims", node, tensorMap, context);
        return [ops.all(getParamValue("x", node, tensorMap, context), axis, keepDims)];
      }
      case "Any": {
        const axis = getParamValue("axis", node, tensorMap, context);
        const keepDims = getParamValue("keepDims", node, tensorMap, context);
        return [ops.any(getParamValue("x", node, tensorMap, context), axis, keepDims)];
      }
      case "ArgMax": {
        const axis = getParamValue("axis", node, tensorMap, context);
        return [ops.argMax(getParamValue("x", node, tensorMap, context), axis)];
      }
      case "ArgMin": {
        const axis = getParamValue("axis", node, tensorMap, context);
        return [ops.argMin(getParamValue("x", node, tensorMap, context), axis)];
      }
      case "Prod": {
        const axis = getParamValue("axis", node, tensorMap, context);
        const keepDims = getParamValue("keepDims", node, tensorMap, context);
        return [ops.prod(getParamValue("x", node, tensorMap, context), axis, keepDims)];
      }
      case "Cumprod": {
        const axis = getParamValue("axis", node, tensorMap, context);
        const exclusive = getParamValue("exclusive", node, tensorMap, context);
        const reverse2 = getParamValue("reverse", node, tensorMap, context);
        return [ops.cumprod(getParamValue("x", node, tensorMap, context), axis, exclusive, reverse2)];
      }
      case "Cumsum": {
        const axis = getParamValue("axis", node, tensorMap, context);
        const exclusive = getParamValue("exclusive", node, tensorMap, context);
        const reverse2 = getParamValue("reverse", node, tensorMap, context);
        return [ops.cumsum(getParamValue("x", node, tensorMap, context), axis, exclusive, reverse2)];
      }
      case "Bincount":
        const x = getParamValue("x", node, tensorMap, context);
        const weights = getParamValue("weights", node, tensorMap, context);
        const size = getParamValue("size", node, tensorMap, context);
        return [ops.bincount(x, weights, size)];
      case "DenseBincount": {
        const x2 = getParamValue("x", node, tensorMap, context);
        const weights2 = getParamValue("weights", node, tensorMap, context);
        const size2 = getParamValue("size", node, tensorMap, context);
        const binaryOutput = getParamValue("binaryOutput", node, tensorMap, context);
        return [ops.denseBincount(x2, weights2, size2, binaryOutput)];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$5 = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "ConcatV2":
      case "Concat": {
        const n = getParamValue("n", node, tensorMap, context);
        const axis = getParamValue("axis", node, tensorMap, context);
        let inputs = getParamValue("tensors", node, tensorMap, context);
        inputs = inputs.slice(0, n);
        return [ops.concat(inputs, axis)];
      }
      case "Gather": {
        const input = getParamValue("x", node, tensorMap, context);
        const indices = getParamValue("indices", node, tensorMap, context);
        return [ops.gather(input, ops.cast(indices, "int32"), 0)];
      }
      case "GatherV2": {
        const axis = getParamValue("axis", node, tensorMap, context);
        const batchDims = getParamValue("batchDims", node, tensorMap, context);
        const input = getParamValue("x", node, tensorMap, context);
        const indices = getParamValue("indices", node, tensorMap, context);
        return [ops.gather(input, ops.cast(indices, "int32"), axis, batchDims)];
      }
      case "Reverse": {
        const dims = getParamValue("dims", node, tensorMap, context);
        const axis = [];
        for (let i = 0; i < dims.length; i++) {
          if (dims[i]) {
            axis.push(i);
          }
        }
        const input = getParamValue("x", node, tensorMap, context);
        return [ops.reverse(input, axis)];
      }
      case "ReverseV2": {
        const axis = getParamValue("axis", node, tensorMap, context);
        const input = getParamValue("x", node, tensorMap, context);
        return [ops.reverse(input, axis)];
      }
      case "Slice": {
        const begin = getParamValue("begin", node, tensorMap, context);
        const size = getParamValue("size", node, tensorMap, context);
        return [ops.slice(getParamValue("x", node, tensorMap, context), begin, size)];
      }
      case "StridedSlice": {
        const begin = getParamValue("begin", node, tensorMap, context);
        const end = getParamValue("end", node, tensorMap, context);
        const strides = getParamValue("strides", node, tensorMap, context);
        const beginMask = getParamValue("beginMask", node, tensorMap, context);
        const endMask = getParamValue("endMask", node, tensorMap, context);
        const ellipsisMask = getParamValue("ellipsisMask", node, tensorMap, context);
        const newAxisMask = getParamValue("newAxisMask", node, tensorMap, context);
        const shrinkAxisMask = getParamValue("shrinkAxisMask", node, tensorMap, context);
        const tensor2 = getParamValue("x", node, tensorMap, context);
        return [ops.stridedSlice(tensor2, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];
      }
      case "Pack": {
        return tidy(() => {
          const axis = getParamValue("axis", node, tensorMap, context);
          const tensors = getParamValue("tensors", node, tensorMap, context);
          const shape = tensors[0].shape;
          const squeezedShape = ops.squeeze(tensors[0]).shape;
          const mapped = tensors.map((tensor2) => {
            const sameShape = arraysEqual(tensor2.shape, shape);
            if (!sameShape && !arraysEqual(ops.squeeze(tensor2).shape, squeezedShape)) {
              throw new Error("the input tensors shape does not match");
            }
            return sameShape ? tensor2 : ops.reshape(tensor2, shape);
          });
          return [ops.stack(mapped, axis)];
        });
      }
      case "Unpack": {
        const axis = getParamValue("axis", node, tensorMap, context);
        const tensor2 = getParamValue("tensor", node, tensorMap, context);
        return ops.unstack(tensor2, axis);
      }
      case "Tile": {
        const reps = getParamValue("reps", node, tensorMap, context);
        return [ops.tile(getParamValue("x", node, tensorMap, context), reps)];
      }
      case "Split":
      case "SplitV": {
        const axis = getParamValue("axis", node, tensorMap, context);
        const numOrSizeSplits = getParamValue("numOrSizeSplits", node, tensorMap, context);
        const tensor2 = getParamValue("x", node, tensorMap, context);
        return ops.split(tensor2, numOrSizeSplits, axis);
      }
      case "ScatterNd": {
        const indices = getParamValue("indices", node, tensorMap, context);
        const values = getParamValue("values", node, tensorMap, context);
        const shape = getParamValue("shape", node, tensorMap, context);
        return [ops.scatterND(indices, values, shape)];
      }
      case "GatherNd": {
        const x = getParamValue("x", node, tensorMap, context);
        const indices = getParamValue("indices", node, tensorMap, context);
        return [ops.gatherND(x, indices)];
      }
      case "SparseToDense": {
        const indices = getParamValue("sparseIndices", node, tensorMap, context);
        const shape = getParamValue("outputShape", node, tensorMap, context);
        const sparseValues = getParamValue("sparseValues", node, tensorMap, context);
        const defaultValue = getParamValue("defaultValue", node, tensorMap, context);
        return [ops.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : ops.cast(defaultValue, sparseValues.dtype))];
      }
      case "TensorScatterUpdate": {
        const indices = getParamValue("indices", node, tensorMap, context);
        const values = getParamValue("values", node, tensorMap, context);
        const tensor2 = getParamValue("tensor", node, tensorMap, context);
        return [ops.tensorScatterUpdate(tensor2, indices, values)];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$4 = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "SparseFillEmptyRows": {
        const { outputIndices, outputValues, emptyRowIndicator, reverseIndexMap } = ops.sparse.sparseFillEmptyRows(getParamValue("indices", node, tensorMap, context), getParamValue("values", node, tensorMap, context), getParamValue("denseShape", node, tensorMap, context), getParamValue("defaultValue", node, tensorMap, context));
        return [
          outputIndices,
          outputValues,
          emptyRowIndicator,
          reverseIndexMap
        ];
      }
      case "SparseReshape": {
        const { outputIndices, outputShape } = ops.sparse.sparseReshape(getParamValue("inputIndices", node, tensorMap, context), getParamValue("inputShape", node, tensorMap, context), getParamValue("newShape", node, tensorMap, context));
        return [outputIndices, outputShape];
      }
      case "SparseSegmentMean": {
        const outputData = ops.sparse.sparseSegmentMean(getParamValue("data", node, tensorMap, context), getParamValue("indices", node, tensorMap, context), getParamValue("segmentIds", node, tensorMap, context));
        return [outputData];
      }
      case "SparseSegmentSum": {
        const outputData = ops.sparse.sparseSegmentSum(getParamValue("data", node, tensorMap, context), getParamValue("indices", node, tensorMap, context), getParamValue("segmentIds", node, tensorMap, context));
        return [outputData];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$3 = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "FFT": {
        return [ops.fft(getParamValue("x", node, tensorMap, context))];
      }
      case "IFFT": {
        return [ops.ifft(getParamValue("x", node, tensorMap, context))];
      }
      case "RFFT": {
        return [ops.rfft(getParamValue("x", node, tensorMap, context))];
      }
      case "IRFFT": {
        return [ops.irfft(getParamValue("x", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$2 = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "StaticRegexReplace": {
        return [ops.string.staticRegexReplace(getParamValue("input", node, tensorMap, context), getParamValue("pattern", node, tensorMap, context), getParamValue("rewrite", node, tensorMap, context), getParamValue("replaceGlobal", node, tensorMap, context))];
      }
      case "StringNGrams": {
        const { nGrams, nGramsSplits } = ops.string.stringNGrams(getParamValue("data", node, tensorMap, context), getParamValue("dataSplits", node, tensorMap, context), getParamValue("separator", node, tensorMap, context), getParamValue("nGramWidths", node, tensorMap, context), getParamValue("leftPad", node, tensorMap, context), getParamValue("rightPad", node, tensorMap, context), getParamValue("padWidth", node, tensorMap, context), getParamValue("preserveShortSequences", node, tensorMap, context));
        return [nGrams, nGramsSplits];
      }
      case "StringSplit": {
        const { indices, values, shape } = ops.string.stringSplit(getParamValue("input", node, tensorMap, context), getParamValue("delimiter", node, tensorMap, context), getParamValue("skipEmpty", node, tensorMap, context));
        return [indices, values, shape];
      }
      case "StringToHashBucketFast": {
        const output = ops.string.stringToHashBucketFast(getParamValue("input", node, tensorMap, context), getParamValue("numBuckets", node, tensorMap, context));
        return [output];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const executeOp$1 = (node, tensorMap, context, ops = tfOps) => {
    switch (node.op) {
      case "Cast": {
        return [ops.cast(getParamValue("x", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
      }
      case "ExpandDims": {
        const axis = getParamValue("axis", node, tensorMap, context);
        return [ops.expandDims(getParamValue("x", node, tensorMap, context), axis)];
      }
      case "Squeeze": {
        const axis = getParamValue("axis", node, tensorMap, context);
        return [ops.squeeze(getParamValue("x", node, tensorMap, context), axis)];
      }
      case "Reshape": {
        return [ops.reshape(getParamValue("x", node, tensorMap, context), getParamValue("shape", node, tensorMap, context))];
      }
      case "EnsureShape": {
        return [ops.ensureShape(getParamValue("x", node, tensorMap, context), getParamValue("shape", node, tensorMap, context))];
      }
      case "MirrorPad": {
        return [ops.mirrorPad(getParamValue("x", node, tensorMap, context), getParamValue("padding", node, tensorMap, context), getParamValue("mode", node, tensorMap, context))];
      }
      case "PadV2":
      case "Pad": {
        return [ops.pad(getParamValue("x", node, tensorMap, context), getParamValue("padding", node, tensorMap, context), getParamValue("constantValue", node, tensorMap, context))];
      }
      case "SpaceToBatchND": {
        const blockShape = getParamValue("blockShape", node, tensorMap, context);
        const paddings = getParamValue("paddings", node, tensorMap, context);
        return [ops.spaceToBatchND(getParamValue("x", node, tensorMap, context), blockShape, paddings)];
      }
      case "BatchToSpaceND": {
        const blockShape = getParamValue("blockShape", node, tensorMap, context);
        const crops = getParamValue("crops", node, tensorMap, context);
        return [ops.batchToSpaceND(getParamValue("x", node, tensorMap, context), blockShape, crops)];
      }
      case "DepthToSpace": {
        const blockSize = getParamValue("blockSize", node, tensorMap, context);
        const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
        return [ops.depthToSpace(getParamValue("x", node, tensorMap, context), blockSize, dataFormat)];
      }
      case "BroadcastTo": {
        return [ops.broadcastTo(getParamValue("x", node, tensorMap, context), getParamValue("shape", node, tensorMap, context))];
      }
      case "BroadcastArgs": {
        return [ops.broadcastArgs(getParamValue("s0", node, tensorMap, context), getParamValue("s1", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function executeOp(node, tensorMap, context, resourceManager, tidy$1 = tidy) {
    const value = ((node2, tensorMap2, context2) => {
      switch (node2.category) {
        case "arithmetic":
          return tidy$1(() => executeOp$k(node2, tensorMap2, context2));
        case "basic_math":
          return tidy$1(() => executeOp$j(node2, tensorMap2, context2));
        case "control":
          return executeOp$i(node2, tensorMap2, context2);
        case "convolution":
          return tidy$1(() => executeOp$h(node2, tensorMap2, context2));
        case "creation":
          return tidy$1(() => executeOp$g(node2, tensorMap2, context2));
        case "dynamic":
          return executeOp$f(node2, tensorMap2, context2);
        case "evaluation":
          return tidy$1(() => executeOp$e(node2, tensorMap2, context2));
        case "image":
          return tidy$1(() => executeOp$b(node2, tensorMap2, context2));
        case "graph":
          return tidy$1(() => executeOp$d(node2, tensorMap2, context2));
        case "logical":
          return tidy$1(() => executeOp$a(node2, tensorMap2, context2));
        case "matrices":
          return tidy$1(() => executeOp$9(node2, tensorMap2, context2));
        case "normalization":
          return tidy$1(() => executeOp$8(node2, tensorMap2, context2));
        case "ragged":
          return tidy$1(() => executeOp$7(node2, tensorMap2, context2));
        case "reduction":
          return tidy$1(() => executeOp$6(node2, tensorMap2, context2));
        case "slice_join":
          return tidy$1(() => executeOp$5(node2, tensorMap2, context2));
        case "sparse":
          return tidy$1(() => executeOp$4(node2, tensorMap2, context2));
        case "spectral":
          return tidy$1(() => executeOp$3(node2, tensorMap2, context2));
        case "string":
          return tidy$1(() => executeOp$2(node2, tensorMap2, context2));
        case "transformation":
          return tidy$1(() => executeOp$1(node2, tensorMap2, context2));
        case "hash_table":
          return executeOp$c(node2, tensorMap2, context2, resourceManager);
        case "custom":
          const opMapper = getRegisteredOp(node2.op);
          if (opMapper && opMapper.customExecutor) {
            return opMapper.customExecutor(new NodeValueImpl(node2, tensorMap2, context2));
          } else {
            throw TypeError(`Custom op ${node2.op} is not registered.`);
          }
        default:
          throw TypeError(`Unknown op '${node2.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`);
      }
    })(node, tensorMap, context);
    if (isPromise(value)) {
      return value.then((data) => [].concat(data));
    }
    return [].concat(value);
  }
  class ExecutionContext {
    constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}, parseNodeNameCache) {
      this.weightMap = weightMap;
      this.tensorArrayMap = tensorArrayMap;
      this.tensorListMap = tensorListMap;
      this.functionMap = functionMap;
      this.parseNodeNameCache = parseNodeNameCache;
      this.rootContext = { id: 0, frameName: "", iterationId: 0 };
      this.contexts = [this.rootContext];
      this.lastId = 0;
      this.generateCurrentContextIds();
    }
    newFrame(id, frameName) {
      return { id, frameName, iterationId: 0 };
    }
    /**
     * Set the current context
     * @param contexts: ExecutionContextInfo[] the current path of execution
     * frames
     */
    set currentContext(contexts2) {
      if (this.contexts !== contexts2) {
        this.contexts = contexts2;
        this.generateCurrentContextIds();
      }
    }
    get currentContext() {
      return this.contexts;
    }
    /**
     * Returns the current context in string format.
     */
    get currentContextId() {
      return this._currentContextIds[0];
    }
    /**
     * Returns the current context and all parent contexts in string format.
     * This allow access to the nodes in the current and parent frames.
     */
    get currentContextIds() {
      return this._currentContextIds;
    }
    generateCurrentContextIds() {
      const names = [];
      for (let i = 0; i < this.contexts.length - 1; i++) {
        const contexts2 = this.contexts.slice(0, this.contexts.length - i);
        names.push(this.contextIdforContexts(contexts2));
      }
      names.push("");
      this._currentContextIds = names;
    }
    contextIdforContexts(contexts2) {
      return contexts2 ? contexts2.map((context) => context.id === 0 && context.iterationId === 0 ? "" : `${context.frameName}-${context.iterationId}`).join("/") : "";
    }
    /**
     * Enter a new frame, a new context is pushed on the current context list.
     * @param frameId new frame id
     */
    enterFrame(frameId) {
      if (this.contexts) {
        this.lastId++;
        this.contexts = this.contexts.slice();
        this.contexts.push(this.newFrame(this.lastId, frameId));
        this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));
      }
    }
    /**
     * Exit the current frame, the last context is removed from the current
     * context list.
     */
    exitFrame() {
      if (this.contexts && this.contexts.length > 1) {
        this.contexts = this.contexts.slice();
        this.contexts.splice(-1);
        this.currentContextIds.shift();
      } else {
        throw new Error("Cannot exit frame, the context is empty");
      }
    }
    /**
     * Enter the next iteration of a loop, the iteration id of last context is
     * increased.
     */
    nextIteration() {
      if (this.contexts && this.contexts.length > 0) {
        this.contexts = this.contexts.slice();
        this.lastId++;
        const context = Object.assign({}, this.contexts[this.contexts.length - 1]);
        context.iterationId += 1;
        context.id = this.lastId;
        this.contexts.splice(-1, 1, context);
        this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
      } else {
        throw new Error("Cannot increase frame iteration, the context is empty");
      }
    }
    getWeight(name) {
      return this.weightMap[name];
    }
    addTensorArray(tensorArray) {
      this.tensorArrayMap[tensorArray.id] = tensorArray;
    }
    getTensorArray(id) {
      return this.tensorArrayMap[id];
    }
    addTensorList(tensorList) {
      this.tensorListMap[tensorList.id] = tensorList;
    }
    getTensorList(id) {
      return this.tensorListMap[id];
    }
    dispose(keepIds) {
      for (const key in this.tensorArrayMap) {
        this.tensorArrayMap[key].clearAndClose(keepIds);
      }
      for (const key in this.tensorListMap) {
        this.tensorListMap[key].clearAndClose(keepIds);
      }
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {
    const usedNodes = /* @__PURE__ */ new Set();
    const missingInputs = [];
    let dynamicNode = null;
    let syncInputs = null;
    const seen2 = /* @__PURE__ */ new Set();
    const inputNodeNames = new Set(Object.keys(inputs).map((name) => parseNodeName(name)[0]));
    initNodes = initNodes || [];
    const initNodeNames = new Set(initNodes.map((node) => parseNodeName(node.name)[0]));
    const frontier = [...outputs];
    while (frontier.length > 0) {
      const node = frontier.pop();
      if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {
        if (dynamicNode == null) {
          dynamicNode = node;
          syncInputs = dynamicNode.children.map((child) => child.name).filter((name) => usedNodes.has(name));
        }
      }
      usedNodes.add(node.name);
      if (weightMap[node.name] != null) {
        continue;
      }
      if (inputNodeNames.has(node.name)) {
        continue;
      }
      if (initNodeNames.has(node.name)) {
        continue;
      }
      if (node.inputs.length === 0) {
        missingInputs.push(node.name);
        continue;
      }
      node.inputs.forEach((input) => {
        if (seen2.has(input.name)) {
          return;
        }
        seen2.add(input.name);
        frontier.push(input);
      });
    }
    return { inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs };
  }
  function getNodesInTopologicalOrder(graph2, executionInfo) {
    const { usedNodes, inputs } = executionInfo;
    const inputNodes = Object.keys(inputs).map((name) => parseNodeName(name)[0]).map((name) => graph2.nodes[name]);
    const initNodes = graph2.initNodes || [];
    const isUsed = (node) => usedNodes.has(typeof node === "string" ? node : node.name);
    function unique2(nodes) {
      return [...new Map(nodes.map((node) => [node.name, node])).values()];
    }
    const predefinedNodes = unique2([
      ...inputNodes,
      ...graph2.weights,
      ...initNodes
    ]).filter(isUsed);
    const allNodes = unique2([
      ...predefinedNodes,
      ...Object.values(graph2.nodes)
    ]).filter(isUsed);
    const nameToNode = new Map(allNodes.map((node) => [node.name, node]));
    const inCounts = {};
    for (const node of allNodes) {
      inCounts[node.name] = inCounts[node.name] || 0;
      for (const child of node.children) {
        if (!isUsed(child)) {
          inCounts[child.name] = Number.POSITIVE_INFINITY;
        }
        inCounts[child.name] = (inCounts[child.name] || 0) + 1;
      }
    }
    const frontier = Object.entries(inCounts).filter(([, inCount]) => inCount === 0).map(([name]) => name);
    const orderedNodeNames = [...frontier];
    while (frontier.length > 0) {
      const nodeName = frontier.pop();
      const node = nameToNode.get(nodeName);
      for (const child of node.children.filter(isUsed)) {
        if (--inCounts[child.name] === 0) {
          orderedNodeNames.push(child.name);
          frontier.push(child.name);
        }
      }
    }
    const orderedNodes = orderedNodeNames.map((name) => nameToNode.get(name));
    const filteredOrderedNodes = filterPredefinedReachableNodes(orderedNodes, predefinedNodes);
    validateNodesExecutionOrder(filteredOrderedNodes, predefinedNodes);
    return filteredOrderedNodes;
  }
  function filterPredefinedReachableNodes(orderedNodes, predefinedNodes) {
    const nameToNode = new Map(orderedNodes.map((node) => [node.name, node]));
    const stack2 = predefinedNodes.map((node) => node.name);
    const predefinedReachableNodeNames = new Set(stack2);
    while (stack2.length > 0) {
      const nodeName = stack2.pop();
      const node = nameToNode.get(nodeName);
      for (const child of node.children) {
        if (!nameToNode.has(child.name) || predefinedReachableNodeNames.has(child.name)) {
          continue;
        }
        predefinedReachableNodeNames.add(child.name);
        stack2.push(child.name);
      }
    }
    const filteredOrderedNodes = orderedNodes.filter((node) => predefinedReachableNodeNames.has(node.name));
    return filteredOrderedNodes;
  }
  class NodesExecutionOrderError extends Error {
    constructor(message) {
      super(`NodesExecutionOrderError: ${message}`);
    }
  }
  function validateNodesExecutionOrder(orderedNodes, predefinedNodes) {
    const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));
    const predefinedNodeNames = new Set(predefinedNodes.map((node) => node.name));
    const isPredefined = (node) => predefinedNodeNames.has(typeof node === "string" ? node : node.name);
    const willBeExecutedNodeNames = new Set(orderedNodes.map((node) => node.name));
    const willBeExecuted = (node) => willBeExecutedNodeNames.has(typeof node === "string" ? node : node.name);
    for (const node of orderedNodes) {
      for (const child of node.children.filter(willBeExecuted)) {
        if (!nodeNameToOrder.has(child.name)) {
          throw new NodesExecutionOrderError(`Child ${child.name} of node ${node.name} is unreachable.`);
        }
        if (nodeNameToOrder.get(node.name) > nodeNameToOrder.get(child.name)) {
          throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run after its child ${child.name}.`);
        }
      }
      if (!isPredefined(node)) {
        for (const input of node.inputs) {
          if (!nodeNameToOrder.has(input.name)) {
            throw new NodesExecutionOrderError(`Input ${input.name} of node ${node.name} is unreachable.`);
          }
          if (nodeNameToOrder.get(input.name) > nodeNameToOrder.get(node.name)) {
            throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run before its input ${input.name}.`);
          }
        }
      }
    }
  }
  function getNodeLiveUntilMap(orderedNodes) {
    const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));
    const INF_LIFE = Number.MAX_SAFE_INTEGER;
    const selfLifespans = orderedNodes.map((node, nodeOrder) => isControlFlow(node) ? INF_LIFE : nodeOrder);
    const getSelfLifeSpan = (node) => {
      const selfLife = selfLifespans[nodeNameToOrder.get(node.name)];
      if (selfLife == null) {
        return -1;
      }
      return selfLife;
    };
    const liveUntilOrders = orderedNodes.map((node, nodeOrder) => {
      return node.children.map(getSelfLifeSpan).reduce((a, b) => Math.max(a, b), selfLifespans[nodeOrder]);
    });
    const liveUntilMap = /* @__PURE__ */ new Map();
    for (let nodeOrder = 0; nodeOrder < orderedNodes.length; ++nodeOrder) {
      const liveUntilOrder = liveUntilOrders[nodeOrder];
      if (liveUntilOrder === INF_LIFE) {
        continue;
      }
      const node = orderedNodes[nodeOrder];
      const liveUntilNode = orderedNodes[liveUntilOrder];
      if (!liveUntilMap.has(liveUntilNode.name)) {
        liveUntilMap.set(liveUntilNode.name, []);
      }
      liveUntilMap.get(liveUntilNode.name).push(node);
    }
    return liveUntilMap;
  }
  const CONTROL_FLOW_OPS = /* @__PURE__ */ new Set([
    "Switch",
    "Merge",
    "Enter",
    "Exit",
    "NextIteration",
    "StatelessIf",
    "StatelessWhile",
    "if",
    "While"
  ]);
  const DYNAMIC_SHAPE_OPS = /* @__PURE__ */ new Set([
    "NonMaxSuppressionV2",
    "NonMaxSuppressionV3",
    "NonMaxSuppressionV5",
    "Where"
  ]);
  const HASH_TABLE_OPS = /* @__PURE__ */ new Set([
    "HashTable",
    "HashTableV2",
    "LookupTableImport",
    "LookupTableImportV2",
    "LookupTableFind",
    "LookupTableFindV2",
    "LookupTableSize",
    "LookupTableSizeV2"
  ]);
  function isControlFlow(node) {
    return CONTROL_FLOW_OPS.has(node.op);
  }
  function isDynamicShape(node) {
    return DYNAMIC_SHAPE_OPS.has(node.op);
  }
  function isHashTable(node) {
    return HASH_TABLE_OPS.has(node.op);
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class GraphExecutor {
    get weightIds() {
      return this.parent ? this.parent.weightIds : this._weightIds;
    }
    get functionExecutorMap() {
      return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
    }
    get weightMap() {
      return this.parent ? this.parent.weightMap : this._weightMap;
    }
    set weightMap(weightMap) {
      const weightIds = Object.keys(weightMap).map((key) => weightMap[key].map((tensor2) => tensor2.id));
      this._weightIds = [].concat(...weightIds);
      this._weightMap = weightMap;
    }
    /**
     * Set `ResourceManager` shared by executors of a model.
     * @param resourceManager: `ResourceManager` of the `GraphModel`.
     */
    set resourceManager(resourceManager) {
      this._resourceManager = resourceManager;
    }
    get inputs() {
      return this._inputs.map((node) => {
        return {
          name: node.name,
          shape: node.attrParams["shape"] ? node.attrParams["shape"].value : void 0,
          dtype: node.attrParams["dtype"] ? node.attrParams["dtype"].value : void 0
        };
      });
    }
    get outputs() {
      return this._outputs.map((node) => {
        return {
          name: node.name,
          shape: node.attrParams["shape"] ? node.attrParams["shape"].value : void 0,
          dtype: node.attrParams["dtype"] ? node.attrParams["dtype"].value : void 0
        };
      });
    }
    get inputNodes() {
      return this._inputs.map((node) => node.signatureKey || node.name);
    }
    get outputNodes() {
      return this._outputs.map((node) => {
        const name = node.signatureKey || node.name;
        return node.defaultOutput ? `${name}:${node.defaultOutput}` : name;
      });
    }
    get functions() {
      return Object.keys(this._functions).reduce((map, key) => {
        map[key] = this._functions[key].signature;
        return map;
      }, {});
    }
    /**
     *
     * @param graph Graph the model or function graph to be executed.
     * @param parent When building function exector you need to set the parent
     * executor. Since the weights and function executor maps are set at parant
     * level, that function executor can access the function maps and weight maps
     * through the parent.
     */
    constructor(graph2, parent) {
      this.graph = graph2;
      this.parent = parent;
      this.compiledMap = /* @__PURE__ */ new Map();
      this.parseNodeNameCache = /* @__PURE__ */ new Map();
      this._weightMap = {};
      this.SEPARATOR = ",";
      this._functions = {};
      this._functionExecutorMap = {};
      this.keepIntermediateTensors = false;
      this._outputs = graph2.outputs;
      this._inputs = graph2.inputs;
      this._initNodes = graph2.initNodes;
      this._signature = graph2.signature;
      this._functions = graph2.functions;
      if (graph2.functions != null) {
        Object.keys(graph2.functions).forEach((name) => {
          this._functionExecutorMap[name] = new GraphExecutor(graph2.functions[name], this);
        });
      }
    }
    getCompilationKey(inputs, outputs) {
      const sortedInputs = inputs.map((node) => node.name).sort();
      const sortedOutputs = outputs.map((node) => node.name).sort();
      return sortedInputs.join(this.SEPARATOR) + "--" + sortedOutputs.join(this.SEPARATOR);
    }
    /**
     * Compiles the inference graph and returns the minimal set of nodes that are
     * required for execution, in the correct execution order.
     * @returns {Object} compilation The compile result.
     * @returns {Node[]} compilation.orderedNodes Nodes in the correct execution
     *     order.
     * @returns {Map<string, Node[]>} compilation.nodeLiveUntilMap A map from node
     *     to disposable nodes after its execution. That is, for a node `x`,
     *     `nodeLiveUntilMap[x]` indicates all nodes whose intermediate
     *     tensors should be disposed after `x` is executed.
     */
    compile(inputs, outputs) {
      const executionInfo = getExecutionSubgraph(inputs, outputs, this.weightMap, this._initNodes);
      const { missingInputs, dynamicNode, syncInputs } = executionInfo;
      if (dynamicNode != null) {
        throw new Error(`This execution contains the node '${dynamicNode.name}', which has the dynamic op '${dynamicNode.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${syncInputs}]`);
      }
      if (missingInputs.length > 0) {
        const outNames = outputs.map((n) => n.name);
        const inNames = Object.keys(inputs);
        throw new Error(`Cannot compute the outputs [${outNames}] from the provided inputs [${inNames}]. Missing the following inputs: [${missingInputs}]`);
      }
      const orderedNodes = getNodesInTopologicalOrder(this.graph, executionInfo);
      const nodeLiveUntilMap = getNodeLiveUntilMap(orderedNodes);
      return { orderedNodes, nodeLiveUntilMap };
    }
    cloneAndKeepTensor(tensor2) {
      if (tensor2 == null) {
        return null;
      }
      const clone2 = tensor2.clone();
      keep(clone2);
      return clone2;
    }
    cloneTensorList(tensors) {
      if (!tensors) {
        return null;
      }
      const clonedTensor = tensors.map((tensor2) => {
        return this.cloneAndKeepTensor(tensor2);
      });
      return clonedTensor;
    }
    cloneTensorMap(tensorsMap) {
      return Object.fromEntries(Object.entries(tensorsMap).map(([name, tensorsList]) => {
        return [name, this.cloneTensorList(tensorsList)];
      }));
    }
    /**
     * Executes the inference for given input tensors.
     * @param inputs Tensor map for the model inputs, keyed by the input node
     * names.
     * @param outputs Optional. output node name from the Tensorflow model, if
     * no outputs are specified, the default outputs of the model would be used.
     * You can inspect intermediate nodes of the model by adding them to the
     * outputs array.
     */
    execute(inputs, outputs) {
      this.disposeIntermediateTensors();
      inputs = this.mapInputs(inputs);
      const names = Object.keys(inputs).sort();
      this.checkInputs(inputs);
      this.checkInputShapeAndType(inputs);
      outputs = this.mapOutputs(outputs);
      this.checkOutputs(outputs);
      const inputNodes = names.map((name) => this.graph.nodes[parseNodeName(name)[0]]);
      const outputNodeNames = outputs.map((name) => parseNodeName(name)[0]);
      const outputNodeNameSet = new Set(outputNodeNames);
      let outputNodes = outputNodeNames.map((name) => this.graph.nodes[name]);
      if (outputNodes.length === 0) {
        outputNodes = this._outputs;
      }
      const compilationKey = this.getCompilationKey(inputNodes, outputNodes);
      let compilation = this.compiledMap.get(compilationKey);
      if (compilation == null) {
        compilation = this.compile(inputs, outputNodes);
        this.compiledMap.set(compilationKey, compilation);
      }
      try {
        this.keepIntermediateTensors = env().getBool("KEEP_INTERMEDIATE_TENSORS");
      } catch (e) {
        this.keepIntermediateTensors = false;
        console.warn(e.message);
      }
      const tensorArrayMap = {};
      const tensorListMap = {};
      return tidy(() => {
        const context = new ExecutionContext(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap, this.parseNodeNameCache);
        const tensorsMap = Object.assign({}, this.weightMap);
        if (this.keepIntermediateTensors) {
          this.clonedTensorsMap = this.cloneTensorMap(this.weightMap);
        }
        Object.keys(inputs).forEach((name) => {
          const [nodeName, index2] = parseNodeName(name, context);
          const tensors = [];
          tensors[index2] = inputs[name];
          tensorsMap[nodeName] = tensors;
          if (this.keepIntermediateTensors) {
            this.clonedTensorsMap[nodeName] = this.cloneTensorList(tensors);
          }
        });
        const tensorsToKeep = this.getFrozenTensorIds(tensorsMap);
        const { orderedNodes, nodeLiveUntilMap } = compilation;
        for (const node of orderedNodes) {
          if (tensorsMap[node.name]) {
            continue;
          }
          const tensors = executeOp(node, tensorsMap, context, this._resourceManager);
          if (isPromise(tensors)) {
            throw new Error(`The execution of the op '${node.op}' returned a promise. Please use model.executeAsync() instead.`);
          }
          tensorsMap[node.name] = tensors;
          if (this.keepIntermediateTensors) {
            this.clonedTensorsMap[node.name] = this.cloneTensorList(tensors);
          }
          this.checkTensorForDisposalWithNodeLiveUntilInfo(node, tensorsMap, context, tensorsToKeep, outputNodeNameSet, nodeLiveUntilMap.get(node.name));
        }
        if (this.parent == null) {
          context.dispose(tensorsToKeep);
        }
        return outputs.map((name) => getTensor(name, tensorsMap, context));
      });
    }
    getFrozenTensorIds(tensorMap) {
      const ids = [].concat.apply([], Object.keys(tensorMap).map((key) => tensorMap[key]).map((tensors) => tensors.map((tensor2) => tensor2.id)));
      return new Set(ids);
    }
    checkTensorForDisposal(nodeName, node, tensorMap, context, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount) {
      if (isControlFlow(node) || outputNodeNameSet.has(nodeName)) {
        return;
      }
      for (const tensor2 of tensorMap[nodeName]) {
        if (tensor2 == null) {
          continue;
        }
        intermediateTensorConsumerCount[tensor2.id] = (intermediateTensorConsumerCount[tensor2.id] || 0) + node.children.length;
      }
      for (const input of node.inputs) {
        if (isControlFlow(input)) {
          continue;
        }
        const tensors = getTensorsForCurrentContext(input.name, tensorMap, context);
        if (tensors == null) {
          continue;
        }
        for (const tensor2 of tensors) {
          if (!tensor2 || tensor2.kept || tensorsToKeep.has(tensor2.id)) {
            continue;
          }
          const count = intermediateTensorConsumerCount[tensor2.id];
          if (count === 1) {
            tensor2.dispose();
            delete intermediateTensorConsumerCount[tensor2.id];
          } else if (count != null) {
            intermediateTensorConsumerCount[tensor2.id]--;
          }
        }
      }
    }
    checkTensorForDisposalWithNodeLiveUntilInfo(node, tensorMap, context, tensorsToKeep, outputNodeNameSet, liveUntilNodes) {
      function isNonDisposableNode(node2) {
        return isControlFlow(node2) || outputNodeNameSet.has(node2.name);
      }
      if (isControlFlow(node) || liveUntilNodes == null) {
        return;
      }
      for (const nodeToDispose of liveUntilNodes) {
        if (isNonDisposableNode(nodeToDispose)) {
          continue;
        }
        const tensors = getTensorsForCurrentContext(nodeToDispose.name, tensorMap, context);
        for (const tensor2 of tensors) {
          if (!tensor2 || tensor2.kept || tensorsToKeep.has(tensor2.id)) {
            continue;
          }
          tensor2.dispose();
        }
      }
    }
    /**
     * Executes the inference for given input tensors in Async fashion.
     * @param inputs Tensor map for the model inputs, keyed by the input node
     * names.
     * @param outputs output node name from the Tensorflow model, if no outputs
     * are specified, the default outputs of the model would be used. You can
     * inspect intermediate nodes of the model by adding them to the outputs
     * array.
     */
    async executeAsync(inputs, outputs) {
      return this._executeAsync(inputs, outputs);
    }
    disposeIntermediateTensors() {
      if (!this.clonedTensorsMap) {
        return;
      }
      Object.values(this.clonedTensorsMap).forEach((tensorsList) => {
        for (const tensor2 of tensorsList) {
          if (tensor2 && !tensor2.isDisposed) {
            tensor2.dispose();
          }
        }
      });
      this.clonedTensorsMap = null;
    }
    getIntermediateTensors() {
      return this.clonedTensorsMap;
    }
    /**
     * Executes the inference for given input tensors in Async fashion.
     * @param inputs Tensor map for the model inputs, keyed by the input node
     * names.
     * @param outputs Optional. output node name from the Tensorflow model,
     * if no outputs are specified, the default outputs of the model would be
     * used. You can inspect intermediate nodes of the model by adding them to
     * the outputs array.
     * @param isFunctionExecution Optional. Flag for executing a function.
     * @param tensorArrayMap Optional, global TensorArray map by id. Used for
     * function execution.
     * @param tensorArrayMap Optional global TensorList map by id. Used for
     * function execution.
     */
    async _executeAsync(inputs, outputs, isFunctionExecution = false, tensorArrayMap = {}, tensorListMap = {}) {
      this.disposeIntermediateTensors();
      if (!isFunctionExecution) {
        inputs = this.mapInputs(inputs);
        this.checkInputs(inputs);
        this.checkInputShapeAndType(inputs);
        outputs = this.mapOutputs(outputs);
        this.checkOutputs(outputs);
      }
      try {
        this.keepIntermediateTensors = env().getBool("KEEP_INTERMEDIATE_TENSORS");
      } catch (e) {
        this.keepIntermediateTensors = false;
        console.warn(e.message);
      }
      const context = new ExecutionContext(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap, this.parseNodeNameCache);
      if (this.keepIntermediateTensors) {
        this.clonedTensorsMap = this.cloneTensorMap(this.weightMap);
      }
      const tensorsMap = await this.executeWithControlFlow(inputs, context, outputs, isFunctionExecution);
      const results = outputs.map((name) => getTensor(name, tensorsMap, context));
      const outputIds = results.map((t) => t.id);
      const inputIds = Object.keys(inputs).map((name) => inputs[name].id);
      const keepIds = /* @__PURE__ */ new Set([...outputIds, ...inputIds, ...this.weightIds]);
      Object.values(tensorsMap).forEach((tensorsList) => {
        tensorsList.forEach((tensor2) => {
          if (tensor2 && !tensor2.isDisposed && !keepIds.has(tensor2.id)) {
            tensor2.dispose();
          }
        });
      });
      if (this.parent == null) {
        context.dispose(keepIds);
      }
      return results;
    }
    async executeFunctionAsync(inputs, tensorArrayMap, tensorListMap) {
      const mappedInputs = inputs.reduce((map, tensor2, index2) => {
        map[this.inputs[index2].name] = tensor2;
        return map;
      }, {});
      return this._executeAsync(mappedInputs, this.outputNodes, true, tensorArrayMap, tensorListMap);
    }
    /**
     * When there are control flow nodes in the graph, the graph execution use
     * ExecutionContext to keep track of the frames and loop iterators.
     * @param inputs placeholder tensors for the graph.
     * @param context the execution context object for current execution.
     * @param outputNames Optional. output node name from the Tensorflow model,
     * if no outputs are specified, the default outputs of the model would be
     * used. You can inspect intermediate nodes of the model by adding them to
     * the outputs array.
     * @param isFunctionExecution Flag for executing a function.
     */
    async executeWithControlFlow(inputs, context, outputNames, isFunctionExecution) {
      const names = Object.keys(inputs);
      const inputNodes = names.map((name) => this.graph.nodes[parseNodeName(name)[0]]);
      const outputNodeNames = outputNames.map((name) => parseNodeName(name)[0]);
      const outputNodeNameSet = new Set(outputNodeNames);
      let outputNodes = outputNodeNames.map((name) => this.graph.nodes[name]);
      if (outputNodes.length === 0) {
        outputNodes = this._outputs;
      }
      const { usedNodes, missingInputs, dynamicNode, syncInputs } = getExecutionSubgraph(inputs, outputNodes, this.weightMap, this._initNodes);
      const stack2 = [
        ...inputNodes,
        ...this.graph.weights,
        ...this._initNodes || []
      ].map((node) => {
        return { node, contexts: context.currentContext };
      });
      const tensorsMap = Object.assign({}, this.weightMap);
      Object.keys(inputs).forEach((name) => {
        const [nodeName, index2] = parseNodeName(name);
        const tensors = [];
        tensors[index2] = inputs[name];
        tensorsMap[nodeName] = tensors;
      });
      const intermediateTensorConsumerCount = {};
      const tensorsToKeep = this.getFrozenTensorIds(tensorsMap);
      const added = {};
      while (stack2.length > 0) {
        const promises = this.processStack(inputNodes, stack2, context, tensorsMap, added, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount, usedNodes);
        await Promise.all(promises);
      }
      if (dynamicNode == null && !isFunctionExecution) {
        console.warn(`This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.`);
      }
      const missingOutputs = outputNodes.filter((node) => !isControlFlow(node) && !getTensor(node.name, tensorsMap, context)).map((node) => node.name);
      if (missingOutputs.length > 0) {
        let alternativeMsg = "";
        if (dynamicNode != null) {
          alternativeMsg = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${syncInputs}]`;
        }
        throw new Error(`Cannot compute the outputs [${missingOutputs}] from the provided inputs [${names}]. Consider providing the following inputs: [${missingInputs}]. ${alternativeMsg}`);
      }
      return tensorsMap;
    }
    processStack(inputNodes, stack2, context, tensorMap, added, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount, usedNodes) {
      const promises = [];
      while (stack2.length > 0) {
        const item = stack2.pop();
        context.currentContext = item.contexts;
        let nodeName = "";
        if (item.node.op === "Enter" && getParamValue("isConstant", item.node, tensorMap, context)) {
          [nodeName] = getNodeNameAndIndex(item.node.name, context);
        }
        if (tensorMap[item.node.name] == null) {
          const tensors = executeOp(item.node, tensorMap, context, this._resourceManager);
          if (!nodeName) {
            [nodeName] = getNodeNameAndIndex(item.node.name, context);
          }
          const currentContext = context.currentContext;
          if (isPromise(tensors)) {
            promises.push(tensors.then((t) => {
              tensorMap[nodeName] = t;
              if (this.keepIntermediateTensors) {
                this.clonedTensorsMap[nodeName] = this.cloneTensorList(t);
              }
              context.currentContext = currentContext;
              this.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount);
              this.processChildNodes(item.node, stack2, context, tensorMap, added, usedNodes);
              return t;
            }));
          } else {
            tensorMap[nodeName] = tensors;
            if (this.keepIntermediateTensors) {
              this.clonedTensorsMap[nodeName] = this.cloneTensorList(tensors);
            }
            this.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount);
            this.processChildNodes(item.node, stack2, context, tensorMap, added, usedNodes);
          }
        } else {
          this.processChildNodes(item.node, stack2, context, tensorMap, added, usedNodes);
        }
      }
      return promises;
    }
    processChildNodes(node, stack2, context, tensorMap, added, usedNodes) {
      node.children.forEach((childNode) => {
        const [nodeName] = getNodeNameAndIndex(childNode.name, context);
        if (added[nodeName] || !usedNodes.has(childNode.name)) {
          return;
        }
        if (childNode.op === "Merge") {
          if (childNode.inputNames.some((name) => {
            return !!getTensor(name, tensorMap, context);
          })) {
            added[nodeName] = true;
            stack2.push({ contexts: context.currentContext, node: childNode });
          }
        } else if (childNode.inputNames.every((name) => {
          return !!getTensor(name, tensorMap, context);
        })) {
          added[nodeName] = true;
          stack2.push({ contexts: context.currentContext, node: childNode });
        }
      });
    }
    /**
     * Releases the memory used by the weight tensors.
     */
    dispose() {
      Object.keys(this.weightMap).forEach((key) => this.weightMap[key].forEach((tensor2) => tensor2.dispose()));
    }
    checkInputShapeAndType(inputs) {
      Object.keys(inputs).forEach((name) => {
        const input = inputs[name];
        const [nodeName] = parseNodeName(name);
        const node = this.graph.nodes[nodeName];
        if (node.attrParams["shape"] && node.attrParams["shape"].value) {
          const shape = node.attrParams["shape"].value;
          const match = shape.length === input.shape.length && input.shape.every((dim, index2) => shape[index2] === -1 || shape[index2] === dim);
          assert(match, () => `The shape of dict['${node.name}'] provided in model.execute(dict) must be [${shape}], but was [${input.shape}]`);
        }
        if (node.attrParams["dtype"] && node.attrParams["dtype"].value) {
          assert(input.dtype === node.attrParams["dtype"].value, () => `The dtype of dict['${node.name}'] provided in model.execute(dict) must be ${node.attrParams["dtype"].value}, but was ${input.dtype}`);
        }
      });
    }
    mapInputs(inputs) {
      var _a, _b;
      const result = {};
      for (const inputName in inputs) {
        const tensor2 = (_b = (_a = this._signature) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b[inputName];
        if (tensor2 != null) {
          result[tensor2.name] = inputs[inputName];
        } else {
          result[inputName] = inputs[inputName];
        }
      }
      return result;
    }
    checkInputs(inputs) {
      const notInGraph = Object.keys(inputs).filter((name) => {
        const [nodeName] = parseNodeName(name);
        return this.graph.nodes[nodeName] == null;
      });
      if (notInGraph.length > 0) {
        throw new Error(`The dict provided in model.execute(dict) has keys: [${notInGraph}] that are not part of graph`);
      }
    }
    mapOutputs(outputs) {
      return outputs.map((name) => {
        var _a, _b;
        const tensor2 = (_b = (_a = this._signature) === null || _a === void 0 ? void 0 : _a.outputs) === null || _b === void 0 ? void 0 : _b[name];
        if (tensor2 != null) {
          return tensor2.name;
        }
        return name;
      }, {});
    }
    checkOutputs(outputs) {
      outputs.forEach((name) => {
        const [normalizedName] = parseNodeName(name);
        if (!this.graph.nodes[normalizedName]) {
          throw new Error(`The output '${name}' is not found in the graph`);
        }
      });
    }
  }
  class ResourceManager {
    constructor(hashTableNameToHandle = {}, hashTableMap = {}) {
      this.hashTableNameToHandle = hashTableNameToHandle;
      this.hashTableMap = hashTableMap;
    }
    /**
     * Register a `HashTable` in the resource manager.
     *
     * The `HashTable` can be retrieved by `resourceManager.getHashTableById`,
     * where id is the table handle tensor's id.
     *
     * @param name Op node name that creates the `HashTable`.
     * @param hashTable The `HashTable` to be added to resource manager.
     */
    addHashTable(name, hashTable2) {
      this.hashTableNameToHandle[name] = hashTable2.handle;
      this.hashTableMap[hashTable2.id] = hashTable2;
    }
    /**
     * Get the table handle by node name.
     * @param name Op node name that creates the `HashTable`. This name is also
     *     used in the inputs list of lookup and import `HashTable` ops.
     */
    getHashTableHandleByName(name) {
      return this.hashTableNameToHandle[name];
    }
    /**
     * Get the actual `HashTable` by its handle tensor's id.
     * @param id The id of the handle tensor.
     */
    getHashTableById(id) {
      return this.hashTableMap[id];
    }
    /**
     * Dispose `ResourceManager`, including its hashTables and tensors in them.
     */
    dispose() {
      for (const key in this.hashTableMap) {
        this.hashTableMap[key].clearAndClose();
        delete this.hashTableMap[key];
      }
      for (const name in this.hashTableNameToHandle) {
        this.hashTableNameToHandle[name].dispose();
        delete this.hashTableNameToHandle[name];
      }
    }
  }
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const TFHUB_SEARCH_PARAM = "?tfjs-format=file";
  const DEFAULT_MODEL_NAME = "model.json";
  class GraphModel {
    // Returns the version information for the tensorflow model GraphDef.
    get modelVersion() {
      return this.version;
    }
    get inputNodes() {
      return this.executor.inputNodes;
    }
    get outputNodes() {
      return this.executor.outputNodes;
    }
    get inputs() {
      return this.executor.inputs;
    }
    get outputs() {
      return this.executor.outputs;
    }
    get weights() {
      return this.executor.weightMap;
    }
    get metadata() {
      return this.artifacts.userDefinedMetadata;
    }
    get modelSignature() {
      return this.signature;
    }
    get modelStructuredOutputKeys() {
      return this.structuredOutputKeys;
    }
    /**
     * @param modelUrl url for the model, or an `io.IOHandler`.
     * @param weightManifestUrl url for the weight file generated by
     * scripts/convert.py script.
     * @param requestOption options for Request, which allows to send credentials
     * and custom headers.
     * @param onProgress Optional, progress callback function, fired periodically
     * before the load is completed.
     */
    constructor(modelUrl, loadOptions = {}, tfio = io) {
      this.modelUrl = modelUrl;
      this.loadOptions = loadOptions;
      this.version = "n/a";
      this.io = tfio;
      if (loadOptions == null) {
        this.loadOptions = {};
      }
      this.resourceManager = new ResourceManager();
    }
    findIOHandler() {
      const path = this.modelUrl;
      if (path.load != null) {
        this.handler = path;
      } else if (this.loadOptions.requestInit != null) {
        this.handler = this.io.browserHTTPRequest(path, this.loadOptions);
      } else {
        const handlers = this.io.getLoadHandlers(path, this.loadOptions);
        if (handlers.length === 0) {
          handlers.push(this.io.browserHTTPRequest(path, this.loadOptions));
        } else if (handlers.length > 1) {
          throw new Error(`Found more than one (${handlers.length}) load handlers for URL '${[path]}'`);
        }
        this.handler = handlers[0];
      }
    }
    /**
     * Loads the model and weight files, construct the in memory weight map and
     * compile the inference graph.
     */
    load() {
      this.findIOHandler();
      if (this.handler.load == null) {
        throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
      }
      const loadResult = this.handler.load();
      if (isPromise(loadResult)) {
        return loadResult.then((artifacts) => {
          if (artifacts.getWeightStream == null) {
            return this.loadSync(artifacts);
          }
          return this.loadStreaming(artifacts);
        });
      }
      return this.loadSync(loadResult);
    }
    /**
     * Synchronously construct the in memory weight map and
     * compile the inference graph.
     *
     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
     */
    loadSync(artifacts) {
      const weightMap = this.io.decodeWeights(artifacts.weightData, artifacts.weightSpecs);
      return this.loadWithWeightMap(artifacts, weightMap);
    }
    async loadStreaming(artifacts) {
      if (artifacts.getWeightStream == null) {
        throw new Error("Model artifacts missing streamWeights function");
      }
      const weightMap = await decodeWeightsStream(artifacts.getWeightStream(), artifacts.weightSpecs);
      return this.loadWithWeightMap(artifacts, weightMap);
    }
    loadWithWeightMap(artifacts, weightMap) {
      this.artifacts = artifacts;
      const graph2 = this.artifacts.modelTopology;
      let signature = this.artifacts.signature;
      if (this.artifacts.userDefinedMetadata != null) {
        const metadata = this.artifacts.userDefinedMetadata;
        if (metadata.signature != null) {
          signature = metadata.signature;
        }
        if (metadata.structuredOutputKeys != null) {
          this.structuredOutputKeys = metadata.structuredOutputKeys;
        }
      }
      this.signature = signature;
      this.version = `${graph2.versions.producer}.${graph2.versions.minConsumer}`;
      this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(graph2, this.signature));
      this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
      this.executor.resourceManager = this.resourceManager;
      if (artifacts.modelInitializer != null && artifacts.modelInitializer.node != null) {
        const initializer = OperationMapper.Instance.transformGraph(artifacts.modelInitializer);
        this.initializer = new GraphExecutor(initializer);
        this.initializer.weightMap = this.executor.weightMap;
        this.initializer.resourceManager = this.resourceManager;
        this.initializerSignature = artifacts.initializerSignature;
      }
      return true;
    }
    /**
     * Save the configuration and/or weights of the GraphModel.
     *
     * An `IOHandler` is an object that has a `save` method of the proper
     * signature defined. The `save` method manages the storing or
     * transmission of serialized data ("artifacts") that represent the
     * model's topology and weights onto or via a specific medium, such as
     * file downloads, local storage, IndexedDB in the web browser and HTTP
     * requests to a server. TensorFlow.js provides `IOHandler`
     * implementations for a number of frequently used saving mediums, such as
     * `tf.io.browserDownloads` and `tf.io.browserLocalStorage`. See `tf.io`
     * for more details.
     *
     * This method also allows you to refer to certain types of `IOHandler`s
     * as URL-like string shortcuts, such as 'localstorage://' and
     * 'indexeddb://'.
     *
     * Example 1: Save `model`'s topology and weights to browser [local
     * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);
     * then load it back.
     *
     * ```js
     * const modelUrl =
     *    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';
     * const model = await tf.loadGraphModel(modelUrl);
     * const zeros = tf.zeros([1, 224, 224, 3]);
     * model.predict(zeros).print();
     *
     * const saveResults = await model.save('localstorage://my-model-1');
     *
     * const loadedModel = await tf.loadGraphModel('localstorage://my-model-1');
     * console.log('Prediction from loaded model:');
     * model.predict(zeros).print();
     * ```
     *
     * @param handlerOrURL An instance of `IOHandler` or a URL-like,
     * scheme-based string shortcut for `IOHandler`.
     * @param config Options for saving the model.
     * @returns A `Promise` of `SaveResult`, which summarizes the result of
     * the saving, such as byte sizes of the saved artifacts for the model's
     *   topology and weight values.
     *
     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
     */
    async save(handlerOrURL, config) {
      if (typeof handlerOrURL === "string") {
        const handlers = this.io.getSaveHandlers(handlerOrURL);
        if (handlers.length === 0) {
          throw new Error(`Cannot find any save handlers for URL '${handlerOrURL}'`);
        } else if (handlers.length > 1) {
          throw new Error(`Found more than one (${handlers.length}) save handlers for URL '${handlerOrURL}'`);
        }
        handlerOrURL = handlers[0];
      }
      if (handlerOrURL.save == null) {
        throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
      }
      return handlerOrURL.save(this.artifacts);
    }
    addStructuredOutputNames(outputTensors) {
      if (this.structuredOutputKeys) {
        const outputTensorsArray = outputTensors instanceof Tensor ? [outputTensors] : outputTensors;
        const outputTensorMap = {};
        outputTensorsArray.forEach((outputTensor, i) => outputTensorMap[this.structuredOutputKeys[i]] = outputTensor);
        return outputTensorMap;
      }
      return outputTensors;
    }
    /**
     * Execute the inference for the input tensors.
     *
     * @param input The input tensors, when there is single input for the model,
     * inputs param should be a `tf.Tensor`. For models with multiple inputs,
     * inputs params should be in either `tf.Tensor`[] if the input order is
     * fixed, or otherwise NamedTensorMap format.
     *
     * For model with multiple inputs, we recommend you use NamedTensorMap as the
     * input type, if you use `tf.Tensor`[], the order of the array needs to
     * follow the
     * order of inputNodes array. @see {@link GraphModel.inputNodes}
     *
     * You can also feed any intermediate nodes using the NamedTensorMap as the
     * input type. For example, given the graph
     *    InputNode => Intermediate => OutputNode,
     * you can execute the subgraph Intermediate => OutputNode by calling
     *    model.execute('IntermediateNode' : tf.tensor(...));
     *
     * This is useful for models that uses tf.dynamic_rnn, where the intermediate
     * state needs to be fed manually.
     *
     * For batch inference execution, the tensors for each input need to be
     * concatenated together. For example with mobilenet, the required input shape
     * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
     * If we are provide a batched data of 100 images, the input tensor should be
     * in the shape of [100, 244, 244, 3].
     *
     * @param config Prediction configuration for specifying the batch size.
     * Currently the batch size option is ignored for graph model.
     *
     * @returns Inference result tensors. If the model is converted and it
     * originally had structured_outputs in tensorflow, then a NamedTensorMap
     * will be returned matching the structured_outputs. If no structured_outputs
     * are present, the output will be single `tf.Tensor` if the model has single
     * output node, otherwise Tensor[].
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    predict(inputs, config) {
      const outputTensors = this.execute(inputs, this.outputNodes);
      return this.addStructuredOutputNames(outputTensors);
    }
    /**
     * Execute the inference for the input tensors in async fashion, use this
     * method when your model contains control flow ops.
     *
     * @param input The input tensors, when there is single input for the model,
     * inputs param should be a `tf.Tensor`. For models with mutliple inputs,
     * inputs params should be in either `tf.Tensor`[] if the input order is
     * fixed, or otherwise NamedTensorMap format.
     *
     * For model with multiple inputs, we recommend you use NamedTensorMap as the
     * input type, if you use `tf.Tensor`[], the order of the array needs to
     * follow the
     * order of inputNodes array. @see {@link GraphModel.inputNodes}
     *
     * You can also feed any intermediate nodes using the NamedTensorMap as the
     * input type. For example, given the graph
     *    InputNode => Intermediate => OutputNode,
     * you can execute the subgraph Intermediate => OutputNode by calling
     *    model.execute('IntermediateNode' : tf.tensor(...));
     *
     * This is useful for models that uses tf.dynamic_rnn, where the intermediate
     * state needs to be fed manually.
     *
     * For batch inference execution, the tensors for each input need to be
     * concatenated together. For example with mobilenet, the required input shape
     * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
     * If we are provide a batched data of 100 images, the input tensor should be
     * in the shape of [100, 244, 244, 3].
     *
     * @param config Prediction configuration for specifying the batch size.
     * Currently the batch size option is ignored for graph model.
     *
     * @returns A Promise of inference result tensors. If the model is converted
     * and it originally had structured_outputs in tensorflow, then a
     * NamedTensorMap will be returned matching the structured_outputs. If no
     * structured_outputs are present, the output will be single `tf.Tensor` if
     * the model has single output node, otherwise Tensor[].
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    async predictAsync(inputs, config) {
      const outputTensors = await this.executeAsync(inputs, this.outputNodes);
      return this.addStructuredOutputNames(outputTensors);
    }
    normalizeInputs(inputs) {
      var _a;
      if (!(inputs instanceof Tensor) && !Array.isArray(inputs)) {
        const signatureInputs = (_a = this.signature) === null || _a === void 0 ? void 0 : _a.inputs;
        if (signatureInputs != null) {
          for (const input in signatureInputs) {
            const tensor2 = signatureInputs[input];
            if (tensor2.resourceId != null) {
              inputs[input] = this.resourceIdToCapturedInput[tensor2.resourceId];
            }
          }
        }
        return inputs;
      }
      inputs = Array.isArray(inputs) ? inputs : [inputs];
      const numCapturedInputs = Object.keys(this.resourceIdToCapturedInput).length;
      if (inputs.length + numCapturedInputs !== this.inputNodes.length) {
        throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length - numCapturedInputs} non-resource placeholders, while there are ${inputs.length} input tensors provided.`);
      }
      let inputIndex = 0;
      return this.inputNodes.reduce((map, inputName) => {
        var _a2, _b, _c;
        const resourceId = (_c = (_b = (_a2 = this.signature) === null || _a2 === void 0 ? void 0 : _a2.inputs) === null || _b === void 0 ? void 0 : _b[inputName]) === null || _c === void 0 ? void 0 : _c.resourceId;
        if (resourceId != null) {
          map[inputName] = this.resourceIdToCapturedInput[resourceId];
        } else {
          map[inputName] = inputs[inputIndex++];
        }
        return map;
      }, {});
    }
    normalizeOutputs(outputs) {
      outputs = outputs || this.outputNodes;
      return !Array.isArray(outputs) ? [outputs] : outputs;
    }
    executeInitializerGraph() {
      if (this.initializer == null) {
        return [];
      }
      if (this.initializerSignature == null) {
        return this.initializer.execute({}, []);
      } else {
        return this.initializer.execute({}, Object.keys(this.initializerSignature.outputs));
      }
    }
    async executeInitializerGraphAsync() {
      if (this.initializer == null) {
        return [];
      }
      if (this.initializerSignature == null) {
        return this.initializer.executeAsync({}, []);
      } else {
        return this.initializer.executeAsync({}, Object.keys(this.initializerSignature.outputs));
      }
    }
    setResourceIdToCapturedInput(outputs) {
      this.resourceIdToCapturedInput = {};
      if (this.initializerSignature) {
        const signatureOutputs = this.initializerSignature.outputs;
        const outputNames = Object.keys(signatureOutputs);
        for (let i = 0; i < outputNames.length; i++) {
          const outputName = outputNames[i];
          const tensorInfo = signatureOutputs[outputName];
          this.resourceIdToCapturedInput[tensorInfo.resourceId] = outputs[i];
        }
      }
    }
    /**
     * Executes inference for the model for given input tensors.
     * @param inputs tensor, tensor array or tensor map of the inputs for the
     * model, keyed by the input node names.
     * @param outputs output node name from the TensorFlow model, if no
     * outputs are specified, the default outputs of the model would be used.
     * You can inspect intermediate nodes of the model by adding them to the
     * outputs array.
     *
     * @returns A single tensor if provided with a single output or no outputs
     * are provided and there is only one default output, otherwise return a
     * tensor array. The order of the tensor array is the same as the outputs
     * if provided, otherwise the order of outputNodes attribute of the model.
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    execute(inputs, outputs) {
      if (this.resourceIdToCapturedInput == null) {
        this.setResourceIdToCapturedInput(this.executeInitializerGraph());
      }
      inputs = this.normalizeInputs(inputs);
      outputs = this.normalizeOutputs(outputs);
      const result = this.executor.execute(inputs, outputs);
      return result.length > 1 ? result : result[0];
    }
    /**
     * Executes inference for the model for given input tensors in async
     * fashion, use this method when your model contains control flow ops.
     * @param inputs tensor, tensor array or tensor map of the inputs for the
     * model, keyed by the input node names.
     * @param outputs output node name from the TensorFlow model, if no outputs
     * are specified, the default outputs of the model would be used. You can
     * inspect intermediate nodes of the model by adding them to the outputs
     * array.
     *
     * @returns A Promise of single tensor if provided with a single output or
     * no outputs are provided and there is only one default output, otherwise
     * return a tensor map.
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    async executeAsync(inputs, outputs) {
      if (this.resourceIdToCapturedInput == null) {
        this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync());
      }
      inputs = this.normalizeInputs(inputs);
      outputs = this.normalizeOutputs(outputs);
      const result = await this.executor.executeAsync(inputs, outputs);
      return result.length > 1 ? result : result[0];
    }
    /**
     * Get intermediate tensors for model debugging mode (flag
     * KEEP_INTERMEDIATE_TENSORS is true).
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    getIntermediateTensors() {
      return this.executor.getIntermediateTensors();
    }
    /**
     * Dispose intermediate tensors for model debugging mode (flag
     * KEEP_INTERMEDIATE_TENSORS is true).
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    disposeIntermediateTensors() {
      this.executor.disposeIntermediateTensors();
    }
    convertTensorMapToTensorsMap(map) {
      return Object.keys(map).reduce((newMap, key) => {
        newMap[key] = [map[key]];
        return newMap;
      }, {});
    }
    /**
     * Releases the memory used by the weight tensors and resourceManager.
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    dispose() {
      this.executor.dispose();
      if (this.initializer) {
        this.initializer.dispose();
        if (this.resourceIdToCapturedInput) {
          dispose(this.resourceIdToCapturedInput);
        }
      }
      this.resourceManager.dispose();
    }
  }
  async function loadGraphModel(modelUrl, options = {}, tfio = io) {
    if (modelUrl == null) {
      throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
    }
    if (options == null) {
      options = {};
    }
    if (options.fromTFHub && typeof modelUrl === "string") {
      modelUrl = getTFHubUrl(modelUrl);
    }
    const model = new GraphModel(modelUrl, options, tfio);
    await model.load();
    return model;
  }
  function getTFHubUrl(modelUrl) {
    if (!modelUrl.endsWith("/")) {
      modelUrl = modelUrl + "/";
    }
    return `${modelUrl}${DEFAULT_MODEL_NAME}${TFHUB_SEARCH_PARAM}`;
  }
  /**
      * @license
      * Copyright 2024 Google LLC. All Rights Reserved.
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing, software
      * distributed under the License is distributed on an "AS IS" BASIS,
      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      * See the License for the specific language governing permissions and
      * limitations under the License.
      * =============================================================================
      */
  var E = function() {
    return E = Object.assign || function(t) {
      for (var e, n = 1, r = arguments.length; n < r; n++)
        for (var i in e = arguments[n])
          Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
      return t;
    }, E.apply(this, arguments);
  };
  function S(t, e, n, r) {
    return new (n || (n = Promise))(function(i, o) {
      function a(t2) {
        try {
          s(r.next(t2));
        } catch (t3) {
          o(t3);
        }
      }
      function u(t2) {
        try {
          s(r.throw(t2));
        } catch (t3) {
          o(t3);
        }
      }
      function s(t2) {
        var e2;
        t2.done ? i(t2.value) : (e2 = t2.value, e2 instanceof n ? e2 : new n(function(t3) {
          t3(e2);
        })).then(a, u);
      }
      s((r = r.apply(t, e || [])).next());
    });
  }
  function F(t, e) {
    var n, r, i, o, a = { label: 0, sent: function() {
      if (1 & i[0])
        throw i[1];
      return i[1];
    }, trys: [], ops: [] };
    return o = { next: u(0), throw: u(1), return: u(2) }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
      return this;
    }), o;
    function u(o2) {
      return function(u2) {
        return function(o3) {
          if (n)
            throw new TypeError("Generator is already executing.");
          for (; a; )
            try {
              if (n = 1, r && (i = 2 & o3[0] ? r.return : o3[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o3[1])).done)
                return i;
              switch (r = 0, i && (o3 = [2 & o3[0], i.value]), o3[0]) {
                case 0:
                case 1:
                  i = o3;
                  break;
                case 4:
                  return a.label++, { value: o3[1], done: false };
                case 5:
                  a.label++, r = o3[1], o3 = [0];
                  continue;
                case 7:
                  o3 = a.ops.pop(), a.trys.pop();
                  continue;
                default:
                  if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o3[0] && 2 !== o3[0])) {
                    a = 0;
                    continue;
                  }
                  if (3 === o3[0] && (!i || o3[1] > i[0] && o3[1] < i[3])) {
                    a.label = o3[1];
                    break;
                  }
                  if (6 === o3[0] && a.label < i[1]) {
                    a.label = i[1], i = o3;
                    break;
                  }
                  if (i && a.label < i[2]) {
                    a.label = i[2], a.ops.push(o3);
                    break;
                  }
                  i[2] && a.ops.pop(), a.trys.pop();
                  continue;
              }
              o3 = e.call(t, a);
            } catch (t2) {
              o3 = [6, t2], r = 0;
            } finally {
              n = i = 0;
            }
          if (5 & o3[0])
            throw o3[1];
          return { value: o3[0] ? o3[1] : void 0, done: true };
        }([o2, u2]);
      };
    }
  }
  function C(t) {
    var e = t.map(function(t2) {
      return t2[0];
    });
    return e.push(t[t.length - 1][1]), e;
  }
  var O = { lips: C([[61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]]), leftEye: C([[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]]), leftEyebrow: C([[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]]), leftIris: C([[474, 475], [475, 476], [476, 477], [477, 474]]), rightEye: C([[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]]), rightEyebrow: C([[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]]), rightIris: C([[469, 470], [470, 471], [471, 472], [472, 469]]), faceOval: C([[10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]]) }, j = Object.entries(O).map(function(t) {
    var e = t[0];
    return t[1].map(function(t2) {
      return [t2, e];
    });
  }).flat(), k = new Map(j);
  function R(t) {
    for (var e = { locationData: { relativeKeypoints: [] } }, n = Number.MAX_SAFE_INTEGER, r = Number.MIN_SAFE_INTEGER, i = Number.MAX_SAFE_INTEGER, o = Number.MIN_SAFE_INTEGER, a = 0; a < t.length; ++a) {
      var u = t[a];
      n = Math.min(n, u.x), r = Math.max(r, u.x), i = Math.min(i, u.y), o = Math.max(o, u.y), e.locationData.relativeKeypoints.push({ x: u.x, y: u.y });
    }
    return e.locationData.relativeBoundingBox = { xMin: n, yMin: i, xMax: r, yMax: o, width: r - n, height: o - i }, e;
  }
  var I = { runtime: "mediapipe", maxFaces: 1, refineLandmarks: false };
  var L = function() {
    function n(e) {
      var n2 = this;
      this.width = 0, this.height = 0, this.selfieMode = false, this.faceMeshSolution = new face_mesh.FaceMesh({ locateFile: function(t, n3) {
        return e.solutionPath ? e.solutionPath.replace(/\/+$/, "") + "/" + t : n3 + "/" + t;
      } }), this.faceMeshSolution.setOptions({ refineLandmarks: e.refineLandmarks, selfieMode: this.selfieMode, maxNumFaces: e.maxFaces }), this.faceMeshSolution.onResults(function(t) {
        if (n2.height = t.image.height, n2.width = t.image.width, n2.faces = [], null !== t.multiFaceLandmarks)
          for (var e2 = t.multiFaceLandmarks, r = 0; r < e2.length; r++) {
            var i = n2.translateOutput(e2[r]);
            n2.faces.push({ keypoints: i, box: R(i).locationData.relativeBoundingBox });
          }
      });
    }
    return n.prototype.translateOutput = function(t) {
      var e = this;
      return t.map(function(t2, n2) {
        var r = { x: t2.x * e.width, y: t2.y * e.height, z: t2.z * e.width }, i = k.get(n2);
        return null != i && (r.name = i), r;
      });
    }, n.prototype.estimateFaces = function(t, n2) {
      return S(this, void 0, void 0, function() {
        var r, i;
        return F(this, function(o) {
          switch (o.label) {
            case 0:
              return n2 && n2.flipHorizontal && n2.flipHorizontal !== this.selfieMode && (this.selfieMode = n2.flipHorizontal, this.faceMeshSolution.setOptions({ selfieMode: this.selfieMode })), t instanceof Tensor ? (i = ImageData.bind, [4, toPixels(t)]) : [3, 2];
            case 1:
              return r = new (i.apply(ImageData, [void 0, o.sent(), t.shape[1], t.shape[0]]))(), [3, 3];
            case 2:
              r = t, o.label = 3;
            case 3:
              return t = r, [4, this.faceMeshSolution.send({ image: t })];
            case 4:
              return o.sent(), [2, this.faces];
          }
        });
      });
    }, n.prototype.dispose = function() {
      this.faceMeshSolution.close();
    }, n.prototype.reset = function() {
      this.faceMeshSolution.reset(), this.width = 0, this.height = 0, this.faces = null, this.selfieMode = false;
    }, n.prototype.initialize = function() {
      return this.faceMeshSolution.initialize();
    }, n;
  }();
  function B(t) {
    return S(this, void 0, void 0, function() {
      var e, n;
      return F(this, function(r) {
        switch (r.label) {
          case 0:
            return e = function(t2) {
              if (null == t2)
                return E({}, I);
              var e2 = E({}, t2);
              return e2.runtime = "mediapipe", null == e2.maxFaces && (e2.maxFaces = I.maxFaces), null == e2.refineLandmarks && (e2.refineLandmarks = I.refineLandmarks), e2;
            }(t), [4, (n = new L(e)).initialize()];
          case 1:
            return r.sent(), [2, n];
        }
      });
    });
  }
  var D = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, P = {};
  (function() {
    var t;
    function e(t2) {
      var e2 = 0;
      return function() {
        return e2 < t2.length ? { done: false, value: t2[e2++] } : { done: true };
      };
    }
    var n = "function" == typeof Object.defineProperties ? Object.defineProperty : function(t2, e2, n2) {
      return t2 == Array.prototype || t2 == Object.prototype || (t2[e2] = n2.value), t2;
    };
    var r = function(t2) {
      t2 = ["object" == typeof globalThis && globalThis, t2, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof D && D];
      for (var e2 = 0; e2 < t2.length; ++e2) {
        var n2 = t2[e2];
        if (n2 && n2.Math == Math)
          return n2;
      }
      throw Error("Cannot find global object");
    }(this);
    function i(t2, e2) {
      if (e2)
        t: {
          var i2 = r;
          t2 = t2.split(".");
          for (var o2 = 0; o2 < t2.length - 1; o2++) {
            var a2 = t2[o2];
            if (!(a2 in i2))
              break t;
            i2 = i2[a2];
          }
          (e2 = e2(o2 = i2[t2 = t2[t2.length - 1]])) != o2 && null != e2 && n(i2, t2, { configurable: true, writable: true, value: e2 });
        }
    }
    function o(t2) {
      return (t2 = { next: t2 })[Symbol.iterator] = function() {
        return this;
      }, t2;
    }
    function a(t2) {
      var n2 = "undefined" != typeof Symbol && Symbol.iterator && t2[Symbol.iterator];
      return n2 ? n2.call(t2) : { next: e(t2) };
    }
    function u(t2) {
      if (!(t2 instanceof Array)) {
        t2 = a(t2);
        for (var e2, n2 = []; !(e2 = t2.next()).done; )
          n2.push(e2.value);
        t2 = n2;
      }
      return t2;
    }
    i("Symbol", function(t2) {
      function e2(t3, e3) {
        this.g = t3, n(this, "description", { configurable: true, writable: true, value: e3 });
      }
      if (t2)
        return t2;
      e2.prototype.toString = function() {
        return this.g;
      };
      var r2 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", i2 = 0;
      return function t3(n2) {
        if (this instanceof t3)
          throw new TypeError("Symbol is not a constructor");
        return new e2(r2 + (n2 || "") + "_" + i2++, n2);
      };
    }), i("Symbol.iterator", function(t2) {
      if (t2)
        return t2;
      t2 = Symbol("Symbol.iterator");
      for (var i2 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), a2 = 0; a2 < i2.length; a2++) {
        var u2 = r[i2[a2]];
        "function" == typeof u2 && "function" != typeof u2.prototype[t2] && n(u2.prototype, t2, { configurable: true, writable: true, value: function() {
          return o(e(this));
        } });
      }
      return t2;
    });
    var s, c = "function" == typeof Object.create ? Object.create : function(t2) {
      function e2() {
      }
      return e2.prototype = t2, new e2();
    };
    if ("function" == typeof Object.setPrototypeOf)
      s = Object.setPrototypeOf;
    else {
      var h;
      t: {
        var l = {};
        try {
          l.__proto__ = { a: true }, h = l.a;
          break t;
        } catch (t2) {
        }
        h = false;
      }
      s = h ? function(t2, e2) {
        if (t2.__proto__ = e2, t2.__proto__ !== e2)
          throw new TypeError(t2 + " is not extensible");
        return t2;
      } : null;
    }
    var f = s;
    function d(t2, e2) {
      if (t2.prototype = c(e2.prototype), t2.prototype.constructor = t2, f)
        f(t2, e2);
      else
        for (var n2 in e2)
          if ("prototype" != n2)
            if (Object.defineProperties) {
              var r2 = Object.getOwnPropertyDescriptor(e2, n2);
              r2 && Object.defineProperty(t2, n2, r2);
            } else
              t2[n2] = e2[n2];
      t2.na = e2.prototype;
    }
    function p() {
      this.l = false, this.i = null, this.h = void 0, this.g = 1, this.u = this.o = 0, this.j = null;
    }
    function g(t2) {
      if (t2.l)
        throw new TypeError("Generator is already running");
      t2.l = true;
    }
    function v(t2, e2) {
      t2.j = { da: e2, ea: true }, t2.g = t2.o || t2.u;
    }
    function m(t2, e2, n2) {
      return t2.g = n2, { value: e2 };
    }
    function y(t2) {
      this.g = new p(), this.h = t2;
    }
    function w(t2, e2, n2, r2) {
      try {
        var i2 = e2.call(t2.g.i, n2);
        if (!(i2 instanceof Object))
          throw new TypeError("Iterator result " + i2 + " is not an object");
        if (!i2.done)
          return t2.g.l = false, i2;
        var o2 = i2.value;
      } catch (e3) {
        return t2.g.i = null, v(t2.g, e3), b(t2);
      }
      return t2.g.i = null, r2.call(t2.g, o2), b(t2);
    }
    function b(t2) {
      for (; t2.g.g; )
        try {
          var e2 = t2.h(t2.g);
          if (e2)
            return t2.g.l = false, { value: e2.value, done: false };
        } catch (e3) {
          t2.g.h = void 0, v(t2.g, e3);
        }
      if (t2.g.l = false, t2.g.j) {
        if (e2 = t2.g.j, t2.g.j = null, e2.ea)
          throw e2.da;
        return { value: e2.return, done: true };
      }
      return { value: void 0, done: true };
    }
    function x(t2) {
      this.next = function(e2) {
        return g(t2.g), t2.g.i ? e2 = w(t2, t2.g.i.next, e2, t2.g.s) : (t2.g.s(e2), e2 = b(t2)), e2;
      }, this.throw = function(e2) {
        return g(t2.g), t2.g.i ? e2 = w(t2, t2.g.i.throw, e2, t2.g.s) : (v(t2.g, e2), e2 = b(t2)), e2;
      }, this.return = function(e2) {
        return function(t3, e3) {
          g(t3.g);
          var n2 = t3.g.i;
          return n2 ? w(t3, "return" in n2 ? n2.return : function(t4) {
            return { value: t4, done: true };
          }, e3, t3.g.return) : (t3.g.return(e3), b(t3));
        }(t2, e2);
      }, this[Symbol.iterator] = function() {
        return this;
      };
    }
    function M(t2) {
      return function(t3) {
        function e2(e3) {
          return t3.next(e3);
        }
        function n2(e3) {
          return t3.throw(e3);
        }
        return new Promise(function(r2, i2) {
          !function t4(o2) {
            o2.done ? r2(o2.value) : Promise.resolve(o2.value).then(e2, n2).then(t4, i2);
          }(t3.next());
        });
      }(new x(new y(t2)));
    }
    p.prototype.s = function(t2) {
      this.h = t2;
    }, p.prototype.return = function(t2) {
      this.j = { return: t2 }, this.g = this.u;
    }, i("Promise", function(t2) {
      function e2(t3) {
        this.h = 0, this.i = void 0, this.g = [], this.s = false;
        var e3 = this.j();
        try {
          t3(e3.resolve, e3.reject);
        } catch (t4) {
          e3.reject(t4);
        }
      }
      function n2() {
        this.g = null;
      }
      function i2(t3) {
        return t3 instanceof e2 ? t3 : new e2(function(e3) {
          e3(t3);
        });
      }
      if (t2)
        return t2;
      n2.prototype.h = function(t3) {
        if (null == this.g) {
          this.g = [];
          var e3 = this;
          this.i(function() {
            e3.l();
          });
        }
        this.g.push(t3);
      };
      var o2 = r.setTimeout;
      n2.prototype.i = function(t3) {
        o2(t3, 0);
      }, n2.prototype.l = function() {
        for (; this.g && this.g.length; ) {
          var t3 = this.g;
          this.g = [];
          for (var e3 = 0; e3 < t3.length; ++e3) {
            var n3 = t3[e3];
            t3[e3] = null;
            try {
              n3();
            } catch (t4) {
              this.j(t4);
            }
          }
        }
        this.g = null;
      }, n2.prototype.j = function(t3) {
        this.i(function() {
          throw t3;
        });
      }, e2.prototype.j = function() {
        function t3(t4) {
          return function(r2) {
            n3 || (n3 = true, t4.call(e3, r2));
          };
        }
        var e3 = this, n3 = false;
        return { resolve: t3(this.D), reject: t3(this.l) };
      }, e2.prototype.D = function(t3) {
        if (t3 === this)
          this.l(new TypeError("A Promise cannot resolve to itself"));
        else if (t3 instanceof e2)
          this.H(t3);
        else {
          t:
            switch (typeof t3) {
              case "object":
                var n3 = null != t3;
                break t;
              case "function":
                n3 = true;
                break t;
              default:
                n3 = false;
            }
          n3 ? this.A(t3) : this.o(t3);
        }
      }, e2.prototype.A = function(t3) {
        var e3 = void 0;
        try {
          e3 = t3.then;
        } catch (t4) {
          return void this.l(t4);
        }
        "function" == typeof e3 ? this.I(e3, t3) : this.o(t3);
      }, e2.prototype.l = function(t3) {
        this.u(2, t3);
      }, e2.prototype.o = function(t3) {
        this.u(1, t3);
      }, e2.prototype.u = function(t3, e3) {
        if (0 != this.h)
          throw Error("Cannot settle(" + t3 + ", " + e3 + "): Promise already settled in state" + this.h);
        this.h = t3, this.i = e3, 2 === this.h && this.G(), this.B();
      }, e2.prototype.G = function() {
        var t3 = this;
        o2(function() {
          if (t3.C()) {
            var e3 = r.console;
            void 0 !== e3 && e3.error(t3.i);
          }
        }, 1);
      }, e2.prototype.C = function() {
        if (this.s)
          return false;
        var t3 = r.CustomEvent, e3 = r.Event, n3 = r.dispatchEvent;
        return void 0 === n3 || ("function" == typeof t3 ? t3 = new t3("unhandledrejection", { cancelable: true }) : "function" == typeof e3 ? t3 = new e3("unhandledrejection", { cancelable: true }) : (t3 = r.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection", false, true, t3), t3.promise = this, t3.reason = this.i, n3(t3));
      }, e2.prototype.B = function() {
        if (null != this.g) {
          for (var t3 = 0; t3 < this.g.length; ++t3)
            u2.h(this.g[t3]);
          this.g = null;
        }
      };
      var u2 = new n2();
      return e2.prototype.H = function(t3) {
        var e3 = this.j();
        t3.M(e3.resolve, e3.reject);
      }, e2.prototype.I = function(t3, e3) {
        var n3 = this.j();
        try {
          t3.call(e3, n3.resolve, n3.reject);
        } catch (t4) {
          n3.reject(t4);
        }
      }, e2.prototype.then = function(t3, n3) {
        function r2(t4, e3) {
          return "function" == typeof t4 ? function(e4) {
            try {
              i3(t4(e4));
            } catch (t5) {
              o3(t5);
            }
          } : e3;
        }
        var i3, o3, a2 = new e2(function(t4, e3) {
          i3 = t4, o3 = e3;
        });
        return this.M(r2(t3, i3), r2(n3, o3)), a2;
      }, e2.prototype.catch = function(t3) {
        return this.then(void 0, t3);
      }, e2.prototype.M = function(t3, e3) {
        function n3() {
          switch (r2.h) {
            case 1:
              t3(r2.i);
              break;
            case 2:
              e3(r2.i);
              break;
            default:
              throw Error("Unexpected state: " + r2.h);
          }
        }
        var r2 = this;
        null == this.g ? u2.h(n3) : this.g.push(n3), this.s = true;
      }, e2.resolve = i2, e2.reject = function(t3) {
        return new e2(function(e3, n3) {
          n3(t3);
        });
      }, e2.race = function(t3) {
        return new e2(function(e3, n3) {
          for (var r2 = a(t3), o3 = r2.next(); !o3.done; o3 = r2.next())
            i2(o3.value).M(e3, n3);
        });
      }, e2.all = function(t3) {
        var n3 = a(t3), r2 = n3.next();
        return r2.done ? i2([]) : new e2(function(t4, e3) {
          function o3(e4) {
            return function(n4) {
              a2[e4] = n4, 0 == --u3 && t4(a2);
            };
          }
          var a2 = [], u3 = 0;
          do {
            a2.push(void 0), u3++, i2(r2.value).M(o3(a2.length - 1), e3), r2 = n3.next();
          } while (!r2.done);
        });
      }, e2;
    });
    var A = "function" == typeof Object.assign ? Object.assign : function(t2, e2) {
      for (var n2 = 1; n2 < arguments.length; n2++) {
        var r2 = arguments[n2];
        if (r2)
          for (var i2 in r2)
            Object.prototype.hasOwnProperty.call(r2, i2) && (t2[i2] = r2[i2]);
      }
      return t2;
    };
    i("Object.assign", function(t2) {
      return t2 || A;
    }), i("Object.is", function(t2) {
      return t2 || function(t3, e2) {
        return t3 === e2 ? 0 !== t3 || 1 / t3 == 1 / e2 : t3 != t3 && e2 != e2;
      };
    }), i("Array.prototype.includes", function(t2) {
      return t2 || function(t3, e2) {
        var n2 = this;
        n2 instanceof String && (n2 = String(n2));
        var r2 = n2.length;
        for (0 > (e2 = e2 || 0) && (e2 = Math.max(e2 + r2, 0)); e2 < r2; e2++) {
          var i2 = n2[e2];
          if (i2 === t3 || Object.is(i2, t3))
            return true;
        }
        return false;
      };
    }), i("String.prototype.includes", function(t2) {
      return t2 || function(t3, e2) {
        if (null == this)
          throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");
        if (t3 instanceof RegExp)
          throw new TypeError("First argument to String.prototype.includes must not be a regular expression");
        return -1 !== this.indexOf(t3, e2 || 0);
      };
    }), i("Array.prototype.keys", function(t2) {
      return t2 || function() {
        return function(t3, e2) {
          t3 instanceof String && (t3 += "");
          var n2 = 0, r2 = false, i2 = { next: function() {
            if (!r2 && n2 < t3.length) {
              var i3 = n2++;
              return { value: e2(i3, t3[i3]), done: false };
            }
            return r2 = true, { done: true, value: void 0 };
          } };
          return i2[Symbol.iterator] = function() {
            return i2;
          }, i2;
        }(this, function(t3) {
          return t3;
        });
      };
    });
    var T = this || self;
    function E2(t2, e2) {
      t2 = t2.split(".");
      var n2, r2 = T;
      t2[0] in r2 || void 0 === r2.execScript || r2.execScript("var " + t2[0]);
      for (; t2.length && (n2 = t2.shift()); )
        t2.length || void 0 === e2 ? r2 = r2[n2] && r2[n2] !== Object.prototype[n2] ? r2[n2] : r2[n2] = {} : r2[n2] = e2;
    }
    function S2() {
      throw Error("Invalid UTF8");
    }
    function F2(t2, e2) {
      return e2 = String.fromCharCode.apply(null, e2), null == t2 ? e2 : t2 + e2;
    }
    var C2, O2, _ = "undefined" != typeof TextDecoder, j2 = "undefined" != typeof TextEncoder, k3 = {}, R2 = null;
    function I2(t2) {
      var e2;
      void 0 === e2 && (e2 = 0), B2(), e2 = k3[e2];
      for (var n2 = Array(Math.floor(t2.length / 3)), r2 = e2[64] || "", i2 = 0, o2 = 0; i2 < t2.length - 2; i2 += 3) {
        var a2 = t2[i2], u2 = t2[i2 + 1], s2 = t2[i2 + 2], c2 = e2[a2 >> 2];
        a2 = e2[(3 & a2) << 4 | u2 >> 4], u2 = e2[(15 & u2) << 2 | s2 >> 6], s2 = e2[63 & s2], n2[o2++] = c2 + a2 + u2 + s2;
      }
      switch (c2 = 0, s2 = r2, t2.length - i2) {
        case 2:
          s2 = e2[(15 & (c2 = t2[i2 + 1])) << 2] || r2;
        case 1:
          t2 = t2[i2], n2[o2] = e2[t2 >> 2] + e2[(3 & t2) << 4 | c2 >> 4] + s2 + r2;
      }
      return n2.join("");
    }
    function L2(t2) {
      var e2 = t2.length, n2 = 3 * e2 / 4;
      n2 % 3 ? n2 = Math.floor(n2) : -1 != "=.".indexOf(t2[e2 - 1]) && (n2 = -1 != "=.".indexOf(t2[e2 - 2]) ? n2 - 2 : n2 - 1);
      var r2 = new Uint8Array(n2), i2 = 0;
      return function(t3, e3) {
        function n3(e4) {
          for (; r3 < t3.length; ) {
            var n4 = t3.charAt(r3++), i4 = R2[n4];
            if (null != i4)
              return i4;
            if (!/^[\s\xa0]*$/.test(n4))
              throw Error("Unknown base64 encoding at char: " + n4);
          }
          return e4;
        }
        B2();
        for (var r3 = 0; ; ) {
          var i3 = n3(-1), o2 = n3(0), a2 = n3(64), u2 = n3(64);
          if (64 === u2 && -1 === i3)
            break;
          e3(i3 << 2 | o2 >> 4), 64 != a2 && (e3(o2 << 4 & 240 | a2 >> 2), 64 != u2 && e3(a2 << 6 & 192 | u2));
        }
      }(t2, function(t3) {
        r2[i2++] = t3;
      }), i2 !== n2 ? r2.subarray(0, i2) : r2;
    }
    function B2() {
      if (!R2) {
        R2 = {};
        for (var t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), e2 = ["+/=", "+/", "-_=", "-_.", "-_"], n2 = 0; 5 > n2; n2++) {
          var r2 = t2.concat(e2[n2].split(""));
          k3[n2] = r2;
          for (var i2 = 0; i2 < r2.length; i2++) {
            var o2 = r2[i2];
            void 0 === R2[o2] && (R2[o2] = i2);
          }
        }
      }
    }
    var P2, z2 = "function" == typeof Uint8Array;
    function U2(t2) {
      return z2 && null != t2 && t2 instanceof Uint8Array;
    }
    function N2(t2) {
      if (this.L = t2, null !== t2 && 0 === t2.length)
        throw Error("ByteString should be constructed with non-empty values");
    }
    var V2 = "function" == typeof Uint8Array.prototype.slice, H2 = 0;
    function K2(t2, e2) {
      return Error("Invalid wire type: " + t2 + " (at position " + e2 + ")");
    }
    function W2() {
      return Error("Failed to read varint, encoding is invalid.");
    }
    function G2(t2, e2) {
      e2 = void 0 !== (e2 = void 0 === e2 ? {} : e2).v && e2.v, this.h = null, this.g = this.i = this.j = 0, this.v = e2, t2 && X2(this, t2);
    }
    function X2(t2, e2) {
      t2.h = function(t3, e3) {
        if (t3.constructor === Uint8Array)
          return t3;
        if (t3.constructor === ArrayBuffer)
          return new Uint8Array(t3);
        if (t3.constructor === Array)
          return new Uint8Array(t3);
        if (t3.constructor === String)
          return L2(t3);
        if (t3.constructor === N2)
          return !e3 && (e3 = t3.L) && e3.constructor === Uint8Array ? e3 : (e3 = null == (e3 = t3.L) || U2(e3) ? e3 : "string" == typeof e3 ? L2(e3) : null, (t3 = t3.L = e3) ? new Uint8Array(t3) : P2 || (P2 = new Uint8Array(0)));
        if (t3 instanceof Uint8Array)
          return new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength);
        throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, or Array of numbers");
      }(e2, t2.v), t2.j = 0, t2.i = t2.h.length, t2.g = t2.j;
    }
    function Y2(t2) {
      if (t2.g > t2.i)
        throw Error("Tried to read past the end of the data " + t2.g + " > " + t2.i);
    }
    function J2(t2) {
      var e2 = t2.h, n2 = e2[t2.g], r2 = 127 & n2;
      if (128 > n2)
        return t2.g += 1, Y2(t2), r2;
      if (r2 |= (127 & (n2 = e2[t2.g + 1])) << 7, 128 > n2)
        return t2.g += 2, Y2(t2), r2;
      if (r2 |= (127 & (n2 = e2[t2.g + 2])) << 14, 128 > n2)
        return t2.g += 3, Y2(t2), r2;
      if (r2 |= (127 & (n2 = e2[t2.g + 3])) << 21, 128 > n2)
        return t2.g += 4, Y2(t2), r2;
      if (n2 = e2[t2.g + 4], t2.g += 5, r2 |= (15 & n2) << 28, 128 > n2)
        return Y2(t2), r2;
      if (128 <= e2[t2.g++] && 128 <= e2[t2.g++] && 128 <= e2[t2.g++] && 128 <= e2[t2.g++] && 128 <= e2[t2.g++])
        throw W2();
      return Y2(t2), r2;
    }
    G2.prototype.reset = function() {
      this.g = this.j;
    };
    var q2 = [];
    function $2() {
      this.g = [];
    }
    function Z2(t2, e2) {
      for (; 127 < e2; )
        t2.g.push(127 & e2 | 128), e2 >>>= 7;
      t2.g.push(e2);
    }
    function Q2(t2) {
      var e2 = {}, n2 = void 0 !== e2.W && e2.W;
      this.l = { v: void 0 !== e2.v && e2.v }, this.W = n2, e2 = this.l, q2.length ? (n2 = q2.pop(), e2 && (n2.v = e2.v), t2 && X2(n2, t2), t2 = n2) : t2 = new G2(t2, e2), this.g = t2, this.j = this.g.g, this.h = this.i = -1;
    }
    function tt2(t2) {
      var e2 = t2.g;
      if (e2.g == e2.i)
        return false;
      t2.j = t2.g.g;
      var n2 = J2(t2.g) >>> 0;
      if (e2 = n2 >>> 3, !(0 <= (n2 &= 7) && 5 >= n2))
        throw K2(n2, t2.j);
      if (1 > e2)
        throw Error("Invalid field number: " + e2 + " (at position " + t2.j + ")");
      return t2.i = e2, t2.h = n2, true;
    }
    function et2(t2) {
      switch (t2.h) {
        case 0:
          if (0 != t2.h)
            et2(t2);
          else
            t: {
              for (var e2 = (t2 = t2.g).g, n2 = e2 + 10; e2 < n2; )
                if (0 == (128 & t2.h[e2++])) {
                  t2.g = e2, Y2(t2);
                  break t;
                }
              throw W2();
            }
          break;
        case 1:
          (t2 = t2.g).g += 8, Y2(t2);
          break;
        case 2:
          2 != t2.h ? et2(t2) : (e2 = J2(t2.g) >>> 0, (t2 = t2.g).g += e2, Y2(t2));
          break;
        case 5:
          (t2 = t2.g).g += 4, Y2(t2);
          break;
        case 3:
          for (e2 = t2.i; ; ) {
            if (!tt2(t2))
              throw Error("Unmatched start-group tag: stream EOF");
            if (4 == t2.h) {
              if (t2.i != e2)
                throw Error("Unmatched end-group tag");
              break;
            }
            et2(t2);
          }
          break;
        default:
          throw K2(t2.h, t2.j);
      }
    }
    $2.prototype.length = function() {
      return this.g.length;
    }, $2.prototype.end = function() {
      var t2 = this.g;
      return this.g = [], t2;
    }, Q2.prototype.reset = function() {
      this.g.reset(), this.j = this.g.g, this.h = this.i = -1;
    };
    var nt2 = [];
    function rt2() {
      this.i = [], this.h = 0, this.g = new $2();
    }
    function it2(t2, e2) {
      0 !== e2.length && (t2.i.push(e2), t2.h += e2.length);
    }
    var ot2 = "function" == typeof Symbol && "symbol" == typeof Symbol() ? Symbol(void 0) : void 0;
    function at2(t2, e2) {
      Object.isFrozen(t2) || (ot2 ? t2[ot2] |= e2 : void 0 !== t2.N ? t2.N |= e2 : Object.defineProperties(t2, { N: { value: e2, configurable: true, writable: true, enumerable: false } }));
    }
    function ut2(t2) {
      var e2;
      return null == (e2 = ot2 ? t2[ot2] : t2.N) ? 0 : e2;
    }
    function st2(t2) {
      return at2(t2, 1), t2;
    }
    function ct2(t2) {
      return !!Array.isArray(t2) && !!(2 & ut2(t2));
    }
    function ht2(t2) {
      if (!Array.isArray(t2))
        throw Error("cannot mark non-array as immutable");
      at2(t2, 2);
    }
    function lt2(t2) {
      return null !== t2 && "object" == typeof t2 && !Array.isArray(t2) && t2.constructor === Object;
    }
    var ft2 = Object.freeze(st2([]));
    function dt2(t2) {
      if (ct2(t2.m))
        throw Error("Cannot mutate an immutable Message");
    }
    var pt2, gt2 = "undefined" != typeof Symbol && void 0 !== Symbol.hasInstance;
    function vt2(t2) {
      return { value: t2, configurable: false, writable: false, enumerable: false };
    }
    function mt2(t2, e2, n2) {
      return -1 === e2 ? null : e2 >= t2.i ? t2.g ? t2.g[e2] : void 0 : void 0 !== n2 && n2 && t2.g && null != (n2 = t2.g[e2]) ? n2 : t2.m[e2 + t2.h];
    }
    function yt2(t2, e2, n2, r2) {
      r2 = void 0 !== r2 && r2, dt2(t2), e2 < t2.i && !r2 ? t2.m[e2 + t2.h] = n2 : (t2.g || (t2.g = t2.m[t2.i + t2.h] = {}))[e2] = n2;
    }
    function wt2(t2, e2, n2, r2) {
      n2 = void 0 === n2 || n2;
      var i2 = mt2(t2, e2, r2 = void 0 !== r2 && r2);
      return null == i2 && (i2 = ft2), ct2(t2.m) ? n2 && (ht2(i2), Object.freeze(i2)) : (i2 === ft2 || ct2(i2)) && yt2(t2, e2, i2 = st2(i2.slice()), r2), i2;
    }
    function bt2(t2, e2, n2) {
      return null == (t2 = null == (t2 = mt2(t2, e2)) ? t2 : +t2) ? void 0 === n2 ? 0 : n2 : t2;
    }
    function xt2(t2, e2, n2, r2) {
      t2.j || (t2.j = {});
      var i2 = ct2(t2.m), o2 = t2.j[n2];
      if (!o2) {
        r2 = wt2(t2, n2, true, void 0 !== r2 && r2), o2 = [], i2 = i2 || ct2(r2);
        for (var a2 = 0; a2 < r2.length; a2++)
          o2[a2] = new e2(r2[a2]), i2 && ht2(o2[a2].m);
        i2 && (ht2(o2), Object.freeze(o2)), t2.j[n2] = o2;
      }
      return o2;
    }
    function Mt2(t2, e2, n2, r2, i2) {
      var o2 = void 0 !== o2 && o2;
      return dt2(t2), o2 = xt2(t2, n2, e2, o2), n2 = r2 || new n2(), t2 = wt2(t2, e2), null != i2 ? (o2.splice(i2, 0, n2), t2.splice(i2, 0, n2.m)) : (o2.push(n2), t2.push(n2.m)), n2;
    }
    function At2(t2, e2) {
      return null == (t2 = mt2(t2, e2)) ? 0 : t2;
    }
    function Tt2(t2, e2) {
      return null == (t2 = mt2(t2, e2)) ? "" : t2;
    }
    function Et2(t2) {
      var e2 = Ct2;
      return Ft2(t2, e2 = void 0 === e2 ? Ot2 : e2);
    }
    function St2(t2, e2) {
      if (null != t2) {
        if (Array.isArray(t2))
          t2 = Ft2(t2, e2);
        else if (lt2(t2)) {
          var n2, r2 = {};
          for (n2 in t2)
            r2[n2] = St2(t2[n2], e2);
          t2 = r2;
        } else
          t2 = e2(t2);
        return t2;
      }
    }
    function Ft2(t2, e2) {
      for (var n2 = t2.slice(), r2 = 0; r2 < n2.length; r2++)
        n2[r2] = St2(n2[r2], e2);
      return Array.isArray(t2) && 1 & ut2(t2) && st2(n2), n2;
    }
    function Ct2(t2) {
      return t2 && "object" == typeof t2 && t2.toJSON ? t2.toJSON() : (t2 = function(t3) {
        switch (typeof t3) {
          case "number":
            return isFinite(t3) ? t3 : String(t3);
          case "object":
            if (t3 && !Array.isArray(t3)) {
              if (U2(t3))
                return I2(t3);
              if (t3 instanceof N2) {
                var e2 = t3.L;
                return e2 = null == e2 || "string" == typeof e2 ? e2 : z2 && e2 instanceof Uint8Array ? I2(e2) : null, (t3.L = e2) || "";
              }
            }
        }
        return t3;
      }(t2), Array.isArray(t2) ? Et2(t2) : t2);
    }
    function Ot2(t2) {
      return U2(t2) ? new Uint8Array(t2) : t2;
    }
    function _t2(t2, e2, n2) {
      t2 || (t2 = pt2), pt2 = null;
      var r2 = this.constructor.h;
      if (t2 || (t2 = r2 ? [r2] : []), this.h = (r2 ? 0 : -1) - (this.constructor.g || 0), this.j = void 0, this.m = t2, t2 = (r2 = this.m.length) - 1, r2 && lt2(r2 = this.m[t2]) ? (this.i = t2 - this.h, this.g = r2) : void 0 !== e2 && -1 < e2 ? (this.i = Math.max(e2, t2 + 1 - this.h), this.g = void 0) : this.i = Number.MAX_VALUE, n2)
        for (e2 = 0; e2 < n2.length; e2++)
          if ((t2 = n2[e2]) < this.i)
            t2 += this.h, (r2 = this.m[t2]) ? Array.isArray(r2) && st2(r2) : this.m[t2] = ft2;
          else {
            var i2 = (r2 = this.g || (this.g = this.m[this.i + this.h] = {}))[t2];
            i2 ? Array.isArray(i2) && st2(i2) : r2[t2] = ft2;
          }
    }
    function jt2() {
      _t2.apply(this, arguments);
    }
    if (_t2.prototype.toJSON = function() {
      return Et2(this.m);
    }, _t2.prototype.toString = function() {
      return this.m.toString();
    }, d(jt2, _t2), gt2) {
      var kt2 = {};
      Object.defineProperties(jt2, (kt2[Symbol.hasInstance] = vt2(function() {
        throw Error("Cannot perform instanceof checks for MutableMessage");
      }), kt2));
    }
    function Rt2(t2, e2, n2) {
      if (n2) {
        var r2, i2 = {};
        for (r2 in n2) {
          var o2 = n2[r2], a2 = o2.ha;
          a2 || (i2.F = o2.la || o2.fa.P, o2.aa ? (i2.U = Ut2(o2.aa), a2 = function(t3) {
            return function(e3, n3, r3) {
              return t3.F(e3, n3, r3, t3.U);
            };
          }(i2)) : o2.ca ? (i2.T = Nt2(o2.X.g, o2.ca), a2 = function(t3) {
            return function(e3, n3, r3) {
              return t3.F(e3, n3, r3, t3.T);
            };
          }(i2)) : a2 = i2.F, o2.ha = a2), a2(e2, t2, o2.X), i2 = { F: i2.F, U: i2.U, T: i2.T };
        }
      }
      !function(t3, e3) {
        if (e3 = e3.ba) {
          it2(t3, t3.g.end());
          for (var n3 = 0; n3 < e3.length; n3++)
            it2(t3, e3[n3]);
        }
      }(e2, t2);
    }
    var It2 = Symbol();
    function Lt2(t2, e2, n2) {
      return t2[It2] || (t2[It2] = function(t3, r2) {
        return e2(t3, r2, n2);
      });
    }
    function Bt2(t2) {
      var e2 = t2[It2];
      if (!e2) {
        var n2 = Qt(t2);
        e2 = function(t3, e3) {
          return te(t3, e3, n2);
        }, t2[It2] = e2;
      }
      return e2;
    }
    function Dt2(t2) {
      var e2 = function(t3) {
        var e3 = t3.aa;
        return e3 ? Bt2(e3) : (e3 = t3.ka) ? Lt2(t3.X.g, e3, t3.ca) : void 0;
      }(t2), n2 = t2.X, r2 = t2.fa.O;
      return e2 ? function(t3, i2) {
        return r2(t3, i2, n2, e2);
      } : function(t3, e3) {
        return r2(t3, e3, n2);
      };
    }
    function Pt2(t2, e2, n2, r2, i2, o2) {
      var a2 = 0;
      for ((t2 = t2()).length && "number" != typeof t2[0] && (n2(e2, t2[0]), a2++); a2 < t2.length; ) {
        n2 = t2[a2++];
        for (var u2 = a2 + 1; u2 < t2.length && "number" != typeof t2[u2]; )
          u2++;
        var s2 = t2[a2++];
        switch (u2 -= a2) {
          case 0:
            r2(e2, n2, s2);
            break;
          case 1:
            r2(e2, n2, s2, t2[a2++]);
            break;
          case 2:
            i2(e2, n2, s2, t2[a2++], t2[a2++]);
            break;
          case 3:
            u2 = t2[a2++];
            var c2 = t2[a2++], h2 = t2[a2++];
            Array.isArray(h2) ? i2(e2, n2, s2, u2, c2, h2) : o2(e2, n2, s2, u2, c2, h2);
            break;
          case 4:
            o2(e2, n2, s2, t2[a2++], t2[a2++], t2[a2++], t2[a2++]);
            break;
          default:
            throw Error("unexpected number of binary field arguments: " + u2);
        }
      }
      return e2;
    }
    var zt2 = Symbol();
    function Ut2(t2) {
      var e2 = t2[zt2];
      if (!e2) {
        var n2 = Xt2(t2);
        e2 = function(t3, e3) {
          return ne(t3, e3, n2);
        }, t2[zt2] = e2;
      }
      return e2;
    }
    function Nt2(t2, e2) {
      var n2 = t2[zt2];
      return n2 || (n2 = function(t3, n3) {
        return Rt2(t3, n3, e2);
      }, t2[zt2] = n2), n2;
    }
    var Vt2 = Symbol();
    function Ht2(t2, e2) {
      t2.push(e2);
    }
    function Kt2(t2, e2, n2) {
      t2.push(e2, n2.P);
    }
    function Wt2(t2, e2, n2, r2, i2) {
      var o2 = Ut2(i2), a2 = n2.P;
      t2.push(e2, function(t3, e3, n3) {
        return a2(t3, e3, n3, r2, o2);
      });
    }
    function Gt2(t2, e2, n2, r2, i2, o2) {
      var a2 = Nt2(r2, o2), u2 = n2.P;
      t2.push(e2, function(t3, e3, n3) {
        return u2(t3, e3, n3, r2, a2);
      });
    }
    function Xt2(t2) {
      var e2 = t2[Vt2];
      return e2 || Pt2(t2, t2[Vt2] = [], Ht2, Kt2, Wt2, Gt2);
    }
    var Yt2 = Symbol();
    function Jt2(t2, e2) {
      t2[0] = e2;
    }
    function qt2(t2, e2, n2, r2) {
      var i2 = n2.O;
      t2[e2] = r2 ? function(t3, e3, n3) {
        return i2(t3, e3, n3, r2);
      } : i2;
    }
    function $t2(t2, e2, n2, r2, i2, o2) {
      var a2 = n2.O, u2 = Bt2(i2);
      t2[e2] = function(t3, e3, n3) {
        return a2(t3, e3, n3, r2, u2, o2);
      };
    }
    function Zt(t2, e2, n2, r2, i2, o2, a2) {
      var u2 = n2.O, s2 = Lt2(r2, i2, o2);
      t2[e2] = function(t3, e3, n3) {
        return u2(t3, e3, n3, r2, s2, a2);
      };
    }
    function Qt(t2) {
      var e2 = t2[Yt2];
      return e2 || Pt2(t2, t2[Yt2] = {}, Jt2, qt2, $t2, Zt);
    }
    function te(t2, e2, n2) {
      for (; tt2(e2) && 4 != e2.h; ) {
        var r2 = e2.i, i2 = n2[r2];
        if (!i2) {
          var o2 = n2[0];
          o2 && (o2 = o2[r2]) && (i2 = n2[r2] = Dt2(o2));
        }
        if (!(i2 && i2(e2, t2, r2) || (i2 = e2, r2 = t2, o2 = i2.j, et2(i2), i2.W))) {
          var a2 = i2.g.h;
          i2 = o2 === (i2 = i2.g.g) ? P2 || (P2 = new Uint8Array(0)) : V2 ? a2.slice(o2, i2) : new Uint8Array(a2.subarray(o2, i2)), (o2 = r2.ba) ? o2.push(i2) : r2.ba = [i2];
        }
      }
      return t2;
    }
    function ee(t2, e2, n2) {
      if (nt2.length) {
        var r2 = nt2.pop();
        t2 && (X2(r2.g, t2), r2.i = -1, r2.h = -1), t2 = r2;
      } else
        t2 = new Q2(t2);
      try {
        return te(new e2(), t2, Qt(n2));
      } finally {
        (e2 = t2.g).h = null, e2.j = 0, e2.i = 0, e2.g = 0, e2.v = false, t2.i = -1, t2.h = -1, 100 > nt2.length && nt2.push(t2);
      }
    }
    function ne(t2, e2, n2) {
      for (var r2 = n2.length, i2 = 1 == r2 % 2, o2 = i2 ? 1 : 0; o2 < r2; o2 += 2)
        (0, n2[o2 + 1])(e2, t2, n2[o2]);
      Rt2(t2, e2, i2 ? n2[0] : void 0);
    }
    function re(t2, e2) {
      var n2 = new rt2();
      ne(t2, n2, Xt2(e2)), it2(n2, n2.g.end()), t2 = new Uint8Array(n2.h);
      for (var r2 = (e2 = n2.i).length, i2 = 0, o2 = 0; o2 < r2; o2++) {
        var a2 = e2[o2];
        t2.set(a2, i2), i2 += a2.length;
      }
      return n2.i = [t2], t2;
    }
    function ie(t2, e2) {
      return { O: t2, P: e2 };
    }
    var oe = ie(function(t2, e2, n2) {
      if (5 !== t2.h)
        return false;
      var r2 = (t2 = t2.g).h[t2.g], i2 = t2.h[t2.g + 1], o2 = t2.h[t2.g + 2], a2 = t2.h[t2.g + 3];
      return t2.g += 4, Y2(t2), t2 = 2 * ((i2 = (r2 << 0 | i2 << 8 | o2 << 16 | a2 << 24) >>> 0) >> 31) + 1, r2 = i2 >>> 23 & 255, i2 &= 8388607, yt2(e2, n2, 255 == r2 ? i2 ? NaN : 1 / 0 * t2 : 0 == r2 ? t2 * Math.pow(2, -149) * i2 : t2 * Math.pow(2, r2 - 150) * (i2 + Math.pow(2, 23))), true;
    }, function(t2, e2, n2) {
      if (null != (e2 = mt2(e2, n2))) {
        Z2(t2.g, 8 * n2 + 5), t2 = t2.g;
        var r2 = e2;
        0 === (r2 = (n2 = 0 > r2 ? 1 : 0) ? -r2 : r2) ? 0 < 1 / r2 ? H2 = 0 : H2 = 2147483648 : isNaN(r2) ? H2 = 2147483647 : 34028234663852886e22 < r2 ? H2 = (n2 << 31 | 2139095040) >>> 0 : 11754943508222875e-54 > r2 ? (r2 = Math.round(r2 / Math.pow(2, -149)), H2 = (n2 << 31 | r2) >>> 0) : (e2 = Math.floor(Math.log(r2) / Math.LN2), r2 *= Math.pow(2, -e2), 16777216 <= (r2 = Math.round(8388608 * r2)) && ++e2, H2 = (n2 << 31 | e2 + 127 << 23 | 8388607 & r2) >>> 0), n2 = H2, t2.g.push(n2 >>> 0 & 255), t2.g.push(n2 >>> 8 & 255), t2.g.push(n2 >>> 16 & 255), t2.g.push(n2 >>> 24 & 255);
      }
    }), ae = ie(function(t2, e2, n2) {
      if (0 !== t2.h)
        return false;
      for (var r2 = t2.g, i2 = 128, o2 = 0, a2 = t2 = 0; 4 > a2 && 128 <= i2; a2++)
        i2 = r2.h[r2.g++], Y2(r2), o2 |= (127 & i2) << 7 * a2;
      if (128 <= i2 && (i2 = r2.h[r2.g++], Y2(r2), o2 |= (127 & i2) << 28, t2 |= (127 & i2) >> 4), 128 <= i2)
        for (a2 = 0; 5 > a2 && 128 <= i2; a2++)
          i2 = r2.h[r2.g++], Y2(r2), t2 |= (127 & i2) << 7 * a2 + 3;
      if (!(128 > i2))
        throw W2();
      return r2 = o2 >>> 0, (t2 = 2147483648 & (i2 = t2 >>> 0)) && (i2 = ~i2 >>> 0, 0 == (r2 = 1 + ~r2 >>> 0) && (i2 = i2 + 1 >>> 0)), r2 = 4294967296 * i2 + (r2 >>> 0), yt2(e2, n2, t2 ? -r2 : r2), true;
    }, function(t2, e2, n2) {
      if (null != (e2 = mt2(e2, n2)) && null != e2) {
        Z2(t2.g, 8 * n2), t2 = t2.g;
        var r2 = e2;
        for (n2 = 0 > r2, e2 = (r2 = Math.abs(r2)) >>> 0, r2 = Math.floor((r2 - e2) / 4294967296), r2 >>>= 0, n2 && (r2 = ~r2 >>> 0, 4294967295 < (e2 = 1 + (~e2 >>> 0)) && (e2 = 0, 4294967295 < ++r2 && (r2 = 0))), n2 = H2 = e2, e2 = r2; 0 < e2 || 127 < n2; )
          t2.g.push(127 & n2 | 128), n2 = (n2 >>> 7 | e2 << 25) >>> 0, e2 >>>= 7;
        t2.g.push(n2);
      }
    }), ue = ie(function(t2, e2, n2) {
      return 0 === t2.h && (yt2(e2, n2, J2(t2.g)), true);
    }, function(t2, e2, n2) {
      if (null != (e2 = mt2(e2, n2)) && null != e2)
        if (Z2(t2.g, 8 * n2), t2 = t2.g, 0 <= (n2 = e2))
          Z2(t2, n2);
        else {
          for (e2 = 0; 9 > e2; e2++)
            t2.g.push(127 & n2 | 128), n2 >>= 7;
          t2.g.push(1);
        }
    }), se = ie(function(t2, e2, n2) {
      if (2 !== t2.h)
        return false;
      var r2, i2 = J2(t2.g) >>> 0, o2 = (t2 = t2.g).g;
      if (t2.g += i2, Y2(t2), t2 = t2.h, _)
        (r2 = C2) || (r2 = C2 = new TextDecoder("utf-8", { fatal: true })), r2 = r2.decode(t2.subarray(o2, o2 + i2));
      else {
        i2 = o2 + i2;
        for (var a2, u2, s2, c2 = [], h2 = null; o2 < i2; )
          128 > (a2 = t2[o2++]) ? c2.push(a2) : 224 > a2 ? o2 >= i2 ? S2() : (u2 = t2[o2++], 194 > a2 || 128 != (192 & u2) ? (o2--, S2()) : c2.push((31 & a2) << 6 | 63 & u2)) : 240 > a2 ? o2 >= i2 - 1 ? S2() : 128 != (192 & (u2 = t2[o2++])) || 224 === a2 && 160 > u2 || 237 === a2 && 160 <= u2 || 128 != (192 & (r2 = t2[o2++])) ? (o2--, S2()) : c2.push((15 & a2) << 12 | (63 & u2) << 6 | 63 & r2) : 244 >= a2 ? o2 >= i2 - 2 ? S2() : 128 != (192 & (u2 = t2[o2++])) || 0 != u2 - 144 + (a2 << 28) >> 30 || 128 != (192 & (r2 = t2[o2++])) || 128 != (192 & (s2 = t2[o2++])) ? (o2--, S2()) : (a2 = (7 & a2) << 18 | (63 & u2) << 12 | (63 & r2) << 6 | 63 & s2, a2 -= 65536, c2.push(55296 + (a2 >> 10 & 1023), 56320 + (1023 & a2))) : S2(), 8192 <= c2.length && (h2 = F2(h2, c2), c2.length = 0);
        r2 = F2(h2, c2);
      }
      return yt2(e2, n2, r2), true;
    }, function(t2, e2, n2) {
      if (null != (e2 = mt2(e2, n2))) {
        var r2 = false;
        if (r2 = void 0 !== r2 && r2, j2) {
          if (r2 && /(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(e2))
            throw Error("Found an unpaired surrogate");
          e2 = (O2 || (O2 = new TextEncoder())).encode(e2);
        } else {
          for (var i2 = 0, o2 = new Uint8Array(3 * e2.length), a2 = 0; a2 < e2.length; a2++) {
            var u2 = e2.charCodeAt(a2);
            if (128 > u2)
              o2[i2++] = u2;
            else {
              if (2048 > u2)
                o2[i2++] = u2 >> 6 | 192;
              else {
                if (55296 <= u2 && 57343 >= u2) {
                  if (56319 >= u2 && a2 < e2.length) {
                    var s2 = e2.charCodeAt(++a2);
                    if (56320 <= s2 && 57343 >= s2) {
                      u2 = 1024 * (u2 - 55296) + s2 - 56320 + 65536, o2[i2++] = u2 >> 18 | 240, o2[i2++] = u2 >> 12 & 63 | 128, o2[i2++] = u2 >> 6 & 63 | 128, o2[i2++] = 63 & u2 | 128;
                      continue;
                    }
                    a2--;
                  }
                  if (r2)
                    throw Error("Found an unpaired surrogate");
                  u2 = 65533;
                }
                o2[i2++] = u2 >> 12 | 224, o2[i2++] = u2 >> 6 & 63 | 128;
              }
              o2[i2++] = 63 & u2 | 128;
            }
          }
          e2 = o2.subarray(0, i2);
        }
        Z2(t2.g, 8 * n2 + 2), Z2(t2.g, e2.length), it2(t2, t2.g.end()), it2(t2, e2);
      }
    }), ce = ie(function(t2, e2, n2, r2, i2) {
      if (2 !== t2.h)
        return false;
      e2 = Mt2(e2, n2, r2), n2 = t2.g.i, r2 = J2(t2.g) >>> 0;
      var o2 = t2.g.g + r2, a2 = o2 - n2;
      if (0 >= a2 && (t2.g.i = o2, i2(e2, t2), a2 = o2 - t2.g.g), a2)
        throw Error("Message parsing ended unexpectedly. Expected to read " + r2 + " bytes, instead read " + (r2 - a2) + " bytes, either the data ended unexpectedly or the message misreported its own length");
      return t2.g.g = o2, t2.g.i = n2, true;
    }, function(t2, e2, n2, r2, i2) {
      if (null != (e2 = xt2(e2, r2, n2)))
        for (r2 = 0; r2 < e2.length; r2++) {
          var o2 = t2;
          Z2(o2.g, 8 * n2 + 2);
          var a2 = o2.g.end();
          it2(o2, a2), a2.push(o2.h), o2 = a2, i2(e2[r2], t2), a2 = t2;
          var u2 = o2.pop();
          for (u2 = a2.h + a2.g.length() - u2; 127 < u2; )
            o2.push(127 & u2 | 128), u2 >>>= 7, a2.h++;
          o2.push(u2), a2.h++;
        }
    });
    function he() {
      jt2.apply(this, arguments);
    }
    if (d(he, jt2), gt2) {
      var le = {};
      Object.defineProperties(he, (le[Symbol.hasInstance] = vt2(Object[Symbol.hasInstance]), le));
    }
    function fe(t2) {
      he.call(this, t2);
    }
    function de() {
      return [1, ue, 2, oe, 3, se, 4, se];
    }
    function pe(t2) {
      he.call(this, t2, -1, ve);
    }
    function ge() {
      return [1, ce, fe, de];
    }
    d(fe, he), d(pe, he), pe.prototype.addClassification = function(t2, e2) {
      return Mt2(this, 1, fe, t2, e2), this;
    };
    var ve = [1];
    function me(t2) {
      he.call(this, t2);
    }
    function ye() {
      return [1, oe, 2, oe, 3, oe, 4, oe, 5, oe];
    }
    function we(t2) {
      he.call(this, t2, -1, xe);
    }
    function be() {
      return [1, ce, me, ye];
    }
    d(me, he), d(we, he);
    var xe = [1];
    function Me(t2) {
      he.call(this, t2);
    }
    function Ae() {
      return [1, oe, 2, oe, 3, oe, 4, oe, 5, oe, 6, ae];
    }
    d(Me, he);
    var Te = [[61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]], Ee = [[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]], Se = [[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]], Fe = [[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]], Ce = [[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]], Oe = [[10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]], _e = [].concat(u(Te), u(Ee), u(Se), u(Fe), u(Ce), u(Oe));
    function je(t2, e2, n2) {
      if (n2 = t2.createShader(0 === n2 ? t2.VERTEX_SHADER : t2.FRAGMENT_SHADER), t2.shaderSource(n2, e2), t2.compileShader(n2), !t2.getShaderParameter(n2, t2.COMPILE_STATUS))
        throw Error("Could not compile WebGL shader.\n\n" + t2.getShaderInfoLog(n2));
      return n2;
    }
    function ke(t2) {
      return xt2(t2, fe, 1).map(function(t3) {
        return { index: At2(t3, 1), ga: bt2(t3, 2), label: null != mt2(t3, 3) ? Tt2(t3, 3) : void 0, displayName: null != mt2(t3, 4) ? Tt2(t3, 4) : void 0 };
      });
    }
    function Re(t2) {
      return { x: bt2(t2, 1), y: bt2(t2, 2), z: bt2(t2, 3), visibility: null != mt2(t2, 4) ? bt2(t2, 4) : void 0 };
    }
    function Ie(t2, e2) {
      this.h = t2, this.g = e2, this.l = 0;
    }
    function Le(t2, e2, n2) {
      return function(t3, e3) {
        var n3 = t3.g;
        if (void 0 === t3.o) {
          var r2 = je(n3, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", 0), i2 = je(n3, "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }", 1), o2 = n3.createProgram();
          if (n3.attachShader(o2, r2), n3.attachShader(o2, i2), n3.linkProgram(o2), !n3.getProgramParameter(o2, n3.LINK_STATUS))
            throw Error("Could not compile WebGL program.\n\n" + n3.getProgramInfoLog(o2));
          r2 = t3.o = o2, n3.useProgram(r2), i2 = n3.getUniformLocation(r2, "sampler0"), t3.j = { K: n3.getAttribLocation(r2, "aVertex"), J: n3.getAttribLocation(r2, "aTex"), ma: i2 }, t3.u = n3.createBuffer(), n3.bindBuffer(n3.ARRAY_BUFFER, t3.u), n3.enableVertexAttribArray(t3.j.K), n3.vertexAttribPointer(t3.j.K, 2, n3.FLOAT, false, 0, 0), n3.bufferData(n3.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), n3.STATIC_DRAW), n3.bindBuffer(n3.ARRAY_BUFFER, null), t3.s = n3.createBuffer(), n3.bindBuffer(n3.ARRAY_BUFFER, t3.s), n3.enableVertexAttribArray(t3.j.J), n3.vertexAttribPointer(t3.j.J, 2, n3.FLOAT, false, 0, 0), n3.bufferData(n3.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]), n3.STATIC_DRAW), n3.bindBuffer(n3.ARRAY_BUFFER, null), n3.uniform1i(i2, 0);
        }
        r2 = t3.j, n3.useProgram(t3.o), n3.canvas.width = e3.width, n3.canvas.height = e3.height, n3.viewport(0, 0, e3.width, e3.height), n3.activeTexture(n3.TEXTURE0), t3.h.bindTexture2d(e3.glName), n3.enableVertexAttribArray(r2.K), n3.bindBuffer(n3.ARRAY_BUFFER, t3.u), n3.vertexAttribPointer(r2.K, 2, n3.FLOAT, false, 0, 0), n3.enableVertexAttribArray(r2.J), n3.bindBuffer(n3.ARRAY_BUFFER, t3.s), n3.vertexAttribPointer(r2.J, 2, n3.FLOAT, false, 0, 0), n3.bindFramebuffer(n3.DRAW_FRAMEBUFFER ? n3.DRAW_FRAMEBUFFER : n3.FRAMEBUFFER, null), n3.clearColor(0, 0, 0, 0), n3.clear(n3.COLOR_BUFFER_BIT), n3.colorMask(true, true, true, true), n3.drawArrays(n3.TRIANGLE_FAN, 0, 4), n3.disableVertexAttribArray(r2.K), n3.disableVertexAttribArray(r2.J), n3.bindBuffer(n3.ARRAY_BUFFER, null), t3.h.bindTexture2d(0);
      }(t2, e2), "function" == typeof t2.g.canvas.transferToImageBitmap ? Promise.resolve(t2.g.canvas.transferToImageBitmap()) : n2 ? Promise.resolve(t2.g.canvas) : "function" == typeof createImageBitmap ? createImageBitmap(t2.g.canvas) : (void 0 === t2.i && (t2.i = document.createElement("canvas")), new Promise(function(e3) {
        t2.i.height = t2.g.canvas.height, t2.i.width = t2.g.canvas.width, t2.i.getContext("2d", {}).drawImage(t2.g.canvas, 0, 0, t2.g.canvas.width, t2.g.canvas.height), e3(t2.i);
      }));
    }
    function Be(t2) {
      this.g = t2;
    }
    var De = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]);
    function Pe(t2, e2) {
      return e2 + t2;
    }
    function ze(t2, e2) {
      window[t2] = e2;
    }
    function Ue(t2) {
      if (this.g = t2, this.listeners = {}, this.j = {}, this.H = {}, this.o = {}, this.u = {}, this.I = this.s = this.Z = true, this.D = Promise.resolve(), this.Y = "", this.C = {}, this.locateFile = t2 && t2.locateFile || Pe, "object" == typeof window)
        var e2 = window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/";
      else {
        if ("undefined" == typeof location)
          throw Error("solutions can only be loaded on a web page or in a web worker");
        e2 = location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/";
      }
      if (this.$ = e2, t2.options)
        for (var n2 = (e2 = a(Object.keys(t2.options))).next(); !n2.done; n2 = e2.next()) {
          n2 = n2.value;
          var r2 = t2.options[n2].default;
          void 0 !== r2 && (this.j[n2] = "function" == typeof r2 ? r2() : r2);
        }
    }
    function Ne(t2) {
      var e2, n2, r2, i2, o2, a2, s2, c2, h2, l2, f2;
      return M(function(d2) {
        switch (d2.g) {
          case 1:
            return t2.Z ? (e2 = void 0 === t2.g.files ? [] : "function" == typeof t2.g.files ? t2.g.files(t2.j) : t2.g.files, m(d2, M(function(t3) {
              switch (t3.g) {
                case 1:
                  return t3.o = 2, m(t3, WebAssembly.instantiate(De), 4);
                case 4:
                  t3.g = 3, t3.o = 0;
                  break;
                case 2:
                  return t3.o = 0, t3.j = null, t3.return(false);
                case 3:
                  return t3.return(true);
              }
            }), 2)) : d2.return();
          case 2:
            if (n2 = d2.h, "object" == typeof window)
              return ze("createMediapipeSolutionsWasm", { locateFile: t2.locateFile }), ze("createMediapipeSolutionsPackedAssets", { locateFile: t2.locateFile }), a2 = e2.filter(function(t3) {
                return void 0 !== t3.data;
              }), s2 = e2.filter(function(t3) {
                return void 0 === t3.data;
              }), c2 = Promise.all(a2.map(function(e3) {
                var n3 = Ve(t2, e3.url);
                if (void 0 !== e3.path) {
                  var r3 = e3.path;
                  n3 = n3.then(function(e4) {
                    return t2.overrideFile(r3, e4), Promise.resolve(e4);
                  });
                }
                return n3;
              })), h2 = Promise.all(s2.map(function(e3) {
                return void 0 === e3.simd || e3.simd && n2 || !e3.simd && !n2 ? function(t3) {
                  var e4 = document.createElement("script");
                  return e4.setAttribute("src", t3), e4.setAttribute("crossorigin", "anonymous"), new Promise(function(t4) {
                    e4.addEventListener("load", function() {
                      t4();
                    }, false), e4.addEventListener("error", function() {
                      t4();
                    }, false), document.body.appendChild(e4);
                  });
                }(t2.locateFile(e3.url, t2.$)) : Promise.resolve();
              })).then(function() {
                var e3, n3, r3;
                return M(function(i3) {
                  if (1 == i3.g)
                    return e3 = window.createMediapipeSolutionsWasm, n3 = window.createMediapipeSolutionsPackedAssets, r3 = t2, m(i3, e3(n3), 2);
                  r3.h = i3.h, i3.g = 0;
                });
              }), l2 = M(function(e3) {
                return t2.g.graph && t2.g.graph.url ? e3 = m(e3, Ve(t2, t2.g.graph.url), 0) : (e3.g = 0, e3 = void 0), e3;
              }), m(d2, Promise.all([h2, c2, l2]), 7);
            if ("function" != typeof importScripts)
              throw Error("solutions can only be loaded on a web page or in a web worker");
            return r2 = e2.filter(function(t3) {
              return void 0 === t3.simd || t3.simd && n2 || !t3.simd && !n2;
            }).map(function(e3) {
              return t2.locateFile(e3.url, t2.$);
            }), importScripts.apply(null, u(r2)), i2 = t2, m(d2, createMediapipeSolutionsWasm(Module), 6);
          case 6:
            i2.h = d2.h, t2.l = new OffscreenCanvas(1, 1), t2.h.canvas = t2.l, o2 = t2.h.GL.createContext(t2.l, { antialias: false, alpha: false, ja: "undefined" != typeof WebGL2RenderingContext ? 2 : 1 }), t2.h.GL.makeContextCurrent(o2), d2.g = 4;
            break;
          case 7:
            if (t2.l = document.createElement("canvas"), !(f2 = t2.l.getContext("webgl2", {})) && !(f2 = t2.l.getContext("webgl", {})))
              return alert("Failed to create WebGL canvas context when passing video frame."), d2.return();
            t2.G = f2, t2.h.canvas = t2.l, t2.h.createContext(t2.l, true, true, {});
          case 4:
            t2.i = new t2.h.SolutionWasm(), t2.Z = false, d2.g = 0;
        }
      });
    }
    function Ve(t2, e2) {
      var n2, r2;
      return M(function(i2) {
        return e2 in t2.H ? i2.return(t2.H[e2]) : (n2 = t2.locateFile(e2, ""), r2 = fetch(n2).then(function(t3) {
          return t3.arrayBuffer();
        }), t2.H[e2] = r2, i2.return(r2));
      });
    }
    function He(t2, e2, n2) {
      var r2, i2, o2, u2, s2, c2, h2, l2, f2, d2, p2, g2, v2, y2;
      return M(function(w2) {
        switch (w2.g) {
          case 1:
            if (!n2)
              return w2.return(e2);
            for (r2 = {}, i2 = 0, o2 = a(Object.keys(n2)), u2 = o2.next(); !u2.done; u2 = o2.next())
              s2 = u2.value, "string" != typeof (c2 = n2[s2]) && "texture" === c2.type && void 0 !== e2[c2.stream] && ++i2;
            1 < i2 && (t2.I = false), h2 = a(Object.keys(n2)), u2 = h2.next();
          case 2:
            if (u2.done) {
              w2.g = 4;
              break;
            }
            if (l2 = u2.value, "string" == typeof (f2 = n2[l2]))
              return v2 = r2, y2 = l2, m(w2, function(t3, e3, n3) {
                var r3;
                return M(function(i3) {
                  return "number" == typeof n3 || n3 instanceof Uint8Array || n3 instanceof t3.h.Uint8BlobList ? i3.return(n3) : n3 instanceof t3.h.Texture2dDataOut ? ((r3 = t3.u[e3]) || (r3 = new Ie(t3.h, t3.G), t3.u[e3] = r3), i3.return(Le(r3, n3, t3.I))) : i3.return(void 0);
                });
              }(t2, l2, e2[f2]), 14);
            if (d2 = e2[f2.stream], "detection_list" === f2.type) {
              if (d2) {
                for (var b2 = d2.getRectList(), x2 = d2.getLandmarksList(), A2 = d2.getClassificationsList(), T2 = [], E3 = 0; E3 < b2.size(); ++E3) {
                  var S3 = ee(b2.get(E3), Me, Ae);
                  S3 = { boundingBox: { xCenter: bt2(S3, 1), yCenter: bt2(S3, 2), height: bt2(S3, 3), width: bt2(S3, 4), rotation: bt2(S3, 5, 0), rectId: At2(S3, 6) }, landmarks: xt2(ee(x2.get(E3), we, be), me, 1).map(Re), V: ke(ee(A2.get(E3), pe, ge)) }, T2.push(S3);
                }
                b2 = T2;
              } else
                b2 = [];
              r2[l2] = b2, w2.g = 7;
              break;
            }
            if ("proto_list" === f2.type) {
              if (d2) {
                for (b2 = Array(d2.size()), x2 = 0; x2 < d2.size(); x2++)
                  b2[x2] = d2.get(x2);
                d2.delete();
              } else
                b2 = [];
              r2[l2] = b2, w2.g = 7;
              break;
            }
            if (void 0 === d2) {
              w2.g = 3;
              break;
            }
            if ("float_list" === f2.type) {
              r2[l2] = d2, w2.g = 7;
              break;
            }
            if ("proto" === f2.type) {
              r2[l2] = d2, w2.g = 7;
              break;
            }
            if ("texture" !== f2.type)
              throw Error("Unknown output config type: '" + f2.type + "'");
            return (p2 = t2.u[l2]) || (p2 = new Ie(t2.h, t2.G), t2.u[l2] = p2), m(w2, Le(p2, d2, t2.I), 13);
          case 13:
            g2 = w2.h, r2[l2] = g2;
          case 7:
            f2.transform && r2[l2] && (r2[l2] = f2.transform(r2[l2])), w2.g = 3;
            break;
          case 14:
            v2[y2] = w2.h;
          case 3:
            u2 = h2.next(), w2.g = 2;
            break;
          case 4:
            return w2.return(r2);
        }
      });
    }
    function Ke(t2, e2) {
      for (var n2 = e2.name || "$", r2 = [].concat(u(e2.wants)), i2 = new t2.h.StringList(), o2 = a(e2.wants), s2 = o2.next(); !s2.done; s2 = o2.next())
        i2.push_back(s2.value);
      o2 = t2.h.PacketListener.implement({ onResults: function(i3) {
        for (var o3 = {}, a2 = 0; a2 < e2.wants.length; ++a2)
          o3[r2[a2]] = i3.get(a2);
        var u2 = t2.listeners[n2];
        u2 && (t2.D = He(t2, o3, e2.outs).then(function(n3) {
          n3 = u2(n3);
          for (var i4 = 0; i4 < e2.wants.length; ++i4) {
            var a3 = o3[r2[i4]];
            "object" == typeof a3 && a3.hasOwnProperty && a3.hasOwnProperty("delete") && a3.delete();
          }
          n3 && (t2.D = n3);
        }));
      } }), t2.i.attachMultiListener(i2, o2), i2.delete();
    }
    function We(t2) {
      var e2 = this;
      t2 = t2 || {};
      var n2 = { url: "face_detection_short.binarypb" }, r2 = { type: 1, graphOptionXref: { calculatorType: "TensorsToDetectionsCalculator", calculatorName: "facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator", fieldName: "min_score_thresh" } };
      this.g = new Ue({ locateFile: t2.locateFile, files: [{ data: true, url: "face_detection_short.binarypb" }, { data: true, url: "face_detection_short_range.tflite" }, { simd: true, url: "face_detection_solution_simd_wasm_bin.js" }, { simd: false, url: "face_detection_solution_wasm_bin.js" }], graph: n2, listeners: [{ wants: ["detections", "image_transformed"], outs: { image: "image_transformed", detections: { type: "detection_list", stream: "detections" } } }], inputs: { image: { type: "video", stream: "input_frames_gpu" } }, options: { useCpuInference: { type: 0, graphOptionXref: { calculatorType: "InferenceCalculator", fieldName: "use_cpu_inference" }, default: "object" == typeof window && void 0 !== window.navigator && ("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document) }, selfieMode: { type: 0, graphOptionXref: { calculatorType: "GlScalerCalculator", calculatorIndex: 1, fieldName: "flip_horizontal" } }, model: { type: 0, onChange: function(t3) {
        var i2, o2, u2, s2, c2;
        return M(function(h2) {
          switch (h2.g) {
            case 1:
              i2 = a("short" === t3 ? ["face_detection_short_range.tflite"] : ["face_detection_full_range_sparse.tflite"]), o2 = i2.next();
            case 2:
              if (o2.done) {
                h2.g = 4;
                break;
              }
              return u2 = o2.value, s2 = "third_party/mediapipe/modules/face_detection/" + u2, m(h2, Ve(e2.g, u2), 5);
            case 5:
              c2 = h2.h, e2.g.overrideFile(s2, c2), o2 = i2.next(), h2.g = 2;
              break;
            case 4:
              return n2.url = "short" === t3 ? "face_detection_short.binarypb" : "face_detection_full.binarypb", r2.graphOptionXref.calculatorName = "short" === t3 ? "facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator" : "facedetectionfullrangegpu__facedetectionfullrangecommon__TensorsToDetectionsCalculator", h2.return(true);
          }
        });
      } }, minDetectionConfidence: r2 } });
    }
    (t = Ue.prototype).close = function() {
      return this.i && this.i.delete(), Promise.resolve();
    }, t.reset = function() {
      var t2 = this;
      return M(function(e2) {
        t2.i && (t2.i.reset(), t2.o = {}, t2.u = {}), e2.g = 0;
      });
    }, t.setOptions = function(t2, e2) {
      var n2 = this;
      if (e2 = e2 || this.g.options) {
        for (var r2 = [], i2 = [], o2 = {}, u2 = a(Object.keys(t2)), s2 = u2.next(); !s2.done; o2 = { R: o2.R, S: o2.S }, s2 = u2.next()) {
          var c2 = s2.value;
          c2 in this.j && this.j[c2] === t2[c2] || (this.j[c2] = t2[c2], void 0 !== (s2 = e2[c2]) && (s2.onChange && (o2.R = s2.onChange, o2.S = t2[c2], r2.push(function(t3) {
            return function() {
              return M(function(e3) {
                if (1 == e3.g)
                  return m(e3, t3.R(t3.S), 2);
                true === e3.h && (n2.s = true), e3.g = 0;
              });
            };
          }(o2))), s2.graphOptionXref && (c2 = { valueNumber: 1 === s2.type ? t2[c2] : 0, valueBoolean: 0 === s2.type && t2[c2], valueString: 2 === s2.type ? t2[c2] : "" }, s2 = Object.assign(Object.assign(Object.assign({}, { calculatorName: "", calculatorIndex: 0 }), s2.graphOptionXref), c2), i2.push(s2))));
        }
        0 === r2.length && 0 === i2.length || (this.s = true, this.B = (void 0 === this.B ? [] : this.B).concat(i2), this.A = (void 0 === this.A ? [] : this.A).concat(r2));
      }
    }, t.initialize = function() {
      var t2 = this;
      return M(function(e2) {
        return 1 == e2.g ? m(e2, Ne(t2), 2) : 3 != e2.g ? m(e2, function(t3) {
          var e3, n2, r2, i2, o2, u2, s2, c2;
          return M(function(h2) {
            if (1 == h2.g)
              return t3.g.graph && t3.g.graph.url && t3.Y === t3.g.graph.url ? h2.return() : (t3.s = true, t3.g.graph && t3.g.graph.url ? (t3.Y = t3.g.graph.url, m(h2, Ve(t3, t3.g.graph.url), 3)) : void (h2.g = 2));
            for (2 != h2.g && (e3 = h2.h, t3.i.loadGraph(e3)), n2 = a(Object.keys(t3.C)), r2 = n2.next(); !r2.done; r2 = n2.next())
              i2 = r2.value, t3.i.overrideFile(i2, t3.C[i2]);
            if (t3.C = {}, t3.g.listeners)
              for (o2 = a(t3.g.listeners), u2 = o2.next(); !u2.done; u2 = o2.next())
                s2 = u2.value, Ke(t3, s2);
            c2 = t3.j, t3.j = {}, t3.setOptions(c2), h2.g = 0;
          });
        }(t2), 3) : m(e2, function(t3) {
          var e3, n2, r2, i2, o2, u2;
          return M(function(s2) {
            switch (s2.g) {
              case 1:
                if (!t3.s)
                  return s2.return();
                if (!t3.A) {
                  s2.g = 2;
                  break;
                }
                e3 = a(t3.A), n2 = e3.next();
              case 3:
                if (n2.done) {
                  s2.g = 5;
                  break;
                }
                return m(s2, (0, n2.value)(), 4);
              case 4:
                n2 = e3.next(), s2.g = 3;
                break;
              case 5:
                t3.A = void 0;
              case 2:
                if (t3.B) {
                  for (r2 = new t3.h.GraphOptionChangeRequestList(), i2 = a(t3.B), o2 = i2.next(); !o2.done; o2 = i2.next())
                    u2 = o2.value, r2.push_back(u2);
                  t3.i.changeOptions(r2), r2.delete(), t3.B = void 0;
                }
                t3.s = false, s2.g = 0;
            }
          });
        }(t2), 0);
      });
    }, t.overrideFile = function(t2, e2) {
      this.i ? this.i.overrideFile(t2, e2) : this.C[t2] = e2;
    }, t.clearOverriddenFiles = function() {
      this.C = {}, this.i && this.i.clearOverriddenFiles();
    }, t.send = function(t2, e2) {
      var n2, r2, i2, o2, u2, s2, c2, h2, l2, f2 = this;
      return M(function(d2) {
        switch (d2.g) {
          case 1:
            return f2.g.inputs ? (n2 = 1e3 * (null == e2 ? performance.now() : e2), m(d2, f2.D, 2)) : d2.return();
          case 2:
            return m(d2, f2.initialize(), 3);
          case 3:
            for (r2 = new f2.h.PacketDataList(), i2 = a(Object.keys(t2)), o2 = i2.next(); !o2.done; o2 = i2.next())
              if (u2 = o2.value, s2 = f2.g.inputs[u2]) {
                t: {
                  var p2 = t2[u2];
                  switch (s2.type) {
                    case "video":
                      var g2 = f2.o[s2.stream];
                      if (g2 || (g2 = new Ie(f2.h, f2.G), f2.o[s2.stream] = g2), 0 === g2.l && (g2.l = g2.h.createTexture()), "undefined" != typeof HTMLVideoElement && p2 instanceof HTMLVideoElement)
                        var v2 = p2.videoWidth, y2 = p2.videoHeight;
                      else
                        "undefined" != typeof HTMLImageElement && p2 instanceof HTMLImageElement ? (v2 = p2.naturalWidth, y2 = p2.naturalHeight) : (v2 = p2.width, y2 = p2.height);
                      y2 = { glName: g2.l, width: v2, height: y2 }, (v2 = g2.g).canvas.width = y2.width, v2.canvas.height = y2.height, v2.activeTexture(v2.TEXTURE0), g2.h.bindTexture2d(g2.l), v2.texImage2D(v2.TEXTURE_2D, 0, v2.RGBA, v2.RGBA, v2.UNSIGNED_BYTE, p2), g2.h.bindTexture2d(0), g2 = y2;
                      break t;
                    case "detections":
                      for ((g2 = f2.o[s2.stream]) || (g2 = new Be(f2.h), f2.o[s2.stream] = g2), g2.data || (g2.data = new g2.g.DetectionListData()), g2.data.reset(p2.length), y2 = 0; y2 < p2.length; ++y2) {
                        v2 = p2[y2];
                        var w2 = g2.data, b2 = w2.setBoundingBox, x2 = y2, M2 = v2.boundingBox, A2 = new Me();
                        if (yt2(A2, 1, M2.xCenter), yt2(A2, 2, M2.yCenter), yt2(A2, 3, M2.height), yt2(A2, 4, M2.width), yt2(A2, 5, M2.rotation), yt2(A2, 6, M2.rectId), M2 = re(A2, Ae), b2.call(w2, x2, M2), v2.landmarks)
                          for (w2 = 0; w2 < v2.landmarks.length; ++w2) {
                            var T2 = !!(A2 = v2.landmarks[w2]).visibility;
                            x2 = (b2 = g2.data).addNormalizedLandmark, M2 = y2, A2 = Object.assign(Object.assign({}, A2), { visibility: T2 ? A2.visibility : 0 }), yt2(T2 = new me(), 1, A2.x), yt2(T2, 2, A2.y), yt2(T2, 3, A2.z), A2.visibility && yt2(T2, 4, A2.visibility), A2 = re(T2, ye), x2.call(b2, M2, A2);
                          }
                        if (v2.V)
                          for (w2 = 0; w2 < v2.V.length; ++w2)
                            x2 = (b2 = g2.data).addClassification, M2 = y2, A2 = v2.V[w2], yt2(T2 = new fe(), 2, A2.ga), A2.index && yt2(T2, 1, A2.index), A2.label && yt2(T2, 3, A2.label), A2.displayName && yt2(T2, 4, A2.displayName), A2 = re(T2, de), x2.call(b2, M2, A2);
                      }
                      g2 = g2.data;
                      break t;
                    default:
                      g2 = {};
                  }
                }
                switch (c2 = g2, h2 = s2.stream, s2.type) {
                  case "video":
                    r2.pushTexture2d(Object.assign(Object.assign({}, c2), { stream: h2, timestamp: n2 }));
                    break;
                  case "detections":
                    (l2 = c2).stream = h2, l2.timestamp = n2, r2.pushDetectionList(l2);
                    break;
                  default:
                    throw Error("Unknown input config type: '" + s2.type + "'");
                }
              }
            return f2.i.send(r2), m(d2, f2.D, 4);
          case 4:
            r2.delete(), d2.g = 0;
        }
      });
    }, t.onResults = function(t2, e2) {
      this.listeners[e2 || "$"] = t2;
    }, E2("Solution", Ue), E2("OptionType", { BOOL: 0, NUMBER: 1, ia: 2, 0: "BOOL", 1: "NUMBER", 2: "STRING" }), (t = We.prototype).close = function() {
      return this.g.close(), Promise.resolve();
    }, t.onResults = function(t2) {
      this.g.onResults(t2);
    }, t.initialize = function() {
      var t2 = this;
      return M(function(e2) {
        return m(e2, t2.g.initialize(), 0);
      });
    }, t.reset = function() {
      this.g.reset();
    }, t.send = function(t2) {
      var e2 = this;
      return M(function(n2) {
        return m(n2, e2.g.send(t2), 0);
      });
    }, t.setOptions = function(t2) {
      this.g.setOptions(t2);
    }, E2("FaceDetection", We), E2("FACEDETECTION_LIPS", Te), E2("FACEDETECTION_LEFT_EYE", Ee), E2("FACEDETECTION_LEFT_EYEBROW", Se), E2("FACEDETECTION_RIGHT_EYE", Fe), E2("FACEDETECTION_RIGHT_EYEBROW", Ce), E2("FACEDETECTION_FACE_OVAL", Oe), E2("FACEDETECTION_CONTOURS", _e), E2("FACEDETECTION_TESSELATION", [[127, 34], [34, 139], [139, 127], [11, 0], [0, 37], [37, 11], [232, 231], [231, 120], [120, 232], [72, 37], [37, 39], [39, 72], [128, 121], [121, 47], [47, 128], [232, 121], [121, 128], [128, 232], [104, 69], [69, 67], [67, 104], [175, 171], [171, 148], [148, 175], [118, 50], [50, 101], [101, 118], [73, 39], [39, 40], [40, 73], [9, 151], [151, 108], [108, 9], [48, 115], [115, 131], [131, 48], [194, 204], [204, 211], [211, 194], [74, 40], [40, 185], [185, 74], [80, 42], [42, 183], [183, 80], [40, 92], [92, 186], [186, 40], [230, 229], [229, 118], [118, 230], [202, 212], [212, 214], [214, 202], [83, 18], [18, 17], [17, 83], [76, 61], [61, 146], [146, 76], [160, 29], [29, 30], [30, 160], [56, 157], [157, 173], [173, 56], [106, 204], [204, 194], [194, 106], [135, 214], [214, 192], [192, 135], [203, 165], [165, 98], [98, 203], [21, 71], [71, 68], [68, 21], [51, 45], [45, 4], [4, 51], [144, 24], [24, 23], [23, 144], [77, 146], [146, 91], [91, 77], [205, 50], [50, 187], [187, 205], [201, 200], [200, 18], [18, 201], [91, 106], [106, 182], [182, 91], [90, 91], [91, 181], [181, 90], [85, 84], [84, 17], [17, 85], [206, 203], [203, 36], [36, 206], [148, 171], [171, 140], [140, 148], [92, 40], [40, 39], [39, 92], [193, 189], [189, 244], [244, 193], [159, 158], [158, 28], [28, 159], [247, 246], [246, 161], [161, 247], [236, 3], [3, 196], [196, 236], [54, 68], [68, 104], [104, 54], [193, 168], [168, 8], [8, 193], [117, 228], [228, 31], [31, 117], [189, 193], [193, 55], [55, 189], [98, 97], [97, 99], [99, 98], [126, 47], [47, 100], [100, 126], [166, 79], [79, 218], [218, 166], [155, 154], [154, 26], [26, 155], [209, 49], [49, 131], [131, 209], [135, 136], [136, 150], [150, 135], [47, 126], [126, 217], [217, 47], [223, 52], [52, 53], [53, 223], [45, 51], [51, 134], [134, 45], [211, 170], [170, 140], [140, 211], [67, 69], [69, 108], [108, 67], [43, 106], [106, 91], [91, 43], [230, 119], [119, 120], [120, 230], [226, 130], [130, 247], [247, 226], [63, 53], [53, 52], [52, 63], [238, 20], [20, 242], [242, 238], [46, 70], [70, 156], [156, 46], [78, 62], [62, 96], [96, 78], [46, 53], [53, 63], [63, 46], [143, 34], [34, 227], [227, 143], [123, 117], [117, 111], [111, 123], [44, 125], [125, 19], [19, 44], [236, 134], [134, 51], [51, 236], [216, 206], [206, 205], [205, 216], [154, 153], [153, 22], [22, 154], [39, 37], [37, 167], [167, 39], [200, 201], [201, 208], [208, 200], [36, 142], [142, 100], [100, 36], [57, 212], [212, 202], [202, 57], [20, 60], [60, 99], [99, 20], [28, 158], [158, 157], [157, 28], [35, 226], [226, 113], [113, 35], [160, 159], [159, 27], [27, 160], [204, 202], [202, 210], [210, 204], [113, 225], [225, 46], [46, 113], [43, 202], [202, 204], [204, 43], [62, 76], [76, 77], [77, 62], [137, 123], [123, 116], [116, 137], [41, 38], [38, 72], [72, 41], [203, 129], [129, 142], [142, 203], [64, 98], [98, 240], [240, 64], [49, 102], [102, 64], [64, 49], [41, 73], [73, 74], [74, 41], [212, 216], [216, 207], [207, 212], [42, 74], [74, 184], [184, 42], [169, 170], [170, 211], [211, 169], [170, 149], [149, 176], [176, 170], [105, 66], [66, 69], [69, 105], [122, 6], [6, 168], [168, 122], [123, 147], [147, 187], [187, 123], [96, 77], [77, 90], [90, 96], [65, 55], [55, 107], [107, 65], [89, 90], [90, 180], [180, 89], [101, 100], [100, 120], [120, 101], [63, 105], [105, 104], [104, 63], [93, 137], [137, 227], [227, 93], [15, 86], [86, 85], [85, 15], [129, 102], [102, 49], [49, 129], [14, 87], [87, 86], [86, 14], [55, 8], [8, 9], [9, 55], [100, 47], [47, 121], [121, 100], [145, 23], [23, 22], [22, 145], [88, 89], [89, 179], [179, 88], [6, 122], [122, 196], [196, 6], [88, 95], [95, 96], [96, 88], [138, 172], [172, 136], [136, 138], [215, 58], [58, 172], [172, 215], [115, 48], [48, 219], [219, 115], [42, 80], [80, 81], [81, 42], [195, 3], [3, 51], [51, 195], [43, 146], [146, 61], [61, 43], [171, 175], [175, 199], [199, 171], [81, 82], [82, 38], [38, 81], [53, 46], [46, 225], [225, 53], [144, 163], [163, 110], [110, 144], [52, 65], [65, 66], [66, 52], [229, 228], [228, 117], [117, 229], [34, 127], [127, 234], [234, 34], [107, 108], [108, 69], [69, 107], [109, 108], [108, 151], [151, 109], [48, 64], [64, 235], [235, 48], [62, 78], [78, 191], [191, 62], [129, 209], [209, 126], [126, 129], [111, 35], [35, 143], [143, 111], [117, 123], [123, 50], [50, 117], [222, 65], [65, 52], [52, 222], [19, 125], [125, 141], [141, 19], [221, 55], [55, 65], [65, 221], [3, 195], [195, 197], [197, 3], [25, 7], [7, 33], [33, 25], [220, 237], [237, 44], [44, 220], [70, 71], [71, 139], [139, 70], [122, 193], [193, 245], [245, 122], [247, 130], [130, 33], [33, 247], [71, 21], [21, 162], [162, 71], [170, 169], [169, 150], [150, 170], [188, 174], [174, 196], [196, 188], [216, 186], [186, 92], [92, 216], [2, 97], [97, 167], [167, 2], [141, 125], [125, 241], [241, 141], [164, 167], [167, 37], [37, 164], [72, 38], [38, 12], [12, 72], [38, 82], [82, 13], [13, 38], [63, 68], [68, 71], [71, 63], [226, 35], [35, 111], [111, 226], [101, 50], [50, 205], [205, 101], [206, 92], [92, 165], [165, 206], [209, 198], [198, 217], [217, 209], [165, 167], [167, 97], [97, 165], [220, 115], [115, 218], [218, 220], [133, 112], [112, 243], [243, 133], [239, 238], [238, 241], [241, 239], [214, 135], [135, 169], [169, 214], [190, 173], [173, 133], [133, 190], [171, 208], [208, 32], [32, 171], [125, 44], [44, 237], [237, 125], [86, 87], [87, 178], [178, 86], [85, 86], [86, 179], [179, 85], [84, 85], [85, 180], [180, 84], [83, 84], [84, 181], [181, 83], [201, 83], [83, 182], [182, 201], [137, 93], [93, 132], [132, 137], [76, 62], [62, 183], [183, 76], [61, 76], [76, 184], [184, 61], [57, 61], [61, 185], [185, 57], [212, 57], [57, 186], [186, 212], [214, 207], [207, 187], [187, 214], [34, 143], [143, 156], [156, 34], [79, 239], [239, 237], [237, 79], [123, 137], [137, 177], [177, 123], [44, 1], [1, 4], [4, 44], [201, 194], [194, 32], [32, 201], [64, 102], [102, 129], [129, 64], [213, 215], [215, 138], [138, 213], [59, 166], [166, 219], [219, 59], [242, 99], [99, 97], [97, 242], [2, 94], [94, 141], [141, 2], [75, 59], [59, 235], [235, 75], [24, 110], [110, 228], [228, 24], [25, 130], [130, 226], [226, 25], [23, 24], [24, 229], [229, 23], [22, 23], [23, 230], [230, 22], [26, 22], [22, 231], [231, 26], [112, 26], [26, 232], [232, 112], [189, 190], [190, 243], [243, 189], [221, 56], [56, 190], [190, 221], [28, 56], [56, 221], [221, 28], [27, 28], [28, 222], [222, 27], [29, 27], [27, 223], [223, 29], [30, 29], [29, 224], [224, 30], [247, 30], [30, 225], [225, 247], [238, 79], [79, 20], [20, 238], [166, 59], [59, 75], [75, 166], [60, 75], [75, 240], [240, 60], [147, 177], [177, 215], [215, 147], [20, 79], [79, 166], [166, 20], [187, 147], [147, 213], [213, 187], [112, 233], [233, 244], [244, 112], [233, 128], [128, 245], [245, 233], [128, 114], [114, 188], [188, 128], [114, 217], [217, 174], [174, 114], [131, 115], [115, 220], [220, 131], [217, 198], [198, 236], [236, 217], [198, 131], [131, 134], [134, 198], [177, 132], [132, 58], [58, 177], [143, 35], [35, 124], [124, 143], [110, 163], [163, 7], [7, 110], [228, 110], [110, 25], [25, 228], [356, 389], [389, 368], [368, 356], [11, 302], [302, 267], [267, 11], [452, 350], [350, 349], [349, 452], [302, 303], [303, 269], [269, 302], [357, 343], [343, 277], [277, 357], [452, 453], [453, 357], [357, 452], [333, 332], [332, 297], [297, 333], [175, 152], [152, 377], [377, 175], [347, 348], [348, 330], [330, 347], [303, 304], [304, 270], [270, 303], [9, 336], [336, 337], [337, 9], [278, 279], [279, 360], [360, 278], [418, 262], [262, 431], [431, 418], [304, 408], [408, 409], [409, 304], [310, 415], [415, 407], [407, 310], [270, 409], [409, 410], [410, 270], [450, 348], [348, 347], [347, 450], [422, 430], [430, 434], [434, 422], [313, 314], [314, 17], [17, 313], [306, 307], [307, 375], [375, 306], [387, 388], [388, 260], [260, 387], [286, 414], [414, 398], [398, 286], [335, 406], [406, 418], [418, 335], [364, 367], [367, 416], [416, 364], [423, 358], [358, 327], [327, 423], [251, 284], [284, 298], [298, 251], [281, 5], [5, 4], [4, 281], [373, 374], [374, 253], [253, 373], [307, 320], [320, 321], [321, 307], [425, 427], [427, 411], [411, 425], [421, 313], [313, 18], [18, 421], [321, 405], [405, 406], [406, 321], [320, 404], [404, 405], [405, 320], [315, 16], [16, 17], [17, 315], [426, 425], [425, 266], [266, 426], [377, 400], [400, 369], [369, 377], [322, 391], [391, 269], [269, 322], [417, 465], [465, 464], [464, 417], [386, 257], [257, 258], [258, 386], [466, 260], [260, 388], [388, 466], [456, 399], [399, 419], [419, 456], [284, 332], [332, 333], [333, 284], [417, 285], [285, 8], [8, 417], [346, 340], [340, 261], [261, 346], [413, 441], [441, 285], [285, 413], [327, 460], [460, 328], [328, 327], [355, 371], [371, 329], [329, 355], [392, 439], [439, 438], [438, 392], [382, 341], [341, 256], [256, 382], [429, 420], [420, 360], [360, 429], [364, 394], [394, 379], [379, 364], [277, 343], [343, 437], [437, 277], [443, 444], [444, 283], [283, 443], [275, 440], [440, 363], [363, 275], [431, 262], [262, 369], [369, 431], [297, 338], [338, 337], [337, 297], [273, 375], [375, 321], [321, 273], [450, 451], [451, 349], [349, 450], [446, 342], [342, 467], [467, 446], [293, 334], [334, 282], [282, 293], [458, 461], [461, 462], [462, 458], [276, 353], [353, 383], [383, 276], [308, 324], [324, 325], [325, 308], [276, 300], [300, 293], [293, 276], [372, 345], [345, 447], [447, 372], [352, 345], [345, 340], [340, 352], [274, 1], [1, 19], [19, 274], [456, 248], [248, 281], [281, 456], [436, 427], [427, 425], [425, 436], [381, 256], [256, 252], [252, 381], [269, 391], [391, 393], [393, 269], [200, 199], [199, 428], [428, 200], [266, 330], [330, 329], [329, 266], [287, 273], [273, 422], [422, 287], [250, 462], [462, 328], [328, 250], [258, 286], [286, 384], [384, 258], [265, 353], [353, 342], [342, 265], [387, 259], [259, 257], [257, 387], [424, 431], [431, 430], [430, 424], [342, 353], [353, 276], [276, 342], [273, 335], [335, 424], [424, 273], [292, 325], [325, 307], [307, 292], [366, 447], [447, 345], [345, 366], [271, 303], [303, 302], [302, 271], [423, 266], [266, 371], [371, 423], [294, 455], [455, 460], [460, 294], [279, 278], [278, 294], [294, 279], [271, 272], [272, 304], [304, 271], [432, 434], [434, 427], [427, 432], [272, 407], [407, 408], [408, 272], [394, 430], [430, 431], [431, 394], [395, 369], [369, 400], [400, 395], [334, 333], [333, 299], [299, 334], [351, 417], [417, 168], [168, 351], [352, 280], [280, 411], [411, 352], [325, 319], [319, 320], [320, 325], [295, 296], [296, 336], [336, 295], [319, 403], [403, 404], [404, 319], [330, 348], [348, 349], [349, 330], [293, 298], [298, 333], [333, 293], [323, 454], [454, 447], [447, 323], [15, 16], [16, 315], [315, 15], [358, 429], [429, 279], [279, 358], [14, 15], [15, 316], [316, 14], [285, 336], [336, 9], [9, 285], [329, 349], [349, 350], [350, 329], [374, 380], [380, 252], [252, 374], [318, 402], [402, 403], [403, 318], [6, 197], [197, 419], [419, 6], [318, 319], [319, 325], [325, 318], [367, 364], [364, 365], [365, 367], [435, 367], [367, 397], [397, 435], [344, 438], [438, 439], [439, 344], [272, 271], [271, 311], [311, 272], [195, 5], [5, 281], [281, 195], [273, 287], [287, 291], [291, 273], [396, 428], [428, 199], [199, 396], [311, 271], [271, 268], [268, 311], [283, 444], [444, 445], [445, 283], [373, 254], [254, 339], [339, 373], [282, 334], [334, 296], [296, 282], [449, 347], [347, 346], [346, 449], [264, 447], [447, 454], [454, 264], [336, 296], [296, 299], [299, 336], [338, 10], [10, 151], [151, 338], [278, 439], [439, 455], [455, 278], [292, 407], [407, 415], [415, 292], [358, 371], [371, 355], [355, 358], [340, 345], [345, 372], [372, 340], [346, 347], [347, 280], [280, 346], [442, 443], [443, 282], [282, 442], [19, 94], [94, 370], [370, 19], [441, 442], [442, 295], [295, 441], [248, 419], [419, 197], [197, 248], [263, 255], [255, 359], [359, 263], [440, 275], [275, 274], [274, 440], [300, 383], [383, 368], [368, 300], [351, 412], [412, 465], [465, 351], [263, 467], [467, 466], [466, 263], [301, 368], [368, 389], [389, 301], [395, 378], [378, 379], [379, 395], [412, 351], [351, 419], [419, 412], [436, 426], [426, 322], [322, 436], [2, 164], [164, 393], [393, 2], [370, 462], [462, 461], [461, 370], [164, 0], [0, 267], [267, 164], [302, 11], [11, 12], [12, 302], [268, 12], [12, 13], [13, 268], [293, 300], [300, 301], [301, 293], [446, 261], [261, 340], [340, 446], [330, 266], [266, 425], [425, 330], [426, 423], [423, 391], [391, 426], [429, 355], [355, 437], [437, 429], [391, 327], [327, 326], [326, 391], [440, 457], [457, 438], [438, 440], [341, 382], [382, 362], [362, 341], [459, 457], [457, 461], [461, 459], [434, 430], [430, 394], [394, 434], [414, 463], [463, 362], [362, 414], [396, 369], [369, 262], [262, 396], [354, 461], [461, 457], [457, 354], [316, 403], [403, 402], [402, 316], [315, 404], [404, 403], [403, 315], [314, 405], [405, 404], [404, 314], [313, 406], [406, 405], [405, 313], [421, 418], [418, 406], [406, 421], [366, 401], [401, 361], [361, 366], [306, 408], [408, 407], [407, 306], [291, 409], [409, 408], [408, 291], [287, 410], [410, 409], [409, 287], [432, 436], [436, 410], [410, 432], [434, 416], [416, 411], [411, 434], [264, 368], [368, 383], [383, 264], [309, 438], [438, 457], [457, 309], [352, 376], [376, 401], [401, 352], [274, 275], [275, 4], [4, 274], [421, 428], [428, 262], [262, 421], [294, 327], [327, 358], [358, 294], [433, 416], [416, 367], [367, 433], [289, 455], [455, 439], [439, 289], [462, 370], [370, 326], [326, 462], [2, 326], [326, 370], [370, 2], [305, 460], [460, 455], [455, 305], [254, 449], [449, 448], [448, 254], [255, 261], [261, 446], [446, 255], [253, 450], [450, 449], [449, 253], [252, 451], [451, 450], [450, 252], [256, 452], [452, 451], [451, 256], [341, 453], [453, 452], [452, 341], [413, 464], [464, 463], [463, 413], [441, 413], [413, 414], [414, 441], [258, 442], [442, 441], [441, 258], [257, 443], [443, 442], [442, 257], [259, 444], [444, 443], [443, 259], [260, 445], [445, 444], [444, 260], [467, 342], [342, 445], [445, 467], [459, 458], [458, 250], [250, 459], [289, 392], [392, 290], [290, 289], [290, 328], [328, 460], [460, 290], [376, 433], [433, 435], [435, 376], [250, 290], [290, 392], [392, 250], [411, 416], [416, 433], [433, 411], [341, 463], [463, 464], [464, 341], [453, 464], [464, 465], [465, 453], [357, 465], [465, 412], [412, 357], [343, 412], [412, 399], [399, 343], [360, 363], [363, 440], [440, 360], [437, 399], [399, 456], [456, 437], [420, 456], [456, 363], [363, 420], [401, 435], [435, 288], [288, 401], [372, 383], [383, 353], [353, 372], [339, 255], [255, 249], [249, 339], [448, 261], [261, 255], [255, 448], [133, 243], [243, 190], [190, 133], [133, 155], [155, 112], [112, 133], [33, 246], [246, 247], [247, 33], [33, 130], [130, 25], [25, 33], [398, 384], [384, 286], [286, 398], [362, 398], [398, 414], [414, 362], [362, 463], [463, 341], [341, 362], [263, 359], [359, 467], [467, 263], [263, 249], [249, 255], [255, 263], [466, 467], [467, 260], [260, 466], [75, 60], [60, 166], [166, 75], [238, 239], [239, 79], [79, 238], [162, 127], [127, 139], [139, 162], [72, 11], [11, 37], [37, 72], [121, 232], [232, 120], [120, 121], [73, 72], [72, 39], [39, 73], [114, 128], [128, 47], [47, 114], [233, 232], [232, 128], [128, 233], [103, 104], [104, 67], [67, 103], [152, 175], [175, 148], [148, 152], [119, 118], [118, 101], [101, 119], [74, 73], [73, 40], [40, 74], [107, 9], [9, 108], [108, 107], [49, 48], [48, 131], [131, 49], [32, 194], [194, 211], [211, 32], [184, 74], [74, 185], [185, 184], [191, 80], [80, 183], [183, 191], [185, 40], [40, 186], [186, 185], [119, 230], [230, 118], [118, 119], [210, 202], [202, 214], [214, 210], [84, 83], [83, 17], [17, 84], [77, 76], [76, 146], [146, 77], [161, 160], [160, 30], [30, 161], [190, 56], [56, 173], [173, 190], [182, 106], [106, 194], [194, 182], [138, 135], [135, 192], [192, 138], [129, 203], [203, 98], [98, 129], [54, 21], [21, 68], [68, 54], [5, 51], [51, 4], [4, 5], [145, 144], [144, 23], [23, 145], [90, 77], [77, 91], [91, 90], [207, 205], [205, 187], [187, 207], [83, 201], [201, 18], [18, 83], [181, 91], [91, 182], [182, 181], [180, 90], [90, 181], [181, 180], [16, 85], [85, 17], [17, 16], [205, 206], [206, 36], [36, 205], [176, 148], [148, 140], [140, 176], [165, 92], [92, 39], [39, 165], [245, 193], [193, 244], [244, 245], [27, 159], [159, 28], [28, 27], [30, 247], [247, 161], [161, 30], [174, 236], [236, 196], [196, 174], [103, 54], [54, 104], [104, 103], [55, 193], [193, 8], [8, 55], [111, 117], [117, 31], [31, 111], [221, 189], [189, 55], [55, 221], [240, 98], [98, 99], [99, 240], [142, 126], [126, 100], [100, 142], [219, 166], [166, 218], [218, 219], [112, 155], [155, 26], [26, 112], [198, 209], [209, 131], [131, 198], [169, 135], [135, 150], [150, 169], [114, 47], [47, 217], [217, 114], [224, 223], [223, 53], [53, 224], [220, 45], [45, 134], [134, 220], [32, 211], [211, 140], [140, 32], [109, 67], [67, 108], [108, 109], [146, 43], [43, 91], [91, 146], [231, 230], [230, 120], [120, 231], [113, 226], [226, 247], [247, 113], [105, 63], [63, 52], [52, 105], [241, 238], [238, 242], [242, 241], [124, 46], [46, 156], [156, 124], [95, 78], [78, 96], [96, 95], [70, 46], [46, 63], [63, 70], [116, 143], [143, 227], [227, 116], [116, 123], [123, 111], [111, 116], [1, 44], [44, 19], [19, 1], [3, 236], [236, 51], [51, 3], [207, 216], [216, 205], [205, 207], [26, 154], [154, 22], [22, 26], [165, 39], [39, 167], [167, 165], [199, 200], [200, 208], [208, 199], [101, 36], [36, 100], [100, 101], [43, 57], [57, 202], [202, 43], [242, 20], [20, 99], [99, 242], [56, 28], [28, 157], [157, 56], [124, 35], [35, 113], [113, 124], [29, 160], [160, 27], [27, 29], [211, 204], [204, 210], [210, 211], [124, 113], [113, 46], [46, 124], [106, 43], [43, 204], [204, 106], [96, 62], [62, 77], [77, 96], [227, 137], [137, 116], [116, 227], [73, 41], [41, 72], [72, 73], [36, 203], [203, 142], [142, 36], [235, 64], [64, 240], [240, 235], [48, 49], [49, 64], [64, 48], [42, 41], [41, 74], [74, 42], [214, 212], [212, 207], [207, 214], [183, 42], [42, 184], [184, 183], [210, 169], [169, 211], [211, 210], [140, 170], [170, 176], [176, 140], [104, 105], [105, 69], [69, 104], [193, 122], [122, 168], [168, 193], [50, 123], [123, 187], [187, 50], [89, 96], [96, 90], [90, 89], [66, 65], [65, 107], [107, 66], [179, 89], [89, 180], [180, 179], [119, 101], [101, 120], [120, 119], [68, 63], [63, 104], [104, 68], [234, 93], [93, 227], [227, 234], [16, 15], [15, 85], [85, 16], [209, 129], [129, 49], [49, 209], [15, 14], [14, 86], [86, 15], [107, 55], [55, 9], [9, 107], [120, 100], [100, 121], [121, 120], [153, 145], [145, 22], [22, 153], [178, 88], [88, 179], [179, 178], [197, 6], [6, 196], [196, 197], [89, 88], [88, 96], [96, 89], [135, 138], [138, 136], [136, 135], [138, 215], [215, 172], [172, 138], [218, 115], [115, 219], [219, 218], [41, 42], [42, 81], [81, 41], [5, 195], [195, 51], [51, 5], [57, 43], [43, 61], [61, 57], [208, 171], [171, 199], [199, 208], [41, 81], [81, 38], [38, 41], [224, 53], [53, 225], [225, 224], [24, 144], [144, 110], [110, 24], [105, 52], [52, 66], [66, 105], [118, 229], [229, 117], [117, 118], [227, 34], [34, 234], [234, 227], [66, 107], [107, 69], [69, 66], [10, 109], [109, 151], [151, 10], [219, 48], [48, 235], [235, 219], [183, 62], [62, 191], [191, 183], [142, 129], [129, 126], [126, 142], [116, 111], [111, 143], [143, 116], [118, 117], [117, 50], [50, 118], [223, 222], [222, 52], [52, 223], [94, 19], [19, 141], [141, 94], [222, 221], [221, 65], [65, 222], [196, 3], [3, 197], [197, 196], [45, 220], [220, 44], [44, 45], [156, 70], [70, 139], [139, 156], [188, 122], [122, 245], [245, 188], [139, 71], [71, 162], [162, 139], [149, 170], [170, 150], [150, 149], [122, 188], [188, 196], [196, 122], [206, 216], [216, 92], [92, 206], [164, 2], [2, 167], [167, 164], [242, 141], [141, 241], [241, 242], [0, 164], [164, 37], [37, 0], [11, 72], [72, 12], [12, 11], [12, 38], [38, 13], [13, 12], [70, 63], [63, 71], [71, 70], [31, 226], [226, 111], [111, 31], [36, 101], [101, 205], [205, 36], [203, 206], [206, 165], [165, 203], [126, 209], [209, 217], [217, 126], [98, 165], [165, 97], [97, 98], [237, 220], [220, 218], [218, 237], [237, 239], [239, 241], [241, 237], [210, 214], [214, 169], [169, 210], [140, 171], [171, 32], [32, 140], [241, 125], [125, 237], [237, 241], [179, 86], [86, 178], [178, 179], [180, 85], [85, 179], [179, 180], [181, 84], [84, 180], [180, 181], [182, 83], [83, 181], [181, 182], [194, 201], [201, 182], [182, 194], [177, 137], [137, 132], [132, 177], [184, 76], [76, 183], [183, 184], [185, 61], [61, 184], [184, 185], [186, 57], [57, 185], [185, 186], [216, 212], [212, 186], [186, 216], [192, 214], [214, 187], [187, 192], [139, 34], [34, 156], [156, 139], [218, 79], [79, 237], [237, 218], [147, 123], [123, 177], [177, 147], [45, 44], [44, 4], [4, 45], [208, 201], [201, 32], [32, 208], [98, 64], [64, 129], [129, 98], [192, 213], [213, 138], [138, 192], [235, 59], [59, 219], [219, 235], [141, 242], [242, 97], [97, 141], [97, 2], [2, 141], [141, 97], [240, 75], [75, 235], [235, 240], [229, 24], [24, 228], [228, 229], [31, 25], [25, 226], [226, 31], [230, 23], [23, 229], [229, 230], [231, 22], [22, 230], [230, 231], [232, 26], [26, 231], [231, 232], [233, 112], [112, 232], [232, 233], [244, 189], [189, 243], [243, 244], [189, 221], [221, 190], [190, 189], [222, 28], [28, 221], [221, 222], [223, 27], [27, 222], [222, 223], [224, 29], [29, 223], [223, 224], [225, 30], [30, 224], [224, 225], [113, 247], [247, 225], [225, 113], [99, 60], [60, 240], [240, 99], [213, 147], [147, 215], [215, 213], [60, 20], [20, 166], [166, 60], [192, 187], [187, 213], [213, 192], [243, 112], [112, 244], [244, 243], [244, 233], [233, 245], [245, 244], [245, 128], [128, 188], [188, 245], [188, 114], [114, 174], [174, 188], [134, 131], [131, 220], [220, 134], [174, 217], [217, 236], [236, 174], [236, 198], [198, 134], [134, 236], [215, 177], [177, 58], [58, 215], [156, 143], [143, 124], [124, 156], [25, 110], [110, 7], [7, 25], [31, 228], [228, 25], [25, 31], [264, 356], [356, 368], [368, 264], [0, 11], [11, 267], [267, 0], [451, 452], [452, 349], [349, 451], [267, 302], [302, 269], [269, 267], [350, 357], [357, 277], [277, 350], [350, 452], [452, 357], [357, 350], [299, 333], [333, 297], [297, 299], [396, 175], [175, 377], [377, 396], [280, 347], [347, 330], [330, 280], [269, 303], [303, 270], [270, 269], [151, 9], [9, 337], [337, 151], [344, 278], [278, 360], [360, 344], [424, 418], [418, 431], [431, 424], [270, 304], [304, 409], [409, 270], [272, 310], [310, 407], [407, 272], [322, 270], [270, 410], [410, 322], [449, 450], [450, 347], [347, 449], [432, 422], [422, 434], [434, 432], [18, 313], [313, 17], [17, 18], [291, 306], [306, 375], [375, 291], [259, 387], [387, 260], [260, 259], [424, 335], [335, 418], [418, 424], [434, 364], [364, 416], [416, 434], [391, 423], [423, 327], [327, 391], [301, 251], [251, 298], [298, 301], [275, 281], [281, 4], [4, 275], [254, 373], [373, 253], [253, 254], [375, 307], [307, 321], [321, 375], [280, 425], [425, 411], [411, 280], [200, 421], [421, 18], [18, 200], [335, 321], [321, 406], [406, 335], [321, 320], [320, 405], [405, 321], [314, 315], [315, 17], [17, 314], [423, 426], [426, 266], [266, 423], [396, 377], [377, 369], [369, 396], [270, 322], [322, 269], [269, 270], [413, 417], [417, 464], [464, 413], [385, 386], [386, 258], [258, 385], [248, 456], [456, 419], [419, 248], [298, 284], [284, 333], [333, 298], [168, 417], [417, 8], [8, 168], [448, 346], [346, 261], [261, 448], [417, 413], [413, 285], [285, 417], [326, 327], [327, 328], [328, 326], [277, 355], [355, 329], [329, 277], [309, 392], [392, 438], [438, 309], [381, 382], [382, 256], [256, 381], [279, 429], [429, 360], [360, 279], [365, 364], [364, 379], [379, 365], [355, 277], [277, 437], [437, 355], [282, 443], [443, 283], [283, 282], [281, 275], [275, 363], [363, 281], [395, 431], [431, 369], [369, 395], [299, 297], [297, 337], [337, 299], [335, 273], [273, 321], [321, 335], [348, 450], [450, 349], [349, 348], [359, 446], [446, 467], [467, 359], [283, 293], [293, 282], [282, 283], [250, 458], [458, 462], [462, 250], [300, 276], [276, 383], [383, 300], [292, 308], [308, 325], [325, 292], [283, 276], [276, 293], [293, 283], [264, 372], [372, 447], [447, 264], [346, 352], [352, 340], [340, 346], [354, 274], [274, 19], [19, 354], [363, 456], [456, 281], [281, 363], [426, 436], [436, 425], [425, 426], [380, 381], [381, 252], [252, 380], [267, 269], [269, 393], [393, 267], [421, 200], [200, 428], [428, 421], [371, 266], [266, 329], [329, 371], [432, 287], [287, 422], [422, 432], [290, 250], [250, 328], [328, 290], [385, 258], [258, 384], [384, 385], [446, 265], [265, 342], [342, 446], [386, 387], [387, 257], [257, 386], [422, 424], [424, 430], [430, 422], [445, 342], [342, 276], [276, 445], [422, 273], [273, 424], [424, 422], [306, 292], [292, 307], [307, 306], [352, 366], [366, 345], [345, 352], [268, 271], [271, 302], [302, 268], [358, 423], [423, 371], [371, 358], [327, 294], [294, 460], [460, 327], [331, 279], [279, 294], [294, 331], [303, 271], [271, 304], [304, 303], [436, 432], [432, 427], [427, 436], [304, 272], [272, 408], [408, 304], [395, 394], [394, 431], [431, 395], [378, 395], [395, 400], [400, 378], [296, 334], [334, 299], [299, 296], [6, 351], [351, 168], [168, 6], [376, 352], [352, 411], [411, 376], [307, 325], [325, 320], [320, 307], [285, 295], [295, 336], [336, 285], [320, 319], [319, 404], [404, 320], [329, 330], [330, 349], [349, 329], [334, 293], [293, 333], [333, 334], [366, 323], [323, 447], [447, 366], [316, 15], [15, 315], [315, 316], [331, 358], [358, 279], [279, 331], [317, 14], [14, 316], [316, 317], [8, 285], [285, 9], [9, 8], [277, 329], [329, 350], [350, 277], [253, 374], [374, 252], [252, 253], [319, 318], [318, 403], [403, 319], [351, 6], [6, 419], [419, 351], [324, 318], [318, 325], [325, 324], [397, 367], [367, 365], [365, 397], [288, 435], [435, 397], [397, 288], [278, 344], [344, 439], [439, 278], [310, 272], [272, 311], [311, 310], [248, 195], [195, 281], [281, 248], [375, 273], [273, 291], [291, 375], [175, 396], [396, 199], [199, 175], [312, 311], [311, 268], [268, 312], [276, 283], [283, 445], [445, 276], [390, 373], [373, 339], [339, 390], [295, 282], [282, 296], [296, 295], [448, 449], [449, 346], [346, 448], [356, 264], [264, 454], [454, 356], [337, 336], [336, 299], [299, 337], [337, 338], [338, 151], [151, 337], [294, 278], [278, 455], [455, 294], [308, 292], [292, 415], [415, 308], [429, 358], [358, 355], [355, 429], [265, 340], [340, 372], [372, 265], [352, 346], [346, 280], [280, 352], [295, 442], [442, 282], [282, 295], [354, 19], [19, 370], [370, 354], [285, 441], [441, 295], [295, 285], [195, 248], [248, 197], [197, 195], [457, 440], [440, 274], [274, 457], [301, 300], [300, 368], [368, 301], [417, 351], [351, 465], [465, 417], [251, 301], [301, 389], [389, 251], [394, 395], [395, 379], [379, 394], [399, 412], [412, 419], [419, 399], [410, 436], [436, 322], [322, 410], [326, 2], [2, 393], [393, 326], [354, 370], [370, 461], [461, 354], [393, 164], [164, 267], [267, 393], [268, 302], [302, 12], [12, 268], [312, 268], [268, 13], [13, 312], [298, 293], [293, 301], [301, 298], [265, 446], [446, 340], [340, 265], [280, 330], [330, 425], [425, 280], [322, 426], [426, 391], [391, 322], [420, 429], [429, 437], [437, 420], [393, 391], [391, 326], [326, 393], [344, 440], [440, 438], [438, 344], [458, 459], [459, 461], [461, 458], [364, 434], [434, 394], [394, 364], [428, 396], [396, 262], [262, 428], [274, 354], [354, 457], [457, 274], [317, 316], [316, 402], [402, 317], [316, 315], [315, 403], [403, 316], [315, 314], [314, 404], [404, 315], [314, 313], [313, 405], [405, 314], [313, 421], [421, 406], [406, 313], [323, 366], [366, 361], [361, 323], [292, 306], [306, 407], [407, 292], [306, 291], [291, 408], [408, 306], [291, 287], [287, 409], [409, 291], [287, 432], [432, 410], [410, 287], [427, 434], [434, 411], [411, 427], [372, 264], [264, 383], [383, 372], [459, 309], [309, 457], [457, 459], [366, 352], [352, 401], [401, 366], [1, 274], [274, 4], [4, 1], [418, 421], [421, 262], [262, 418], [331, 294], [294, 358], [358, 331], [435, 433], [433, 367], [367, 435], [392, 289], [289, 439], [439, 392], [328, 462], [462, 326], [326, 328], [94, 2], [2, 370], [370, 94], [289, 305], [305, 455], [455, 289], [339, 254], [254, 448], [448, 339], [359, 255], [255, 446], [446, 359], [254, 253], [253, 449], [449, 254], [253, 252], [252, 450], [450, 253], [252, 256], [256, 451], [451, 252], [256, 341], [341, 452], [452, 256], [414, 413], [413, 463], [463, 414], [286, 441], [441, 414], [414, 286], [286, 258], [258, 441], [441, 286], [258, 257], [257, 442], [442, 258], [257, 259], [259, 443], [443, 257], [259, 260], [260, 444], [444, 259], [260, 467], [467, 445], [445, 260], [309, 459], [459, 250], [250, 309], [305, 289], [289, 290], [290, 305], [305, 290], [290, 460], [460, 305], [401, 376], [376, 435], [435, 401], [309, 250], [250, 392], [392, 309], [376, 411], [411, 433], [433, 376], [453, 341], [341, 464], [464, 453], [357, 453], [453, 465], [465, 357], [343, 357], [357, 412], [412, 343], [437, 343], [343, 399], [399, 437], [344, 360], [360, 440], [440, 344], [420, 437], [437, 456], [456, 420], [360, 420], [420, 363], [363, 360], [361, 401], [401, 288], [288, 361], [265, 372], [372, 353], [353, 265], [390, 339], [339, 249], [249, 390], [339, 448], [448, 255], [255, 339]]), E2("VERSION", "0.4.1646425229");
  }).call(D);
  var z = function() {
    return z = Object.assign || function(t) {
      for (var e, n = 1, r = arguments.length; n < r; n++)
        for (var i in e = arguments[n])
          Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
      return t;
    }, z.apply(this, arguments);
  };
  function U(t, e, n, r) {
    return new (n || (n = Promise))(function(i, o) {
      function a(t2) {
        try {
          s(r.next(t2));
        } catch (t3) {
          o(t3);
        }
      }
      function u(t2) {
        try {
          s(r.throw(t2));
        } catch (t3) {
          o(t3);
        }
      }
      function s(t2) {
        var e2;
        t2.done ? i(t2.value) : (e2 = t2.value, e2 instanceof n ? e2 : new n(function(t3) {
          t3(e2);
        })).then(a, u);
      }
      s((r = r.apply(t, e || [])).next());
    });
  }
  function N(t, e) {
    var n, r, i, o, a = { label: 0, sent: function() {
      if (1 & i[0])
        throw i[1];
      return i[1];
    }, trys: [], ops: [] };
    return o = { next: u(0), throw: u(1), return: u(2) }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
      return this;
    }), o;
    function u(o2) {
      return function(u2) {
        return function(o3) {
          if (n)
            throw new TypeError("Generator is already executing.");
          for (; a; )
            try {
              if (n = 1, r && (i = 2 & o3[0] ? r.return : o3[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o3[1])).done)
                return i;
              switch (r = 0, i && (o3 = [2 & o3[0], i.value]), o3[0]) {
                case 0:
                case 1:
                  i = o3;
                  break;
                case 4:
                  return a.label++, { value: o3[1], done: false };
                case 5:
                  a.label++, r = o3[1], o3 = [0];
                  continue;
                case 7:
                  o3 = a.ops.pop(), a.trys.pop();
                  continue;
                default:
                  if (!((i = (i = a.trys).length > 0 && i[i.length - 1]) || 6 !== o3[0] && 2 !== o3[0])) {
                    a = 0;
                    continue;
                  }
                  if (3 === o3[0] && (!i || o3[1] > i[0] && o3[1] < i[3])) {
                    a.label = o3[1];
                    break;
                  }
                  if (6 === o3[0] && a.label < i[1]) {
                    a.label = i[1], i = o3;
                    break;
                  }
                  if (i && a.label < i[2]) {
                    a.label = i[2], a.ops.push(o3);
                    break;
                  }
                  i[2] && a.ops.pop(), a.trys.pop();
                  continue;
              }
              o3 = e.call(t, a);
            } catch (t2) {
              o3 = [6, t2], r = 0;
            } finally {
              n = i = 0;
            }
          if (5 & o3[0])
            throw o3[1];
          return { value: o3[0] ? o3[1] : void 0, done: true };
        }([o2, u2]);
      };
    }
  }
  var V = ["rightEye", "leftEye", "noseTip", "mouthCenter", "rightEarTragion", "leftEarTragion"], H = { modelType: "short", runtime: "mediapipe", maxFaces: 1 }, K = function() {
    function t(t2) {
      var e = this;
      this.width = 0, this.height = 0, this.selfieMode = false, this.faceDetectorSolution = new P.FaceDetection({ locateFile: function(e2, n) {
        if (t2.solutionPath) {
          var r = t2.solutionPath.replace(/\/+$/, "");
          return "".concat(r, "/").concat(e2);
        }
        return "".concat(n, "/").concat(e2);
      } }), this.faceDetectorSolution.setOptions({ selfieMode: this.selfieMode, model: t2.modelType }), this.faceDetectorSolution.onResults(function(t3) {
        if (e.height = t3.image.height, e.width = t3.image.width, e.faces = [], null !== t3.detections)
          for (var n = 0, r = t3.detections; n < r.length; n++) {
            var i = r[n];
            e.faces.push(e.normalizedToAbsolute(i.landmarks, { xMin: a = (o = i.boundingBox).xCenter - o.width / 2, xMax: a + o.width, yMin: u = o.yCenter - o.height / 2, yMax: u + o.height, width: o.width, height: o.height }));
          }
        var o, a, u;
      });
    }
    return t.prototype.normalizedToAbsolute = function(t2, e) {
      var n = this;
      return { keypoints: t2.map(function(t3, e2) {
        return { x: t3.x * n.width, y: t3.y * n.height, name: V[e2] };
      }), box: { xMin: e.xMin * this.width, yMin: e.yMin * this.height, xMax: e.xMax * this.width, yMax: e.yMax * this.height, width: e.width * this.width, height: e.height * this.height } };
    }, t.prototype.estimateFaces = function(t2, e) {
      return U(this, void 0, void 0, function() {
        var i, o;
        return N(this, function(a) {
          switch (a.label) {
            case 0:
              return e && e.flipHorizontal && e.flipHorizontal !== this.selfieMode && (this.selfieMode = e.flipHorizontal, this.faceDetectorSolution.setOptions({ selfieMode: this.selfieMode })), t2 instanceof Tensor ? (o = ImageData.bind, [4, toPixels(t2)]) : [3, 2];
            case 1:
              return i = new (o.apply(ImageData, [void 0, a.sent(), t2.shape[1], t2.shape[0]]))(), [3, 3];
            case 2:
              i = t2, a.label = 3;
            case 3:
              return t2 = i, [4, this.faceDetectorSolution.send({ image: t2 })];
            case 4:
              return a.sent(), [2, this.faces];
          }
        });
      });
    }, t.prototype.dispose = function() {
      this.faceDetectorSolution.close();
    }, t.prototype.reset = function() {
      this.faceDetectorSolution.reset(), this.width = 0, this.height = 0, this.faces = null, this.selfieMode = false;
    }, t.prototype.initialize = function() {
      return this.faceDetectorSolution.initialize();
    }, t;
  }();
  function W(t) {
    return U(this, void 0, void 0, function() {
      var e, n;
      return N(this, function(r) {
        switch (r.label) {
          case 0:
            return e = function(t2) {
              if (null == t2)
                return z({}, H);
              var e2 = z({}, t2);
              return e2.runtime = "mediapipe", null == e2.modelType && (e2.modelType = H.modelType), null == e2.maxFaces && (e2.maxFaces = H.maxFaces), e2;
            }(t), [4, (n = new K(e)).initialize()];
          case 1:
            return r.sent(), [2, n];
        }
      });
    });
  }
  function G(t) {
    return t instanceof Tensor ? { height: t.shape[0], width: t.shape[1] } : { height: t.height, width: t.width };
  }
  function X(t) {
    return t instanceof Tensor ? t : fromPixels$1(t);
  }
  function Y(t, e) {
    assert(0 !== t.width, function() {
      return "".concat(e, " width cannot be 0.");
    }), assert(0 !== t.height, function() {
      return "".concat(e, " height cannot be 0.");
    });
  }
  function J(t, e, n) {
    var r = e.outputTensorSize, i = e.keepAspectRatio, o = e.borderMode, h = e.outputTensorFloatRange, f = G(t), g = function(t2, e2) {
      return e2 ? { xCenter: e2.xCenter * t2.width, yCenter: e2.yCenter * t2.height, width: e2.width * t2.width, height: e2.height * t2.height, rotation: e2.rotation } : { xCenter: 0.5 * t2.width, yCenter: 0.5 * t2.height, width: t2.width, height: t2.height, rotation: 0 };
    }(f, n), v = function(t2, e2, n2) {
      if (void 0 === n2 && (n2 = false), !n2)
        return { top: 0, left: 0, right: 0, bottom: 0 };
      var r2 = e2.height, i2 = e2.width;
      Y(e2, "targetSize"), Y(t2, "roi");
      var o2, a, u = r2 / i2, s = t2.height / t2.width, c = 0, h2 = 0;
      return u > s ? (o2 = t2.width, a = t2.width * u, h2 = (1 - s / u) / 2) : (o2 = t2.height / u, a = t2.height, c = (1 - u / s) / 2), t2.width = o2, t2.height = a, { top: h2, left: c, right: c, bottom: h2 };
    }(g, r, i), m = function(t2, e2, n2, r2) {
      var i2 = t2.width, o2 = t2.height, a = r2 ? -1 : 1, u = Math.cos(t2.rotation), s = Math.sin(t2.rotation), c = t2.xCenter, h2 = t2.yCenter, l = 1 / e2, f2 = 1 / n2, d = new Array(16);
      return d[0] = i2 * u * a * l, d[1] = -o2 * s * l, d[2] = 0, d[3] = (-0.5 * i2 * u * a + 0.5 * o2 * s + c) * l, d[4] = i2 * s * a * f2, d[5] = o2 * u * f2, d[6] = 0, d[7] = (-0.5 * o2 * u - 0.5 * i2 * s * a + h2) * f2, d[8] = 0, d[9] = 0, d[10] = i2 * l, d[11] = 0, d[12] = 0, d[13] = 0, d[14] = 0, d[15] = 1, function(t3) {
        if (16 !== t3.length)
          throw new Error("Array length must be 16 but got ".concat(t3.length));
        return [[t3[0], t3[1], t3[2], t3[3]], [t3[4], t3[5], t3[6], t3[7]], [t3[8], t3[9], t3[10], t3[11]], [t3[12], t3[13], t3[14], t3[15]]];
      }(d);
    }(g, f.width, f.height, false), y = tidy(function() {
      var e2 = X(t), n2 = tensor2d(function(t2, e3, n3) {
        return Y(n3, "inputResolution"), [1 / n3.width * t2[0][0] * e3.width, 1 / n3.height * t2[0][1] * e3.width, t2[0][3] * e3.width, 1 / n3.width * t2[1][0] * e3.height, 1 / n3.height * t2[1][1] * e3.height, t2[1][3] * e3.height, 0, 0];
      }(m, f, r), [1, 8]), i2 = "zero" === o ? "constant" : "nearest", g2 = image$1.transform(expandDims$1(cast$1(e2, "float32")), n2, "bilinear", i2, 0, [r.height, r.width]);
      return null != h ? function(t2, e3) {
        var n3 = function(t3, e4, n4, r2) {
          var i3 = (r2 - n4) / 255;
          return { scale: i3, offset: n4 - 0 * i3 };
        }(0, 0, e3[0], e3[1]);
        return tidy(function() {
          return add(mul(t2, n3.scale), n3.offset);
        });
      }(g2, h) : g2;
    });
    return { imageTensor: y, padding: v, transformationMatrix: m };
  }
  function q(t) {
    null == t.reduceBoxesInLowestLayer && (t.reduceBoxesInLowestLayer = false), null == t.interpolatedScaleAspectRatio && (t.interpolatedScaleAspectRatio = 1), null == t.fixedAnchorSize && (t.fixedAnchorSize = false);
    for (var e = [], n = 0; n < t.numLayers; ) {
      for (var r = [], i = [], o = [], a = [], u = n; u < t.strides.length && t.strides[u] === t.strides[n]; ) {
        var s = $(t.minScale, t.maxScale, u, t.strides.length);
        if (0 === u && t.reduceBoxesInLowestLayer)
          o.push(1), o.push(2), o.push(0.5), a.push(0.1), a.push(s), a.push(s);
        else {
          for (var c = 0; c < t.aspectRatios.length; ++c)
            o.push(t.aspectRatios[c]), a.push(s);
          if (t.interpolatedScaleAspectRatio > 0) {
            var h = u === t.strides.length - 1 ? 1 : $(t.minScale, t.maxScale, u + 1, t.strides.length);
            a.push(Math.sqrt(s * h)), o.push(t.interpolatedScaleAspectRatio);
          }
        }
        u++;
      }
      for (var l = 0; l < o.length; ++l) {
        var f = Math.sqrt(o[l]);
        r.push(a[l] / f), i.push(a[l] * f);
      }
      var d = 0, p = 0;
      if (t.featureMapHeight.length > 0)
        d = t.featureMapHeight[n], p = t.featureMapWidth[n];
      else {
        var g = t.strides[n];
        d = Math.ceil(t.inputSizeHeight / g), p = Math.ceil(t.inputSizeWidth / g);
      }
      for (var v = 0; v < d; ++v)
        for (var m = 0; m < p; ++m)
          for (var y = 0; y < r.length; ++y) {
            var w = { xCenter: (m + t.anchorOffsetX) / p, yCenter: (v + t.anchorOffsetY) / d, width: 0, height: 0 };
            t.fixedAnchorSize ? (w.width = 1, w.height = 1) : (w.width = i[y], w.height = r[y]), e.push(w);
          }
      n = u;
    }
    return e;
  }
  function $(t, e, n, r) {
    return 1 === r ? 0.5 * (t + e) : t + (e - t) * n / (r - 1);
  }
  function Z(t, e) {
    var n = e[0], r = e[1];
    return [n * t[0] + r * t[1] + t[3], n * t[4] + r * t[5] + t[7]];
  }
  function Q(t, e, n, r) {
    return U(this, void 0, void 0, function() {
      var r2, s, c, h, l;
      return N(this, function(f) {
        switch (f.label) {
          case 0:
            return t.sort(function(t2, e2) {
              return Math.max.apply(Math, e2.score) - Math.max.apply(Math, t2.score);
            }), r2 = tensor2d(t.map(function(t2) {
              return [t2.locationData.relativeBoundingBox.yMin, t2.locationData.relativeBoundingBox.xMin, t2.locationData.relativeBoundingBox.yMax, t2.locationData.relativeBoundingBox.xMax];
            })), s = tensor1d(t.map(function(t2) {
              return t2.score[0];
            })), [4, image$1.nonMaxSuppressionAsync(r2, s, e, n)];
          case 1:
            return [4, (c = f.sent()).array()];
          case 2:
            return h = f.sent(), l = t.filter(function(t2, e2) {
              return h.indexOf(e2) > -1;
            }), dispose([r2, s, c]), [2, l];
        }
      });
    });
  }
  function tt(t, e, n) {
    return U(this, void 0, void 0, function() {
      var r, i, a, u, c;
      return N(this, function(l) {
        switch (l.label) {
          case 0:
            return r = t[0], i = t[1], a = function(t2, e2, n2) {
              return tidy(function() {
                var r2, i2, o, a2;
                n2.reverseOutputOrder ? (i2 = squeeze(slice$1(t2, [0, n2.boxCoordOffset + 0], [-1, 1])), r2 = squeeze(slice$1(t2, [0, n2.boxCoordOffset + 1], [-1, 1])), a2 = squeeze(slice$1(t2, [0, n2.boxCoordOffset + 2], [-1, 1])), o = squeeze(slice$1(t2, [0, n2.boxCoordOffset + 3], [-1, 1]))) : (r2 = squeeze(slice$1(t2, [0, n2.boxCoordOffset + 0], [-1, 1])), i2 = squeeze(slice$1(t2, [0, n2.boxCoordOffset + 1], [-1, 1])), o = squeeze(slice$1(t2, [0, n2.boxCoordOffset + 2], [-1, 1])), a2 = squeeze(slice$1(t2, [0, n2.boxCoordOffset + 3], [-1, 1]))), i2 = add(mul(div(i2, n2.xScale), e2.w), e2.x), r2 = add(mul(div(r2, n2.yScale), e2.h), e2.y), n2.applyExponentialOnBoxSize ? (o = mul(exp$1(div(o, n2.hScale)), e2.h), a2 = mul(exp$1(div(a2, n2.wScale)), e2.w)) : (o = mul(div(o, n2.hScale), e2.h), a2 = mul(div(a2, n2.wScale), e2.h));
                var u2 = sub$1(r2, div(o, 2)), s = sub$1(i2, div(a2, 2)), c2 = add(r2, div(o, 2)), l2 = add(i2, div(a2, 2)), b = concat$1([reshape$1(u2, [n2.numBoxes, 1]), reshape$1(s, [n2.numBoxes, 1]), reshape$1(c2, [n2.numBoxes, 1]), reshape$1(l2, [n2.numBoxes, 1])], 1);
                if (n2.numKeypoints)
                  for (var x = 0; x < n2.numKeypoints; ++x) {
                    var M = n2.keypointCoordOffset + x * n2.numValuesPerKeypoint, A = void 0, T = void 0;
                    n2.reverseOutputOrder ? (A = squeeze(slice$1(t2, [0, M], [-1, 1])), T = squeeze(slice$1(t2, [0, M + 1], [-1, 1]))) : (T = squeeze(slice$1(t2, [0, M], [-1, 1])), A = squeeze(slice$1(t2, [0, M + 1], [-1, 1])));
                    var E2 = add(mul(div(A, n2.xScale), e2.w), e2.x), S2 = add(mul(div(T, n2.yScale), e2.h), e2.y);
                    b = concat$1([b, reshape$1(E2, [n2.numBoxes, 1]), reshape$1(S2, [n2.numBoxes, 1])], 1);
                  }
                return b;
              });
            }(i, e, n), u = tidy(function() {
              var t2 = r;
              return n.sigmoidScore ? (null != n.scoreClippingThresh && (t2 = clipByValue$1(r, -n.scoreClippingThresh, n.scoreClippingThresh)), t2 = sigmoid$1(t2)) : t2;
            }), [4, et(a, u, n)];
          case 1:
            return c = l.sent(), dispose([a, u]), [2, c];
        }
      });
    });
  }
  function et(t, e, n) {
    return U(this, void 0, void 0, function() {
      var r, i, o, a, u, s, c, h, l, f, d, p;
      return N(this, function(g) {
        switch (g.label) {
          case 0:
            return r = [], [4, t.data()];
          case 1:
            return i = g.sent(), [4, e.data()];
          case 2:
            for (o = g.sent(), a = 0; a < n.numBoxes; ++a)
              if (!(null != n.minScoreThresh && o[a] < n.minScoreThresh || (u = a * n.numCoords, s = nt(i[u + 0], i[u + 1], i[u + 2], i[u + 3], o[a], n.flipVertically, a), (c = s.locationData.relativeBoundingBox).width < 0 || c.height < 0))) {
                if (n.numKeypoints > 0)
                  for ((h = s.locationData).relativeKeypoints = [], l = n.numKeypoints * n.numValuesPerKeypoint, f = 0; f < l; f += n.numValuesPerKeypoint)
                    d = u + n.keypointCoordOffset + f, p = { x: i[d + 0], y: n.flipVertically ? 1 - i[d + 1] : i[d + 1] }, h.relativeKeypoints.push(p);
                r.push(s);
              }
            return [2, r];
        }
      });
    });
  }
  function nt(t, e, n, r, i, o, a) {
    return { score: [i], ind: a, locationData: { relativeBoundingBox: { xMin: e, yMin: o ? 1 - n : t, xMax: r, yMax: o ? 1 - t : n, width: r - e, height: n - t } } };
  }
  var rt, it = { reduceBoxesInLowestLayer: false, interpolatedScaleAspectRatio: 1, featureMapHeight: [], featureMapWidth: [], numLayers: 4, minScale: 0.1484375, maxScale: 0.75, inputSizeHeight: 128, inputSizeWidth: 128, anchorOffsetX: 0.5, anchorOffsetY: 0.5, strides: [8, 16, 16, 16], aspectRatios: [1], fixedAnchorSize: true }, ot = { reduceBoxesInLowestLayer: false, interpolatedScaleAspectRatio: 0, featureMapHeight: [], featureMapWidth: [], numLayers: 1, minScale: 0.1484375, maxScale: 0.75, inputSizeHeight: 192, inputSizeWidth: 192, anchorOffsetX: 0.5, anchorOffsetY: 0.5, strides: [4], aspectRatios: [1], fixedAnchorSize: true }, at = { runtime: "tfjs", modelType: "short", maxFaces: 1, detectorModelUrl: "https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1" }, ut = { applyExponentialOnBoxSize: false, flipVertically: false, ignoreClasses: [], numClasses: 1, numBoxes: 896, numCoords: 16, boxCoordOffset: 0, keypointCoordOffset: 4, numKeypoints: 6, numValuesPerKeypoint: 2, sigmoidScore: true, scoreClippingThresh: 100, reverseOutputOrder: true, xScale: 128, yScale: 128, hScale: 128, wScale: 128, minScoreThresh: 0.5 }, st = { applyExponentialOnBoxSize: false, flipVertically: false, ignoreClasses: [], numClasses: 1, numBoxes: 2304, numCoords: 16, boxCoordOffset: 0, keypointCoordOffset: 4, numKeypoints: 6, numValuesPerKeypoint: 2, sigmoidScore: true, scoreClippingThresh: 100, reverseOutputOrder: true, xScale: 192, yScale: 192, hScale: 192, wScale: 192, minScoreThresh: 0.6 }, ct = { outputTensorSize: { width: 128, height: 128 }, keepAspectRatio: true, outputTensorFloatRange: [-1, 1], borderMode: "zero" }, ht = { outputTensorSize: { width: 192, height: 192 }, keepAspectRatio: true, outputTensorFloatRange: [-1, 1], borderMode: "zero" }, lt = function() {
    function t(t2, e, n) {
      this.detectorModel = e, this.maxFaces = n, "full" === t2 ? (this.imageToTensorConfig = ht, this.tensorsToDetectionConfig = st, this.anchors = q(ot)) : (this.imageToTensorConfig = ct, this.tensorsToDetectionConfig = ut, this.anchors = q(it));
      var r = tensor1d(this.anchors.map(function(t3) {
        return t3.width;
      })), o = tensor1d(this.anchors.map(function(t3) {
        return t3.height;
      })), a = tensor1d(this.anchors.map(function(t3) {
        return t3.xCenter;
      })), u = tensor1d(this.anchors.map(function(t3) {
        return t3.yCenter;
      }));
      this.anchorTensor = { x: a, y: u, w: r, h: o };
    }
    return t.prototype.dispose = function() {
      this.detectorModel.dispose(), dispose([this.anchorTensor.x, this.anchorTensor.y, this.anchorTensor.w, this.anchorTensor.h]);
    }, t.prototype.reset = function() {
    }, t.prototype.detectFaces = function(t2, e) {
      return void 0 === e && (e = false), U(this, void 0, void 0, function() {
        var n, r, i, a, d, p, g, v, m, y, w;
        return N(this, function(b) {
          switch (b.label) {
            case 0:
              return null == t2 ? (this.reset(), [2, []]) : (n = tidy(function() {
                var n2 = cast$1(X(t2), "float32");
                return e && (n2 = squeeze(image$1.flipLeftRight(expandDims$1(n2, 0)), [0])), n2;
              }), r = J(n, this.imageToTensorConfig), i = r.imageTensor, a = r.transformationMatrix, d = this.detectorModel.execute(i, "Identity:0"), p = function(t3) {
                return tidy(function() {
                  var e2 = function(t4) {
                    return tidy(function() {
                      return [slice$1(t4, [0, 0, 0], [1, -1, 1]), slice$1(t4, [0, 0, 1], [1, -1, -1])];
                    });
                  }(t3), n2 = e2[0], r2 = e2[1];
                  return { boxes: squeeze(r2), logits: squeeze(n2) };
                });
              }(d), g = p.boxes, [4, tt([v = p.logits, g], this.anchorTensor, this.tensorsToDetectionConfig)]);
            case 1:
              return 0 === (m = b.sent()).length ? (dispose([n, i, d, v, g]), [2, m]) : [4, Q(m, this.maxFaces, 0.3)];
            case 2:
              return y = b.sent(), w = function(t3, e2) {
                void 0 === t3 && (t3 = []);
                var n2, r2 = (n2 = e2, [].concat.apply([], n2));
                return t3.forEach(function(t4) {
                  var e3 = t4.locationData;
                  e3.relativeKeypoints.forEach(function(t5) {
                    var e4 = Z(r2, [t5.x, t5.y]), n4 = e4[0], i3 = e4[1];
                    t5.x = n4, t5.y = i3;
                  });
                  var n3 = e3.relativeBoundingBox, i2 = Number.MAX_VALUE, o = Number.MAX_VALUE, a2 = Number.MIN_VALUE, u = Number.MIN_VALUE;
                  [[n3.xMin, n3.yMin], [n3.xMin + n3.width, n3.yMin], [n3.xMin + n3.width, n3.yMin + n3.height], [n3.xMin, n3.yMin + n3.height]].forEach(function(t5) {
                    var e4 = Z(r2, t5), n4 = e4[0], s = e4[1];
                    i2 = Math.min(i2, n4), a2 = Math.max(a2, n4), o = Math.min(o, s), u = Math.max(u, s);
                  }), e3.relativeBoundingBox = { xMin: i2, xMax: a2, yMin: o, yMax: u, width: a2 - i2, height: u - o };
                }), t3;
              }(y, a), dispose([n, i, d, v, g]), [2, w];
          }
        });
      });
    }, t.prototype.estimateFaces = function(t2, e) {
      return U(this, void 0, void 0, function() {
        var n, r;
        return N(this, function(i) {
          return n = G(t2), r = !!e && e.flipHorizontal, [2, this.detectFaces(t2, r).then(function(t3) {
            return t3.map(function(t4) {
              for (var e2 = t4.locationData.relativeKeypoints.map(function(t5, e3) {
                return z(z({}, t5), { x: t5.x * n.width, y: t5.y * n.height, name: V[e3] });
              }), r2 = t4.locationData.relativeBoundingBox, i2 = 0, o = ["width", "xMax", "xMin"]; i2 < o.length; i2++)
                r2[o[i2]] *= n.width;
              for (var a = 0, u = ["height", "yMax", "yMin"]; a < u.length; a++)
                r2[u[a]] *= n.height;
              return { keypoints: e2, box: r2 };
            });
          })];
        });
      });
    }, t;
  }();
  function ft(t) {
    return U(this, void 0, void 0, function() {
      var e, n, r;
      return N(this, function(i) {
        switch (i.label) {
          case 0:
            return e = function(t2) {
              if (null == t2)
                return z({}, at);
              var e2 = z({}, t2);
              return null == e2.modelType && (e2.modelType = at.modelType), null == e2.maxFaces && (e2.maxFaces = at.maxFaces), null == e2.detectorModelUrl && ("full" === e2.modelType ? e2.detectorModelUrl = "https://tfhub.dev/mediapipe/tfjs-model/face_detection/full/1" : e2.detectorModelUrl = "https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1"), e2;
            }(t), n = "string" == typeof e.detectorModelUrl && e.detectorModelUrl.indexOf("https://tfhub.dev") > -1, [4, loadGraphModel(e.detectorModelUrl, { fromTFHub: n })];
          case 1:
            return r = i.sent(), [2, new lt(e.modelType, r, e.maxFaces)];
        }
      });
    });
  }
  function dt(t, e) {
    return U(this, void 0, void 0, function() {
      var n, r;
      return N(this, function(i) {
        if (t === rt.MediaPipeFaceDetector) {
          if (r = void 0, null != (n = e)) {
            if ("tfjs" === n.runtime)
              return [2, ft(n)];
            if ("mediapipe" === n.runtime)
              return [2, W(n)];
            r = n.runtime;
          }
          throw new Error("Expect modelConfig.runtime to be either 'tfjs' " + "or 'mediapipe', but got ".concat(r));
        }
        throw new Error("".concat(t, " is not a supported model name."));
      });
    });
  }
  function pt(t) {
    return t.width * t.height;
  }
  function gt(t) {
    var e = t.xCenter - t.width / 2, n = e + t.width, r = t.yCenter - t.height / 2;
    return { xMin: e, xMax: n, yMin: r, yMax: r + t.height, width: t.width, height: t.height };
  }
  function vt(t, e) {
    var n = gt(t), r = gt(e);
    if (!function(t2, e2) {
      return !(t2.xMax < e2.xMin || e2.xMax < t2.xMin || t2.yMax < e2.yMin || e2.yMax < t2.yMin);
    }(n, r))
      return 0;
    var i = pt(function(t2, e2) {
      var n2 = Math.max(t2.xMin, e2.xMin), r2 = Math.min(t2.xMax, e2.xMax), i2 = Math.max(t2.yMin, e2.yMin), o2 = Math.min(t2.yMax, e2.yMax);
      return { xMin: n2, xMax: r2, yMin: i2, yMax: o2, width: Math.max(r2 - n2, 0), height: Math.max(o2 - i2, 0) };
    }(n, r)), o = pt(n) + pt(r) - i;
    return o > 0 ? i / o : 0;
  }
  function mt(t, e, n, r) {
    var i = t.width, o = t.height, a = r ? -1 : 1, u = Math.cos(t.rotation), s = Math.sin(t.rotation), c = t.xCenter, h = t.yCenter, l = 1 / e, f = 1 / n, d = new Array(16);
    return d[0] = i * u * a * l, d[1] = -o * s * l, d[2] = 0, d[3] = (-0.5 * i * u * a + 0.5 * o * s + c) * l, d[4] = i * s * a * f, d[5] = o * u * f, d[6] = 0, d[7] = (-0.5 * o * u - 0.5 * i * s * a + h) * f, d[8] = 0, d[9] = 0, d[10] = i * l, d[11] = 0, d[12] = 0, d[13] = 0, d[14] = 0, d[15] = 1, function(t2) {
      if (16 !== t2.length)
        throw new Error("Array length must be 16 but got " + t2.length);
      return [[t2[0], t2[1], t2[2], t2[3]], [t2[4], t2[5], t2[6], t2[7]], [t2[8], t2[9], t2[10], t2[11]], [t2[12], t2[13], t2[14], t2[15]]];
    }(d);
  }
  function yt(t) {
    return t instanceof Tensor ? { height: t.shape[0], width: t.shape[1] } : { height: t.height, width: t.width };
  }
  function wt(t) {
    return t - 2 * Math.PI * Math.floor((t + Math.PI) / (2 * Math.PI));
  }
  function bt(t) {
    return t instanceof Tensor ? t : fromPixels$1(t);
  }
  function xt(t, n) {
    assert(0 !== t.width, function() {
      return n + " width cannot be 0.";
    }), assert(0 !== t.height, function() {
      return n + " height cannot be 0.";
    });
  }
  function Mt(t, n) {
    var r = function(t2, e, n2, r2) {
      var i = e - t2, o = r2 - n2;
      if (0 === i)
        throw new Error("Original min and max are both " + t2 + ", range cannot be 0.");
      var a = o / i;
      return { scale: a, offset: n2 - t2 * a };
    }(0, 255, n[0], n[1]);
    return tidy(function() {
      return add(mul(t, r.scale), r.offset);
    });
  }
  function At(t, n, r) {
    var i = n.outputTensorSize, o = n.keepAspectRatio, a = n.borderMode, u = n.outputTensorFloatRange, s = yt(t), c = function(t2, e) {
      return e ? { xCenter: e.xCenter * t2.width, yCenter: e.yCenter * t2.height, width: e.width * t2.width, height: e.height * t2.height, rotation: e.rotation } : { xCenter: 0.5 * t2.width, yCenter: 0.5 * t2.height, width: t2.width, height: t2.height, rotation: 0 };
    }(s, r), h = function(t2, e, n2) {
      if (void 0 === n2 && (n2 = false), !n2)
        return { top: 0, left: 0, right: 0, bottom: 0 };
      var r2 = e.height, i2 = e.width;
      xt(e, "targetSize"), xt(t2, "roi");
      var o2, a2, u2 = r2 / i2, s2 = t2.height / t2.width, c2 = 0, h2 = 0;
      return u2 > s2 ? (o2 = t2.width, a2 = t2.width * u2, h2 = (1 - s2 / u2) / 2) : (o2 = t2.height / u2, a2 = t2.height, c2 = (1 - u2 / s2) / 2), t2.width = o2, t2.height = a2, { top: h2, left: c2, right: c2, bottom: h2 };
    }(c, i, o), l = mt(c, s.width, s.height, false), f = tidy(function() {
      var n2 = bt(t), r2 = tensor2d(function(t2, e, n3) {
        return xt(n3, "inputResolution"), [1 / n3.width * t2[0][0] * e.width, 1 / n3.height * t2[0][1] * e.width, t2[0][3] * e.width, 1 / n3.width * t2[1][0] * e.height, 1 / n3.height * t2[1][1] * e.height, t2[1][3] * e.height, 0, 0];
      }(l, s, i), [1, 8]), o2 = "zero" === a ? "constant" : "nearest", c2 = image$1.transform(expandDims$1(cast$1(n2, "float32")), r2, "bilinear", o2, 0, [i.height, i.width]);
      return null != u ? Mt(c2, u) : c2;
    });
    return { imageTensor: f, padding: h, transformationMatrix: l };
  }
  function Tt(t) {
    return { xCenter: t.xMin + t.width / 2, yCenter: t.yMin + t.height / 2, width: t.width, height: t.height };
  }
  function Et(t) {
    var e = t.relativeKeypoints;
    if (e.length <= 1)
      throw new Error("2 or more keypoints required to calculate a rect.");
    var n = Number.MAX_VALUE, r = Number.MAX_VALUE, i = Number.MIN_VALUE, o = Number.MIN_VALUE;
    return e.forEach(function(t2) {
      n = Math.min(n, t2.x), i = Math.max(i, t2.x), r = Math.min(r, t2.y), o = Math.max(o, t2.y);
    }), { xCenter: (n + i) / 2, yCenter: (r + o) / 2, width: i - n, height: o - r };
  }
  function St(t, e, n, r, i) {
    var o = "rect" === n ? function(t2, e2, n2) {
      var r2, i2 = t2.locationData;
      if ("boundingbox" === e2)
        r2 = Tt(i2.boundingBox);
      else {
        r2 = Et(i2);
        var o2 = n2.width, a = n2.height;
        r2.xCenter = Math.round(r2.xCenter * o2), r2.yCenter = Math.round(r2.yCenter * a), r2.width = Math.round(r2.width * o2), r2.height = Math.round(r2.height * a);
      }
      return r2;
    }(t, e, r) : function(t2, e2) {
      var n2 = t2.locationData;
      return "boundingbox" === e2 ? Tt(n2.relativeBoundingBox) : Et(n2);
    }(t, e);
    return i && (o.rotation = function(t2, e2, n2) {
      var r2, i2 = t2.locationData, o2 = n2.rotationVectorStartKeypointIndex, a = n2.rotationVectorEndKeypointIndex;
      r2 = n2.rotationVectorTargetAngle ? n2.rotationVectorTargetAngle : Math.PI * n2.rotationVectorTargetAngleDegree / 180;
      var u = i2.relativeKeypoints[o2].x * e2.width, s = i2.relativeKeypoints[o2].y * e2.height, c = i2.relativeKeypoints[a].x * e2.width, h = i2.relativeKeypoints[a].y * e2.height;
      return wt(r2 - Math.atan2(-(h - s), c - u));
    }(t, r, i)), o;
  }
  function Ft(t, e, n) {
    for (var r = 0; r < e.length; ++r) {
      var i = e[r], o = n[t[r]];
      o.x = i.x, o.y = i.y;
    }
  }
  function Ct(t, e, n, r) {
    if ("string" == typeof e) {
      if ("copy" === e)
        for (var i = 0; i < n.length; ++i)
          r[t[i]].z = n[i].z;
    } else {
      var o = function(t2, e2) {
        for (var n2 = 0, r2 = 0; r2 < e2.length; ++r2)
          n2 += t2[e2[r2]].z;
        return n2 / e2.length;
      }(r, e);
      for (i = 0; i < t.length; ++i)
        r[t[i]].z = o;
    }
  }
  function Ot(t, e) {
    for (var n = function(t2) {
      var e2 = [].concat.apply([], t2.map(function(t3) {
        return t3.indexesMapping;
      }));
      if (0 === e2.length)
        throw new Error("There should be at least one landmark in indexes mapping");
      var n2 = e2[0], r2 = e2[0], i2 = new Set(e2);
      i2.forEach(function(t3) {
        n2 = Math.min(n2, t3), r2 = Math.max(r2, t3);
      });
      var o2 = i2.size;
      if (0 !== n2)
        throw new Error("Indexes are expected to start with 0 instead of " + n2);
      if (r2 + 1 !== o2)
        throw new Error("Indexes should have no gaps but " + (r2 - o2 + 1) + " indexes are missing");
      return o2;
    }(e), r = new Array(n).fill(null).map(Object), i = 0; i < t.length; ++i) {
      var o = t[i], a = e[i];
      if (o.length !== a.indexesMapping.length)
        throw new Error("There are " + o.length + " refinement landmarks while mapping has " + a.indexesMapping.length);
      Ft(a.indexesMapping, o, r), Ct(a.indexesMapping, a.zRefinement, o, r);
    }
    return r;
  }
  function _t(t, e) {
    return t.map(function(t2) {
      var n = E(E({}, t2), { x: t2.x * e.width, y: t2.y * e.height });
      return null != t2.z && (n.z = t2.z * e.width), n;
    });
  }
  function jt(t, e) {
    return "none" === t ? e : function(t2) {
      return 1 / (1 + Math.exp(-t2));
    }(e);
  }
  function kt(t, e, n, r) {
    return S(this, void 0, void 0, function() {
      var i, o, a, u, s, c, h, l;
      return F(this, function(f) {
        switch (f.label) {
          case 0:
            return n = n || e.flipHorizontally || false, r = r || e.flipVertically || false, i = t.size, o = i / e.numLandmarks, [4, t.data()];
          case 1:
            for (a = f.sent(), u = [], s = 0; s < e.numLandmarks; ++s)
              c = s * o, (l = { x: 0, y: 0 }).x = n ? e.inputImageWidth - a[c] : a[c], o > 1 && (l.y = r ? e.inputImageHeight - a[c + 1] : a[c + 1]), o > 2 && (l.z = a[c + 2]), o > 3 && (l.score = jt(e.visibilityActivation, a[c + 3])), u.push(l);
            for (h = 0; h < u.length; ++h)
              (l = u[h]).x = l.x / e.inputImageWidth, l.y = l.y / e.inputImageHeight, l.z = l.z / e.inputImageWidth / (e.normalizeZ || 1);
            return [2, u];
        }
      });
    });
  }
  function Rt(t, e, n) {
    var r = t.width, i = t.height, o = t.rotation;
    if (null == n.rotation && null == n.rotationDegree || (o = function(t2, e2) {
      null != e2.rotation ? t2 += e2.rotation : null != e2.rotationDegree && (t2 += Math.PI * e2.rotationDegree / 180);
      return wt(t2);
    }(o, n)), 0 === o)
      t.xCenter = t.xCenter + r * n.shiftX, t.yCenter = t.yCenter + i * n.shiftY;
    else {
      var a = (e.width * r * n.shiftX * Math.cos(o) - e.height * i * n.shiftY * Math.sin(o)) / e.width, u = (e.width * r * n.shiftX * Math.sin(o) + e.height * i * n.shiftY * Math.cos(o)) / e.height;
      t.xCenter = t.xCenter + a, t.yCenter = t.yCenter + u;
    }
    if (n.squareLong) {
      var s = Math.max(r * e.width, i * e.height);
      r = s / e.width, i = s / e.height;
    } else if (n.squareShort) {
      var c = Math.min(r * e.width, i * e.height);
      r = c / e.width, i = c / e.height;
    }
    return t.width = r * n.scaleX, t.height = i * n.scaleY, t;
  }
  (rt || (rt = {})).MediaPipeFaceDetector = "MediaPipeFaceDetector";
  var It = { runtime: "tfjs", maxFaces: 1, refineLandmarks: false, landmarkModelUrl: "https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/face_mesh/1" }, Lt = { flipHorizontal: false, staticImageMode: false }, Bt = { shiftX: 0, shiftY: 0, scaleX: 1.5, scaleY: 1.5, squareLong: true }, Dt = { outputTensorSize: { width: 192, height: 192 }, outputTensorFloatRange: [0, 1], borderMode: "replicate" }, Pt = { numLandmarks: 468, inputImageWidth: 192, inputImageHeight: 192, visibilityActivation: "none", flipHorizontally: false, flipVertically: false }, zt = { numLandmarks: 80, inputImageWidth: 192, inputImageHeight: 192, visibilityActivation: "none", flipHorizontally: false, flipVertically: false }, Ut = { numLandmarks: 71, inputImageWidth: 192, inputImageHeight: 192, visibilityActivation: "none", flipHorizontally: false, flipVertically: false }, Nt = { numLandmarks: 5, inputImageWidth: 192, inputImageHeight: 192, visibilityActivation: "none", flipHorizontally: false, flipVertically: false }, Vt = { indexesMapping: Array.from(Array(468).keys()), zRefinement: "copy" }, Ht = { indexesMapping: [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 185, 40, 39, 37, 0, 267, 269, 270, 409, 78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308, 191, 80, 81, 82, 13, 312, 311, 310, 415, 76, 77, 90, 180, 85, 16, 315, 404, 320, 307, 306, 184, 74, 73, 72, 11, 302, 303, 304, 408, 62, 96, 89, 179, 86, 15, 316, 403, 319, 325, 292, 183, 42, 41, 38, 12, 268, 271, 272, 407], zRefinement: "none" }, Kt = { indexesMapping: [33, 7, 163, 144, 145, 153, 154, 155, 133, 246, 161, 160, 159, 158, 157, 173, 130, 25, 110, 24, 23, 22, 26, 112, 243, 247, 30, 29, 27, 28, 56, 190, 226, 31, 228, 229, 230, 231, 232, 233, 244, 113, 225, 224, 223, 222, 221, 189, 35, 124, 46, 53, 52, 65, 143, 111, 117, 118, 119, 120, 121, 128, 245, 156, 70, 63, 105, 66, 107, 55, 193], zRefinement: "none" }, Wt = { indexesMapping: [263, 249, 390, 373, 374, 380, 381, 382, 362, 466, 388, 387, 386, 385, 384, 398, 359, 255, 339, 254, 253, 252, 256, 341, 463, 467, 260, 259, 257, 258, 286, 414, 446, 261, 448, 449, 450, 451, 452, 453, 464, 342, 445, 444, 443, 442, 441, 413, 265, 353, 276, 283, 282, 295, 372, 340, 346, 347, 348, 349, 350, 357, 465, 383, 300, 293, 334, 296, 336, 285, 417], zRefinement: "none" }, Gt = { indexesMapping: [468, 469, 470, 471, 472], zRefinement: [33, 7, 163, 144, 145, 153, 154, 155, 133, 246, 161, 160, 159, 158, 157, 173] }, Xt = { indexesMapping: [473, 474, 475, 476, 477], zRefinement: [263, 249, 390, 373, 374, 380, 381, 382, 362, 466, 388, 387, 386, 385, 384, 398] };
  var Yt, Jt = function() {
    function t(t2, e, n, r) {
      this.detector = t2, this.landmarkModel = e, this.maxFaces = n, this.withAttention = r, this.prevFaceRectsFromLandmarks = null;
    }
    return t.prototype.estimateFaces = function(t2, n) {
      return S(this, void 0, void 0, function() {
        var r, i, o, a, u, s, c, h, l, f, d, p, g, v = this;
        return F(this, function(m) {
          switch (m.label) {
            case 0:
              return r = function(t3) {
                if (null == t3)
                  return E({}, Lt);
                var e = E({}, t3);
                return null == e.flipHorizontal && (e.flipHorizontal = Lt.flipHorizontal), null == e.staticImageMode && (e.staticImageMode = Lt.staticImageMode), e;
              }(n), null == t2 ? (this.reset(), [2, []]) : (i = yt(t2), o = tidy(function() {
                var n2 = cast$1(bt(t2), "float32");
                if (r.flipHorizontal) {
                  n2 = squeeze(image$1.flipLeftRight(expandDims$1(n2, 0)), [0]);
                }
                return n2;
              }), a = this.prevFaceRectsFromLandmarks, r.staticImageMode || null == a || a.length < this.maxFaces ? [4, this.detector.detectFaces(o, false)] : [3, 2]);
            case 1:
              return 0 === (s = m.sent()).length ? (this.reset(), o.dispose(), [2, []]) : (u = s.map(function(t3) {
                return v.faceDetectionFrontDetectionToRoi(t3, i);
              }), [3, 3]);
            case 2:
              u = [], m.label = 3;
            case 3:
              return y = 0.5, w = [], [u, a || []].forEach(function(t3) {
                return t3.forEach(function(t4) {
                  (w = w.filter(function(e) {
                    return vt(t4, e) <= y;
                  })).push(t4);
                });
              }), c = w, [4, Promise.all(c.map(function(t3) {
                return v.faceLandmark(t3, o);
              }))];
            case 4:
              for (h = m.sent(), l = [], this.prevFaceRectsFromLandmarks = [], f = 0; f < h.length; ++f)
                null != (d = h[f]) && (this.prevFaceRectsFromLandmarks.push(this.faceLandmarksToRoi(d, i)), null != (p = _t(d, i)) && p.forEach(function(t3, e) {
                  var n2 = k.get(e);
                  null != n2 && (t3.name = n2);
                }), g = R(p), l.push({ keypoints: p, box: g.locationData.relativeBoundingBox }));
              return o.dispose(), [2, l];
          }
          var y, w;
        });
      });
    }, t.prototype.dispose = function() {
      this.detector.dispose(), this.landmarkModel.dispose();
    }, t.prototype.reset = function() {
      this.detector.reset(), this.prevFaceRectsFromLandmarks = null;
    }, t.prototype.faceDetectionFrontDetectionToRoi = function(t2, e) {
      return Rt(St(t2, "boundingbox", "normRect", e, { rotationVectorStartKeypointIndex: 0, rotationVectorEndKeypointIndex: 1, rotationVectorTargetAngleDegree: 0 }), e, Bt);
    }, t.prototype.faceLandmark = function(t2, n) {
      return S(this, void 0, void 0, function() {
        var r, i, o, a, u, s, c;
        return F(this, function(h) {
          switch (h.label) {
            case 0:
              return r = At(n, Dt, t2).imageTensor, i = ["output_faceflag"].concat(this.withAttention ? ["output_mesh_identity", "output_lips", "Identity_6:0", "Identity_1:0", "Identity_2:0", "Identity_5:0"] : ["output_mesh"]), o = this.landmarkModel.execute(r, i), a = o[0], u = o.slice(1), [4, a.data()];
            case 1:
              return h.sent()[0] < 0.5 ? (dispose(o), dispose(r), [2, null]) : this.withAttention ? [4, this.tensorsToFaceLandmarksWithAttention(u)] : [3, 3];
            case 2:
              return s = h.sent(), [3, 5];
            case 3:
              return [4, this.tensorsToFaceLandmarks(u)];
            case 4:
              s = h.sent(), h.label = 5;
            case 5:
              return c = function(t3, e, n2) {
                void 0 === n2 && (n2 = { ignoreRotation: false });
                for (var r2 = [], i2 = 0, o2 = t3; i2 < o2.length; i2++) {
                  var a2 = o2[i2], u2 = a2.x - 0.5, s2 = a2.y - 0.5, c2 = n2.ignoreRotation ? 0 : e.rotation, h2 = Math.cos(c2) * u2 - Math.sin(c2) * s2, l = Math.sin(c2) * u2 + Math.cos(c2) * s2;
                  h2 = h2 * e.width + e.xCenter, l = l * e.height + e.yCenter;
                  var f = a2.z * e.width, d = E({}, a2);
                  d.x = h2, d.y = l, d.z = f, r2.push(d);
                }
                return r2;
              }(s, t2), dispose(o), dispose(r), [2, c];
          }
        });
      });
    }, t.prototype.tensorsToFaceLandmarks = function(t2) {
      return S(this, void 0, void 0, function() {
        return F(this, function(e) {
          return [2, kt(t2[0], Pt)];
        });
      });
    }, t.prototype.tensorsToFaceLandmarksWithAttention = function(t2) {
      return S(this, void 0, void 0, function() {
        var e, n, r, i, o, a;
        return F(this, function(u) {
          switch (u.label) {
            case 0:
              return [4, kt(t2[0], Pt)];
            case 1:
              return e = u.sent(), [4, kt(t2[1], zt)];
            case 2:
              return n = u.sent(), [4, kt(t2[3], Ut)];
            case 3:
              return r = u.sent(), [4, kt(t2[5], Ut)];
            case 4:
              return i = u.sent(), [4, kt(t2[4], Nt)];
            case 5:
              return o = u.sent(), [4, kt(t2[2], Nt)];
            case 6:
              return a = u.sent(), [2, Ot([e, n, r, i, o, a], [Vt, Ht, Kt, Wt, Gt, Xt])];
          }
        });
      });
    }, t.prototype.faceLandmarksToRoi = function(t2, e) {
      return Rt(St(R(t2), "boundingbox", "normRect", e, { rotationVectorStartKeypointIndex: 33, rotationVectorEndKeypointIndex: 263, rotationVectorTargetAngleDegree: 0 }), e, Bt);
    }, t;
  }();
  function qt(t) {
    return S(this, void 0, void 0, function() {
      var e, n, r, i;
      return F(this, function(o) {
        switch (o.label) {
          case 0:
            return e = function(t2) {
              if (null == t2)
                return E({}, It);
              var e2 = E({}, t2);
              return e2.runtime = "tfjs", null == e2.maxFaces && (e2.maxFaces = It.maxFaces), null == e2.refineLandmarks && (e2.refineLandmarks = It.refineLandmarks), null == e2.landmarkModelUrl && (e2.landmarkModelUrl = e2.refineLandmarks ? "https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/attention_mesh/1" : "https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/face_mesh/1"), e2;
            }(t), n = "string" == typeof e.landmarkModelUrl && e.landmarkModelUrl.indexOf("https://tfhub.dev") > -1, [4, loadGraphModel(e.landmarkModelUrl, { fromTFHub: n })];
          case 1:
            return r = o.sent(), [4, dt(rt.MediaPipeFaceDetector, { modelType: "short", maxFaces: e.maxFaces, detectorModelUrl: e.detectorModelUrl, runtime: e.runtime })];
          case 2:
            return i = o.sent(), [2, new Jt(i, r, e.maxFaces, e.refineLandmarks)];
        }
      });
    });
  }
  function $t(t, e) {
    return S(this, void 0, void 0, function() {
      var n, r;
      return F(this, function(i) {
        if (t === Yt.MediaPipeFaceMesh) {
          if (r = void 0, null != (n = e)) {
            if ("tfjs" === n.runtime)
              return [2, qt(n)];
            if ("mediapipe" === n.runtime)
              return [2, B(n)];
            r = n.runtime;
          }
          throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got " + r);
        }
        throw new Error(t + " is not a supported model name.");
      });
    });
  }
  !function(t) {
    t.MediaPipeFaceMesh = "MediaPipeFaceMesh";
  }(Yt || (Yt = {}));
  let detector;
  let modelLoadingPromise;
  async function loadFaceMeshModel(rootUrl) {
    if (detector)
      return detector;
    if (modelLoadingPromise)
      return modelLoadingPromise;
    console.log("Loading FaceMesh model...");
    modelLoadingPromise = (async () => {
      await __vitePreload(() => Promise.resolve().then(() => index), false ? "__VITE_PRELOAD__" : void 0);
      const model = Yt.MediaPipeFaceMesh;
      const detectorConfig = {
        runtime: "tfjs",
        refineLandmarks: false,
        maxFaces: 1,
        minDetectionConfidence: 0.3
        // Lower threshold for anime/harder faces
      };
      console.log("Creating detector with config:", detectorConfig);
      detector = await $t(model, detectorConfig);
      console.log("FaceMesh model loaded.");
      return detector;
    })();
    return modelLoadingPromise;
  }
  async function detectFace(input) {
    if (!detector) {
      await loadFaceMeshModel();
    }
    try {
      const faces = await detector.estimateFaces(input, {
        flipHorizontal: false,
        // Mirror mode not usually needed for incoming video
        staticImageMode: false
      });
      return faces;
    } catch (error) {
      console.error("Face detection error:", error);
      return [];
    }
  }
  class BlinkDetector {
    constructor() {
      this.EAR_THRESHOLD = 0.25;
      this.BLINK_MIN_DURATION = 50;
      this.BLINK_MAX_DURATION = 500;
      this.isBlinking = false;
      this.blinkStartTime = 0;
      this.blinkCount = 0;
      this.lastBlinkTime = 0;
      this.blinkHistory = [];
      this.naturalnessScore = 1;
    }
    // MediaPipe Facemesh Landmarks (468 points)
    // Left Eye:  33, 160, 158, 133, 153, 144
    // Right Eye: 362, 385, 387, 263, 373, 380
    calculateEAR(landmarks) {
      const dist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
      const getEyeEAR = (indices) => {
        const p = indices.map((i) => landmarks[i]);
        const v1 = dist(p[1], p[5]);
        const v2 = dist(p[2], p[4]);
        const h = dist(p[0], p[3]);
        return (v1 + v2) / (2 * h);
      };
      const leftEAR = getEyeEAR([33, 160, 158, 133, 153, 144]);
      const rightEAR = getEyeEAR([362, 385, 387, 263, 373, 380]);
      return (leftEAR + rightEAR) / 2;
    }
    update(landmarks, timestamp) {
      if (!landmarks || landmarks.length < 468)
        return null;
      const ear = this.calculateEAR(landmarks);
      const now2 = timestamp || Date.now();
      this.blinkHistory = this.blinkHistory.filter((t) => now2 - t < 6e4);
      if (ear < this.EAR_THRESHOLD) {
        if (!this.isBlinking) {
          this.isBlinking = true;
          this.blinkStartTime = now2;
        }
      } else {
        if (this.isBlinking) {
          this.isBlinking = false;
          const duration = now2 - this.blinkStartTime;
          if (duration >= this.BLINK_MIN_DURATION && duration <= this.BLINK_MAX_DURATION) {
            this.blinkCount++;
            this.blinkHistory.push(now2);
            this.lastBlinkTime = now2;
          }
        }
      }
      this.updateScore();
      return {
        isBlinking: this.isBlinking,
        blinkCount: this.blinkHistory.length,
        // BPM (Blinks Per Minute)
        ear,
        score: this.naturalnessScore
      };
    }
    updateScore() {
      const bpm = this.blinkHistory.length;
      let score = 1;
      if (bpm < 5)
        score -= 0.3;
      if (bpm < 2)
        score -= 0.4;
      if (bpm > 50)
        score -= 0.5;
      this.naturalnessScore = Math.max(0, Math.min(1, score));
    }
  }
  class PulseDetector {
    constructor() {
      this.bufferSize = 150;
      this.greenSignal = [];
      this.timeStamps = [];
      this.confidence = 0.5;
    }
    // Indices for Cheek Areas
    // Left Cheek: 116, 117, 118, 100, 126, 209
    // Right Cheek: 345, 346, 347, 329, 355, 429
    // Forehead: 10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127
    // Simpler approximation: Just use a bounding box around center of cheeks
    getAverageGreen(imageData, landmarks) {
      if (!landmarks || landmarks.length < 468)
        return 0;
      const cheekLandmark = landmarks[117];
      const x = Math.floor(cheekLandmark.x);
      const y = Math.floor(cheekLandmark.y);
      let sumGreen = 0;
      let count = 0;
      for (let dy = -5; dy <= 5; dy++) {
        for (let dx = -5; dx <= 5; dx++) {
          const px = x + dx;
          const py = y + dy;
          if (px >= 0 && px < imageData.width && py >= 0 && py < imageData.height) {
            const index2 = (py * imageData.width + px) * 4;
            sumGreen += imageData.data[index2 + 1];
            count++;
          }
        }
      }
      return count > 0 ? sumGreen / count : 0;
    }
    update(imageData, landmarks, timestamp) {
      const val = this.getAverageGreen(imageData, landmarks);
      if (val === 0)
        return { confidence: 0 };
      this.greenSignal.push(val);
      this.timeStamps.push(timestamp);
      if (this.greenSignal.length > this.bufferSize) {
        this.greenSignal.shift();
        this.timeStamps.shift();
      }
      if (this.greenSignal.length < 30) {
        return { confidence: 0.5, heartRate: null };
      }
      return this.processSignal();
    }
    processSignal() {
      const detrended = [];
      for (let i = 1; i < this.greenSignal.length; i++) {
        detrended.push(this.greenSignal[i] - this.greenSignal[i - 1]);
      }
      const mean2 = detrended.reduce((a, b) => a + b, 0) / detrended.length;
      const variance = detrended.reduce((a, b) => a + Math.pow(b - mean2, 2), 0) / detrended.length;
      let score = 0.5;
      if (variance > 0.1 && variance < 10) {
        score = 0.8;
      } else if (variance <= 0.1) {
        score = 0.2;
      } else {
        score = 0.5;
      }
      this.confidence = score;
      return {
        confidence: this.confidence,
        heartRate: 72
        // Placeholder: FFT is too heavy for simple JS without libraries
      };
    }
  }
  class StabilityDetector {
    constructor() {
      this.prevLandmarks = null;
      this.frameCounter = 0;
      this.stabilityScore = 1;
      this.history = [];
      this.HISTORY_SIZE = 30;
    }
    // Indices for rigid points (Nose bridge, Eye corners)
    // Nose Tip: 1
    // Left Eye Inner: 133
    // Right Eye Inner: 362
    // Chin: 152
    update(landmarks) {
      if (!landmarks || landmarks.length < 468)
        return { score: 1 };
      let frameScore = 1;
      const pLeft = landmarks[133];
      const pRight = landmarks[362];
      const currentIOD = Math.hypot(pLeft.x - pRight.x, pLeft.y - pRight.y);
      if (this.prevLandmarks) {
        const prevPLeft = this.prevLandmarks[133];
        const prevPRight = this.prevLandmarks[362];
        const prevIOD = Math.hypot(prevPLeft.x - prevPRight.x, prevPLeft.y - prevPRight.y);
        const nose = landmarks[1];
        const prevNose = this.prevLandmarks[1];
        const scaleChange = Math.abs(currentIOD - prevIOD) / prevIOD;
        const noseMove = Math.hypot(nose.x - prevNose.x, nose.y - prevNose.y) / prevIOD;
        if (noseMove > 0.05 && scaleChange < 0.01) {
          frameScore -= 0.2;
        }
        if (noseMove > 0.2) {
          frameScore -= 0.5;
        }
      }
      this.prevLandmarks = landmarks;
      this.history.push(frameScore);
      if (this.history.length > this.HISTORY_SIZE)
        this.history.shift();
      const avg = this.history.reduce((a, b) => a + b, 0) / this.history.length;
      this.stabilityScore = Math.max(0, Math.min(1, avg));
      return {
        score: this.stabilityScore,
        iod: currentIOD
      };
    }
  }
  class RiskScorer {
    constructor() {
      this.currentRisk = 0;
      this.alpha = 0.1;
    }
    calculate(signals) {
      const W_STABILITY = 0.4;
      const W_BLINK = 0.35;
      const W_PULSE = 0.25;
      const s = signals.stability !== void 0 ? signals.stability : 0.5;
      const b = signals.blink !== void 0 ? signals.blink : 0.5;
      const p = signals.pulse !== void 0 ? signals.pulse : 0.5;
      const authenticity = s * W_STABILITY + b * W_BLINK + p * W_PULSE;
      const rawRisk = 1 - authenticity;
      this.currentRisk = this.alpha * rawRisk + (1 - this.alpha) * this.currentRisk;
      return {
        score: this.currentRisk,
        label: this.getLabel(this.currentRisk)
      };
    }
    getLabel(score) {
      if (score < 0.35)
        return "SAFE";
      if (score < 0.75)
        return "SUSPICIOUS";
      return "LIKELY DEEPFAKE";
    }
  }
  console.log("Worker: Loaded (Prod Mode)");
  self.onerror = function(err) {
    console.error("Worker Global Error:", err);
    self.postMessage({
      type: "ERROR",
      error: `Worker Global Error: ${err.message || JSON.stringify(err)}`
    });
  };
  let isInitialized = false;
  let blink, pulse, stability, risk;
  async function init(rootUrl) {
    if (isInitialized)
      return;
    try {
      console.log("Worker: Init called with rootUrl:", rootUrl);
      self.postMessage({ type: "PROGRESS", status: "Starting AI Engine..." });
      try {
        self.postMessage({ type: "PROGRESS", status: "Initializing GPU..." });
        if (!tf)
          throw new Error("TensorFlow.js not loaded");
        await setBackend("webgl");
        await ready();
        console.log("Worker: TF Backend ready:", getBackend());
      } catch (backendErr) {
        console.error("Worker: WebGL Init Failed", backendErr);
        self.postMessage({ type: "ERROR", error: "GPU Access Denied" });
        return;
      }
      self.postMessage({ type: "PROGRESS", status: "Loading Face Model..." });
      await loadFaceMeshModel(rootUrl);
      self.postMessage({ type: "PROGRESS", status: "Compiling Shaders..." });
      blink = new BlinkDetector();
      pulse = new PulseDetector();
      stability = new StabilityDetector();
      risk = new RiskScorer();
      isInitialized = true;
      console.log("Worker: Initialization Complete");
      self.postMessage({ type: "INIT_COMPLETE" });
    } catch (err) {
      console.error("Worker: Init Failed", err);
      self.postMessage({ type: "ERROR", error: `Init Failed: ${err.message}` });
    }
  }
  self.onmessage = async (e) => {
    const msg = e.data;
    try {
      if (msg.type === "INIT") {
        await init(msg.rootUrl);
      } else if (msg.type === "FRAME") {
        if (!isInitialized)
          return;
        await processFrame(msg.pixels, msg.width, msg.height, msg.timestamp);
      }
    } catch (handlerErr) {
      console.error("Worker: Message Handler Error", handlerErr);
    }
  };
  async function processFrame(pixels, width, height, timestamp) {
    try {
      const data = new Uint8ClampedArray(pixels);
      const imageData = new ImageData(data, width, height);
      console.log("Worker: Processing frame", width, "x", height);
      const faces = await detectFace(imageData);
      let result = {
        found: false,
        timestamp
      };
      if (faces && faces.length > 0) {
        const face = faces[0];
        const keypoints = face.keypoints;
        console.log("Worker: Face Found!");
        const blinkRes = blink.update(keypoints, timestamp);
        const stabilityRes = stability.update(keypoints);
        const pulseRes = pulse.update(imageData, keypoints, timestamp);
        const riskRes = risk.calculate({
          blink: blinkRes && blinkRes.score || 0.5,
          pulse: pulseRes && pulseRes.confidence || 0.5,
          stability: stabilityRes && stabilityRes.score || 0.5
        });
        result = {
          found: true,
          timestamp,
          blink: blinkRes,
          pulse: pulseRes,
          stability: stabilityRes,
          risk: riskRes,
          box: face.box
          // Return local box coords within the ROI if needed
        };
      } else {
        console.log("Worker: No face detected in this frame");
      }
      self.postMessage({ type: "RESULT", data: result });
    } catch (err) {
      console.error("Worker Error:", err);
    } finally {
    }
  }
})();
